#+Title: Follow code and explain TC-qdisc offloading of TSN features

Upstream kernel community choose to use the TC-qdisc system "offload" feature to
configure the NIC drivers TSN config. In this project we need to understand how
this works. As for XDP there is not such layer. Thus, either we have to design
our own config layer or collaborate with the existing TC layer.

* Summary

Chip i225:
 - LaunchTime max 1 second into the future.
 - Descriptor: LaunchTime 30 bit (bits 61:32).
 - Transmit scheduler accuracy 6.4nsec (156.25 MHz clock).

Chip i210:
 - LaunchTime max 0.5 second into the future.
 - Descriptor: LaunchTime 25-bit (bits 56:32) with 32 nanosec granularity.
 - Limits: Only TX queue 0 and 1 supports LaunchTime.

Both drivers expect that upper Qdisc layer makes sure that launch timestamps are
bounded/sanitised to not exceed the bits available, and there by indirectly the
max time-horizon.

When exposing this to XDP and AF_XDP, we don't have this 'upper-layer'.
This is a design question how this is solved for XDP.

* Autogenerated document index :toc:
- [[#summary][Summary]]
- [[#qdisc-etf][Qdisc: ETF]]
  - [[#drivers-supporting-hw-etf][Drivers supporting HW-ETF]]
- [[#qdisc-taprio][Qdisc: taprio]]
  - [[#drivers-supporting-hw-taprio][Drivers supporting HW-taprio]]
- [[#driver-igc][Driver: igc]]
  - [[#setup-code-driver-igc][Setup code (driver: igc)]]
  - [[#tx-time-to-hardware-driver-igc][TX time to hardware (driver: igc)]]
- [[#driver-igb][Driver: igb]]
  - [[#setup-code-driver-igb][Setup code (driver: igb)]]
  - [[#tx-time-to-hardware-driver-igb][TX time to hardware (driver: igb)]]

* Qdisc: ETF

ETF = Earliest TxTime First.

Use a rb-tree (data astructure) for storing and sorting packets based on the
transmission timestamp.

The desired transmission time comes from the SKB (=skb->tstamp=).

For offloading notice the two functions:
 - etf_disable_offload
 - etf_enable_offload

The both end-up calling the driver callback: =ndo_setup_tc()=
#+begin_src C
  err = ops->ndo_setup_tc(dev, TC_SETUP_QDISC_ETF, &etf);
  if (err < 0)
	pr_warn("Couldn't disable ETF offload for queue %d\n", etf.queue);
#+end_src

The =etf= parameter have type  =struct tc_etf_qopt_offload=:
#+begin_src C
 struct tc_etf_qopt_offload {
	u8 enable;
	s32 queue;
 };
#+end_src

An important detail, that can be seen from this code, is that offloading happens
for a specific and single queue number.

** Drivers supporting HW-ETF

#+begin_src sh
$ gg TC_SETUP_QDISC_ETF drivers/
drivers/net/ethernet/freescale/enetc/enetc.c:   case TC_SETUP_QDISC_ETF:
drivers/net/ethernet/intel/igb/igb_main.c:      case TC_SETUP_QDISC_ETF:
drivers/net/ethernet/intel/igc/igc_main.c:      case TC_SETUP_QDISC_ETF:
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c:      case TC_SETUP_QDISC_ETF:
#+end_src

* Qdisc: taprio

The TC 'taprio' qdisc is a "Time Aware Priority Scheduler".
Kernel code: [[https://elixir.bootlin.com/linux/v5.13-rc5/source/net/sched/sch_taprio.c][net/sched/sch_taprio.c]].

This qdisc is related to IEEE 802.1Qbv.

** Drivers supporting HW-taprio

#+begin_src sh
$ gg TC_SETUP_QDISC_TAPRIO drivers/
drivers/net/dsa/hirschmann/hellcreek.c: if (type != TC_SETUP_QDISC_TAPRIO)
drivers/net/dsa/ocelot/felix_vsc9959.c: case TC_SETUP_QDISC_TAPRIO:
drivers/net/dsa/sja1105/sja1105_main.c: case TC_SETUP_QDISC_TAPRIO:
drivers/net/ethernet/freescale/enetc/enetc.c:   case TC_SETUP_QDISC_TAPRIO:
drivers/net/ethernet/intel/igc/igc_main.c:      case TC_SETUP_QDISC_TAPRIO:
drivers/net/ethernet/stmicro/stmmac/stmmac_main.c:      case TC_SETUP_QDISC_TAPRIO:
drivers/net/ethernet/ti/am65-cpsw-qos.c:        case TC_SETUP_QDISC_TAPRIO:
#+end_src


* Driver: igc

** Setup code (driver: igc)

The drivers =ndo_setup_tc()= callback tell us what offload =type= it supports.
#+begin_src C
static int igc_setup_tc(struct net_device *dev, enum tc_setup_type type,
			void *type_data)
{
	struct igc_adapter *adapter = netdev_priv(dev);

	switch (type) {
	case TC_SETUP_QDISC_TAPRIO:
		return igc_tsn_enable_qbv_scheduling(adapter, type_data);

	case TC_SETUP_QDISC_ETF:
		return igc_tsn_enable_launchtime(adapter, type_data);

	default:
		return -EOPNOTSUPP;
	}
}
#+end_src

Code to setup hardware for "LaunchTime":
#+begin_src C
static int igc_tsn_enable_launchtime(struct igc_adapter *adapter,
				     struct tc_etf_qopt_offload *qopt)
{
	struct igc_hw *hw = &adapter->hw;
	int err;

	if (hw->mac.type != igc_i225)
		return -EOPNOTSUPP;

	err = igc_save_launchtime_params(adapter, qopt->queue, qopt->enable);
	if (err)
		return err;

	return igc_tsn_offload_apply(adapter);
}
#+end_src

The specific =ring= queue enable 'ring->launchtime_enable', but there is also a
for-loop that for every TX ring resets members =start_time= and =end_time=, see:

#+begin_src C
static int igc_save_launchtime_params(struct igc_adapter *adapter, int queue,
				      bool enable)
{
	struct igc_ring *ring;
	int i;

	if (queue < 0 || queue >= adapter->num_tx_queues)
		return -EINVAL;

	ring = adapter->tx_ring[queue];
	ring->launchtime_enable = enable;

	if (adapter->base_time)
		return 0;

	adapter->cycle_time = NSEC_PER_SEC;

	for (i = 0; i < adapter->num_tx_queues; i++) {
		ring = adapter->tx_ring[i];
		ring->start_time = 0;
		ring->end_time = NSEC_PER_SEC;
	}

	return 0;
}

// include/vdso/time64.h
#define NSEC_PER_SEC	1000000000L  // 10^9
#+end_src

The call =igc_tsn_offload_apply()= calls [[https://elixir.bootlin.com/linux/v5.12-rc8/source/drivers/net/ethernet/intel/igc/igc_tsn.c#L63][igc_tsn_enable_offload]] that programs
the actual hardware registers.

** TX time to hardware (driver: igc)

In function [[https://elixir.bootlin.com/linux/v5.12-rc8/source/drivers/net/ethernet/intel/igc/igc_main.c#L913][igc_tx_ctxtdesc]] the the "launch_time" timestamp is transferred to
the hardware via the TX context descriptor (below =context_desc= type struct
igc_adv_tx_context_desc).

#+begin_src C
static void igc_tx_ctxtdesc(struct igc_ring *tx_ring,
			    struct igc_tx_buffer *first,
			    u32 vlan_macip_lens, u32 type_tucmd,
			    u32 mss_l4len_idx)
{
	struct igc_adv_tx_context_desc *context_desc;
	u16 i = tx_ring->next_to_use;

	context_desc = IGC_TX_CTXTDESC(tx_ring, i);

	i++;
	tx_ring->next_to_use = (i < tx_ring->count) ? i : 0;

	/* set bits to identify this as an advanced context descriptor */
	type_tucmd |= IGC_TXD_CMD_DEXT | IGC_ADVTXD_DTYP_CTXT;

	/* For i225, context index must be unique per ring. */
	if (test_bit(IGC_RING_FLAG_TX_CTX_IDX, &tx_ring->flags))
		mss_l4len_idx |= tx_ring->reg_idx << 4;

	context_desc->vlan_macip_lens	= cpu_to_le32(vlan_macip_lens);
	context_desc->type_tucmd_mlhl	= cpu_to_le32(type_tucmd);
	context_desc->mss_l4len_idx	= cpu_to_le32(mss_l4len_idx);

	/* We assume there is always a valid Tx time available. Invalid times
	 * should have been handled by the upper layers.
	 */
	if (tx_ring->launchtime_enable) {
		struct igc_adapter *adapter = netdev_priv(tx_ring->netdev);
		ktime_t txtime = first->skb->tstamp;

		skb_txtime_consumed(first->skb);
		context_desc->launch_time = igc_tx_launchtime(adapter,
							      txtime);
	} else {
		context_desc->launch_time = 0;
	}
}
#+end_src

TX descriptors macros for IGC_TX_DESC and IGC_TX_CTXTDESC seems to overlap:
#+begin_src C
#define IGC_TX_DESC(R, i)       \
	(&(((union igc_adv_tx_desc *)((R)->desc))[i]))
#define IGC_TX_CTXTDESC(R, i)   \
	(&(((struct igc_adv_tx_context_desc *)((R)->desc))[i]))
#+end_src

Layout of =struct igc_adv_tx_context_desc=:
#+begin_src C
$ pahole -C igc_adv_tx_context_desc drivers/net/ethernet/intel/igc/igc.ko
struct igc_adv_tx_context_desc {
	__le32                     vlan_macip_lens;      /*     0     4 */
	__le32                     launch_time;          /*     4     4 */
	__le32                     type_tucmd_mlhl;      /*     8     4 */
	__le32                     mss_l4len_idx;        /*    12     4 */

	/* size: 16, cachelines: 1, members: 4 */
	/* last cacheline: 16 bytes */
};
#+end_src

Layout of =union igc_adv_tx_desc=:
#+begin_src C
$ pahole -C igc_adv_tx_desc drivers/net/ethernet/intel/igc/igc.ko
union igc_adv_tx_desc {
	struct {
		__le64             buffer_addr;        /*     0     8 */
		__le32             cmd_type_len;       /*     8     4 */
		__le32             olinfo_status;      /*    12     4 */
	} read;                                        /*     0    16 */
	struct {
		__le64             rsvd;               /*     0     8 */
		__le32             nxtseq_seed;        /*     8     4 */
		__le32             status;             /*    12     4 */
	} wb;                                          /*     0    16 */
};
#+end_src

Call paths for function: =igc_tx_ctxtdesc()=
 * igc_xmit_frame_ring (not-gso/tso) -> igc_tx_csum -> igc_tx_ctxtdesc
 * igc_xmit_frame_ring (gso/tso)     -> igc_tso     -> igc_tx_ctxtdesc

The 'launch_time' value member is 32-bit (4-bytes). Thus, it cannot contain the
64-bit (8-bytes) long 'ktime_t' value. The SW-datasheet says value LaunchTime is
only 30 bits (bits 61:32). The value resolution are reduced by this function
'igc_tx_launchtime':

#+begin_src C
static __le32 igc_tx_launchtime(struct igc_adapter *adapter, ktime_t txtime)
{
	ktime_t cycle_time = adapter->cycle_time;
	ktime_t base_time = adapter->base_time;
	u32 launchtime;

	/* FIXME: when using ETF together with taprio, we may have a
	 * case where 'delta' is larger than the cycle_time, this may
	 * cause problems if we don't read the current value of
	 * IGC_BASET, as the value writen into the launchtime
	 * descriptor field may be misinterpreted.
	 */
	div_s64_rem(ktime_sub_ns(txtime, base_time), cycle_time, &launchtime);

	return cpu_to_le32(launchtime);
}
#+end_src

The SW-datasheet notes that there us accuracy of 6.4nsec, dictated by the
transmit scheduler operates on a 156.25 MHz clock. The packet is scheduled for
transmission when the SYSTIM registers that is defined for transmit scheduling
(by the Sch_Timer_Sel field in the TQAVCTRL register) is larger than the
"Scheduling Time".

SYSTIM register is related to: igc_ptp_read().

The LaunchTime is a relative offset, to the BaseT register and StQT[n] register
of the queue. It defines the scheduling time of the packet from the packet
buffer to the MAC. On top of it, the GTxOffset register is used to compensate
for the latency between the scheduling “point” and the PHY MDI pins.

In LaunchTime mode (via =igc_save_launchtime_params=) the cycle_time value is
10^9 =(#define NSEC_PER_SEC 1000000000L= in hex 0x3B9ACA00 fits in 32-bit). It
can be configured differently via function [[https://elixir.bootlin.com/linux/v5.12-rc8/A/ident/igc_save_qbv_schedule][igc_save_qbv_schedule]] (indicating
IEEE 802.1Qbv time-aware shaper).  For LaunchTime mode is looks like the
base_time is zero.

The function [[https://elixir.bootlin.com/linux/v5.12-rc8/A/ident/div_s64_rem][div_s64_rem]] :
#+begin_src C
static inline s64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)
{
	*remainder = dividend % divisor;
	return dividend / divisor;
}
#+end_src

As don't use the return value, this is basically reduced to:
#+begin_src C
 u32 launchtime = txtime % NSEC_PER_SEC;
#+end_src

As txtime is in nanosec, then this basically means we can maximum schedule
packets to be send 1 second in the future.

* Driver: igb

** Setup code (driver: igb)

The drivers =ndo_setup_tc()= callback tell us what offload =type= it supports.
#+begin_src C
static int igb_setup_tc(struct net_device *dev, enum tc_setup_type type,
			void *type_data)
{
	struct igb_adapter *adapter = netdev_priv(dev);

	switch (type) {
	case TC_SETUP_QDISC_CBS:
		return igb_offload_cbs(adapter, type_data);
	case TC_SETUP_BLOCK:
		return flow_block_cb_setup_simple(type_data,
						  &igb_block_cb_list,
						  igb_setup_tc_block_cb,
						  adapter, adapter, true);

	case TC_SETUP_QDISC_ETF:
		return igb_offload_txtime(adapter, type_data);

	default:
		return -EOPNOTSUPP;
	}

#+end_src

From below code (function [[https://elixir.bootlin.com/linux/v5.12-rc8/source/drivers/net/ethernet/intel/igb/igb_main.c#L2780][igb_offload_txtime]]) we identify some hardware
limitations. E.g. Launchtime offloading is only supported by queues 0 and 1.
(The function [[https://elixir.bootlin.com/linux/v5.12-rc8/source/drivers/net/ethernet/intel/igb/igb_main.c#L2546][igb_offload_cbs]] also have queue 0+1 limit).

#+begin_src C
static int igb_offload_txtime(struct igb_adapter *adapter,
			      struct tc_etf_qopt_offload *qopt)
{
	struct e1000_hw *hw = &adapter->hw;
	int err;

	/* Launchtime offloading is only supported by i210 controller. */
	if (hw->mac.type != e1000_i210)
		return -EOPNOTSUPP;

	/* Launchtime offloading is only supported by queues 0 and 1. */
	if (qopt->queue < 0 || qopt->queue > 1)
		return -EINVAL;

	err = igb_save_txtime_params(adapter, qopt->queue, qopt->enable);
	if (err)
		return err;

	igb_offload_apply(adapter, qopt->queue);

	return 0;
}
#+end_src

Function [[https://elixir.bootlin.com/linux/v5.12-rc8/source/drivers/net/ethernet/intel/igb/igb_main.c#L1854][igb_save_txtime_params]] simply set =ring->launchtime_enable=.
The function =igb_offload_apply= calls function that does HW setup.

In setup function [[https://elixir.bootlin.com/linux/v5.12/A/ident/igb_config_tx_modes][igb_config_tx_modes()]], there are indications that matching
'queue==0' gets higher priority. Code talk about SR queues, which according to
datasheet means *Strict Reservation* (SR) queues. Only queue 0 and 1 can be
SR-queues.

** TX time to hardware (driver: igb)

In function igb_tx_ctxtdesc the the "launch_time" timestamp is transferred to
the hardware via the TX context descriptor (below =context_desc= type struct
[[https://elixir.bootlin.com/linux/v5.12/source/drivers/net/ethernet/intel/igb/e1000_82575.h#L122][e1000_adv_tx_context_desc]]).

#+begin_src C
/* Context descriptors */
struct e1000_adv_tx_context_desc {
	__le32 vlan_macip_lens;
	__le32 seqnum_seed;
	__le32 type_tucmd_mlhl;
	__le32 mss_l4len_idx;
};
#+end_src

Function: igb_tx_ctxtdesc
#+begin_src C
static void igb_tx_ctxtdesc(struct igb_ring *tx_ring,
			    struct igb_tx_buffer *first,
			    u32 vlan_macip_lens, u32 type_tucmd,
			    u32 mss_l4len_idx)
{
	struct e1000_adv_tx_context_desc *context_desc;
	u16 i = tx_ring->next_to_use;
	struct timespec64 ts;

	context_desc = IGB_TX_CTXTDESC(tx_ring, i);

	i++;
	tx_ring->next_to_use = (i < tx_ring->count) ? i : 0;

	/* set bits to identify this as an advanced context descriptor */
	type_tucmd |= E1000_TXD_CMD_DEXT | E1000_ADVTXD_DTYP_CTXT;

	/* For 82575, context index must be unique per ring. */
	if (test_bit(IGB_RING_FLAG_TX_CTX_IDX, &tx_ring->flags))
		mss_l4len_idx |= tx_ring->reg_idx << 4;

	context_desc->vlan_macip_lens	= cpu_to_le32(vlan_macip_lens);
	context_desc->type_tucmd_mlhl	= cpu_to_le32(type_tucmd);
	context_desc->mss_l4len_idx	= cpu_to_le32(mss_l4len_idx);

	/* We assume there is always a valid tx time available. Invalid times
	 * should have been handled by the upper layers.
	 */
	if (tx_ring->launchtime_enable) {
		ts = ktime_to_timespec64(first->skb->tstamp);
		skb_txtime_consumed(first->skb);
		context_desc->seqnum_seed = cpu_to_le32(ts.tv_nsec / 32);
	} else {
		context_desc->seqnum_seed = 0;
	}
}
#+end_src

We notice the member name =seqnum_seed= is less obviously (than igc) the member
to store the 'LaunchTime' value in. Again the driver comment notes that upper
layers (I assume qdisc) have made sure only valid times reach this code. Code
extracts the nsec part of the timestamp via =ktime_to_timespec64= which calls
=ns_to_timespec64=.

Datasheet for i210 section 7.2.7.5.3 ("Launch Time/Fetch Time Decision")
describe some of these limitations:

The div 32 in the code above, is because the accuracy is 32ns (or 0.032 usec):
 - Launch time/Fetch time match exactly the relevant portion of SYSTIML value.
   It is compared against SYSTIML[29:5], and provides transmission granularity
   of 0.032 µs.

It describes a 0.5 second limit:
 - The Allowed Fetch time and Allowed Launch time should be calculated such that
   it is allowed to Fetch/Transmit a packet if the current time is within
   Fetch/Launch time + 0.5 second.

The SYSTIML register wraps every second in nanosec scale:
 - Note that the SYSTIML register max value is 999,999,999 dec (0x3B9AC9FF) and
   it wraps to 0 when reaching this value (representing a full second).

Datasheet i210 section 7.2.2.2.3 ("LaunchTime (25)") also describe a lot of
useful detail. The LaunchTime is a 25 bit field defined in 32 nsec units (Launch
time = LaunchTime * 32). In LaunchTime bits 56:32 in Advanced Transmit Context
Descriptor Layout (when Type = 0010b).

The 25 bit (with multiplier 32) can represent slightly above 1 sec in future:
#+begin_example
 (2^25)*32/1000000000 = 1.073741824 sec
#+end_example

There is also a LaunchOffset (25 bit, 32nsec granularity):
 - The LaunchTime parameter is a relative time to the LaunchOffset parameter in
   the LAUNCH_OS0 register. So, the actual Launch time equals
   to 32 * (LaunchOffset + LaunchTime).
 - The calculated launch time should not exceed 1 second on which SYSTIML wraps
   around.

