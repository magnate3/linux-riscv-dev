#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef signed char __s8;

typedef unsigned char __u8;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __s8 s8;

typedef __u8 u8;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef unsigned int __kernel_size_t;

typedef int __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef __u32 __le32;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef s32 int32_t;

typedef u32 uint32_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef u32 dma_addr_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u32 phys_addr_t;

typedef long unsigned int irq_hw_number_t;

typedef struct {
	int counter;
} atomic_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct kernel_symbol {
	long unsigned int value;
	const char *name;
	const char *namespace;
};

struct pt_regs {
	long unsigned int uregs[18];
};

struct arch_hw_breakpoint_ctrl {
	u32 __reserved: 9;
	u32 mismatch: 1;
	short: 9;
	u32 len: 8;
	u32 type: 2;
	u32 privilege: 2;
	u32 enabled: 1;
};

struct arch_hw_breakpoint {
	u32 address;
	u32 trigger;
	struct arch_hw_breakpoint_ctrl step_ctrl;
	struct arch_hw_breakpoint_ctrl ctrl;
};

struct perf_event;

struct debug_info {
	struct perf_event *hbp[32];
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	s64 counter;
} atomic64_t;

typedef struct {
	atomic64_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 __reserved_1: 30;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
	int: 32;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	int: 32;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
	int: 32;
};

struct task_struct;

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct list_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			int: 32;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

typedef atomic_t atomic_long_t;

struct __raw_tickets {
	u16 owner;
	u16 next;
};

typedef struct {
	union {
		u32 slock;
		struct __raw_tickets tickets;
	};
} arch_spinlock_t;

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
};

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
};

typedef struct raw_spinlock raw_spinlock_t;

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct ftrace_ops;

struct ftrace_regs;

typedef void (*ftrace_func_t)(long unsigned int, long unsigned int, struct ftrace_ops *, struct ftrace_regs *);

struct ftrace_hash;

struct ftrace_ops_hash {
	struct ftrace_hash *notrace_hash;
	struct ftrace_hash *filter_hash;
	struct mutex regex_lock;
};

struct ftrace_ops {
	ftrace_func_t func;
	struct ftrace_ops *next;
	long unsigned int flags;
	void *private;
	ftrace_func_t saved_func;
	struct ftrace_ops_hash local_hash;
	struct ftrace_ops_hash *func_hash;
	struct ftrace_ops_hash old_hash;
	long unsigned int trampoline;
	long unsigned int trampoline_size;
	struct list_head list;
};

struct pmu;

struct perf_event_context;

struct perf_buffer;

struct fasync_struct;

struct perf_addr_filter_range;

struct pid_namespace;

struct bpf_prog;

struct trace_event_call;

struct event_filter;

struct perf_cgroup;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	int: 32;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	u64 shadow_ctx_time;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	int pending_wakeup;
	int pending_kill;
	int pending_disable;
	struct irq_work pending;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct perf_cgroup *cgrp;
	struct list_head sb_list;
};

struct thread_struct {
	long unsigned int address;
	long unsigned int trap_no;
	long unsigned int error_code;
	struct debug_info debug;
};

typedef int (*initcall_t)();

typedef initcall_t initcall_entry_t;

struct lock_class_key {};

struct fs_context;

struct fs_parameter_spec;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

typedef struct {
	u32 lock;
} arch_rwlock_t;

struct lockdep_map {};

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, bool);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_RUNNING = 2,
	SYSTEM_HALT = 3,
	SYSTEM_POWER_OFF = 4,
	SYSTEM_RESTART = 5,
	SYSTEM_SUSPEND = 6,
};

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
	int: 32;
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

typedef struct {
	uid_t val;
} kuid_t;

typedef struct {
	gid_t val;
} kgid_t;

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct ctl_table;

struct completion;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct key;

struct ucounts;

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	int ucount_max[10];
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
};

struct bug_entry {
	long unsigned int bug_addr;
	const char *file;
	short unsigned int line;
	short unsigned int flags;
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct restart_block {
	long int (*fn)(struct restart_block *);
	int: 32;
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
			int: 32;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			int: 32;
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct vfp_hard_struct {
	__u64 fpregs[32];
	__u32 fpexc;
	__u32 fpscr;
	__u32 fpinst;
	__u32 fpinst2;
	__u32 cpu;
	int: 32;
};

union vfp_state {
	struct vfp_hard_struct hard;
};

struct fp_hard_struct {
	unsigned int save[35];
};

struct fp_soft_struct {
	unsigned int save[35];
};

struct iwmmxt_struct {
	unsigned int save[38];
};

union fp_state {
	struct fp_hard_struct hard;
	struct fp_soft_struct soft;
	struct iwmmxt_struct iwmmxt;
};

typedef struct page *pgtable_t;

struct address_space;

struct kmem_cache;

struct mm_struct;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			dma_addr_t dma_addr;
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page *next;
					short int pages;
					short int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
			unsigned int compound_nr;
		};
		struct {
			long unsigned int _compound_pad_1;
			atomic_t hpage_pinned_refcount;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
};

typedef u32 pteval_t;

typedef pteval_t pgprot_t;

struct vm_userfaultfd_ctx {};

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct *vm_next;
	struct vm_area_struct *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	struct {
		struct rb_node rb;
		long unsigned int rb_subtree_last;
	} shared;
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

typedef u32 pmdval_t;

typedef pteval_t pte_t;

typedef pmdval_t pmd_t;

typedef pmdval_t pgd_t[2];

typedef long unsigned int mm_segment_t;

struct cpu_context_save {
	__u32 r4;
	__u32 r5;
	__u32 r6;
	__u32 r7;
	__u32 r8;
	__u32 r9;
	__u32 sl;
	__u32 fp;
	__u32 sp;
	__u32 pc;
	__u32 extra[2];
};

struct thread_info {
	long unsigned int flags;
	int preempt_count;
	mm_segment_t addr_limit;
	struct task_struct *task;
	__u32 cpu;
	__u32 cpu_domain;
	long unsigned int stack_canary;
	struct cpu_context_save cpu_context;
	__u32 syscall;
	__u8 used_cp[16];
	long unsigned int tp_value[2];
	union fp_state fpstate;
	union vfp_state vfpstate;
	long unsigned int thumbee_state;
	int: 32;
};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct sched_statistics {};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	int: 32;
	struct util_est util_est;
	int: 32;
	int: 32;
};

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	struct sched_statistics statistics;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_avg avg;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	int: 32;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct sched_dl_entity *pi_se;
	int: 32;
};

struct cpumask {
	long unsigned int bits[1];
};

typedef struct cpumask cpumask_t;

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct vmacache {
	u64 seqnum;
	struct vm_area_struct *vmas[4];
};

struct task_rss_stat {
	int events;
	int count[4];
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
	int: 32;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[2];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct syscall_user_dispatch {};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {};

struct tlbflush_unmap_batch {};

struct page_frag {
	struct page *page;
	__u16 offset;
	__u16 size;
};

struct kmap_ctrl {
	int idx;
	pte_t pteval[16];
};

struct llist_head {
	struct llist_node *first;
};

struct sched_class;

struct pid;

struct cred;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct futex_pi_state;

struct rseq;

struct ftrace_ret_stack;

struct uprobe_task;

struct task_struct {
	volatile long int state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_entity se;
	struct sched_rt_entity rt;
	int: 32;
	struct sched_dl_entity dl;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	short unsigned int migration_disabled;
	short unsigned int migration_flags;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	bool trc_reader_checked;
	struct list_head trc_holdout_list;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct vmacache vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	int: 29;
	unsigned int sched_remote_wakeup: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int brk_randomized: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	int: 32;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct rseq *rseq;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	int: 32;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	int: 32;
	long long unsigned int ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct uprobe_task *utask;
	struct kmap_ctrl kmap_ctrl;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct llist_head kretprobe_instances;
	struct thread_struct thread;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct cpumask cpumask_var_t[1];

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 3,
	N_MEMORY = 4,
	N_CPU = 5,
	N_GENERIC_INITIATOR = 6,
	NR_NODE_STATES = 7,
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

typedef struct {
	atomic64_t id;
	unsigned int vmalloc_seq;
	long unsigned int sigpage;
	long unsigned int vdso;
	int: 32;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct linux_binfmt;

struct core_state;

struct kioctx_table;

struct mm_struct {
	struct {
		struct vm_area_struct *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_t has_pinned;
		seqcount_t write_protect_seq;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[42];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		int: 32;
		mm_context_t context;
		long unsigned int flags;
		struct core_state *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct user_namespace *user_ns;
		struct file *exe_file;
		atomic_t tlb_flush_pending;
		struct uprobes_state uprobes_state;
		struct work_struct async_put_work;
		u32 pasid;
		int: 32;
	};
	long unsigned int cpu_bitmap[0];
};

struct arch_uprobe_task {
	u32 backup;
	long unsigned int saved_trap_no;
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct return_instance {
	struct uprobe *uprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct workqueue_struct;

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int nrexceptional;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

struct vmem_altmap {
	const long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_FS_DAX = 2,
	MEMORY_DEVICE_GENERIC = 3,
	MEMORY_DEVICE_PCI_P2PDMA = 4,
};

struct range {
	u64 start;
	u64 end;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref *ref;
	struct percpu_ref internal_ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct range ranges[0];
	};
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	int: 32;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	int: 32;
	struct file_ra_state f_ra;
	u64 f_version;
	void *private_data;
	struct hlist_head *f_ep;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
	int: 32;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	unsigned int degree;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *, long unsigned int);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	void (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

typedef struct {
	pgd_t pgd;
} p4d_t;

typedef struct {
	p4d_t p4d;
} pud_t;

struct vm_fault {
	struct vm_area_struct *vma;
	unsigned int flags;
	gfp_t gfp_mask;
	long unsigned int pgoff;
	long unsigned int address;
	pmd_t *pmd;
	pud_t *pud;
	pte_t orig_pte;
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_KERNEL_MISC_RECLAIMABLE = 33,
	NR_FOLL_PIN_ACQUIRED = 34,
	NR_FOLL_PIN_RELEASED = 35,
	NR_KERNEL_STACK_KB = 36,
	NR_PAGETABLE = 37,
	NR_VM_NODE_STAT_ITEMS = 38,
};

typedef unsigned int isolate_mode_t;

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	u8 enabled;
	u8 offloaded;
};

struct srcu_node;

struct srcu_struct;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	int: 32;
	int: 32;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node node[1];
	struct srcu_node *level[2];
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_last_gp_end;
	struct srcu_data *sda;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	struct delayed_work work;
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct user_struct;

struct group_info;

struct cred {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

typedef __u32 Elf32_Word;

struct elf32_sym {
	Elf32_Word st_name;
	Elf32_Addr st_value;
	Elf32_Word st_size;
	unsigned char st_info;
	unsigned char st_other;
	Elf32_Half st_shndx;
};

typedef struct elf32_sym Elf32_Sym;

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
};

struct kernfs_node;

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
	int: 32;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	int: 32;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	int: 32;
	u64 id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct seq_operations;

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	int: 32;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
	int: 32;
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct kobject;

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct kref {
	refcount_t refcount;
};

struct kset;

struct kobj_type;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kset *, struct kobject *);
	const char * (* const name)(struct kset *, struct kobject *);
	int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};

struct kernel_param;

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct mod_plt_sec {
	struct elf32_shdr *plt;
	int plt_count;
};

struct mod_arch_specific {
	struct mod_plt_sec core;
	struct mod_plt_sec init;
};

struct mod_kallsyms {
	Elf32_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct module_attribute;

struct exception_table_entry;

struct module_sect_attrs;

struct module_notes_attrs;

struct tracepoint;

typedef struct tracepoint * const tracepoint_ptr_t;

struct bpf_raw_event_map;

struct trace_eval_map;

struct module {
	enum module_state state;
	struct list_head list;
	char name[60];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool async_probe_requested;
	const struct kernel_symbol *gpl_future_syms;
	const s32 *gpl_future_crcs;
	unsigned int num_gpl_future_syms;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	void *btf_data;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	long unsigned int *ftrace_callsites;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct static_key {
	atomic_t enabled;
};

struct static_key_false {
	struct static_key key;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct static_call_key;

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

struct static_call_key {
	void *func;
};

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct exception_table_entry {
	long unsigned int insn;
	long unsigned int fixup;
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct bpf_prog_array;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	void *mod;
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
	int: 32;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	int: 32;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[36];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct posix_acl;

struct inode_operations;

struct file_lock_context;

struct cdev;

struct fsnotify_mark_connector;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	seqcount_t i_size_seqcount;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
	int: 32;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	int: 32;
	int: 32;
	int: 32;
};

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	int: 32;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
	int: 32;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
	int: 32;
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct shrink_control;

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	atomic_long_t *nr_deferred;
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct block_device;

struct mtd_info;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	int: 32;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	const struct xattr_handler **s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	int: 32;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	int: 32;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_inode_refs;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct mem_cgroup;

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	long int nr_items;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t *__sigrestore_t;

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			short int _addr_lsb;
			struct {
				char _dummy_bnd[4];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[4];
				__u32 _pkey;
			} _addr_pkey;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct user_struct {
	refcount_t __count;
	atomic_t processes;
	atomic_t sigpending;
	atomic_long_t epoll_watches;
	long unsigned int locked_shm;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	int: 32;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	int: 32;
	struct hrtimer_clock_base clock_base[8];
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct tty_struct;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	int: 32;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	int: 32;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	union {
		__u64 ptr64;
		struct {
			__u32 ptr32;
			__u32 padding;
		} ptr;
	} rseq_cs;
	__u32 flags;
	int: 32;
	int: 32;
	int: 32;
};

struct rq;

struct rq_flags;

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *, u32);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[2];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	int: 32;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct blk_plug {
	struct list_head mq_list;
	struct list_head cb_list;
	short unsigned int rq_count;
	bool multiple_queues;
	bool nowait;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
};

struct percpu_counter {
	raw_spinlock_t lock;
	int: 32;
	s64 count;
	struct list_head list;
	s32 *counters;
	int: 32;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	struct percpu_counter stat[4];
	long unsigned int congested;
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
	int: 32;
};

struct device;

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	int: 32;
	struct bdi_writeback wb;
	struct list_head wb_list;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
	int: 32;
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	atomic_t nr_tasks;
	spinlock_t lock;
	short unsigned int ioprio;
	struct xarray icq_tree;
	struct io_cq *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

struct cgroup_subsys_state;

struct cgroup;

struct css_set {
	struct cgroup_subsys_state *subsys[1];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[1];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct perf_event_groups {
	struct rb_root tree;
	int: 32;
	u64 index;
};

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	int: 32;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	int: 32;
	u64 time;
	u64 timestamp;
	struct perf_event_context *parent_ctx;
	int: 32;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	int nr_cgroups;
	void *task_ctx_data;
	struct callback_head callback_head;
	int: 32;
};

struct ftrace_ret_stack {
	long unsigned int ret;
	long unsigned int func;
	long long unsigned int calltime;
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
	int: 32;
};

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct psi_group {};

struct cgroup_bpf {
	struct bpf_prog_array *effective[38];
	struct list_head progs[38];
	u32 flags[38];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[1];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[1];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	u64 ancestor_ids[0];
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct request_queue;

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

enum rpm_status {
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	int: 32;
	u64 batch;
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	long unsigned int bounce_pfn;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_write_same_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
};

struct bsg_ops;

struct bsg_class_device {
	struct device *class_dev;
	int minor;
	struct request_queue *queue;
	const struct bsg_ops *ops;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
};

struct request;

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_stat_callback;

struct blk_flush_queue;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int queue_depth;
	struct blk_mq_hw_ctx **queue_hw_ctx;
	unsigned int nr_hw_queues;
	struct backing_dev_info *backing_dev_info;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	gfp_t bounce_gfp;
	spinlock_t queue_lock;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct device *dev;
	enum rpm_status rpm_status;
	unsigned int nr_pending;
	long unsigned int nr_requests;
	unsigned int dma_pad_mask;
	unsigned int dma_alignment;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	int: 32;
	struct blk_rq_stat poll_stat[16];
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_sbitmap;
	struct list_head icq_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	int node;
	struct mutex debugfs_mutex;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct bsg_class_device bsg_dev;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct bio_set bio_split;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	bool mq_sysfs_init_done;
	size_t cmd_size;
	u64 write_hints[5];
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	int: 32;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	union {
		unsigned int ki_cookie;
		struct wait_page_queue *ki_waitq;
	};
	int: 32;
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
	int: 32;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	int: 32;
	struct mem_dqblk dq_dqb;
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_dqblk {
	int d_fieldmask;
	int: 32;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
	int: 32;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	int: 32;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	int: 32;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct wait_page_queue {
	struct page *page;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct writeback_control;

struct readahead_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*readpage)(struct file *, struct page *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	int (*set_page_dirty)(struct page *);
	int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidatepage)(struct page *, unsigned int, unsigned int);
	int (*releasepage)(struct page *, gfp_t);
	void (*freepage)(struct page *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
	bool (*isolate_page)(struct page *, isolate_mode_t);
	void (*putback_page)(struct page *);
	int (*launder_page)(struct page *);
	int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int *cluster_next_cpu;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct fiemap_extent_info;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct dentry *, struct iattr *);
	int (*getattr)(const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct inode *, struct posix_acl *, int);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
	int: 32;
};

struct lock_manager_operations {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
};

struct iomap;

struct fid;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	long unsigned int flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
	int: 32;
};

struct dma_iommu_mapping;

struct dev_archdata {
	struct dma_iommu_mapping *mapping;
	unsigned int dma_coherent: 1;
	unsigned int dma_ops_setup: 1;
};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct irq_domain;

struct dev_pin_info;

struct dma_map_ops;

struct bus_dma_region;

struct device_dma_parameters;

struct dma_coherent_mem;

struct cma;

struct device_node;

struct fwnode_handle;

struct class;

struct iommu_group;

struct dev_iommu;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	int: 32;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct irq_domain *msi_domain;
	struct dev_pin_info *pins;
	struct list_head msi_list;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	int: 32;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dma_coherent_mem *dma_mem;
	struct cma *cma_area;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	int: 28;
	int: 32;
};

struct disk_stats;

struct gendisk;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	struct disk_stats *bd_stats;
	long unsigned int bd_stamp;
	bool bd_read_only;
	dev_t bd_dev;
	int bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	struct mutex bd_mutex;
	void *bd_claiming;
	int: 32;
	struct device bd_device;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct list_head bd_holder_disks;
	struct kobject *bd_holder_dir;
	u8 bd_partno;
	unsigned int bd_part_count;
	spinlock_t bd_size_lock;
	struct gendisk *bd_disk;
	struct backing_dev_info *bd_bdi;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct super_block *bd_fsfreeze_sb;
	struct partition_meta_info *bd_meta_info;
	int: 32;
};

typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	int: 32;
	loff_t pos;
};

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
};

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
	int: 32;
};

typedef void bio_end_io_t(struct bio *);

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bio {
	struct bio *bi_next;
	struct gendisk *bi_disk;
	unsigned int bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	short unsigned int bi_write_hint;
	blk_status_t bi_status;
	u8 bi_partno;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	union {	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	int: 32;
	loff_t written;
	loff_t pos;
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct pm_domain_data;

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	struct list_head clock_list;
	struct pm_domain_data *domain_data;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
	int: 30;
	int: 32;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

enum iommu_cap {
	IOMMU_CAP_CACHE_COHERENCY = 0,
	IOMMU_CAP_INTR_REMAP = 1,
	IOMMU_CAP_NOEXEC = 2,
};

enum iommu_attr {
	DOMAIN_ATTR_GEOMETRY = 0,
	DOMAIN_ATTR_PAGING = 1,
	DOMAIN_ATTR_WINDOWS = 2,
	DOMAIN_ATTR_FSL_PAMU_STASH = 3,
	DOMAIN_ATTR_FSL_PAMU_ENABLE = 4,
	DOMAIN_ATTR_FSL_PAMUV1 = 5,
	DOMAIN_ATTR_NESTING = 6,
	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE = 7,
	DOMAIN_ATTR_IO_PGTABLE_CFG = 8,
	DOMAIN_ATTR_MAX = 9,
};

enum iommu_dev_features {
	IOMMU_DEV_FEAT_AUX = 0,
	IOMMU_DEV_FEAT_SVA = 1,
};

struct iommu_domain;

struct iommu_iotlb_gather;

struct iommu_device;

struct iommu_resv_region;

struct of_phandle_args;

struct iommu_sva;

struct iommu_fault_event;

struct iommu_page_response;

struct iommu_cache_invalidate_info;

struct iommu_gpasid_bind_data;

struct iommu_ops {
	bool (*capable)(enum iommu_cap);
	struct iommu_domain * (*domain_alloc)(unsigned int);
	void (*domain_free)(struct iommu_domain *);
	int (*attach_dev)(struct iommu_domain *, struct device *);
	void (*detach_dev)(struct iommu_domain *, struct device *);
	int (*map)(struct iommu_domain *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	size_t (*unmap)(struct iommu_domain *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	void (*flush_iotlb_all)(struct iommu_domain *);
	void (*iotlb_sync_map)(struct iommu_domain *);
	void (*iotlb_sync)(struct iommu_domain *, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct iommu_domain *, dma_addr_t);
	struct iommu_device * (*probe_device)(struct device *);
	void (*release_device)(struct device *);
	void (*probe_finalize)(struct device *);
	struct iommu_group * (*device_group)(struct device *);
	int (*domain_get_attr)(struct iommu_domain *, enum iommu_attr, void *);
	int (*domain_set_attr)(struct iommu_domain *, enum iommu_attr, void *);
	void (*get_resv_regions)(struct device *, struct list_head *);
	void (*put_resv_regions)(struct device *, struct list_head *);
	void (*apply_resv_region)(struct device *, struct iommu_domain *, struct iommu_resv_region *);
	int (*domain_window_enable)(struct iommu_domain *, u32, phys_addr_t, u64, int);
	void (*domain_window_disable)(struct iommu_domain *, u32);
	int (*of_xlate)(struct device *, struct of_phandle_args *);
	bool (*is_attach_deferred)(struct iommu_domain *, struct device *);
	bool (*dev_has_feat)(struct device *, enum iommu_dev_features);
	bool (*dev_feat_enabled)(struct device *, enum iommu_dev_features);
	int (*dev_enable_feat)(struct device *, enum iommu_dev_features);
	int (*dev_disable_feat)(struct device *, enum iommu_dev_features);
	int (*aux_attach_dev)(struct iommu_domain *, struct device *);
	void (*aux_detach_dev)(struct iommu_domain *, struct device *);
	int (*aux_get_pasid)(struct iommu_domain *, struct device *);
	struct iommu_sva * (*sva_bind)(struct device *, struct mm_struct *, void *);
	void (*sva_unbind)(struct iommu_sva *);
	u32 (*sva_get_pasid)(struct iommu_sva *);
	int (*page_response)(struct device *, struct iommu_fault_event *, struct iommu_page_response *);
	int (*cache_invalidate)(struct iommu_domain *, struct device *, struct iommu_cache_invalidate_info *);
	int (*sva_bind_gpasid)(struct iommu_domain *, struct device *, struct iommu_gpasid_bind_data *);
	int (*sva_unbind_gpasid)(struct device *, u32);
	int (*def_domain_type)(struct device *);
	long unsigned int pgsize_bitmap;
	struct module *owner;
};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[9];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	long unsigned int segment_boundary_mask;
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
};

struct irq_domain_ops;

struct irq_domain_chip_generic;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_tree_mutex;
	unsigned int linear_revmap[0];
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	void * (*alloc_noncoherent)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_noncoherent)(struct device *, size_t, void *, dma_addr_t, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	struct kobject kobj;
	long unsigned int _flags;
	void *data;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_VMSTAT_DEAD = 14,
	CPUHP_SOFTIRQ_DEAD = 15,
	CPUHP_NET_MVNETA_DEAD = 16,
	CPUHP_CPUIDLE_DEAD = 17,
	CPUHP_ARM64_FPSIMD_DEAD = 18,
	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
	CPUHP_IRQ_POLL_DEAD = 20,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
	CPUHP_ACPI_CPUDRV_DEAD = 22,
	CPUHP_S390_PFAULT_DEAD = 23,
	CPUHP_BLK_MQ_DEAD = 24,
	CPUHP_FS_BUFF_DEAD = 25,
	CPUHP_PRINTK_DEAD = 26,
	CPUHP_MM_MEMCQ_DEAD = 27,
	CPUHP_PERCPU_CNT_DEAD = 28,
	CPUHP_RADIX_DEAD = 29,
	CPUHP_PAGE_ALLOC_DEAD = 30,
	CPUHP_NET_DEV_DEAD = 31,
	CPUHP_PCI_XGENE_DEAD = 32,
	CPUHP_IOMMU_INTEL_DEAD = 33,
	CPUHP_LUSTRE_CFS_DEAD = 34,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
	CPUHP_PADATA_DEAD = 36,
	CPUHP_WORKQUEUE_PREP = 37,
	CPUHP_POWER_NUMA_PREPARE = 38,
	CPUHP_HRTIMERS_PREPARE = 39,
	CPUHP_PROFILE_PREPARE = 40,
	CPUHP_X2APIC_PREPARE = 41,
	CPUHP_SMPCFD_PREPARE = 42,
	CPUHP_RELAY_PREPARE = 43,
	CPUHP_SLAB_PREPARE = 44,
	CPUHP_MD_RAID5_PREPARE = 45,
	CPUHP_RCUTREE_PREP = 46,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
	CPUHP_POWERPC_PMAC_PREPARE = 48,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
	CPUHP_XEN_PREPARE = 50,
	CPUHP_XEN_EVTCHN_PREPARE = 51,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
	CPUHP_SH_SH3X_PREPARE = 53,
	CPUHP_NET_FLOW_PREPARE = 54,
	CPUHP_TOPOLOGY_PREPARE = 55,
	CPUHP_NET_IUCV_PREPARE = 56,
	CPUHP_ARM_BL_PREPARE = 57,
	CPUHP_TRACE_RB_PREPARE = 58,
	CPUHP_MM_ZS_PREPARE = 59,
	CPUHP_MM_ZSWP_MEM_PREPARE = 60,
	CPUHP_MM_ZSWP_POOL_PREPARE = 61,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 62,
	CPUHP_ZCOMP_PREPARE = 63,
	CPUHP_TIMERS_PREPARE = 64,
	CPUHP_MIPS_SOC_PREPARE = 65,
	CPUHP_BP_PREPARE_DYN = 66,
	CPUHP_BP_PREPARE_DYN_END = 86,
	CPUHP_BRINGUP_CPU = 87,
	CPUHP_AP_IDLE_DEAD = 88,
	CPUHP_AP_OFFLINE = 89,
	CPUHP_AP_SCHED_STARTING = 90,
	CPUHP_AP_RCUTREE_DYING = 91,
	CPUHP_AP_CPU_PM_STARTING = 92,
	CPUHP_AP_IRQ_GIC_STARTING = 93,
	CPUHP_AP_IRQ_HIP04_STARTING = 94,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 95,
	CPUHP_AP_IRQ_BCM2836_STARTING = 96,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 97,
	CPUHP_AP_IRQ_RISCV_STARTING = 98,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 99,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 100,
	CPUHP_AP_MICROCODE_LOADER = 101,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 102,
	CPUHP_AP_PERF_X86_STARTING = 103,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 104,
	CPUHP_AP_PERF_X86_CQM_STARTING = 105,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 106,
	CPUHP_AP_PERF_XTENSA_STARTING = 107,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 108,
	CPUHP_AP_ARM_SDEI_STARTING = 109,
	CPUHP_AP_ARM_VFP_STARTING = 110,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 111,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 112,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 113,
	CPUHP_AP_PERF_ARM_STARTING = 114,
	CPUHP_AP_ARM_L2X0_STARTING = 115,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 116,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 117,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 118,
	CPUHP_AP_JCORE_TIMER_STARTING = 119,
	CPUHP_AP_ARM_TWD_STARTING = 120,
	CPUHP_AP_QCOM_TIMER_STARTING = 121,
	CPUHP_AP_TEGRA_TIMER_STARTING = 122,
	CPUHP_AP_ARMADA_TIMER_STARTING = 123,
	CPUHP_AP_MARCO_TIMER_STARTING = 124,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 125,
	CPUHP_AP_ARC_TIMER_STARTING = 126,
	CPUHP_AP_RISCV_TIMER_STARTING = 127,
	CPUHP_AP_CLINT_TIMER_STARTING = 128,
	CPUHP_AP_CSKY_TIMER_STARTING = 129,
	CPUHP_AP_HYPERV_TIMER_STARTING = 130,
	CPUHP_AP_KVM_STARTING = 131,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 132,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 133,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 134,
	CPUHP_AP_DUMMY_TIMER_STARTING = 135,
	CPUHP_AP_ARM_XEN_STARTING = 136,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 137,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 138,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 139,
	CPUHP_AP_SMPCFD_DYING = 140,
	CPUHP_AP_X86_TBOOT_DYING = 141,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 142,
	CPUHP_AP_ONLINE = 143,
	CPUHP_TEARDOWN_CPU = 144,
	CPUHP_AP_ONLINE_IDLE = 145,
	CPUHP_AP_SCHED_WAIT_EMPTY = 146,
	CPUHP_AP_SMPBOOT_THREADS = 147,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 148,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 149,
	CPUHP_AP_BLK_MQ_ONLINE = 150,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 151,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 152,
	CPUHP_AP_PERF_ONLINE = 153,
	CPUHP_AP_PERF_X86_ONLINE = 154,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 155,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 156,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 157,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 158,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 159,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 160,
	CPUHP_AP_PERF_S390_CF_ONLINE = 161,
	CPUHP_AP_PERF_S390_SF_ONLINE = 162,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 163,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 164,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 165,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 166,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 167,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 168,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 169,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 170,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 171,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 172,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 173,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 174,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 175,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 176,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 177,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 178,
	CPUHP_AP_WATCHDOG_ONLINE = 179,
	CPUHP_AP_WORKQUEUE_ONLINE = 180,
	CPUHP_AP_RCUTREE_ONLINE = 181,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 182,
	CPUHP_AP_ONLINE_DYN = 183,
	CPUHP_AP_ONLINE_DYN_END = 213,
	CPUHP_AP_X86_HPET_ONLINE = 214,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 215,
	CPUHP_AP_ACTIVE = 216,
	CPUHP_ONLINE = 217,
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	void (*kill)(struct dev_pagemap *);
	void (*cleanup)(struct dev_pagemap *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	int: 32;
	loff_t readpos;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	int full;
	int: 32;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
	unsigned int ipi_offset;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqaction;

struct irq_affinity_notify;

struct proc_dir_entry;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	int: 32;
	int: 32;
	int: 32;
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RECLAIM = 1,
	KMALLOC_DMA = 2,
	NR_KMALLOC_TYPES = 3,
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct msi_msg;

struct irq_chip {
	struct device *parent_device;
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_cpu_online)(struct irq_data *);
	void (*irq_cpu_offline)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	int: 32;
	int: 32;
	int: 32;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_rsvd: 24;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 reserved: 40;
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	int count;
	atomic_t ucount[10];
};

struct ftrace_regs {
	struct pt_regs regs;
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
	int: 32;
};

struct u64_stats_sync {
	seqcount_t seq;
};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
	int: 32;
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	struct bpf_cgroup_storage *cgroup_storage[2];
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
	int: 32;
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	int: 32;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	int: 32;
	struct cgroup cgrp;
	u64 cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
};

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct perf_cgroup *cgrp;
	struct list_head cgrp_cpuctx_entry;
	int sched_cb_usage;
	int online;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 addr;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 period;
	u64 weight;
	u64 txn;
	union perf_mem_data_src data_src;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	int: 32;
	u64 aux_size;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	u64 cgroup;
	u64 data_page_size;
	u64 code_page_size;
};

struct perf_cgroup_info;

struct perf_cgroup {
	struct cgroup_subsys_state css;
	struct perf_cgroup_info *info;
	int: 32;
};

struct perf_cgroup_info {
	u64 time;
	u64 timestamp;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	int: 32;
	u64 ts;
	loff_t pos;
	long int idx;
	int: 32;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_buffer;

struct trace_event_file;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	long unsigned int flags;
	int pc;
	struct pt_regs *regs;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_PTR_STRING = 3,
	FILTER_TRACE_FN = 4,
	FILTER_COMM = 5,
	FILTER_CPU = 6,
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
	long unsigned int _flags;
	struct bin_attribute attr;
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

struct disk_part_tbl;

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct cdrom_device_info;

struct badblocks;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct disk_part_tbl *part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	int flags;
	long unsigned int state;
	struct kobject *slave_dir;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	struct cdrom_device_info *cdi;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

typedef unsigned int blk_qc_t;

struct disk_part_tbl {
	struct callback_head callback_head;
	int len;
	struct block_device *last_lookup;
	struct block_device *part[0];
};

struct blk_zone;

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	blk_qc_t (*submit_bio)(struct bio *);
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*revalidate_disk)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	struct module *owner;
	const struct pr_ops *pr_ops;
};

enum fixed_addresses {
	FIX_EARLYCON_MEM_BASE = 0,
	__end_of_permanent_fixed_addresses = 1,
	FIX_KMAP_BEGIN = 1,
	FIX_KMAP_END = 256,
	FIX_TEXT_POKE0 = 257,
	FIX_TEXT_POKE1 = 258,
	__end_of_fixmap_region = 259,
	FIX_BTMAP_END = 1,
	FIX_BTMAP_BEGIN = 224,
	__end_of_early_ioremap_region = 225,
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct bsg_ops {
	int (*check_proto)(struct sg_io_v4 *);
	int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t);
	int (*complete_rq)(struct request *, struct sg_io_v4 *);
	void (*free_rq)(struct request *);
};

typedef __u32 req_flags_t;

typedef void rq_end_io_fn(struct request *, blk_status_t);

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	unsigned int cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	struct list_head queuelist;
	union {
		struct hlist_node hash;
		struct list_head ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
		int error_count;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	struct gendisk *rq_disk;
	struct block_device *part;
	int: 32;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int write_hint;
	short unsigned int ioprio;
	enum mq_rq_state state;
	refcount_t ref;
	unsigned int timeout;
	long unsigned int deadline;
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct elevator_type;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct blk_mq_hw_ctx *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct blk_mq_debugfs_attr;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	bool (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *);
	enum blk_eh_timer_return (*timeout)(struct request *, bool);
	int (*poll)(struct blk_mq_hw_ctx *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*initialize_rq_fn)(struct request *);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	int (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_parse_result {
	bool negated;
	int: 24;
	int: 32;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

typedef short int __s16;

typedef __s16 s16;

typedef __u16 __le16;

typedef __u16 __be16;

typedef __u32 __be32;

typedef __u64 __be64;

typedef __u32 __wsum;

typedef unsigned int slab_flags_t;

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {} possible_net_t;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	int: 32;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
	int: 32;
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sk_buff;

struct sk_buff_head {
	struct sk_buff *next;
	struct sk_buff *prev;
	__u32 qlen;
	spinlock_t lock;
};

typedef u64 netdev_features_t;

struct sock_cgroup_data {
	union {
		struct {
			u8 is_data: 1;
			u8 no_refcnt: 1;
			u8 unused: 6;
			u8 padding;
			u16 prioidx;
			u32 classid;
		};
		u64 val;
	};
};

struct sk_filter;

struct socket_wq;

struct xfrm_policy;

struct dst_entry;

struct socket;

struct sock_reuseport;

struct bpf_local_storage;

struct sock {
	struct sock_common __sk_common;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff *sk_rx_skb_cache;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct xfrm_policy *sk_policy[2];
	struct dst_entry *sk_rx_dst;
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff *sk_tx_skb_cache;
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	int: 32;
	netdev_features_t sk_route_caps;
	netdev_features_t sk_route_nocaps;
	netdev_features_t sk_route_forced_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_padding: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	u8 sk_prefer_busy_poll;
	u16 sk_busy_poll_budget;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	seqlock_t sk_stamp_seq;
	u16 sk_tsflags;
	u8 sk_shutdown;
	u32 sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
	int: 32;
};

struct rhash_head {
	struct rhash_head *next;
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct tty_driver;

struct tty_operations;

struct tty_ldisc;

struct tty_port;

struct tty_struct {
	int magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	spinlock_t ctrl_lock;
	spinlock_t flow_lock;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	struct pid *pgrp;
	struct pid *session;
	long unsigned int flags;
	int count;
	struct winsize winsize;
	long unsigned int stopped: 1;
	long unsigned int flow_stopped: 1;
	long unsigned int unused: 30;
	int hw_stopped;
	long unsigned int ctrl_status: 8;
	long unsigned int packet: 1;
	long unsigned int unused_ctrl: 23;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

struct iovec;

struct kvec;

struct iov_iter {
	unsigned int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct pipe_inode_info *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
	};
};

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	int (*write_room)(struct tty_struct *);
	int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_driver {
	int magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	unsigned char low_latency: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_ldisc_ops {
	int magic;
	char *name;
	int num;
	int flags;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	int (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, char *, int);
	struct module *owner;
	int refcount;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int *sock_inuse;
	struct prot_inuse *prot_inuse;
};

struct tcp_mib;

struct ipstats_mib;

struct linux_mib;

struct udp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct netns_mib {
	struct tcp_mib *tcp_statistics;
	struct ipstats_mib *ip_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udplite_statistics;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
	struct udp_mib *udp_stats_in6;
	struct udp_mib *udplite_stats_in6;
	struct ipstats_mib *ipv6_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_unix {
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	atomic_t tw_count;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct ipv4_devconf;

struct ip_ra_chain;

struct inet_peer_base;

struct fqdir;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	bool fib_has_custom_local_routes;
	struct hlist_head *fib_table_hash;
	bool fib_offload_disabled;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct sock **tcp_sk;
	struct fqdir *fqdir;
	int sysctl_icmp_echo_ignore_all;
	int sysctl_icmp_echo_ignore_broadcasts;
	int sysctl_icmp_ignore_bogus_error_responses;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_errors_use_inbound_ifaddr;
	struct local_ports ip_local_ports;
	int sysctl_tcp_ecn;
	int sysctl_tcp_ecn_fallback;
	int sysctl_ip_default_ttl;
	int sysctl_ip_no_pmtu_disc;
	int sysctl_ip_fwd_use_pmtu;
	int sysctl_ip_fwd_update_priority;
	int sysctl_ip_nonlocal_bind;
	int sysctl_ip_autobind_reuse;
	int sysctl_ip_dynaddr;
	int sysctl_ip_early_demux;
	int sysctl_tcp_early_demux;
	int sysctl_udp_early_demux;
	int sysctl_nexthop_compat_mode;
	int sysctl_fwmark_reflect;
	int sysctl_tcp_fwmark_accept;
	int sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_probes;
	int sysctl_tcp_keepalive_intvl;
	int sysctl_tcp_syn_retries;
	int sysctl_tcp_synack_retries;
	int sysctl_tcp_syncookies;
	int sysctl_tcp_reordering;
	int sysctl_tcp_retries1;
	int sysctl_tcp_retries2;
	int sysctl_tcp_orphan_retries;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_tw_reuse;
	int sysctl_tcp_sack;
	int sysctl_tcp_window_scaling;
	int sysctl_tcp_timestamps;
	int sysctl_tcp_early_retrans;
	int sysctl_tcp_recovery;
	int sysctl_tcp_thin_linear_timeouts;
	int sysctl_tcp_slow_start_after_idle;
	int sysctl_tcp_retrans_collapse;
	int sysctl_tcp_stdurg;
	int sysctl_tcp_rfc1337;
	int sysctl_tcp_abort_on_overflow;
	int sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_dsack;
	int sysctl_tcp_app_win;
	int sysctl_tcp_adv_win_scale;
	int sysctl_tcp_frto;
	int sysctl_tcp_nometrics_save;
	int sysctl_tcp_no_ssthresh_metrics_save;
	int sysctl_tcp_moderate_rcvbuf;
	int sysctl_tcp_tso_win_divisor;
	int sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_tso_segs;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_autocorking;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	int sysctl_tcp_comp_sack_nr;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct inet_timewait_death_row tcp_death_row;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	spinlock_t tcp_fastopen_ctx_lock;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_tcp_reflect_tos;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_llm_reports;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	int: 32;
	siphash_key_t ip_id_key;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int bindv6only;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	int multipath_hash_policy;
	int flowlabel_consistency;
	int auto_flowlabels;
	int icmpv6_time;
	int icmpv6_echo_ignore_all;
	int icmpv6_echo_ignore_multicast;
	int icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[8];
	long unsigned int *icmpv6_ratemask_ptr;
	int anycast_src_echo_reply;
	int ip_nonlocal_bind;
	int fwmark_reflect;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_state_ranges;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	bool skip_notify_on_dev_down;
};

struct net_device;

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct percpu_counter pcpuc_entries;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct fib_rules_ops;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct dst_ops ip6_dst_ops;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	unsigned int ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned int fib6_rules_require_fldissect;
	bool fib6_has_custom_rules;
	struct rt6_info *ip6_prohibit_entry;
	struct rt6_info *ip6_blk_hole_entry;
	struct fib6_table *fib6_local_tbl;
	struct fib_rules_ops *fib6_rules_ops;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct xfrm_policy_hash {
	struct hlist_head *table;
	unsigned int hmask;
	u8 dbits4;
	u8 sbits4;
	u8 dbits6;
	u8 sbits6;
};

struct xfrm_policy_hthresh {
	struct work_struct work;
	seqlock_t lock;
	u8 lbits4;
	u8 rbits4;
	u8 lbits6;
	u8 rbits6;
};

struct netns_xfrm {
	struct list_head state_all;
	struct hlist_head *state_bydst;
	struct hlist_head *state_bysrc;
	struct hlist_head *state_byspi;
	unsigned int state_hmask;
	unsigned int state_num;
	struct work_struct state_hash_work;
	struct list_head policy_all;
	struct hlist_head *policy_byidx;
	unsigned int policy_idx_hmask;
	struct hlist_head policy_inexact[3];
	struct xfrm_policy_hash policy_bydst[3];
	unsigned int policy_count[6];
	struct work_struct policy_hash_work;
	struct xfrm_policy_hthresh policy_hthresh;
	struct list_head inexact_bins;
	struct sock *nlsk;
	struct sock *nlsk_stash;
	u32 sysctl_aevent_etime;
	u32 sysctl_aevent_rseqth;
	int sysctl_larval_drop;
	u32 sysctl_acq_expires;
	struct ctl_table_header *sysctl_hdr;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct dst_ops xfrm4_dst_ops;
	struct dst_ops xfrm6_dst_ops;
	spinlock_t xfrm_state_lock;
	spinlock_t xfrm_policy_lock;
	struct mutex xfrm_cfg_mutex;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct net_generic *gen;
	struct netns_bpf bpf;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct netns_xfrm xfrm;
	atomic64_t net_cookie;
	struct sock *crypto_nlsk;
	struct sock *diag_nlsk;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct {
	u64 v;
} u64_stats_t;

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	__MAX_BPF_ATTACH_TYPE = 38,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
	};
	struct {
		__u32 map_fd;
		int: 32;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
		int: 32;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
		int: 32;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
		int: 32;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
		int: 32;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
				int: 32;
			};
		};
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct btf_type;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	int: 32;
	u64 writecnt;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[60];
	bool kernel_btf;
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[128];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_prog_ops;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_stats;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	enum bpf_tramp_prog_type trampoline_prog_type;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	struct bpf_prog_stats *stats;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct sock_filter insns[0];
	struct bpf_insn insnsi[0];
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct net_device_stats {
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	long unsigned int rx_errors;
	long unsigned int tx_errors;
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int multicast;
	long unsigned int collisions;
	long unsigned int rx_length_errors;
	long unsigned int rx_over_errors;
	long unsigned int rx_crc_errors;
	long unsigned int rx_frame_errors;
	long unsigned int rx_fifo_errors;
	long unsigned int rx_missed_errors;
	long unsigned int tx_aborted_errors;
	long unsigned int tx_carrier_errors;
	long unsigned int tx_fifo_errors;
	long unsigned int tx_heartbeat_errors;
	long unsigned int tx_window_errors;
	long unsigned int rx_compressed;
	long unsigned int tx_compressed;
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
};

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

struct pcpu_dstats;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct udp_tunnel_nic;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct ethtool_ops;

struct ndisc_ops;

struct header_ops;

struct dsa_port;

struct in_device;

struct inet6_dev;

struct wireless_dev;

struct wpan_dev;

struct netdev_rx_queue;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct rtnl_link_ops;

struct phy_device;

struct udp_tunnel_nic_info;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	int irq;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	int: 32;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	int ifindex;
	int group;
	struct net_device_stats stats;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct net_device_ops *netdev_ops;
	const struct ethtool_ops *ethtool_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct header_ops *header_ops;
	unsigned int flags;
	unsigned int priv_flags;
	short unsigned int gflags;
	short unsigned int padded;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned int mtu;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	short unsigned int hard_header_len;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	spinlock_t addr_list_lock;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct dsa_port *dsa_ptr;
	struct in_device *ip_ptr;
	struct inet6_dev *ip6_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	int napi_defer_hard_irqs;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct netdev_queue *ingress_queue;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct xps_dev_maps *xps_cpus_map;
	struct xps_dev_maps *xps_rxqs_map;
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	possible_net_t nd_net;
	union {
		void *ml_priv;
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	int: 32;
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	struct lock_class_key *qdisc_running_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_VALUE_OR_NULL = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCKET_OR_NULL = 12,
	PTR_TO_SOCK_COMMON = 13,
	PTR_TO_SOCK_COMMON_OR_NULL = 14,
	PTR_TO_TCP_SOCK = 15,
	PTR_TO_TCP_SOCK_OR_NULL = 16,
	PTR_TO_TP_BUFFER = 17,
	PTR_TO_XDP_SOCK = 18,
	PTR_TO_BTF_ID = 19,
	PTR_TO_BTF_ID_OR_NULL = 20,
	PTR_TO_MEM = 21,
	PTR_TO_MEM_OR_NULL = 22,
	PTR_TO_RDONLY_BUF = 23,
	PTR_TO_RDONLY_BUF_OR_NULL = 24,
	PTR_TO_RDWR_BUF = 25,
	PTR_TO_RDWR_BUF_OR_NULL = 26,
	PTR_TO_PERCPU_BTF_ID = 27,
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_prog_stats {
	u64 cnt;
	u64 nsecs;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
};

struct bpf_trampoline {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	void *image;
	u64 selector;
	struct bpf_ksym ksym;
	int: 32;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

typedef unsigned char *sk_buff_data_t;

struct skb_ext;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
	};
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 active_extensions;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 ndisc_nodetype: 2;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	__u8 offload_fwd_mark: 1;
	__u8 offload_l3_fwd_mark: 1;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	struct skb_ext *extensions;
	int: 32;
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

typedef short unsigned int __kernel_sa_family_t;

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct msghdr {
	void *msg_name;
	int msg_namelen;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
	struct kiocb *msg_iocb;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
	int: 32;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	struct {
		__le16 dport;
		__le16 sport;
	} dnports;
	__be32 spi;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
	int: 32;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
	int: 32;
};

struct flowidn {
	struct flowi_common __fl_common;
	__le16 daddr;
	__le16 saddr;
	union flowi_uli uli;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
		struct flowidn dn;
	} u;
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
	int: 32;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct linux_mib {
	long unsigned int mibs[124];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct rhashtable rhashtable;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	u32 (*undo_cwnd)(struct sock *);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
};

struct netlink_ext_ack;

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct xfrm_state;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	struct xfrm_state *xfrm;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
	atomic_t __refcnt;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[8];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	__u8 flags;
	__u8 nud_state;
	__u8 type;
	__u8 dead;
	u8 protocol;
	seqlock_t ha_lock;
	int: 32;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct callback_head rcu;
	struct net_device *dev;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_ra_rtr_pref;
	__s32 rtr_probe_interval;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 optimistic_dad;
	__s32 use_optimistic;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	struct ctl_table_header *sysctl_header;
};

struct fib_rule;

struct fib_lookup_arg;

struct fib_rule_hdr;

struct nlattr;

struct nla_policy;

struct fib_rules_ops {
	int family;
	struct list_head list;
	int rule_size;
	int addr_size;
	int unresolved_rules;
	int nr_goto_rules;
	unsigned int fib_rules_seq;
	int (*action)(struct fib_rule *, struct flowi *, int, struct fib_lookup_arg *);
	bool (*suppress)(struct fib_rule *, struct fib_lookup_arg *);
	int (*match)(struct fib_rule *, struct flowi *, int);
	int (*configure)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *, struct nlattr **, struct netlink_ext_ack *);
	int (*delete)(struct fib_rule *);
	int (*compare)(struct fib_rule *, struct fib_rule_hdr *, struct nlattr **);
	int (*fill)(struct fib_rule *, struct sk_buff *, struct fib_rule_hdr *);
	size_t (*nlmsg_payload)(struct fib_rule *);
	void (*flush_cache)(struct fib_rules_ops *);
	int nlgroup;
	const struct nla_policy *policy;
	struct list_head rules_list;
	struct module *owner;
	struct net *fro_net;
	struct callback_head rcu;
};

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct socket_wq wq;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct proto_ops {
	int family;
	unsigned int flags;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct skb_ext {
	refcount_t refcnt;
	u8 offset[1];
	u8 chunks;
	short: 16;
	char data[0];
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	unsigned int napi_id;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize: 8;
	u32 frame_sz: 24;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	u8 cookie[20];
	u8 cookie_len;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		struct netlink_range_validation *range;
		struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
		u16 strict_start_type;
	};
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
};

struct ifla_vf_guid {
	__u32 vf;
	int: 32;
	__u64 guid;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
	int: 32;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct netdev_queue {
	struct net_device *dev;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device *sb_dev;
	int: 32;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct dql dql;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_packed {
	__u64 bytes;
	__u64 packets;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct net_rate_estimator;

struct gnet_stats_basic_cpu;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t busylock;
	spinlock_t seqlock;
	bool empty;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long int privdata[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct netdev_rx_queue {
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xdp_rxq_info xdp_rxq;
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	struct xps_map *attr_map[0];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum tc_setup_type {
	TC_SETUP_QDISC_MQPRIO = 0,
	TC_SETUP_CLSU32 = 1,
	TC_SETUP_CLSFLOWER = 2,
	TC_SETUP_CLSMATCHALL = 3,
	TC_SETUP_CLSBPF = 4,
	TC_SETUP_BLOCK = 5,
	TC_SETUP_QDISC_CBS = 6,
	TC_SETUP_QDISC_RED = 7,
	TC_SETUP_QDISC_PRIO = 8,
	TC_SETUP_QDISC_MQ = 9,
	TC_SETUP_QDISC_ETF = 10,
	TC_SETUP_ROOT_QDISC = 11,
	TC_SETUP_QDISC_GRED = 12,
	TC_SETUP_QDISC_TAPRIO = 13,
	TC_SETUP_FT = 14,
	TC_SETUP_QDISC_ETS = 15,
	TC_SETUP_QDISC_TBF = 16,
	TC_SETUP_QDISC_FIFO = 17,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

struct xsk_buff_pool;

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct udp_tunnel_info;

struct devlink_port;

struct ip_tunnel_parm;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *);
	void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_change_proto_down)(struct net_device *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	int data[13];
	long unsigned int data_state[1];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
};

struct pcpu_sw_netstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_drvinfo;

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_link_ext_state_info;

struct ethtool_eeprom;

struct ethtool_coalesce;

struct ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_flash;

struct ethtool_channels;

struct ethtool_dump;

struct ethtool_ts_info;

struct ethtool_modinfo;

struct ethtool_eee;

struct ethtool_tunable;

struct ethtool_link_ksettings;

struct ethtool_fecparam;

struct ethtool_ops {
	u32 supported_coalesce_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	spinlock_t mc_lock;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct timer_list mc_gq_timer;
	struct timer_list mc_ifc_timer;
	struct timer_list mc_dad_timer;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	void (*setup)(struct net_device *);
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_stats_basic_cpu {
	struct gnet_stats_basic_packed bstats;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct tcf_block;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, bool, bool, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_GC_STALETIME = 7,
	NEIGH_VAR_QUEUE_LEN_BYTES = 8,
	NEIGH_VAR_PROXY_QLEN = 9,
	NEIGH_VAR_ANYCAST_DELAY = 10,
	NEIGH_VAR_PROXY_DELAY = 11,
	NEIGH_VAR_LOCKTIME = 12,
	NEIGH_VAR_QUEUE_LEN = 13,
	NEIGH_VAR_RETRANS_TIME_MS = 14,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,
	NEIGH_VAR_GC_INTERVAL = 16,
	NEIGH_VAR_GC_THRESH1 = 17,
	NEIGH_VAR_GC_THRESH2 = 18,
	NEIGH_VAR_GC_THRESH3 = 19,
	NEIGH_VAR_MAX = 20,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	u8 flags;
	u8 protocol;
	u8 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct fib_rule_hdr {
	__u8 family;
	__u8 dst_len;
	__u8 src_len;
	__u8 tos;
	__u8 table;
	__u8 res1;
	__u8 res2;
	__u8 action;
	__u32 flags;
};

struct fib_rule_port_range {
	__u16 start;
	__u16 end;
};

struct fib_kuid_range {
	kuid_t start;
	kuid_t end;
};

struct fib_rule {
	struct list_head list;
	int iifindex;
	int oifindex;
	u32 mark;
	u32 mark_mask;
	u32 flags;
	u32 table;
	u8 action;
	u8 l3mdev;
	u8 proto;
	u8 ip_proto;
	u32 target;
	__be64 tun_id;
	struct fib_rule *ctarget;
	struct net *fr_net;
	refcount_t refcnt;
	u32 pref;
	int suppress_ifgroup;
	int suppress_prefixlen;
	char iifname[16];
	char oifname[16];
	struct fib_kuid_range uid_range;
	struct fib_rule_port_range sport_range;
	struct fib_rule_port_range dport_range;
	struct callback_head rcu;
};

struct fib_lookup_arg {
	void *lookup_ptr;
	const void *lookup_data;
	void *result;
	struct fib_rule *rule;
	u32 table;
	int flags;
};

struct smc_hashinfo;

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*stream_memory_read)(const struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	struct percpu_counter *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
	int: 32;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct timer_list mca_timer;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	spinlock_t mca_lock;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_MAX = 11,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 18,
};

enum {
	TSK_TRACE_FL_TRACE_BIT = 0,
	TSK_TRACE_FL_GRAPH_BIT = 1,
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

typedef __u64 __le64;

struct minix_super_block {
	__u16 s_ninodes;
	__u16 s_nzones;
	__u16 s_imap_blocks;
	__u16 s_zmap_blocks;
	__u16 s_firstdatazone;
	__u16 s_log_zone_size;
	__u32 s_max_size;
	__u16 s_magic;
	__u16 s_state;
	__u32 s_zones;
};

struct romfs_super_block {
	__be32 word0;
	__be32 word1;
	__be32 size;
	__be32 checksum;
	char name[0];
};

struct cramfs_inode {
	__u32 mode: 16;
	__u32 uid: 16;
	__u32 size: 24;
	__u32 gid: 8;
	__u32 namelen: 6;
	__u32 offset: 26;
};

struct cramfs_info {
	__u32 crc;
	__u32 edition;
	__u32 blocks;
	__u32 files;
};

struct cramfs_super {
	__u32 magic;
	__u32 size;
	__u32 flags;
	__u32 future;
	__u8 signature[16];
	struct cramfs_info fsid;
	__u8 name[16];
	struct cramfs_inode root;
};

struct squashfs_super_block {
	__le32 s_magic;
	__le32 inodes;
	__le32 mkfs_time;
	__le32 block_size;
	__le32 fragments;
	__le16 compression;
	__le16 block_log;
	__le16 flags;
	__le16 no_ids;
	__le16 s_major;
	__le16 s_minor;
	__le64 root_inode;
	__le64 bytes_used;
	__le64 id_table_start;
	__le64 xattr_id_table_start;
	__le64 inode_table_start;
	__le64 directory_table_start;
	__le64 fragment_table_start;
	__le64 lookup_table_start;
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

typedef phys_addr_t resource_size_t;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	char *name;
	int: 32;
	time64_t mtime;
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

struct arm_delay_ops {
	void (*delay)(long unsigned int);
	void (*const_udelay)(long unsigned int);
	void (*udelay)(long unsigned int);
	long unsigned int ticks_per_jiffy;
};

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_CMA = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_FREE_CMA_PAGES = 9,
	NR_VM_ZONE_STAT_ITEMS = 10,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	NR_WMARK = 3,
};

enum {
	ZONELIST_FALLBACK = 0,
	MAX_ZONELISTS = 1,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	NR_COMPOUND_DTORS = 2,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA = 4,
	PGALLOC_NORMAL = 5,
	PGALLOC_HIGH = 6,
	PGALLOC_MOVABLE = 7,
	ALLOCSTALL_DMA = 8,
	ALLOCSTALL_NORMAL = 9,
	ALLOCSTALL_HIGH = 10,
	ALLOCSTALL_MOVABLE = 11,
	PGSCAN_SKIP_DMA = 12,
	PGSCAN_SKIP_NORMAL = 13,
	PGSCAN_SKIP_HIGH = 14,
	PGSCAN_SKIP_MOVABLE = 15,
	PGFREE = 16,
	PGACTIVATE = 17,
	PGDEACTIVATE = 18,
	PGLAZYFREE = 19,
	PGFAULT = 20,
	PGMAJFAULT = 21,
	PGLAZYFREED = 22,
	PGREFILL = 23,
	PGREUSE = 24,
	PGSTEAL_KSWAPD = 25,
	PGSTEAL_DIRECT = 26,
	PGSCAN_KSWAPD = 27,
	PGSCAN_DIRECT = 28,
	PGSCAN_DIRECT_THROTTLE = 29,
	PGSCAN_ANON = 30,
	PGSCAN_FILE = 31,
	PGSTEAL_ANON = 32,
	PGSTEAL_FILE = 33,
	PGINODESTEAL = 34,
	SLABS_SCANNED = 35,
	KSWAPD_INODESTEAL = 36,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 37,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 38,
	PAGEOUTRUN = 39,
	PGROTATED = 40,
	DROP_PAGECACHE = 41,
	DROP_SLAB = 42,
	OOM_KILL = 43,
	PGMIGRATE_SUCCESS = 44,
	PGMIGRATE_FAIL = 45,
	THP_MIGRATION_SUCCESS = 46,
	THP_MIGRATION_FAIL = 47,
	THP_MIGRATION_SPLIT = 48,
	COMPACTMIGRATE_SCANNED = 49,
	COMPACTFREE_SCANNED = 50,
	COMPACTISOLATED = 51,
	COMPACTSTALL = 52,
	COMPACTFAIL = 53,
	COMPACTSUCCESS = 54,
	KCOMPACTD_WAKE = 55,
	KCOMPACTD_MIGRATE_SCANNED = 56,
	KCOMPACTD_FREE_SCANNED = 57,
	UNEVICTABLE_PGCULLED = 58,
	UNEVICTABLE_PGSCANNED = 59,
	UNEVICTABLE_PGRESCUED = 60,
	UNEVICTABLE_PGMLOCKED = 61,
	UNEVICTABLE_PGMUNLOCKED = 62,
	UNEVICTABLE_PGCLEARED = 63,
	UNEVICTABLE_PGSTRANDED = 64,
	SWAP_RA = 65,
	SWAP_RA_HIT = 66,
	NR_VM_EVENT_ITEMS = 67,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_COUNTS = 10,
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_MAX = 28,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	__LINUX_MIB_MAX = 124,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	__LINUX_MIB_TLSMAX = 11,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO = 13,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_SHARE_CPUCAPACITY = 6,
	__SD_SHARE_PKG_RESOURCES = 7,
	__SD_SERIALIZE = 8,
	__SD_ASYM_PACKING = 9,
	__SD_PREFER_SIBLING = 10,
	__SD_OVERLAP = 11,
	__SD_NUMA = 12,
	__SD_FLAG_CNT = 13,
};

enum skb_ext_id {
	SKB_EXT_SEC_PATH = 0,
	SKB_EXT_NUM = 1,
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

enum cpu_pm_event {
	CPU_PM_ENTER = 0,
	CPU_PM_ENTER_FAILED = 1,
	CPU_PM_EXIT = 2,
	CPU_CLUSTER_PM_ENTER = 3,
	CPU_CLUSTER_PM_ENTER_FAILED = 4,
	CPU_CLUSTER_PM_EXIT = 5,
};

struct user_vfp {
	long long unsigned int fpregs[32];
	long unsigned int fpscr;
	int: 32;
};

struct user_vfp_exc {
	long unsigned int fpexc;
	long unsigned int fpinst;
	long unsigned int fpinst2;
};

struct undef_hook {
	struct list_head node;
	u32 instr_mask;
	u32 instr_val;
	u32 cpsr_mask;
	u32 cpsr_val;
	int (*fn)(struct pt_regs *, unsigned int);
};

typedef u64 uint64_t;

struct vfp_single {
	s16 exponent;
	u16 sign;
	u32 significand;
};

struct vfp_double {
	s16 exponent;
	u16 sign;
	int: 32;
	u64 significand;
};

struct op {
	u32 (* const fn)(int, int, int, u32);
	u32 flags;
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

struct smp_operations {
	void (*smp_init_cpus)();
	void (*smp_prepare_cpus)(unsigned int);
	void (*smp_secondary_init)(unsigned int);
	int (*smp_boot_secondary)(unsigned int, struct task_struct *);
	int (*cpu_kill)(unsigned int);
	void (*cpu_die)(unsigned int);
	bool (*cpu_can_disable)(unsigned int);
	int (*cpu_disable)(unsigned int);
};

struct l2x0_regs {
	long unsigned int phy_base;
	long unsigned int aux_ctrl;
	long unsigned int tag_latency;
	long unsigned int data_latency;
	long unsigned int filter_start;
	long unsigned int filter_end;
	long unsigned int prefetch_ctrl;
	long unsigned int pwr_ctrl;
	long unsigned int ctrl;
	long unsigned int aux2_ctrl;
};

struct outer_cache_fns {
	void (*inv_range)(long unsigned int, long unsigned int);
	void (*clean_range)(long unsigned int, long unsigned int);
	void (*flush_range)(long unsigned int, long unsigned int);
	void (*flush_all)();
	void (*disable)();
	void (*sync)();
	void (*resume)();
	void (*write_sec)(long unsigned int, unsigned int);
	void (*configure)(const struct l2x0_regs *);
};

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

struct tag;

struct machine_desc {
	unsigned int nr;
	const char *name;
	long unsigned int atag_offset;
	const char * const *dt_compat;
	unsigned int nr_irqs;
	phys_addr_t dma_zone_size;
	unsigned int video_start;
	unsigned int video_end;
	unsigned char reserve_lp0: 1;
	unsigned char reserve_lp1: 1;
	unsigned char reserve_lp2: 1;
	enum reboot_mode reboot_mode;
	unsigned int l2c_aux_val;
	unsigned int l2c_aux_mask;
	void (*l2c_write_sec)(long unsigned int, unsigned int);
	const struct smp_operations *smp;
	bool (*smp_init)();
	void (*fixup)(struct tag *, char **);
	void (*dt_fixup)();
	long long int (*pv_fixup)();
	void (*reserve)();
	void (*map_io)();
	void (*init_early)();
	void (*init_irq)();
	void (*init_time)();
	void (*init_machine)();
	void (*init_late)();
	void (*handle_irq)(struct pt_regs *);
	void (*restart)(enum reboot_mode, const char *);
};

struct svc_pt_regs {
	struct pt_regs regs;
	u32 dacr;
	u32 addr_limit;
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct processor {
	void (*_data_abort)(long unsigned int);
	long unsigned int (*_prefetch_abort)(long unsigned int);
	void (*_proc_init)();
	void (*check_bugs)();
	void (*_proc_fin)();
	void (*reset)(long unsigned int, bool);
	int (*_do_idle)();
	void (*dcache_clean_area)(void *, int);
	void (*switch_mm)(phys_addr_t, struct mm_struct *);
	void (*set_pte_ext)(pte_t *, pte_t, unsigned int);
	unsigned int suspend_size;
	void (*do_suspend)(void *);
	void (*do_resume)(void *);
};

enum cpu_led_event {
	CPU_LED_IDLE_START = 0,
	CPU_LED_IDLE_END = 1,
	CPU_LED_START = 2,
	CPU_LED_STOP = 3,
	CPU_LED_HALTED = 4,
};

struct stackframe {
	long unsigned int fp;
	long unsigned int sp;
	long unsigned int lr;
	long unsigned int pc;
};

struct linux_binprm___2;

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 1,
	TYPE_MAX = 2,
};

struct membuf {
	void *p;
	size_t left;
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

struct pt_regs_offset {
	const char *name;
	int offset;
};

enum arm_regset {
	REGSET_GPR = 0,
	REGSET_FPR = 1,
	REGSET_VFP = 2,
};

enum ptrace_syscall_dir {
	PTRACE_SYSCALL_ENTER = 0,
	PTRACE_SYSCALL_EXIT = 1,
};

struct cpu_cache_fns {
	void (*flush_icache_all)();
	void (*flush_kern_all)();
	void (*flush_kern_louis)();
	void (*flush_user_all)();
	void (*flush_user_range)(long unsigned int, long unsigned int, unsigned int);
	void (*coherent_kern_range)(long unsigned int, long unsigned int);
	int (*coherent_user_range)(long unsigned int, long unsigned int);
	void (*flush_kern_dcache_area)(void *, size_t);
	void (*dma_map_area)(const void *, size_t, int);
	void (*dma_unmap_area)(const void *, size_t, int);
	void (*dma_flush_range)(const void *, const void *);
};

typedef void (*phys_reset_t)(long unsigned int, bool);

typedef long unsigned int uintptr_t;

typedef u8 uint8_t;

struct __va_list {
	void *__ap;
};

typedef struct __va_list __gnuc_va_list;

typedef __gnuc_va_list va_list;

struct cpu_user_fns {
	void (*cpu_clear_user_highpage)(struct page *, long unsigned int);
	void (*cpu_copy_user_highpage)(struct page *, struct page *, long unsigned int, struct vm_area_struct *);
};

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct cpu_tlb_fns {
	void (*flush_user_range)(long unsigned int, long unsigned int, struct vm_area_struct *);
	void (*flush_kern_range)(long unsigned int, long unsigned int);
	long unsigned int tlb_flags;
};

typedef __be32 fdt32_t;

struct fdt_header {
	fdt32_t magic;
	fdt32_t totalsize;
	fdt32_t off_dt_struct;
	fdt32_t off_dt_strings;
	fdt32_t off_mem_rsvmap;
	fdt32_t version;
	fdt32_t last_comp_version;
	fdt32_t boot_cpuid_phys;
	fdt32_t size_dt_strings;
	fdt32_t size_dt_struct;
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct cpuinfo_arm {
	struct cpu cpu;
	u32 cpuid;
	unsigned int loops_per_jiffy;
};

struct mpidr_hash {
	u32 mask;
	u32 shift_aff[3];
	u32 bits;
};

struct proc_info_list {
	unsigned int cpu_val;
	unsigned int cpu_mask;
	long unsigned int __cpu_mm_mmu_flags;
	long unsigned int __cpu_io_mmu_flags;
	long unsigned int __cpu_flush;
	const char *arch_name;
	const char *elf_name;
	unsigned int elf_hwcap;
	const char *cpu_name;
	struct processor *proc;
	struct cpu_tlb_fns *tlb;
	struct cpu_user_fns *user;
	struct cpu_cache_fns *cache;
};

struct tag_header {
	__u32 size;
	__u32 tag;
};

struct tag_core {
	__u32 flags;
	__u32 pagesize;
	__u32 rootdev;
};

struct tag_mem32 {
	__u32 size;
	__u32 start;
};

struct tag_videotext {
	__u8 x;
	__u8 y;
	__u16 video_page;
	__u8 video_mode;
	__u8 video_cols;
	__u16 video_ega_bx;
	__u8 video_lines;
	__u8 video_isvga;
	__u16 video_points;
};

struct tag_ramdisk {
	__u32 flags;
	__u32 size;
	__u32 start;
};

struct tag_initrd {
	__u32 start;
	__u32 size;
};

struct tag_serialnr {
	__u32 low;
	__u32 high;
};

struct tag_revision {
	__u32 rev;
};

struct tag_videolfb {
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u16 lfb_linelength;
	__u32 lfb_base;
	__u32 lfb_size;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
};

struct tag_cmdline {
	char cmdline[1];
};

struct tag_acorn {
	__u32 memc_control_reg;
	__u32 vram_pages;
	__u8 sounddefault;
	__u8 adfsdrives;
};

struct tag_memclk {
	__u32 fmemclk;
};

struct tag {
	struct tag_header hdr;
	union {
		struct tag_core core;
		struct tag_mem32 mem;
		struct tag_videotext videotext;
		struct tag_ramdisk ramdisk;
		struct tag_initrd initrd;
		struct tag_serialnr serialnr;
		struct tag_revision revision;
		struct tag_videolfb videolfb;
		struct tag_cmdline cmdline;
		struct tag_acorn acorn;
		struct tag_memclk memclk;
	} u;
};

struct stack {
	u32 irq[3];
	u32 abt[3];
	u32 und[3];
	u32 fiq[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct sigcontext {
	long unsigned int trap_no;
	long unsigned int error_code;
	long unsigned int oldmask;
	long unsigned int arm_r0;
	long unsigned int arm_r1;
	long unsigned int arm_r2;
	long unsigned int arm_r3;
	long unsigned int arm_r4;
	long unsigned int arm_r5;
	long unsigned int arm_r6;
	long unsigned int arm_r7;
	long unsigned int arm_r8;
	long unsigned int arm_r9;
	long unsigned int arm_r10;
	long unsigned int arm_fp;
	long unsigned int arm_ip;
	long unsigned int arm_sp;
	long unsigned int arm_lr;
	long unsigned int arm_pc;
	long unsigned int arm_cpsr;
	long unsigned int fault_address;
};

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	struct sigcontext uc_mcontext;
	sigset_t uc_sigmask;
	int __unused[30];
	long unsigned int uc_regspace[128];
};

struct iwmmxt_sigframe {
	long unsigned int magic;
	long unsigned int size;
	struct iwmmxt_struct storage;
};

struct vfp_sigframe {
	long unsigned int magic;
	long unsigned int size;
	struct user_vfp ufp;
	struct user_vfp_exc ufp_exc;
	int: 32;
};

struct aux_sigframe {
	struct iwmmxt_sigframe iwmmxt;
	struct vfp_sigframe vfp;
	long unsigned int end_magic;
	int: 32;
};

struct sigframe {
	struct ucontext uc;
	long unsigned int retcode[4];
};

struct rt_sigframe {
	struct siginfo info;
	struct sigframe sig;
};

struct stack_trace {
	unsigned int nr_entries;
	unsigned int max_entries;
	long unsigned int *entries;
	unsigned int skip;
};

struct stack_trace_data {
	struct stack_trace *trace;
	unsigned int no_sched_functions;
	unsigned int skip;
};

typedef void (*clock_access_fn)(struct timespec64 *);

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

enum die_val {
	DIE_UNUSED = 0,
	DIE_OOPS = 1,
};

struct return_address_data {
	unsigned int level;
	void *addr;
};

struct tagtable {
	__u32 tag;
	int (*parse)(const struct tag *);
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

struct buffer {
	size_t size;
	char data[0];
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	u64 exit_latency_ns;
	u64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int: 32;
};

struct cpuidle_state_kobj;

struct cpuidle_driver_kobj;

struct cpuidle_device_kobj;

struct cpuidle_coupled;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	int: 32;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
	cpumask_t coupled_cpus;
	struct cpuidle_coupled *coupled;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	int: 31;
	int: 32;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct cpuidle_ops {
	int (*suspend)(long unsigned int);
	int (*init)(struct device_node *, int);
};

struct of_cpuidle_method {
	const char *method;
	const struct cpuidle_ops *ops;
};

struct elf32_rel {
	Elf32_Addr r_offset;
	Elf32_Word r_info;
};

typedef struct elf32_rel Elf32_Rel;

typedef struct elf32_hdr Elf32_Ehdr;

typedef struct elf32_shdr Elf32_Shdr;

struct plt_entries {
	u32 ldr[16];
	u32 lit[16];
};

typedef unsigned int u_int;

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct pci_bus;

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

typedef short unsigned int pci_bus_flags_t;

struct pci_dev;

struct pci_ops;

struct msi_controller;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	struct msi_controller *msi;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	int domain_nr;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	int: 31;
	int: 32;
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_BRIDGE_RESOURCES = 7,
	PCI_BRIDGE_RESOURCE_END = 10,
	PCI_NUM_RESOURCES = 11,
	DEVICE_COUNT_RESOURCE = 11,
};

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef unsigned int pcie_reset_state_t;

typedef short unsigned int pci_dev_flags_t;

struct rcec_ea;

struct pci_driver;

struct pcie_link_state;

struct pci_vpd;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	struct rcec_ea *rcec_ea;
	struct pci_dev *rcec;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int runtime_d3cold: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	u16 l1ss;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	int: 32;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[11];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int reset_fn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *rom_attr;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[11];
	struct bin_attribute *res_attr_wc[11];
	const struct attribute_group **msi_irq_groups;
	struct pci_vpd *vpd;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	char *driver_override;
	long unsigned int priv_flags;
	int: 32;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	struct device_driver driver;
	struct pci_dynids dynids;
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	struct msi_controller *msi;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

struct pci_sys_data;

struct hw_pci {
	struct pci_ops *ops;
	int nr_controllers;
	void **private_data;
	int (*setup)(int, struct pci_sys_data *);
	int (*scan)(int, struct pci_host_bridge *);
	void (*preinit)();
	void (*postinit)();
	u8 (*swizzle)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
};

struct pci_sys_data {
	struct list_head node;
	int busnr;
	int: 32;
	u64 mem_offset;
	long unsigned int io_offset;
	struct pci_bus *bus;
	struct list_head resources;
	struct resource io_res;
	char io_res_name[12];
	u8 (*swizzle)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void *private_data;
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	void (*hook)(struct pci_dev *);
};

struct map_desc {
	long unsigned int virtual;
	long unsigned int pfn;
	long unsigned int length;
	unsigned int type;
};

struct sleep_save_sp {
	u32 *save_ptr_stash;
	u32 save_ptr_stash_phys;
};

struct mpu_rgn {
	union {
		u32 drbar;
		u32 prbar;
	};
	union {
		u32 drsr;
		u32 prlar;
	};
	union {
		u32 dracr;
		u32 unused;
	};
};

struct mpu_rgn_info {
	unsigned int used;
	struct mpu_rgn rgns[16];
};

struct secondary_data {
	union {
		struct mpu_rgn_info *mpu_rgn_info;
		u64 pgdir;
	};
	long unsigned int swapper_pg_dir;
	void *stack;
};

struct plist_head {
	struct list_head node_list;
};

typedef struct {
	unsigned int __softirq_pending;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
} irq_cpustat_t;

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
};

struct trace_event_data_offsets_ipi_handler {};

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

enum ipi_msg_type {
	IPI_WAKEUP = 0,
	IPI_TIMER = 1,
	IPI_RESCHEDULE = 2,
	IPI_CALL_FUNC = 3,
	IPI_CPU_STOP = 4,
	IPI_IRQ_WORK = 5,
	IPI_COMPLETION = 6,
	NR_IPI = 7,
	IPI_CPU_BACKTRACE = 7,
	MAX_IPI = 8,
};

struct tlb_args {
	struct vm_area_struct *ta_vma;
	long unsigned int ta_start;
	long unsigned int ta_end;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

typedef int (*of_init_fn_1_ret)(struct device_node *);

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	int: 32;
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct delay_timer {
	long unsigned int (*read_current_timer)();
	long unsigned int freq;
};

struct dyn_arch_ftrace {};

struct dyn_ftrace {
	long unsigned int ip;
	long unsigned int flags;
	struct dyn_arch_ftrace arch;
};

struct patch {
	void *addr;
	unsigned int insn;
};

struct kimage_arch {
	u32 kernel_r2;
};

typedef long unsigned int kimage_entry_t;

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 1073741824,
};

struct kexec_relocate_data {
	long unsigned int kexec_start_address;
	long unsigned int kexec_indirection_page;
	long unsigned int kexec_mach_type;
	long unsigned int kexec_r2;
};

struct of_cpu_method {
	const char *method;
	const struct smp_operations *ops;
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_event_arm_regs {
	PERF_REG_ARM_R0 = 0,
	PERF_REG_ARM_R1 = 1,
	PERF_REG_ARM_R2 = 2,
	PERF_REG_ARM_R3 = 3,
	PERF_REG_ARM_R4 = 4,
	PERF_REG_ARM_R5 = 5,
	PERF_REG_ARM_R6 = 6,
	PERF_REG_ARM_R7 = 7,
	PERF_REG_ARM_R8 = 8,
	PERF_REG_ARM_R9 = 9,
	PERF_REG_ARM_R10 = 10,
	PERF_REG_ARM_FP = 11,
	PERF_REG_ARM_IP = 12,
	PERF_REG_ARM_SP = 13,
	PERF_REG_ARM_LR = 14,
	PERF_REG_ARM_PC = 15,
	PERF_REG_ARM_MAX = 16,
};

struct perf_guest_info_callbacks {
	int (*is_in_guest)();
	int (*is_user_mode)();
	long unsigned int (*get_guest_ip)();
	void (*handle_intel_pt_intr)();
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

struct frame_tail {
	struct frame_tail *fp;
	long unsigned int sp;
	long unsigned int lr;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

struct omap_device;

struct pdev_archdata {
	struct omap_device *od;
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
	int: 32;
};

struct mfd_cell;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	int: 24;
	int: 32;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};

struct arm_pmu;

struct pmu_hw_events {
	struct perf_event *events[32];
	long unsigned int used_mask[1];
	raw_spinlock_t pmu_lock;
	struct arm_pmu *percpu_pmu;
	int irq;
};

struct arm_pmu {
	struct pmu pmu;
	cpumask_t supported_cpus;
	char *name;
	int pmuver;
	irqreturn_t (*handle_irq)(struct arm_pmu *);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	int (*get_event_idx)(struct pmu_hw_events *, struct perf_event *);
	void (*clear_event_idx)(struct pmu_hw_events *, struct perf_event *);
	int (*set_event_filter)(struct hw_perf_event *, struct perf_event_attr *);
	u64 (*read_counter)(struct perf_event *);
	void (*write_counter)(struct perf_event *, u64);
	void (*start)(struct arm_pmu *);
	void (*stop)(struct arm_pmu *);
	void (*reset)(void *);
	int (*map_event)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int num_events;
	bool secure_access;
	long unsigned int pmceid_bitmap[2];
	long unsigned int pmceid_ext_bitmap[2];
	struct platform_device *plat_device;
	struct pmu_hw_events *hw_events;
	struct hlist_node node;
	struct notifier_block cpu_pm_nb;
	const struct attribute_group *attr_groups[5];
	u64 reg_pmmir;
	long unsigned int acpi_cpuid;
	int: 32;
};

enum armpmu_attr_groups {
	ARMPMU_ATTR_GROUP_COMMON = 0,
	ARMPMU_ATTR_GROUP_EVENTS = 1,
	ARMPMU_ATTR_GROUP_FORMATS = 2,
	ARMPMU_ATTR_GROUP_CAPS = 3,
	ARMPMU_NR_ATTR_GROUPS = 4,
};

typedef int (*armpmu_init_fn)(struct arm_pmu *);

struct pmu_probe_info {
	unsigned int cpuid;
	unsigned int mask;
	armpmu_init_fn init;
};

struct cpu_topology {
	int thread_id;
	int core_id;
	int package_id;
	int llc_id;
	cpumask_t thread_sibling;
	cpumask_t core_sibling;
	cpumask_t llc_sibling;
};

struct cpu_efficiency {
	const char *compatible;
	long unsigned int efficiency;
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

struct arch_vdso_data {};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

union vdso_data_store {
	struct vdso_data data[2];
	u8 page[4096];
};

struct elfinfo {
	Elf32_Ehdr *hdr;
	Elf32_Sym *dynsym;
	long unsigned int dynsymsize;
	char *dynstr;
};

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

enum {
	MT_UNCACHED = 4,
	MT_CACHECLEAN = 5,
	MT_MINICLEAN = 6,
	MT_LOW_VECTORS = 7,
	MT_HIGH_VECTORS = 8,
	MT_MEMORY_RWX = 9,
	MT_MEMORY_RW = 10,
	MT_ROM = 11,
	MT_MEMORY_RWX_NONCACHED = 12,
	MT_MEMORY_RW_DTCM = 13,
	MT_MEMORY_RWX_ITCM = 14,
	MT_MEMORY_RW_SO = 15,
	MT_MEMORY_DMA_READY = 16,
};

struct psci_operations {
	u32 (*get_version)();
	int (*cpu_suspend)(u32, long unsigned int);
	int (*cpu_off)(u32);
	int (*cpu_on)(long unsigned int, long unsigned int);
	int (*migrate)(long unsigned int);
	int (*affinity_info)(long unsigned int, long unsigned int);
	int (*migrate_info_type)();
};

typedef u32 probes_opcode_t;

struct arch_probes_insn;

typedef void probes_insn_handler_t(probes_opcode_t, struct arch_probes_insn *, struct pt_regs *);

typedef long unsigned int probes_check_cc(long unsigned int);

typedef void probes_insn_singlestep_t(probes_opcode_t, struct arch_probes_insn *, struct pt_regs *);

typedef void probes_insn_fn_t();

struct arch_probes_insn {
	probes_opcode_t *insn;
	probes_insn_handler_t *insn_handler;
	probes_check_cc *insn_check_cc;
	probes_insn_singlestep_t *insn_singlestep;
	probes_insn_fn_t *insn_fn;
	int stack_space;
	long unsigned int register_usage_flags;
	bool kprobe_direct_exec;
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_HINDEX_MASK = 983040,
};

enum zone_type {
	ZONE_DMA = 0,
	ZONE_NORMAL = 1,
	ZONE_HIGHMEM = 2,
	ZONE_MOVABLE = 3,
	__MAX_NR_ZONES = 4,
};

typedef u32 kprobe_opcode_t;

struct kprobe;

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

typedef int (*kprobe_fault_handler_t)(struct kprobe *, struct pt_regs *, int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_fault_handler_t fault_handler;
	kprobe_opcode_t opcode;
	struct arch_probes_insn ainsn;
	u32 flags;
};

typedef void (*harden_branch_predictor_fn_t)();

struct fsr_info {
	int (*fn)(long unsigned int, unsigned int, struct pt_regs *);
	int sig;
	int code;
	const char *name;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
	unsigned int dma_length;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct section_perm {
	const char *name;
	long unsigned int start;
	long unsigned int end;
	pmdval_t mask;
	pmdval_t prot;
	pmdval_t clear;
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	__NR_PAGEFLAGS = 22,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 6,
	PG_isolated = 18,
	PG_reported = 2,
};

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

struct dma_iommu_mapping {
	struct iommu_domain *domain;
	long unsigned int **bitmaps;
	unsigned int nr_bitmaps;
	unsigned int extensions;
	size_t bitmap_size;
	size_t bits;
	dma_addr_t base;
	spinlock_t lock;
	struct kref kref;
};

struct iommu_fault_param;

struct iommu_fwspec;

struct dev_iommu {
	struct mutex lock;
	struct iommu_fault_param *fault_param;
	struct iommu_fwspec *fwspec;
	struct iommu_device *iommu_dev;
	void *priv;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct iommu_fault_unrecoverable {
	__u32 reason;
	__u32 flags;
	__u32 pasid;
	__u32 perm;
	__u64 addr;
	__u64 fetch_addr;
};

struct iommu_fault_page_request {
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 perm;
	__u64 addr;
	__u64 private_data[2];
};

struct iommu_fault {
	__u32 type;
	__u32 padding;
	union {
		struct iommu_fault_unrecoverable event;
		struct iommu_fault_page_request prm;
		__u8 padding2[56];
	};
};

struct iommu_page_response {
	__u32 argsz;
	__u32 version;
	__u32 flags;
	__u32 pasid;
	__u32 grpid;
	__u32 code;
};

struct iommu_inv_addr_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
	__u64 addr;
	__u64 granule_size;
	__u64 nb_granules;
};

struct iommu_inv_pasid_info {
	__u32 flags;
	__u32 archid;
	__u64 pasid;
};

struct iommu_cache_invalidate_info {
	__u32 argsz;
	__u32 version;
	__u8 cache;
	__u8 granularity;
	__u8 padding[6];
	union {
		struct iommu_inv_pasid_info pasid_info;
		struct iommu_inv_addr_info addr_info;
	} granu;
};

struct iommu_gpasid_bind_data_vtd {
	__u64 flags;
	__u32 pat;
	__u32 emt;
};

struct iommu_gpasid_bind_data {
	__u32 argsz;
	__u32 version;
	__u32 format;
	__u32 addr_width;
	__u64 flags;
	__u64 gpgd;
	__u64 hpasid;
	__u64 gpasid;
	__u8 padding[8];
	union {
		struct iommu_gpasid_bind_data_vtd vtd;
	} vendor;
};

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain {
	unsigned int type;
	const struct iommu_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	void *iova_cookie;
};

typedef int (*iommu_dev_fault_handler_t)(struct iommu_fault *, void *);

enum iommu_resv_type {
	IOMMU_RESV_DIRECT = 0,
	IOMMU_RESV_DIRECT_RELAXABLE = 1,
	IOMMU_RESV_RESERVED = 2,
	IOMMU_RESV_MSI = 3,
	IOMMU_RESV_SW_MSI = 4,
};

struct iommu_resv_region {
	struct list_head list;
	phys_addr_t start;
	size_t length;
	int prot;
	enum iommu_resv_type type;
};

struct iommu_iotlb_gather {
	long unsigned int start;
	long unsigned int end;
	size_t pgsize;
	struct page *freelist;
};

struct iommu_device {
	struct list_head list;
	const struct iommu_ops *ops;
	struct fwnode_handle *fwnode;
	struct device *dev;
};

struct iommu_sva {
	struct device *dev;
};

struct iommu_fault_event {
	struct iommu_fault fault;
	struct list_head list;
};

struct iommu_fault_param {
	iommu_dev_fault_handler_t handler;
	void *data;
	struct list_head faults;
	struct mutex lock;
};

struct iommu_fwspec {
	const struct iommu_ops *ops;
	struct fwnode_handle *iommu_fwnode;
	u32 flags;
	u32 num_pasid_bits;
	unsigned int num_ids;
	u32 ids[0];
};

struct arm_dma_alloc_args {
	struct device *dev;
	size_t size;
	gfp_t gfp;
	pgprot_t prot;
	const void *caller;
	bool want_vaddr;
	int coherent_flag;
};

struct arm_dma_free_args {
	struct device *dev;
	size_t size;
	void *cpu_addr;
	struct page *page;
	bool want_vaddr;
};

struct arm_dma_allocator {
	void * (*alloc)(struct arm_dma_alloc_args *, struct page **);
	void (*free)(struct arm_dma_free_args *);
};

struct arm_dma_buffer {
	struct list_head list;
	void *virt;
	struct arm_dma_allocator *allocator;
};

struct dma_contig_early_reserve {
	phys_addr_t base;
	long unsigned int size;
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum cgroup_subsys_id {
	perf_event_cgrp_id = 0,
	CGROUP_SUBSYS_COUNT = 1,
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct mem_type {
	pteval_t prot_pte;
	pteval_t prot_pte_s2;
	pmdval_t prot_l1;
	pmdval_t prot_sect;
	unsigned int domain;
};

struct static_vm {
	struct vm_struct vm;
	struct list_head list;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

struct free_area {
	struct list_head free_list[6];
	long unsigned int nr_free;
};

struct zone_padding {
	char x[0];
};

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
};

struct per_cpu_pages {
	int count;
	int high;
	int batch;
	struct list_head lists[3];
};

struct per_cpu_pageset {
	struct per_cpu_pages pcp;
	s8 stat_threshold;
	s8 vm_stat_diff[10];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[38];
};

struct pglist_data;

struct zone {
	long unsigned int _watermark[3];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[4];
	struct pglist_data *zone_pgdat;
	struct per_cpu_pageset *pageset;
	int pageset_high;
	int pageset_batch;
	long unsigned int *pageblock_flags;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	int initialized;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct zone_padding _pad1_;
	struct free_area free_area[12];
	long unsigned int flags;
	spinlock_t lock;
	int: 32;
	int: 32;
	struct zone_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct zone_padding _pad3_;
	atomic_long_t vm_stat[10];
	atomic_long_t vm_numa_stat[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[5];
};

struct pglist_data {
	struct zone node_zones[4];
	struct zonelist node_zonelists[1];
	int nr_zones;
	struct page *node_mem_map;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	long unsigned int totalreserve_pages;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct zone_padding _pad1_;
	struct lruvec __lruvec;
	long unsigned int flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct zone_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[38];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct pglist_data pg_data_t;

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct cachepolicy {
	const char policy[16];
	unsigned int cr_mask;
	pmdval_t pmd;
	pteval_t pte;
};

struct page_change_data {
	pgprot_t set_mask;
	pgprot_t clear_mask;
};

union offset_union {
	long unsigned int un;
	long int sn;
};

enum arm_smccc_conduit {
	SMCCC_CONDUIT_NONE = 0,
	SMCCC_CONDUIT_SMC = 1,
	SMCCC_CONDUIT_HVC = 2,
};

struct arm_smccc_res {
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

struct l2c_init_data {
	const char *type;
	unsigned int way_size_0;
	unsigned int num_lock;
	void (*of_parse)(const struct device_node *, u32 *, u32 *);
	void (*enable)(void *, unsigned int);
	void (*fixup)(void *, u32, struct outer_cache_fns *);
	void (*save)(void *);
	void (*configure)(void *);
	void (*unlock)(void *, unsigned int);
	struct outer_cache_fns outer_cache;
};

struct firmware_ops {
	int (*prepare_idle)(long unsigned int);
	int (*do_idle)(long unsigned int);
	int (*set_cpu_boot_addr)(int, long unsigned int);
	int (*get_cpu_boot_addr)(int, long unsigned int *);
	int (*cpu_boot)(int);
	int (*l2x0_init)();
	int (*suspend)();
	int (*resume)();
};

struct mcpm_platform_ops {
	int (*cpu_powerup)(unsigned int, unsigned int);
	int (*cluster_powerup)(unsigned int);
	void (*cpu_suspend_prepare)(unsigned int, unsigned int);
	void (*cpu_powerdown_prepare)(unsigned int, unsigned int);
	void (*cluster_powerdown_prepare)(unsigned int);
	void (*cpu_cache_disable)();
	void (*cluster_cache_disable)();
	void (*cpu_is_up)(unsigned int, unsigned int);
	void (*cluster_is_up)(unsigned int);
	int (*wait_for_powerdown)(unsigned int, unsigned int);
};

struct mcpm_sync_struct {
	struct {
		s8 cpu;
		int: 24;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	} cpus[4];
	s8 cluster;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	s8 inbound;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sync_struct {
	struct mcpm_sync_struct clusters[4];
};

typedef void (*phys_reset_t___2)(long unsigned int, bool);

enum decode_type {
	DECODE_TYPE_END = 0,
	DECODE_TYPE_TABLE = 1,
	DECODE_TYPE_CUSTOM = 2,
	DECODE_TYPE_SIMULATE = 3,
	DECODE_TYPE_EMULATE = 4,
	DECODE_TYPE_OR = 5,
	DECODE_TYPE_REJECT = 6,
	NUM_DECODE_TYPES = 7,
};

enum decode_reg_type {
	REG_TYPE_NONE = 0,
	REG_TYPE_ANY = 1,
	REG_TYPE_SAMEAS16 = 2,
	REG_TYPE_SP = 3,
	REG_TYPE_PC = 4,
	REG_TYPE_NOSP = 5,
	REG_TYPE_NOSPPC = 6,
	REG_TYPE_NOPC = 7,
	REG_TYPE_NOPCWB = 8,
	REG_TYPE_NOPCX = 9,
	REG_TYPE_NOSPPCX = 10,
	REG_TYPE_0 = 0,
};

union decode_item {
	u32 bits;
	const union decode_item *table;
	int action;
};

enum probes_insn {
	INSN_REJECTED = 0,
	INSN_GOOD = 1,
	INSN_GOOD_NO_SLOT = 2,
};

struct decode_header;

typedef enum probes_insn probes_custom_decode_t(probes_opcode_t, struct arch_probes_insn *, const struct decode_header *);

struct decode_header {
	union decode_item type_regs;
	union decode_item mask;
	union decode_item value;
};

union decode_action {
	probes_insn_handler_t *handler;
	probes_custom_decode_t *decoder;
};

typedef enum probes_insn probes_check_t(probes_opcode_t, struct arch_probes_insn *, const struct decode_header *);

struct decode_checker {
	probes_check_t *checker;
};

struct decode_table {
	struct decode_header header;
	union decode_item table;
};

struct decode_custom {
	struct decode_header header;
	union decode_item decoder;
};

struct decode_simulate {
	struct decode_header header;
	union decode_item handler;
};

struct decode_emulate {
	struct decode_header header;
	union decode_item handler;
};

enum probes_arm_action {
	PROBES_PRELOAD_IMM = 0,
	PROBES_PRELOAD_REG = 1,
	PROBES_BRANCH_IMM = 2,
	PROBES_BRANCH_REG = 3,
	PROBES_MRS = 4,
	PROBES_CLZ = 5,
	PROBES_SATURATING_ARITHMETIC = 6,
	PROBES_MUL1 = 7,
	PROBES_MUL2 = 8,
	PROBES_SWP = 9,
	PROBES_LDRSTRD = 10,
	PROBES_LOAD = 11,
	PROBES_STORE = 12,
	PROBES_LOAD_EXTRA = 13,
	PROBES_STORE_EXTRA = 14,
	PROBES_MOV_IP_SP = 15,
	PROBES_DATA_PROCESSING_REG = 16,
	PROBES_DATA_PROCESSING_IMM = 17,
	PROBES_MOV_HALFWORD = 18,
	PROBES_SEV = 19,
	PROBES_WFE = 20,
	PROBES_SATURATE = 21,
	PROBES_REV = 22,
	PROBES_MMI = 23,
	PROBES_PACK = 24,
	PROBES_EXTEND = 25,
	PROBES_EXTEND_ADD = 26,
	PROBES_MUL_ADD_LONG = 27,
	PROBES_MUL_ADD = 28,
	PROBES_BITFIELD = 29,
	PROBES_BRANCH = 30,
	PROBES_LDMSTM = 31,
	NUM_PROBES_ARM_ACTIONS = 32,
};

typedef u32 uprobe_opcode_t;

struct arch_uprobe {
	u8 insn[4];
	long unsigned int ixol[2];
	uprobe_opcode_t bpinsn;
	bool simulate;
	u32 pcreg;
	void (*prehandler)(struct arch_uprobe *, struct arch_uprobe_task *, struct pt_regs *);
	void (*posthandler)(struct arch_uprobe *, struct arch_uprobe_task *, struct pt_regs *);
	struct arch_probes_insn asi;
};

struct freelist_node {
	atomic_t refs;
	struct freelist_node *next;
};

struct freelist_head {
	struct freelist_node *head;
};

struct prev_kprobe {
	struct kprobe *kp;
	unsigned int status;
};

struct kprobe_ctlblk {
	unsigned int kprobe_status;
	struct prev_kprobe prev_kprobe;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe_holder;

struct kretprobe_instance {
	union {
		struct freelist_node freelist;
		struct callback_head rcu;
	};
	struct llist_node llist;
	struct kretprobe_holder *rph;
	kprobe_opcode_t *ret_addr;
	void *fp;
	char data[0];
};

struct kretprobe;

struct kretprobe_holder {
	struct kretprobe *rp;
	refcount_t ref;
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct freelist_head freelist;
	struct kretprobe_holder *rph;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

typedef enum probes_insn kprobe_decode_insn_t(probes_opcode_t, struct arch_probes_insn *, bool, const union decode_action *, const struct decode_checker **);

enum {
	STACK_USE_NONE = 0,
	STACK_USE_UNKNOWN = 1,
	STACK_USE_FIXED_X0X = 2,
	STACK_USE_FIXED_XXX = 3,
	STACK_USE_STMDX = 4,
	NUM_STACK_USE_TYPES = 5,
};

struct arch_optimized_insn {
	kprobe_opcode_t copied_insn[1];
	kprobe_opcode_t *insn;
};

struct optimized_kprobe {
	struct kprobe kp;
	struct list_head list;
	struct arch_optimized_insn optinsn;
};

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

struct bpf_binary_header {
	u32 pages;
	int: 32;
	u8 image[0];
};

enum {
	BPF_R2_HI = 0,
	BPF_R2_LO = 1,
	BPF_R3_HI = 2,
	BPF_R3_LO = 3,
	BPF_R4_HI = 4,
	BPF_R4_LO = 5,
	BPF_R5_HI = 6,
	BPF_R5_LO = 7,
	BPF_R7_HI = 8,
	BPF_R7_LO = 9,
	BPF_R8_HI = 10,
	BPF_R8_LO = 11,
	BPF_R9_HI = 12,
	BPF_R9_LO = 13,
	BPF_FP_HI = 14,
	BPF_FP_LO = 15,
	BPF_TC_HI = 16,
	BPF_TC_LO = 17,
	BPF_AX_HI = 18,
	BPF_AX_LO = 19,
	BPF_JIT_SCRATCH_REGS = 20,
};

struct jit_ctx {
	const struct bpf_prog *prog;
	unsigned int idx;
	unsigned int prologue_bytes;
	unsigned int epilogue_offset;
	unsigned int cpu_architecture;
	u32 flags;
	u32 *offsets;
	u32 *target;
	u32 stack_size;
};

struct al_cpu_resume_regs_per_cpu {
	uint32_t flags;
	uint32_t resume_addr;
};

struct al_cpu_resume_regs {
	uint32_t watermark;
	uint32_t flags;
	struct al_cpu_resume_regs_per_cpu per_cpu[0];
};

struct regmap;

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

typedef struct {
	char *from;
	char *to;
} substring_t;

typedef int suspend_state_t;

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct at91_pm_data {
	void *pmc;
	void *ramc[2];
	long unsigned int uhp_udp_mask;
	unsigned int memctrl;
	unsigned int mode;
	void *shdwc;
	void *sfrbu;
	unsigned int standby_mode;
	unsigned int suspend_mode;
	unsigned int pmc_mckr_offset;
	unsigned int pmc_version;
};

struct at91_soc_pm {
	int (*config_shdwc_ws)(void *, u32 *, u32 *);
	int (*config_pmc_ws)(void *, u32, u32);
	const struct of_device_id *ws_ids;
	struct at91_pm_data data;
};

struct at91_pm_bu {
	int suspended;
	long unsigned int reserved;
	phys_addr_t canary;
	phys_addr_t resume;
};

struct wakeup_source_info {
	unsigned int pmc_fsmr_bit;
	unsigned int shdwc_mr_bit;
	bool set_polarity;
};

struct ramc_info {
	void (*idle)();
	unsigned int memctrl;
};

struct pmc_info {
	long unsigned int uhp_udp_mask;
	long unsigned int mckr;
	long unsigned int version;
};

struct bcm_kona_smc_data {
	unsigned int service_id;
	unsigned int arg0;
	unsigned int arg1;
	unsigned int arg2;
	unsigned int arg3;
	unsigned int result;
};

enum {
	ZONE_MAN_CLKEN_MASK = 1,
	ZONE_MAN_RESET_CNTL_MASK = 2,
	ZONE_MAN_MEM_PWR_MASK = 16,
	ZONE_RESERVED_1_MASK = 32,
	ZONE_MAN_ISO_CNTL_MASK = 64,
	ZONE_MANUAL_CONTROL_MASK = 128,
	ZONE_PWR_DN_REQ_MASK = 512,
	ZONE_PWR_UP_REQ_MASK = 1024,
	ZONE_BLK_RST_ASSERT_MASK = 4096,
	ZONE_PWR_OFF_STATE_MASK = 33554432,
	ZONE_PWR_ON_STATE_MASK = 67108864,
	ZONE_DPG_PWR_STATE_MASK = 268435456,
	ZONE_MEM_PWR_STATE_MASK = 536870912,
	ZONE_RESET_STATE_MASK = 2147483648,
	CPU0_PWR_ZONE_CTRL_REG = 1,
	CPU_RESET_CONFIG_REG = 2,
};

struct cpuidle_exynos_data {
	int (*cpu0_enter_aftr)();
	int (*cpu1_powerdown)();
	void (*pre_enter_aftr)();
	void (*post_enter_aftr)();
};

enum {
	FW_DO_IDLE_SLEEP = 0,
	FW_DO_IDLE_AFTR = 1,
};

enum sys_powerdown {
	SYS_AFTR = 0,
	SYS_LPA = 1,
	SYS_SLEEP = 2,
	NUM_SYS_POWERDOWN = 3,
};

typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);

struct exynos_wkup_irq {
	unsigned int hwirq;
	u32 mask;
};

struct exynos_pm_data {
	const struct exynos_wkup_irq *wkup_irq;
	unsigned int wake_disable_mask;
	void (*pm_prepare)();
	void (*pm_resume_prepare)();
	void (*pm_resume)();
	int (*pm_suspend)();
	int (*cpu_suspend)(long unsigned int);
};

struct exynos_pm_state {
	int cpu_state;
	unsigned int pmu_spare3;
	void *sysram_base;
	phys_addr_t sysram_phys;
	bool secure_firmware;
};

enum {
	HI3620_CTRL = 0,
	ERROR_CTRL = 1,
};

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

struct reset_control;

struct pxa_device_desc {
	const char *dev_name;
	const char *drv_name;
	int id;
	int irq;
	long unsigned int start;
	long unsigned int size;
	int dma[2];
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_ARCHTIMER = 1,
	VDSO_CLOCKMODE_MAX = 2,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	int: 32;
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	int: 32;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct module *owner;
	int: 32;
};

struct mvebu_system_controller {
	u32 rstoutn_mask_offset;
	u32 system_soft_reset_offset;
	u32 rstoutn_mask_reset_out_en;
	u32 system_soft_reset;
	u32 resume_boot_addr;
	u32 dev_id;
	u32 rev_id;
};

struct soc_device_attribute {
	const char *machine;
	const char *family;
	const char *revision;
	const char *serial_number;
	const char *soc_id;
	const void *data;
	const struct attribute_group *custom_attr_group;
};

struct soc_device;

enum {
	COHERENCY_FABRIC_TYPE_NONE = 0,
	COHERENCY_FABRIC_TYPE_ARMADA_370_XP = 1,
	COHERENCY_FABRIC_TYPE_ARMADA_375 = 2,
	COHERENCY_FABRIC_TYPE_ARMADA_380 = 3,
};

enum pmsu_idle_prepare_flags {
	PMSU_PREPARE_NORMAL = 0,
	PMSU_PREPARE_DEEP_IDLE = 1,
	PMSU_PREPARE_SNOOP_DISABLE = 2,
};

struct pinctrl;

struct pinctrl_state;

struct dev_pin_info {
	struct pinctrl *p;
	struct pinctrl_state *default_state;
	struct pinctrl_state *init_state;
	struct pinctrl_state *sleep_state;
	struct pinctrl_state *idle_state;
};

struct mxc_extra_irq {
	int (*set_irq_fiq)(unsigned int, unsigned int);
};

enum mxc_cpu_pwr_mode {
	WAIT_CLOCKED = 0,
	WAIT_UNCLOCKED = 1,
	WAIT_UNCLOCKED_POWER_OFF = 2,
	STOP_POWER_ON = 3,
	STOP_POWER_OFF = 4,
};

struct imx5_suspend_io_state {
	u32 offset;
	u32 clear;
	u32 set;
	u32 saved_value;
};

struct imx5_pm_data {
	phys_addr_t ccm_addr;
	phys_addr_t cortex_addr;
	phys_addr_t gpc_addr;
	phys_addr_t m4if_addr;
	phys_addr_t iomuxc_addr;
	void (*suspend_asm)(void *);
	const u32 *suspend_asm_sz;
	const struct imx5_suspend_io_state *suspend_io_config;
	int suspend_io_count;
};

struct imx5_cpu_suspend_info {
	void *m4if_base;
	void *iomuxc_base;
	u32 io_count;
	struct imx5_suspend_io_state io_state[20];
	int: 32;
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

typedef unsigned int xa_mark_t;

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct ida {
	struct xarray xa;
};

struct fsl_mmdc_devtype_data {
	unsigned int flags;
};

struct mmdc_pmu {
	struct pmu pmu;
	void *mmdc_base;
	cpumask_t cpu;
	struct hrtimer hrtimer;
	unsigned int active_events;
	struct device *dev;
	struct perf_event *mmdc_events[6];
	struct hlist_node node;
	struct fsl_mmdc_devtype_data *devtype_data;
	int: 32;
};

struct reset_controller_dev;

struct reset_control_ops {
	int (*reset)(struct reset_controller_dev *, long unsigned int);
	int (*assert)(struct reset_controller_dev *, long unsigned int);
	int (*deassert)(struct reset_controller_dev *, long unsigned int);
	int (*status)(struct reset_controller_dev *, long unsigned int);
};

struct reset_controller_dev {
	const struct reset_control_ops *ops;
	struct module *owner;
	struct list_head list;
	struct list_head reset_control_head;
	struct device *dev;
	struct device_node *of_node;
	int of_reset_n_cells;
	int (*of_xlate)(struct reset_controller_dev *, const struct of_phandle_args *);
	unsigned int nr_resets;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[2];
		} value;
	};
};

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	int: 32;
	u64 dma_mask;
	const struct property_entry *properties;
	int: 32;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 92,
};

struct mii_bus;

struct gpio_desc;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
	PHY_CABLETEST = 6,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_RGMII = 8,
	PHY_INTERFACE_MODE_RGMII_ID = 9,
	PHY_INTERFACE_MODE_RGMII_RXID = 10,
	PHY_INTERFACE_MODE_RGMII_TXID = 11,
	PHY_INTERFACE_MODE_RTBI = 12,
	PHY_INTERFACE_MODE_SMII = 13,
	PHY_INTERFACE_MODE_XGMII = 14,
	PHY_INTERFACE_MODE_XLGMII = 15,
	PHY_INTERFACE_MODE_MOCA = 16,
	PHY_INTERFACE_MODE_QSGMII = 17,
	PHY_INTERFACE_MODE_TRGMII = 18,
	PHY_INTERFACE_MODE_1000BASEX = 19,
	PHY_INTERFACE_MODE_2500BASEX = 20,
	PHY_INTERFACE_MODE_RXAUI = 21,
	PHY_INTERFACE_MODE_XAUI = 22,
	PHY_INTERFACE_MODE_10GBASER = 23,
	PHY_INTERFACE_MODE_USXGMII = 24,
	PHY_INTERFACE_MODE_10GKR = 25,
	PHY_INTERFACE_MODE_MAX = 26,
} phy_interface_t;

struct phy_driver;

struct phy_package_shared;

struct phylink;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[3];
	long unsigned int advertising[3];
	long unsigned int lp_advertising[3];
	long unsigned int adv_old[3];
	u32 eee_broken_modes;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	u8 mdix;
	u8 mdix_ctrl;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
	int: 32;
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	int: 32;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	enum {
		MDIOBUS_NO_CAP = 0,
		MDIOBUS_C22 = 1,
		MDIOBUS_C45 = 2,
		MDIOBUS_C22_C45 = 3,
	} probe_capabilities;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
	int: 32;
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
};

struct imx6_pm_base {
	phys_addr_t pbase;
	void *vbase;
};

struct imx6_pm_socdata {
	u32 ddr_type;
	const char *mmdc_compat;
	const char *src_compat;
	const char *iomuxc_compat;
	const char *gpc_compat;
	const char *pl310_compat;
	const u32 mmdc_io_num;
	const u32 *mmdc_io_offset;
};

struct imx6_cpu_pm_info {
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 ddr_type;
	u32 pm_info_size;
	struct imx6_pm_base mmdc_base;
	struct imx6_pm_base src_base;
	struct imx6_pm_base iomuxc_base;
	struct imx6_pm_base ccm_base;
	struct imx6_pm_base gpc_base;
	struct imx6_pm_base l2_base;
	u32 mmdc_io_num;
	u32 mmdc_io_val[66];
	int: 32;
};

struct mtk_smp_boot_info {
	long unsigned int smp_base;
	unsigned int jump_reg;
	unsigned int core_keys[7];
	unsigned int core_regs[7];
};

typedef void (*phys_reset_t___3)(long unsigned int);

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

enum twl_module_ids {
	TWL_MODULE_USB = 0,
	TWL_MODULE_PIH = 1,
	TWL_MODULE_MAIN_CHARGE = 2,
	TWL_MODULE_PM_MASTER = 3,
	TWL_MODULE_PM_RECEIVER = 4,
	TWL_MODULE_RTC = 5,
	TWL_MODULE_PWM = 6,
	TWL_MODULE_LED = 7,
	TWL_MODULE_SECURED_REG = 8,
	TWL_MODULE_LAST = 9,
};

struct omap_die_id {
	u32 id_0;
	u32 id_1;
	u32 id_2;
	u32 id_3;
};

struct omap_id {
	u16 hawkeye;
	u8 dev;
	u32 type;
};

struct omap_hwmod_rst_info {
	const char *name;
	u8 rst_shift;
	u8 st_shift;
};

struct omap_hwmod_opt_clk {
	const char *role;
	const char *clk;
	struct clk *_clk;
};

struct omap_hwmod_omap2_firewall {
	u8 l3_perm_bit;
	u8 l4_fw_region;
	u8 l4_prot_group;
	u8 flags;
};

struct omap_hwmod_addr_space;

struct omap_hwmod;

struct omap_hwmod_ocp_if {
	struct omap_hwmod *master;
	struct omap_hwmod *slave;
	struct omap_hwmod_addr_space *addr;
	const char *clk;
	struct clk *_clk;
	struct list_head node;
	union {
		struct omap_hwmod_omap2_firewall omap2;
	} fw;
	u8 width;
	u8 user;
	u8 flags;
	u8 _int_flags;
};

struct omap_hwmod_omap2_prcm {
	s16 module_offs;
	u8 idlest_reg_id;
	u8 idlest_idle_bit;
};

struct omap_hwmod_omap4_prcm {
	u16 clkctrl_offs;
	u16 rstctrl_offs;
	u16 rstst_offs;
	u16 context_offs;
	u32 lostcontext_mask;
	u8 submodule_wkdep_bit;
	u8 modulemode;
	u8 flags;
	int context_lost_counter;
};

struct omap_hwmod_class;

struct clockdomain;

struct omap_hwmod {
	const char *name;
	struct omap_hwmod_class *class;
	struct omap_device *od;
	struct omap_hwmod_rst_info *rst_lines;
	union {
		struct omap_hwmod_omap2_prcm omap2;
		struct omap_hwmod_omap4_prcm omap4;
	} prcm;
	const char *main_clk;
	struct clk *_clk;
	struct omap_hwmod_opt_clk *opt_clks;
	const char *clkdm_name;
	struct clockdomain *clkdm;
	struct list_head slave_ports;
	void *dev_attr;
	u32 _sysc_cache;
	void *_mpu_rt_va;
	spinlock_t _lock;
	struct lock_class_key hwmod_key;
	struct list_head node;
	struct omap_hwmod_ocp_if *_mpu_port;
	u32 flags;
	u8 mpu_rt_idx;
	u8 response_lat;
	u8 rst_lines_cnt;
	u8 opt_clks_cnt;
	u8 slaves_cnt;
	u8 hwmods_cnt;
	u8 _int_flags;
	u8 _state;
	u8 _postsetup_state;
	struct omap_hwmod *parent_hwmod;
};

struct sysc_regbits;

struct omap_hwmod_class_sysconfig {
	s32 rev_offs;
	s32 sysc_offs;
	s32 syss_offs;
	u16 sysc_flags;
	struct sysc_regbits *sysc_fields;
	u8 srst_udelay;
	u8 idlemodes;
};

struct omap_hwmod_class {
	const char *name;
	struct omap_hwmod_class_sysconfig *sysc;
	int (*pre_shutdown)(struct omap_hwmod *);
	int (*reset)(struct omap_hwmod *);
	void (*lock)(struct omap_hwmod *);
	void (*unlock)(struct omap_hwmod *);
};

struct powerdomain;

struct clkdm_dep;

struct clockdomain {
	const char *name;
	union {
		const char *name;
		struct powerdomain *ptr;
	} pwrdm;
	const u16 clktrctrl_mask;
	const u8 flags;
	u8 _flags;
	const u8 dep_bit;
	const u8 prcm_partition;
	const u16 cm_inst;
	const u16 clkdm_offs;
	struct clkdm_dep *wkdep_srcs;
	struct clkdm_dep *sleepdep_srcs;
	int usecount;
	int forcewake_count;
	struct list_head node;
	u32 context;
};

struct omap_volt_data {
	u32 volt_nominal;
	u32 sr_efuse_offs;
	u8 sr_errminlimit;
	u8 vp_errgain;
};

struct omap_vc_common {
	u32 cmd_on_mask;
	u32 valid;
	u8 bypass_val_reg;
	u8 data_shift;
	u8 slaveaddr_shift;
	u8 regaddr_shift;
	u8 cmd_on_shift;
	u8 cmd_onlp_shift;
	u8 cmd_ret_shift;
	u8 cmd_off_shift;
	u8 i2c_cfg_reg;
	u8 i2c_cfg_clear_mask;
	u8 i2c_cfg_hsen_mask;
	u8 i2c_mcode_mask;
};

struct omap_vc_channel {
	u16 i2c_slave_addr;
	u16 volt_reg_addr;
	u16 cmd_reg_addr;
	u8 cfg_channel;
	bool i2c_high_speed;
	const struct omap_vc_common *common;
	u32 smps_sa_mask;
	u32 smps_volra_mask;
	u32 smps_cmdra_mask;
	u8 cmdval_reg;
	u8 smps_sa_reg;
	u8 smps_volra_reg;
	u8 smps_cmdra_reg;
	u8 cfg_channel_reg;
	u8 cfg_channel_sa_shift;
	u8 flags;
};

struct omap_vc_param {
	u32 on;
	u32 onlp;
	u32 ret;
	u32 off;
};

struct omap_vp_ops {
	u32 (*check_txdone)(u8);
	void (*clear_txdone)(u8);
};

struct omap_vp_common {
	u32 vpconfig_erroroffset_mask;
	u32 vpconfig_errorgain_mask;
	u32 vpconfig_initvoltage_mask;
	u8 vpconfig_timeouten;
	u8 vpconfig_initvdd;
	u8 vpconfig_forceupdate;
	u8 vpconfig_vpenable;
	u8 vstepmin_stepmin_shift;
	u8 vstepmin_smpswaittimemin_shift;
	u8 vstepmax_stepmax_shift;
	u8 vstepmax_smpswaittimemax_shift;
	u8 vlimitto_vddmin_shift;
	u8 vlimitto_vddmax_shift;
	u8 vlimitto_timeout_shift;
	u8 vpvoltage_mask;
	const struct omap_vp_ops *ops;
};

struct omap_vp_instance {
	const struct omap_vp_common *common;
	u8 vpconfig;
	u8 vstepmin;
	u8 vstepmax;
	u8 vlimitto;
	u8 vstatus;
	u8 voltage;
	u8 id;
	bool enabled;
};

struct omap_vp_param {
	u32 vddmax;
	u32 vddmin;
};

struct omap_vfsm_instance {
	u32 voltsetup_mask;
	u8 voltsetup_reg;
	u8 voltsetup_off_reg;
};

struct omap_voltdm_pmic;

struct voltagedomain {
	char *name;
	bool scalable;
	struct list_head node;
	struct omap_vc_channel *vc;
	const struct omap_vfsm_instance *vfsm;
	struct omap_vp_instance *vp;
	struct omap_voltdm_pmic *pmic;
	struct omap_vp_param *vp_param;
	struct omap_vc_param *vc_param;
	u32 (*read)(u8);
	void (*write)(u32, u8);
	u32 (*rmw)(u32, u32, u8);
	union {
		const char *name;
		u32 rate;
	} sys_clk;
	int (*scale)(struct voltagedomain *, long unsigned int);
	u32 nominal_volt;
	struct omap_volt_data *volt_data;
};

struct omap_voltdm_pmic {
	int slew_rate;
	int step_size;
	u16 i2c_slave_addr;
	u16 volt_reg_addr;
	u16 cmd_reg_addr;
	u8 vp_erroroffset;
	u8 vp_vstepmin;
	u8 vp_vstepmax;
	u32 vddmin;
	u32 vddmax;
	u8 vp_timeout_us;
	bool i2c_high_speed;
	u32 i2c_pad_load;
	u8 i2c_mcode;
	long unsigned int (*vsel_to_uv)(const u8);
	u8 (*uv_to_vsel)(long unsigned int);
};

struct powerdomain {
	const char *name;
	union {
		const char *name;
		struct voltagedomain *ptr;
	} voltdm;
	const s16 prcm_offs;
	const u8 pwrsts;
	const u8 pwrsts_logic_ret;
	const u8 flags;
	const u8 banks;
	const u8 pwrsts_mem_ret[5];
	const u8 pwrsts_mem_on[5];
	const u8 prcm_partition;
	struct clockdomain *pwrdm_clkdms[11];
	struct list_head node;
	struct list_head voltdm_node;
	int state;
	unsigned int state_counter[4];
	unsigned int ret_logic_off_counter;
	unsigned int ret_mem_off_counter[5];
	spinlock_t _lock;
	long unsigned int _lock_flags;
	const u8 pwrstctrl_offs;
	const u8 pwrstst_offs;
	const u32 logicretstate_mask;
	const u32 mem_on_mask[5];
	const u32 mem_ret_mask[5];
	const u32 mem_pwrst_mask[5];
	const u32 mem_retst_mask[5];
	u32 context;
};

struct clkdm_dep {
	const char *clkdm_name;
	struct clockdomain *clkdm;
	s16 wkdep_usecount;
	s16 sleepdep_usecount;
};

struct omap_sdrc_params {
	long unsigned int rate;
	u32 actim_ctrla;
	u32 actim_ctrlb;
	u32 rfr_ctrl;
	u32 mr;
};

struct omap_prcm_init_data {
	int index;
	void *mem;
	u32 phys;
	s16 offset;
	u16 flags;
	s32 device_inst_offset;
	int (*init)(const struct omap_prcm_init_data *);
	struct device_node *np;
};

enum {
	TI_CLKM_CM = 0,
	TI_CLKM_CM2 = 1,
	TI_CLKM_PRM = 2,
	TI_CLKM_SCRM = 3,
	TI_CLKM_CTRL = 4,
	TI_CLKM_CTRL_AUX = 5,
	TI_CLKM_PLLSS = 6,
	CLK_MAX_MEMMAPS = 7,
};

struct omap3_scratchpad {
	u32 boot_config_ptr;
	u32 public_restore_ptr;
	u32 secure_ram_restore_ptr;
	u32 sdrc_module_semaphore;
	u32 prcm_block_offset;
	u32 sdrc_block_offset;
};

struct omap3_scratchpad_prcm_block {
	u32 prm_contents[2];
	u32 cm_contents[11];
	u32 prcm_block_size;
};

struct omap3_scratchpad_sdrc_block {
	u16 sysconfig;
	u16 cs_cfg;
	u16 sharing;
	u16 err_type;
	u32 dll_a_ctrl;
	u32 dll_b_ctrl;
	u32 power;
	u32 cs_0;
	u32 mcfg_0;
	u16 mr_0;
	u16 emr_1_0;
	u16 emr_2_0;
	u16 emr_3_0;
	u32 actim_ctrla_0;
	u32 actim_ctrlb_0;
	u32 rfr_ctrl_0;
	u32 cs_1;
	u32 mcfg_1;
	u16 mr_1;
	u16 emr_1_1;
	u16 emr_2_1;
	u16 emr_3_1;
	u32 actim_ctrla_1;
	u32 actim_ctrlb_1;
	u32 rfr_ctrl_1;
	u16 dcdl_1_ctrl;
	u16 dcdl_2_ctrl;
	u32 flags;
	u32 block_size;
};

struct omap3_control_regs {
	u32 sysconfig;
	u32 devconf0;
	u32 mem_dftrw0;
	u32 mem_dftrw1;
	u32 msuspendmux_0;
	u32 msuspendmux_1;
	u32 msuspendmux_2;
	u32 msuspendmux_3;
	u32 msuspendmux_4;
	u32 msuspendmux_5;
	u32 sec_ctrl;
	u32 devconf1;
	u32 csirxfe;
	u32 iva2_bootaddr;
	u32 iva2_bootmod;
	u32 wkup_ctrl;
	u32 debobs_0;
	u32 debobs_1;
	u32 debobs_2;
	u32 debobs_3;
	u32 debobs_4;
	u32 debobs_5;
	u32 debobs_6;
	u32 debobs_7;
	u32 debobs_8;
	u32 prog_io0;
	u32 prog_io1;
	u32 dss_dpll_spreading;
	u32 core_dpll_spreading;
	u32 per_dpll_spreading;
	u32 usbhost_dpll_spreading;
	u32 pbias_lite;
	u32 temp_sensor;
	u32 sramldo4;
	u32 sramldo5;
	u32 csi;
	u32 padconf_sys_nirq;
};

struct control_init_data {
	int index;
	void *mem;
	s16 offset;
};

struct omap2_oscillator {
	u32 startup_time;
	u32 shutdown_time;
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

enum omap_reg_offsets {
	GCR = 0,
	GSCR = 1,
	GRST1 = 2,
	HW_ID = 3,
	PCH2_ID = 4,
	PCH0_ID = 5,
	PCH1_ID = 6,
	PCHG_ID = 7,
	PCHD_ID = 8,
	CAPS_0 = 9,
	CAPS_1 = 10,
	CAPS_2 = 11,
	CAPS_3 = 12,
	CAPS_4 = 13,
	PCH2_SR = 14,
	PCH0_SR = 15,
	PCH1_SR = 16,
	PCHD_SR = 17,
	REVISION = 18,
	IRQSTATUS_L0 = 19,
	IRQSTATUS_L1 = 20,
	IRQSTATUS_L2 = 21,
	IRQSTATUS_L3 = 22,
	IRQENABLE_L0 = 23,
	IRQENABLE_L1 = 24,
	IRQENABLE_L2 = 25,
	IRQENABLE_L3 = 26,
	SYSSTATUS = 27,
	OCP_SYSCONFIG = 28,
	CPC = 29,
	CCR2 = 30,
	LCH_CTRL = 31,
	CSDP = 32,
	CCR = 33,
	CICR = 34,
	CSR = 35,
	CEN = 36,
	CFN = 37,
	CSFI = 38,
	CSEI = 39,
	CSAC = 40,
	CDAC = 41,
	CDEI = 42,
	CDFI = 43,
	CLNK_CTRL = 44,
	CSSA = 45,
	CDSA = 46,
	COLOR = 47,
	CCEN = 48,
	CCFN = 49,
	CDP = 50,
	CNDP = 51,
	CCDN = 52,
};

struct omap_dma_dev_attr {
	u32 dev_caps;
	u16 lch_count;
	u16 chan_count;
};

enum {
	OMAP_DMA_REG_NONE = 0,
	OMAP_DMA_REG_16BIT = 1,
	OMAP_DMA_REG_2X16BIT = 2,
	OMAP_DMA_REG_32BIT = 3,
};

struct omap_dma_reg {
	u16 offset;
	u8 stride;
	u8 type;
};

struct omap_system_dma_plat_info {
	const struct omap_dma_reg *reg_map;
	unsigned int channel_stride;
	struct omap_dma_dev_attr *dma_attr;
	u32 errata;
	void (*show_dma_caps)();
	void (*clear_lch_regs)(int);
	void (*clear_dma)(int);
	void (*dma_write)(u32, int, int);
	u32 (*dma_read)(int, int);
	const struct dma_slave_map *slave_map;
	int slavecnt;
};

struct clk_hw;

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

enum ti_sysc_module_type {
	TI_SYSC_OMAP2 = 0,
	TI_SYSC_OMAP2_TIMER = 1,
	TI_SYSC_OMAP3_SHAM = 2,
	TI_SYSC_OMAP3_AES = 3,
	TI_SYSC_OMAP4 = 4,
	TI_SYSC_OMAP4_TIMER = 5,
	TI_SYSC_OMAP4_SIMPLE = 6,
	TI_SYSC_OMAP34XX_SR = 7,
	TI_SYSC_OMAP36XX_SR = 8,
	TI_SYSC_OMAP4_SR = 9,
	TI_SYSC_OMAP4_MCASP = 10,
	TI_SYSC_OMAP4_USB_HOST_FS = 11,
	TI_SYSC_DRA7_MCAN = 12,
	TI_SYSC_PRUSS = 13,
};

struct ti_sysc_cookie {
	void *data;
	void *clkdm;
};

struct sysc_regbits {
	s8 midle_shift;
	s8 clkact_shift;
	s8 sidle_shift;
	s8 enwkup_shift;
	s8 srst_shift;
	s8 autoidle_shift;
	s8 dmadisable_shift;
	s8 emufree_shift;
};

struct sysc_capabilities {
	const enum ti_sysc_module_type type;
	const u32 sysc_mask;
	const struct sysc_regbits *regbits;
	const u32 mod_quirks;
};

struct sysc_config {
	u32 sysc_val;
	u32 syss_mask;
	u8 midlemodes;
	u8 sidlemodes;
	u8 srst_udelay;
	u32 quirks;
};

enum sysc_registers {
	SYSC_REVISION = 0,
	SYSC_SYSCONFIG = 1,
	SYSC_SYSSTATUS = 2,
	SYSC_MAX_REGS = 3,
};

struct ti_sysc_module_data {
	const char *name;
	int: 32;
	u64 module_pa;
	u32 module_size;
	int *offsets;
	int nr_offsets;
	const struct sysc_capabilities *cap;
	struct sysc_config *cfg;
	int: 32;
};

struct clk_omap_reg {
	void *ptr;
	u16 offset;
	u8 index;
	u8 flags;
};

struct dpll_data {
	struct clk_omap_reg mult_div1_reg;
	u32 mult_mask;
	u32 div1_mask;
	struct clk_hw *clk_bypass;
	struct clk_hw *clk_ref;
	struct clk_omap_reg control_reg;
	u32 enable_mask;
	long unsigned int last_rounded_rate;
	u16 last_rounded_m;
	u8 last_rounded_m4xen;
	u8 last_rounded_lpmode;
	u16 max_multiplier;
	u8 last_rounded_n;
	u8 min_divider;
	u16 max_divider;
	long unsigned int max_rate;
	u8 modes;
	struct clk_omap_reg autoidle_reg;
	struct clk_omap_reg idlest_reg;
	u32 autoidle_mask;
	u32 freqsel_mask;
	u32 idlest_mask;
	u32 dco_mask;
	u32 sddiv_mask;
	u32 dcc_mask;
	long unsigned int dcc_rate;
	u32 lpmode_mask;
	u32 m4xen_mask;
	u8 auto_recal_bit;
	u8 recal_en_bit;
	u8 recal_st_bit;
	u8 flags;
};

struct clk_hw_omap;

struct clk_hw_omap_ops {
	void (*find_idlest)(struct clk_hw_omap *, struct clk_omap_reg *, u8 *, u8 *);
	void (*find_companion)(struct clk_hw_omap *, struct clk_omap_reg *, u8 *);
	void (*allow_idle)(struct clk_hw_omap *);
	void (*deny_idle)(struct clk_hw_omap *);
};

struct clk_hw_omap {
	struct clk_hw hw;
	struct list_head node;
	long unsigned int fixed_rate;
	u8 fixed_div;
	struct clk_omap_reg enable_reg;
	u8 enable_bit;
	long unsigned int flags;
	struct clk_omap_reg clksel_reg;
	struct dpll_data *dpll_data;
	const char *clkdm_name;
	struct clockdomain *clkdm;
	const struct clk_hw_omap_ops *ops;
	u32 context;
	int autoidle_count;
};

struct clkctrl_provider {
	int num_addrs;
	u32 *addr;
	u32 *size;
	struct device_node *node;
	struct list_head link;
};

struct omap_hwmod_reset {
	const char *match;
	int len;
	int (*reset)(struct omap_hwmod *);
};

struct omap_hwmod_soc_ops {
	void (*enable_module)(struct omap_hwmod *);
	int (*disable_module)(struct omap_hwmod *);
	int (*wait_target_ready)(struct omap_hwmod *);
	int (*assert_hardreset)(struct omap_hwmod *, struct omap_hwmod_rst_info *);
	int (*deassert_hardreset)(struct omap_hwmod *, struct omap_hwmod_rst_info *);
	int (*is_hardreset_asserted)(struct omap_hwmod *, struct omap_hwmod_rst_info *);
	int (*init_clkdm)(struct omap_hwmod *);
	void (*update_context_lost)(struct omap_hwmod *);
	int (*get_context_lost)(struct omap_hwmod *);
	int (*disable_direct_prcm)(struct omap_hwmod *);
	u32 (*xlate_clkctrl)(struct omap_hwmod *);
};

struct omap_dss_dispc_dev_attr {
	u8 manager_count;
	bool has_framedonetv_irq;
};

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

struct omap_device {
	struct platform_device *pdev;
	struct omap_hwmod **hwmods;
	long unsigned int _driver_status;
	u8 hwmods_cnt;
	u8 _state;
	u8 flags;
};

enum twl6030_module_ids {
	TWL6030_MODULE_ID0 = 9,
	TWL6030_MODULE_ID1 = 10,
	TWL6030_MODULE_ID2 = 11,
	TWL6030_MODULE_GPADC = 12,
	TWL6030_MODULE_GASGAUGE = 13,
	TWL6030_MODULE_LAST = 14,
};

struct omap2_sms_regs {
	u32 sms_sysconfig;
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
};

struct omap_wakeupgen_ops {
	void (*save_context)();
	void (*restore_context)();
};

struct omap_smp_config {
	long unsigned int cpu1_rstctrl_pa;
	void *cpu1_rstctrl_va;
	void *scu_base;
	void *wakeupgen_base;
	void *startup_addr;
};

struct omap_domain_base {
	u32 pa;
	void *va;
	s16 offset;
};

struct omap4_cpu_pm_info {
	struct powerdomain *pwrdm;
	void *scu_sar_addr;
	void *wkup_sar_addr;
	void *l2x0_sar_addr;
};

struct cpu_pm_ops {
	int (*finish_suspend)(long unsigned int);
	void (*resume)();
	void (*scu_prepare)(unsigned int, unsigned int);
	void (*hotplug_restart)();
};

struct power_state {
	struct powerdomain *pwrdm;
	u32 next_state;
	u32 saved_state;
	struct list_head node;
};

struct power_state___2 {
	struct powerdomain *pwrdm;
	u32 next_state;
	u32 next_logic_state;
	u32 saved_state;
	u32 saved_logic_state;
	struct list_head node;
};

struct static_dep_map {
	const char *from;
	const char *to;
};

struct am33xx_pm_sram_addr {
	void (*do_wfi)();
	long unsigned int *do_wfi_sz;
	long unsigned int *resume_offset;
	long unsigned int *emif_sram_table;
	long unsigned int *ro_sram_data;
	long unsigned int resume_address;
};

struct am33xx_pm_platform_data {
	int (*init)(int (*)(u32));
	int (*deinit)();
	int (*soc_suspend)(unsigned int, int (*)(long unsigned int), long unsigned int);
	int (*cpu_suspend)(int (*)(long unsigned int), long unsigned int);
	void (*begin_suspend)();
	void (*finish_suspend)();
	struct am33xx_pm_sram_addr * (*get_sram_addrs)();
	void (*save_context)();
	void (*restore_context)();
	int (*check_off_mode_enable)();
};

struct amx3_idle_state {
	int wfi_flags;
};

struct omap3_idle_statedata {
	u8 mpu_state;
	u8 core_state;
	u8 per_min_state;
	u8 flags;
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

struct idle_statedata {
	u32 cpu_state;
	u32 mpu_logic_state;
	u32 mpu_state;
	u32 mpu_state_vote;
};

struct omap_prcm_irq {
	const char *name;
	unsigned int offset;
	bool priority;
};

struct omap_prcm_irq_setup {
	u16 ack;
	u16 mask;
	u16 pm_ctrl;
	u8 nr_regs;
	u8 nr_irqs;
	const struct omap_prcm_irq *irqs;
	int irq;
	void (*read_pending_irqs)(long unsigned int *);
	void (*ocp_barrier)();
	void (*save_and_clear_irqen)(u32 *);
	void (*restore_irqen)(u32 *);
	void (*reconfigure_io_chain)();
	u32 *saved_mask;
	u32 *priority_mask;
	int base_irq;
	bool suspended;
	bool suspend_save_flag;
};

struct prm_ll_data {
	u32 (*read_reset_sources)();
	bool (*was_any_context_lost_old)(u8, s16, u16);
	void (*clear_context_loss_flags_old)(u8, s16, u16);
	int (*late_init)();
	int (*assert_hardreset)(u8, u8, s16, u16);
	int (*deassert_hardreset)(u8, u8, u8, s16, u16, u16);
	int (*is_hardreset_asserted)(u8, u8, s16, u16);
	void (*reset_system)();
	int (*clear_mod_irqs)(s16, u8, u32);
	u32 (*vp_check_txdone)(u8);
	void (*vp_clear_txdone)(u8);
};

struct cm_ll_data {
	int (*split_idlest_reg)(struct clk_omap_reg *, s16 *, u8 *);
	int (*wait_module_ready)(u8, s16, u16, u8);
	int (*wait_module_idle)(u8, s16, u16, u8);
	void (*module_enable)(u8, u8, u16, u16);
	void (*module_disable)(u8, u16, u16);
	u32 (*xlate_clkctrl)(u8, u16, u16);
};

typedef void (*exitcall_t)();

struct pwrdm_ops {
	int (*pwrdm_set_next_pwrst)(struct powerdomain *, u8);
	int (*pwrdm_read_next_pwrst)(struct powerdomain *);
	int (*pwrdm_read_pwrst)(struct powerdomain *);
	int (*pwrdm_read_prev_pwrst)(struct powerdomain *);
	int (*pwrdm_set_logic_retst)(struct powerdomain *, u8);
	int (*pwrdm_set_mem_onst)(struct powerdomain *, u8, u8);
	int (*pwrdm_set_mem_retst)(struct powerdomain *, u8, u8);
	int (*pwrdm_read_logic_pwrst)(struct powerdomain *);
	int (*pwrdm_read_prev_logic_pwrst)(struct powerdomain *);
	int (*pwrdm_read_logic_retst)(struct powerdomain *);
	int (*pwrdm_read_mem_pwrst)(struct powerdomain *, u8);
	int (*pwrdm_read_prev_mem_pwrst)(struct powerdomain *, u8);
	int (*pwrdm_read_mem_retst)(struct powerdomain *, u8);
	int (*pwrdm_clear_all_prev_pwrst)(struct powerdomain *);
	int (*pwrdm_enable_hdwr_sar)(struct powerdomain *);
	int (*pwrdm_disable_hdwr_sar)(struct powerdomain *);
	int (*pwrdm_set_lowpwrstchange)(struct powerdomain *);
	int (*pwrdm_wait_transition)(struct powerdomain *);
	int (*pwrdm_has_voltdm)();
	void (*pwrdm_save_context)(struct powerdomain *);
	void (*pwrdm_restore_context)(struct powerdomain *);
};

struct prm_reset_src_map {
	s8 reg_shift;
	s8 std_shift;
};

struct omap3_vp {
	u32 tranxdone_status;
};

struct clkdm_ops {
	int (*clkdm_add_wkdep)(struct clockdomain *, struct clockdomain *);
	int (*clkdm_del_wkdep)(struct clockdomain *, struct clockdomain *);
	int (*clkdm_read_wkdep)(struct clockdomain *, struct clockdomain *);
	int (*clkdm_clear_all_wkdeps)(struct clockdomain *);
	int (*clkdm_add_sleepdep)(struct clockdomain *, struct clockdomain *);
	int (*clkdm_del_sleepdep)(struct clockdomain *, struct clockdomain *);
	int (*clkdm_read_sleepdep)(struct clockdomain *, struct clockdomain *);
	int (*clkdm_clear_all_sleepdeps)(struct clockdomain *);
	int (*clkdm_sleep)(struct clockdomain *);
	int (*clkdm_wakeup)(struct clockdomain *);
	void (*clkdm_allow_idle)(struct clockdomain *);
	void (*clkdm_deny_idle)(struct clockdomain *);
	int (*clkdm_clk_enable)(struct clockdomain *);
	int (*clkdm_clk_disable)(struct clockdomain *);
	int (*clkdm_save_context)(struct clockdomain *);
	int (*clkdm_restore_context)(struct clockdomain *);
};

struct omap3_cm_regs {
	u32 iva2_cm_clksel1;
	u32 iva2_cm_clksel2;
	u32 cm_sysconfig;
	u32 sgx_cm_clksel;
	u32 dss_cm_clksel;
	u32 cam_cm_clksel;
	u32 per_cm_clksel;
	u32 emu_cm_clksel;
	u32 emu_cm_clkstctrl;
	u32 pll_cm_autoidle;
	u32 pll_cm_autoidle2;
	u32 pll_cm_clksel4;
	u32 pll_cm_clksel5;
	u32 pll_cm_clken2;
	u32 cm_polctrl;
	u32 iva2_cm_fclken;
	u32 iva2_cm_clken_pll;
	u32 core_cm_fclken1;
	u32 core_cm_fclken3;
	u32 sgx_cm_fclken;
	u32 wkup_cm_fclken;
	u32 dss_cm_fclken;
	u32 cam_cm_fclken;
	u32 per_cm_fclken;
	u32 usbhost_cm_fclken;
	u32 core_cm_iclken1;
	u32 core_cm_iclken2;
	u32 core_cm_iclken3;
	u32 sgx_cm_iclken;
	u32 wkup_cm_iclken;
	u32 dss_cm_iclken;
	u32 cam_cm_iclken;
	u32 per_cm_iclken;
	u32 usbhost_cm_iclken;
	u32 iva2_cm_autoidle2;
	u32 mpu_cm_autoidle2;
	u32 iva2_cm_clkstctrl;
	u32 mpu_cm_clkstctrl;
	u32 core_cm_clkstctrl;
	u32 sgx_cm_clkstctrl;
	u32 dss_cm_clkstctrl;
	u32 cam_cm_clkstctrl;
	u32 per_cm_clkstctrl;
	u32 neon_cm_clkstctrl;
	u32 usbhost_cm_clkstctrl;
	u32 core_cm_autoidle1;
	u32 core_cm_autoidle2;
	u32 core_cm_autoidle3;
	u32 wkup_cm_autoidle;
	u32 dss_cm_autoidle;
	u32 cam_cm_autoidle;
	u32 per_cm_autoidle;
	u32 usbhost_cm_autoidle;
	u32 sgx_cm_sleepdep;
	u32 dss_cm_sleepdep;
	u32 cam_cm_sleepdep;
	u32 per_cm_sleepdep;
	u32 usbhost_cm_sleepdep;
	u32 cm_clkout_ctrl;
};

struct omap_prm_irq_context {
	long unsigned int irq_enable;
	long unsigned int pm_ctrl;
};

struct omap4_vp {
	u32 irqstatus_mpu;
	u32 tranxdone_status;
};

struct omap_vc_channel_cfg {
	u8 sa;
	u8 rav;
	u8 rac;
	u8 racen;
	u8 cmd;
};

struct omap3_vc_timings {
	u32 voltsetup1;
	u32 voltsetup2;
};

struct omap3_vc {
	struct voltagedomain *vd;
	u32 voltctrl;
	u32 voltsetup1;
	u32 voltsetup2;
	struct omap3_vc_timings timings[2];
};

struct i2c_init_data {
	u8 loadbits;
	u8 load;
	u8 hsscll_38_4;
	u8 hsscll_26;
	u8 hsscll_19_2;
	u8 hsscll_16_8;
	u8 hsscll_12;
};

enum {
	PWRDM_STATE_NOW = 0,
	PWRDM_STATE_PREV = 1,
};

struct clkdm_autodep {
	union {
		const char *name;
		struct clockdomain *ptr;
	} clkdm;
};

struct omap_hwmod___2;

struct ti_clk_ll_ops {
	u32 (*clk_readl)(const struct clk_omap_reg *);
	void (*clk_writel)(u32, const struct clk_omap_reg *);
	void (*clk_rmw)(u32, u32, const struct clk_omap_reg *);
	int (*clkdm_clk_enable)(struct clockdomain *, struct clk *);
	int (*clkdm_clk_disable)(struct clockdomain *, struct clk *);
	struct clockdomain * (*clkdm_lookup)(const char *);
	int (*cm_wait_module_ready)(u8, s16, u16, u8);
	int (*cm_split_idlest_reg)(struct clk_omap_reg *, s16 *, u8 *);
};

struct ti_clk_features {
	u32 flags;
	long int fint_min;
	long int fint_max;
	long int fint_band1_max;
	long int fint_band2_min;
	u8 dpll_bypass_vals;
	u8 cm_idlest_val;
};

enum sr_instance {
	OMAP_SR_MPU = 0,
	OMAP_SR_CORE = 1,
	OMAP_SR_IVA = 2,
	OMAP_SR_NR = 3,
};

struct omap_smartreflex_dev_attr {
	const char *sensor_voltdm_name;
};

struct omap_hsmmc_dev_attr {
	u8 flags;
};

struct emac_platform_data {
	char mac_addr[6];
	u32 ctrl_reg_offset;
	u32 ctrl_mod_reg_offset;
	u32 ctrl_ram_offset;
	u32 hw_ram_addr;
	u32 ctrl_ram_size;
	const char *phy_id;
	u8 rmii_en;
	u8 version;
	bool no_bd_ram;
	void (*interrupt_enable)();
	void (*interrupt_disable)();
};

struct gpio {
	unsigned int gpio;
	long unsigned int flags;
	const char *label;
};

struct of_dev_auxdata {
	char *compatible;
	resource_size_t phys_addr;
	char *name;
	void *platform_data;
};

struct omap_sr_nvalue_table {
	u32 efuse_offs;
	u32 nvalue;
	u32 errminlimit;
	long unsigned int volt_nominal;
};

struct omap_sr_data {
	const char *name;
	int ip_type;
	u32 senp_mod;
	u32 senn_mod;
	u32 err_weight;
	u32 err_maxlimit;
	u32 accum_data;
	u32 senn_avgweight;
	u32 senp_avgweight;
	int nvalue_count;
	bool enable_on_init;
	struct omap_sr_nvalue_table *nvalue_table;
	struct voltagedomain *voltdm;
};

struct pcs_pdata {
	int irq;
	void (*rearm)();
};

struct omap_hsmmc_platform_data {
	struct device *dev;
	unsigned int max_freq;
	u8 controller_flags;
	u16 reg_offset;
	u32 caps;
	u32 pm_caps;
	unsigned int nonremovable: 1;
	unsigned int no_regulator_off_init: 1;
	unsigned int features;
	char *version;
	const char *name;
	u32 ocr_mask;
};

struct iommu_platform_data {
	const char *reset_name;
	int (*assert_reset)(struct platform_device *, const char *);
	int (*deassert_reset)(struct platform_device *, const char *);
	int (*device_enable)(struct platform_device *);
	int (*device_idle)(struct platform_device *);
	int (*set_pwrdm_constraint)(struct platform_device *, bool, u8 *);
};

struct ti_sysc_platform_data {
	struct of_dev_auxdata *auxdata;
	bool (*soc_type_gp)();
	int (*init_clockdomain)(struct device *, struct clk *, struct clk *, struct ti_sysc_cookie *);
	void (*clkdm_deny_idle)(struct device *, const struct ti_sysc_cookie *);
	void (*clkdm_allow_idle)(struct device *, const struct ti_sysc_cookie *);
	int (*init_module)(struct device *, const struct ti_sysc_module_data *, struct ti_sysc_cookie *);
	int (*enable_module)(struct device *, const struct ti_sysc_cookie *);
	int (*idle_module)(struct device *, const struct ti_sysc_cookie *);
	int (*shutdown_module)(struct device *, const struct ti_sysc_cookie *);
};

struct ti_prm_platform_data {
	void (*clkdm_deny_idle)(struct clockdomain *);
	void (*clkdm_allow_idle)(struct clockdomain *);
	struct clockdomain * (*clkdm_lookup)(const char *);
};

struct twl4030_gpio_platform_data {
	bool use_leds;
	u8 mmc_cd;
	u32 debounce;
	u32 pullups;
	u32 pulldowns;
	int (*setup)(struct device *, unsigned int, unsigned int);
	int (*teardown)(struct device *, unsigned int, unsigned int);
};

struct omap_system_dma_plat_info___2;

struct pdata_init {
	const char *compatible;
	void (*fn)();
};

enum musb_mode {
	MUSB_UNDEFINED = 0,
	MUSB_HOST = 1,
	MUSB_PERIPHERAL = 2,
	MUSB_OTG = 3,
};

enum rk3288_pwr_mode_con {
	PMU_PWR_MODE_EN = 0,
	PMU_CLK_CORE_SRC_GATE_EN = 1,
	PMU_GLOBAL_INT_DISABLE = 2,
	PMU_L2FLUSH_EN = 3,
	PMU_BUS_PD_EN = 4,
	PMU_A12_0_PD_EN = 5,
	PMU_SCU_EN = 6,
	PMU_PLL_PD_EN = 7,
	PMU_CHIP_PD_EN = 8,
	PMU_PWROFF_COMB = 9,
	PMU_ALIVE_USE_LF = 10,
	PMU_PMU_USE_LF = 11,
	PMU_OSC_24M_DIS = 12,
	PMU_INPUT_CLAMP_EN = 13,
	PMU_WAKEUP_RESET_EN = 14,
	PMU_SREF0_ENTER_EN = 15,
	PMU_SREF1_ENTER_EN = 16,
	PMU_DDR0IO_RET_EN = 17,
	PMU_DDR1IO_RET_EN = 18,
	PMU_DDR0_GATING_EN = 19,
	PMU_DDR1_GATING_EN = 20,
	PMU_DDR0IO_RET_DE_REQ = 21,
	PMU_DDR1IO_RET_DE_REQ = 22,
};

enum rk3288_pwr_mode_con1 {
	PMU_CLR_BUS = 0,
	PMU_CLR_CORE = 1,
	PMU_CLR_CPUP = 2,
	PMU_CLR_ALIVE = 3,
	PMU_CLR_DMA = 4,
	PMU_CLR_PERI = 5,
	PMU_CLR_GPU = 6,
	PMU_CLR_VIDEO = 7,
	PMU_CLR_HEVC = 8,
	PMU_CLR_VIO = 9,
};

enum {
	ROCKCHIP_ARM_OFF_LOGIC_NORMAL = 0,
	ROCKCHIP_ARM_OFF_LOGIC_DEEP = 1,
};

struct rockchip_pm_data {
	const struct platform_suspend_ops *ops;
	int (*init)(struct device_node *);
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_COMPRESSED = 2,
	REGCACHE_FLAT = 3,
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	bool fast_io;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool use_relaxed_mmio;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct memory_reserve_config {
	u64 reserved;
	u64 base;
	u64 size;
};

struct rt_mutex {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

enum i2c_slave_event {
	I2C_SLAVE_READ_REQUESTED = 0,
	I2C_SLAVE_WRITE_REQUESTED = 1,
	I2C_SLAVE_READ_PROCESSED = 2,
	I2C_SLAVE_WRITE_RECEIVED = 3,
	I2C_SLAVE_STOP = 4,
};

struct i2c_client;

typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);

struct i2c_adapter;

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	int: 32;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	i2c_slave_cb_t slave_cb;
	int: 32;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	int: 32;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
};

struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
	int (*reg_slave)(struct i2c_client *);
	int (*unreg_slave)(struct i2c_client *);
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
	int: 32;
};

struct regulator_quirk {
	struct list_head list;
	const struct of_device_id *id;
	struct device_node *np;
	struct of_phandle_args irq_args;
	struct i2c_msg i2c_msg;
	bool shared;
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

typedef void (*regmap_hw_free_context)(void *);

struct regmap_bus {
	bool fast_io;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
};

struct sunxi_mc_smp_nodes {
	struct device_node *prcm_node;
	struct device_node *cpucfg_node;
	struct device_node *sram_node;
	struct device_node *r_cpucfg_node;
};

struct sunxi_mc_smp_data {
	const char *enable_method;
	int (*get_smp_nodes)(struct sunxi_mc_smp_nodes *);
	bool is_a83t;
};

struct tegra_cpu_car_ops {
	void (*wait_for_reset)(u32);
	void (*put_in_reset)(u32);
	void (*out_of_reset)(u32);
	void (*enable_clock)(u32);
	void (*disable_clock)(u32);
	bool (*rail_off_ready)();
	void (*suspend)();
	void (*resume)();
};

enum tegra_suspend_mode {
	TEGRA_SUSPEND_NONE = 0,
	TEGRA_SUSPEND_LP2 = 1,
	TEGRA_SUSPEND_LP1 = 2,
	TEGRA_SUSPEND_LP0 = 3,
	TEGRA_MAX_SUSPEND_MODE = 4,
};

struct tegra_lp1_iram {
	void *start_addr;
	void *end_addr;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

enum gpd_status {
	GENPD_STATE_ON = 0,
	GENPD_STATE_OFF = 1,
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *);
	bool (*suspend_ok)(struct device *);
};

struct gpd_dev_ops {
	int (*start)(struct device *);
	int (*stop)(struct device *);
};

struct genpd_power_state {
	s64 power_off_latency_ns;
	s64 power_on_latency_ns;
	s64 residency_ns;
	u64 usage;
	u64 rejected;
	struct fwnode_handle *fwnode;
	int: 32;
	ktime_t idle_time;
	void *data;
	int: 32;
};

struct opp_table;

struct dev_pm_opp;

struct genpd_lock_ops;

struct generic_pm_domain {
	struct device dev;
	struct dev_pm_domain domain;
	struct list_head gpd_list_node;
	struct list_head parent_links;
	struct list_head child_links;
	struct list_head dev_list;
	struct dev_power_governor *gov;
	struct work_struct power_off_work;
	struct fwnode_handle *provider;
	bool has_provider;
	const char *name;
	atomic_t sd_count;
	enum gpd_status status;
	unsigned int device_count;
	unsigned int suspended_count;
	unsigned int prepared_count;
	unsigned int performance_state;
	cpumask_var_t cpus;
	int (*power_off)(struct generic_pm_domain *);
	int (*power_on)(struct generic_pm_domain *);
	struct raw_notifier_head power_notifiers;
	struct opp_table *opp_table;
	unsigned int (*opp_to_performance_state)(struct generic_pm_domain *, struct dev_pm_opp *);
	int (*set_performance_state)(struct generic_pm_domain *, unsigned int);
	struct gpd_dev_ops dev_ops;
	int: 32;
	s64 max_off_time_ns;
	bool max_off_time_changed;
	bool cached_power_down_ok;
	bool cached_power_down_state_idx;
	int (*attach_dev)(struct generic_pm_domain *, struct device *);
	void (*detach_dev)(struct generic_pm_domain *, struct device *);
	unsigned int flags;
	struct genpd_power_state *states;
	void (*free_states)(struct genpd_power_state *, unsigned int);
	unsigned int state_count;
	unsigned int state_idx;
	ktime_t on_time;
	ktime_t accounting_time;
	const struct genpd_lock_ops *lock_ops;
	union {
		struct mutex mlock;
		struct {
			spinlock_t slock;
			long unsigned int lock_flags;
		};
	};
};

struct genpd_lock_ops {
	void (*lock)(struct generic_pm_domain *);
	void (*lock_nested)(struct generic_pm_domain *, int);
	int (*lock_interruptible)(struct generic_pm_domain *);
	void (*unlock)(struct generic_pm_domain *);
};

typedef struct generic_pm_domain * (*genpd_xlate_t)(struct of_phandle_args *, void *);

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
	genpd_xlate_t xlate;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct ve_spc_opp {
	long unsigned int freq;
	long unsigned int u_volt;
};

struct ve_spc_drvdata {
	void *baseaddr;
	u32 a15_clusid;
	uint32_t cur_rsp_mask;
	uint32_t cur_rsp_stat;
	struct semaphore sem;
	struct completion done;
	struct ve_spc_opp *opps[2];
	int num_opps[2];
};

struct clk_spc {
	struct clk_hw hw;
	int cluster;
};

enum omap_dma_burst_mode {
	OMAP_DMA_DATA_BURST_DIS = 0,
	OMAP_DMA_DATA_BURST_4 = 1,
	OMAP_DMA_DATA_BURST_8 = 2,
	OMAP_DMA_DATA_BURST_16 = 3,
};

enum omap_dma_channel_mode {
	OMAP_DMA_LCH_2D = 0,
	OMAP_DMA_LCH_G = 1,
	OMAP_DMA_LCH_P = 2,
	OMAP_DMA_LCH_PD = 3,
};

struct omap_dma_lch {
	int next_lch;
	int dev_id;
	u16 saved_csr;
	u16 enabled_irqs;
	const char *dev_name;
	void (*callback)(int, u16, void *);
	void *data;
	long int flags;
	int state;
	int chain_id;
	int status;
};

typedef long unsigned int cycles_t;

enum {
	MFP_PIN_INVALID = 4294967295,
	MFP_PIN_GPIO0 = 0,
	MFP_PIN_GPIO1 = 1,
	MFP_PIN_GPIO2 = 2,
	MFP_PIN_GPIO3 = 3,
	MFP_PIN_GPIO4 = 4,
	MFP_PIN_GPIO5 = 5,
	MFP_PIN_GPIO6 = 6,
	MFP_PIN_GPIO7 = 7,
	MFP_PIN_GPIO8 = 8,
	MFP_PIN_GPIO9 = 9,
	MFP_PIN_GPIO10 = 10,
	MFP_PIN_GPIO11 = 11,
	MFP_PIN_GPIO12 = 12,
	MFP_PIN_GPIO13 = 13,
	MFP_PIN_GPIO14 = 14,
	MFP_PIN_GPIO15 = 15,
	MFP_PIN_GPIO16 = 16,
	MFP_PIN_GPIO17 = 17,
	MFP_PIN_GPIO18 = 18,
	MFP_PIN_GPIO19 = 19,
	MFP_PIN_GPIO20 = 20,
	MFP_PIN_GPIO21 = 21,
	MFP_PIN_GPIO22 = 22,
	MFP_PIN_GPIO23 = 23,
	MFP_PIN_GPIO24 = 24,
	MFP_PIN_GPIO25 = 25,
	MFP_PIN_GPIO26 = 26,
	MFP_PIN_GPIO27 = 27,
	MFP_PIN_GPIO28 = 28,
	MFP_PIN_GPIO29 = 29,
	MFP_PIN_GPIO30 = 30,
	MFP_PIN_GPIO31 = 31,
	MFP_PIN_GPIO32 = 32,
	MFP_PIN_GPIO33 = 33,
	MFP_PIN_GPIO34 = 34,
	MFP_PIN_GPIO35 = 35,
	MFP_PIN_GPIO36 = 36,
	MFP_PIN_GPIO37 = 37,
	MFP_PIN_GPIO38 = 38,
	MFP_PIN_GPIO39 = 39,
	MFP_PIN_GPIO40 = 40,
	MFP_PIN_GPIO41 = 41,
	MFP_PIN_GPIO42 = 42,
	MFP_PIN_GPIO43 = 43,
	MFP_PIN_GPIO44 = 44,
	MFP_PIN_GPIO45 = 45,
	MFP_PIN_GPIO46 = 46,
	MFP_PIN_GPIO47 = 47,
	MFP_PIN_GPIO48 = 48,
	MFP_PIN_GPIO49 = 49,
	MFP_PIN_GPIO50 = 50,
	MFP_PIN_GPIO51 = 51,
	MFP_PIN_GPIO52 = 52,
	MFP_PIN_GPIO53 = 53,
	MFP_PIN_GPIO54 = 54,
	MFP_PIN_GPIO55 = 55,
	MFP_PIN_GPIO56 = 56,
	MFP_PIN_GPIO57 = 57,
	MFP_PIN_GPIO58 = 58,
	MFP_PIN_GPIO59 = 59,
	MFP_PIN_GPIO60 = 60,
	MFP_PIN_GPIO61 = 61,
	MFP_PIN_GPIO62 = 62,
	MFP_PIN_GPIO63 = 63,
	MFP_PIN_GPIO64 = 64,
	MFP_PIN_GPIO65 = 65,
	MFP_PIN_GPIO66 = 66,
	MFP_PIN_GPIO67 = 67,
	MFP_PIN_GPIO68 = 68,
	MFP_PIN_GPIO69 = 69,
	MFP_PIN_GPIO70 = 70,
	MFP_PIN_GPIO71 = 71,
	MFP_PIN_GPIO72 = 72,
	MFP_PIN_GPIO73 = 73,
	MFP_PIN_GPIO74 = 74,
	MFP_PIN_GPIO75 = 75,
	MFP_PIN_GPIO76 = 76,
	MFP_PIN_GPIO77 = 77,
	MFP_PIN_GPIO78 = 78,
	MFP_PIN_GPIO79 = 79,
	MFP_PIN_GPIO80 = 80,
	MFP_PIN_GPIO81 = 81,
	MFP_PIN_GPIO82 = 82,
	MFP_PIN_GPIO83 = 83,
	MFP_PIN_GPIO84 = 84,
	MFP_PIN_GPIO85 = 85,
	MFP_PIN_GPIO86 = 86,
	MFP_PIN_GPIO87 = 87,
	MFP_PIN_GPIO88 = 88,
	MFP_PIN_GPIO89 = 89,
	MFP_PIN_GPIO90 = 90,
	MFP_PIN_GPIO91 = 91,
	MFP_PIN_GPIO92 = 92,
	MFP_PIN_GPIO93 = 93,
	MFP_PIN_GPIO94 = 94,
	MFP_PIN_GPIO95 = 95,
	MFP_PIN_GPIO96 = 96,
	MFP_PIN_GPIO97 = 97,
	MFP_PIN_GPIO98 = 98,
	MFP_PIN_GPIO99 = 99,
	MFP_PIN_GPIO100 = 100,
	MFP_PIN_GPIO101 = 101,
	MFP_PIN_GPIO102 = 102,
	MFP_PIN_GPIO103 = 103,
	MFP_PIN_GPIO104 = 104,
	MFP_PIN_GPIO105 = 105,
	MFP_PIN_GPIO106 = 106,
	MFP_PIN_GPIO107 = 107,
	MFP_PIN_GPIO108 = 108,
	MFP_PIN_GPIO109 = 109,
	MFP_PIN_GPIO110 = 110,
	MFP_PIN_GPIO111 = 111,
	MFP_PIN_GPIO112 = 112,
	MFP_PIN_GPIO113 = 113,
	MFP_PIN_GPIO114 = 114,
	MFP_PIN_GPIO115 = 115,
	MFP_PIN_GPIO116 = 116,
	MFP_PIN_GPIO117 = 117,
	MFP_PIN_GPIO118 = 118,
	MFP_PIN_GPIO119 = 119,
	MFP_PIN_GPIO120 = 120,
	MFP_PIN_GPIO121 = 121,
	MFP_PIN_GPIO122 = 122,
	MFP_PIN_GPIO123 = 123,
	MFP_PIN_GPIO124 = 124,
	MFP_PIN_GPIO125 = 125,
	MFP_PIN_GPIO126 = 126,
	MFP_PIN_GPIO127 = 127,
	MFP_PIN_GPIO128 = 128,
	MFP_PIN_GPIO129 = 129,
	MFP_PIN_GPIO130 = 130,
	MFP_PIN_GPIO131 = 131,
	MFP_PIN_GPIO132 = 132,
	MFP_PIN_GPIO133 = 133,
	MFP_PIN_GPIO134 = 134,
	MFP_PIN_GPIO135 = 135,
	MFP_PIN_GPIO136 = 136,
	MFP_PIN_GPIO137 = 137,
	MFP_PIN_GPIO138 = 138,
	MFP_PIN_GPIO139 = 139,
	MFP_PIN_GPIO140 = 140,
	MFP_PIN_GPIO141 = 141,
	MFP_PIN_GPIO142 = 142,
	MFP_PIN_GPIO143 = 143,
	MFP_PIN_GPIO144 = 144,
	MFP_PIN_GPIO145 = 145,
	MFP_PIN_GPIO146 = 146,
	MFP_PIN_GPIO147 = 147,
	MFP_PIN_GPIO148 = 148,
	MFP_PIN_GPIO149 = 149,
	MFP_PIN_GPIO150 = 150,
	MFP_PIN_GPIO151 = 151,
	MFP_PIN_GPIO152 = 152,
	MFP_PIN_GPIO153 = 153,
	MFP_PIN_GPIO154 = 154,
	MFP_PIN_GPIO155 = 155,
	MFP_PIN_GPIO156 = 156,
	MFP_PIN_GPIO157 = 157,
	MFP_PIN_GPIO158 = 158,
	MFP_PIN_GPIO159 = 159,
	MFP_PIN_GPIO160 = 160,
	MFP_PIN_GPIO161 = 161,
	MFP_PIN_GPIO162 = 162,
	MFP_PIN_GPIO163 = 163,
	MFP_PIN_GPIO164 = 164,
	MFP_PIN_GPIO165 = 165,
	MFP_PIN_GPIO166 = 166,
	MFP_PIN_GPIO167 = 167,
	MFP_PIN_GPIO168 = 168,
	MFP_PIN_GPIO169 = 169,
	MFP_PIN_GPIO170 = 170,
	MFP_PIN_GPIO171 = 171,
	MFP_PIN_GPIO172 = 172,
	MFP_PIN_GPIO173 = 173,
	MFP_PIN_GPIO174 = 174,
	MFP_PIN_GPIO175 = 175,
	MFP_PIN_GPIO176 = 176,
	MFP_PIN_GPIO177 = 177,
	MFP_PIN_GPIO178 = 178,
	MFP_PIN_GPIO179 = 179,
	MFP_PIN_GPIO180 = 180,
	MFP_PIN_GPIO181 = 181,
	MFP_PIN_GPIO182 = 182,
	MFP_PIN_GPIO183 = 183,
	MFP_PIN_GPIO184 = 184,
	MFP_PIN_GPIO185 = 185,
	MFP_PIN_GPIO186 = 186,
	MFP_PIN_GPIO187 = 187,
	MFP_PIN_GPIO188 = 188,
	MFP_PIN_GPIO189 = 189,
	MFP_PIN_GPIO190 = 190,
	MFP_PIN_GPIO191 = 191,
	MFP_PIN_GPIO255 = 255,
	MFP_PIN_GPIO0_2 = 256,
	MFP_PIN_GPIO1_2 = 257,
	MFP_PIN_GPIO2_2 = 258,
	MFP_PIN_GPIO3_2 = 259,
	MFP_PIN_GPIO4_2 = 260,
	MFP_PIN_GPIO5_2 = 261,
	MFP_PIN_GPIO6_2 = 262,
	MFP_PIN_GPIO7_2 = 263,
	MFP_PIN_GPIO8_2 = 264,
	MFP_PIN_GPIO9_2 = 265,
	MFP_PIN_GPIO10_2 = 266,
	MFP_PIN_GPIO11_2 = 267,
	MFP_PIN_GPIO12_2 = 268,
	MFP_PIN_GPIO13_2 = 269,
	MFP_PIN_GPIO14_2 = 270,
	MFP_PIN_GPIO15_2 = 271,
	MFP_PIN_GPIO16_2 = 272,
	MFP_PIN_GPIO17_2 = 273,
	MFP_PIN_ULPI_STP = 274,
	MFP_PIN_ULPI_NXT = 275,
	MFP_PIN_ULPI_DIR = 276,
	MFP_PIN_nXCVREN = 277,
	MFP_PIN_DF_CLE_nOE = 278,
	MFP_PIN_DF_nADV1_ALE = 279,
	MFP_PIN_DF_SCLK_E = 280,
	MFP_PIN_DF_SCLK_S = 281,
	MFP_PIN_nBE0 = 282,
	MFP_PIN_nBE1 = 283,
	MFP_PIN_DF_nADV2_ALE = 284,
	MFP_PIN_DF_INT_RnB = 285,
	MFP_PIN_DF_nCS0 = 286,
	MFP_PIN_DF_nCS1 = 287,
	MFP_PIN_nLUA = 288,
	MFP_PIN_nLLA = 289,
	MFP_PIN_DF_nWE = 290,
	MFP_PIN_DF_ALE_nWE = 291,
	MFP_PIN_DF_nRE_nOE = 292,
	MFP_PIN_DF_ADDR0 = 293,
	MFP_PIN_DF_ADDR1 = 294,
	MFP_PIN_DF_ADDR2 = 295,
	MFP_PIN_DF_ADDR3 = 296,
	MFP_PIN_DF_IO0 = 297,
	MFP_PIN_DF_IO1 = 298,
	MFP_PIN_DF_IO2 = 299,
	MFP_PIN_DF_IO3 = 300,
	MFP_PIN_DF_IO4 = 301,
	MFP_PIN_DF_IO5 = 302,
	MFP_PIN_DF_IO6 = 303,
	MFP_PIN_DF_IO7 = 304,
	MFP_PIN_DF_IO8 = 305,
	MFP_PIN_DF_IO9 = 306,
	MFP_PIN_DF_IO10 = 307,
	MFP_PIN_DF_IO11 = 308,
	MFP_PIN_DF_IO12 = 309,
	MFP_PIN_DF_IO13 = 310,
	MFP_PIN_DF_IO14 = 311,
	MFP_PIN_DF_IO15 = 312,
	MFP_PIN_DF_nCS0_SM_nCS2 = 313,
	MFP_PIN_DF_nCS1_SM_nCS3 = 314,
	MFP_PIN_SM_nCS0 = 315,
	MFP_PIN_SM_nCS1 = 316,
	MFP_PIN_DF_WEn = 317,
	MFP_PIN_DF_REn = 318,
	MFP_PIN_DF_CLE_SM_OEn = 319,
	MFP_PIN_DF_ALE_SM_WEn = 320,
	MFP_PIN_DF_RDY0 = 321,
	MFP_PIN_DF_RDY1 = 322,
	MFP_PIN_SM_SCLK = 323,
	MFP_PIN_SM_BE0 = 324,
	MFP_PIN_SM_BE1 = 325,
	MFP_PIN_SM_ADV = 326,
	MFP_PIN_SM_ADVMUX = 327,
	MFP_PIN_SM_RDY = 328,
	MFP_PIN_MMC1_DAT7 = 329,
	MFP_PIN_MMC1_DAT6 = 330,
	MFP_PIN_MMC1_DAT5 = 331,
	MFP_PIN_MMC1_DAT4 = 332,
	MFP_PIN_MMC1_DAT3 = 333,
	MFP_PIN_MMC1_DAT2 = 334,
	MFP_PIN_MMC1_DAT1 = 335,
	MFP_PIN_MMC1_DAT0 = 336,
	MFP_PIN_MMC1_CMD = 337,
	MFP_PIN_MMC1_CLK = 338,
	MFP_PIN_MMC1_CD = 339,
	MFP_PIN_MMC1_WP = 340,
	MFP_PIN_GSIM_UIO = 341,
	MFP_PIN_GSIM_UCLK = 342,
	MFP_PIN_GSIM_UDET = 343,
	MFP_PIN_GSIM_nURST = 344,
	MFP_PIN_PMIC_INT = 345,
	MFP_PIN_RDY = 346,
	MFP_PIN_TWSI1_SCL = 347,
	MFP_PIN_TWSI1_SDA = 348,
	MFP_PIN_TWSI4_SCL = 349,
	MFP_PIN_TWSI4_SDA = 350,
	MFP_PIN_CLK_REQ = 351,
	MFP_PIN_MAX = 352,
};

struct mfp_addr_map {
	unsigned int start;
	unsigned int end;
	long unsigned int offset;
};

struct mfp_pin {
	long unsigned int config;
	long unsigned int mfpr_off;
	long unsigned int mfpr_run;
	long unsigned int mfpr_lpm;
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_DELAYED_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_DELAYED = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 15,
	WORK_NO_COLOR = 15,
	WORK_CPU_UNBOUND = 16,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_CANCELING = 16,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 27,
	WORK_OFFQ_POOL_BITS = 27,
	WORK_OFFQ_POOL_NONE = 134217727,
	WORK_STRUCT_FLAG_MASK = 255,
	WORK_STRUCT_WQ_DATA_MASK = 4294967040,
	WORK_STRUCT_NO_POOL = 4294967264,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[32];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct io_identity {
	struct files_struct *files;
	struct mm_struct *mm;
	const struct cred *creds;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	long unsigned int fsize;
	refcount_t count;
};

struct io_uring_task {
	struct xarray xa;
	struct wait_queue_head wait;
	struct file *last;
	int: 32;
	struct percpu_counter inflight;
	struct io_identity __identity;
	struct io_identity *identity;
	atomic_t in_idle;
	bool sqpoll;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	struct cgroup *cgrp;
	struct css_set *cset;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

struct mempolicy {};

typedef struct poll_table_struct poll_table;

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

struct audit_context;

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

typedef void (*dr_release_t)(struct device *, void *);

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

typedef struct siginfo siginfo_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct user_struct *user;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
			int: 24;
			int: 32;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
			int: 32;
		} seccomp;
	};
};

typedef long unsigned int old_sigset_t;

struct old_sigaction {
	__sighandler_t sa_handler;
	old_sigset_t sa_mask;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_MCEERR = 4,
	SIL_FAULT_BNDERR = 5,
	SIL_FAULT_PKUERR = 6,
	SIL_CHLD = 7,
	SIL_RT = 8,
	SIL_SYS = 9,
};

struct fd {
	struct file *file;
	unsigned int flags;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[8];
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

enum uts_proc {
	UTS_PROC_OSTYPE = 0,
	UTS_PROC_OSRELEASE = 1,
	UTS_PROC_VERSION = 2,
	UTS_PROC_HOSTNAME = 3,
	UTS_PROC_DOMAINNAME = 4,
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
	int: 32;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[32];
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

struct __una_u32 {
	u32 x;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[15];
	int nr_active;
	int max_active;
	struct list_head delayed_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic_t nr_running;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 30000,
	MAYDAY_INITIAL_TIMEOUT = 2,
	MAYDAY_INTERVAL = 10,
	CREATE_COOLDOWN = 100,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	int: 32;
	struct device dev;
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *workqueue;
	unsigned int req_cpu;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_queue_work {};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

typedef void (*btf_trace_workqueue_queue_work)(void *, unsigned int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[6];
		long unsigned int marks[6];
	};
};

typedef struct {} local_lock_t;

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_PCMCIA_CIS = 10,
	LOCKDOWN_TIOCSSERIAL = 11,
	LOCKDOWN_MODULE_PARAMETERS = 12,
	LOCKDOWN_MMIOTRACE = 13,
	LOCKDOWN_DEBUGFS = 14,
	LOCKDOWN_XMON_WR = 15,
	LOCKDOWN_INTEGRITY_MAX = 16,
	LOCKDOWN_KCORE = 17,
	LOCKDOWN_KPROBES = 18,
	LOCKDOWN_BPF_READ = 19,
	LOCKDOWN_PERF = 20,
	LOCKDOWN_TRACEFS = 21,
	LOCKDOWN_XMON_RW = 22,
	LOCKDOWN_XFRM_SECRET = 23,
	LOCKDOWN_CONFIDENTIALITY_MAX = 24,
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct sched_param {
	int sched_priority;
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	int (*threadfn)(void *);
	void *data;
	mm_segment_t oldfs;
	struct completion parked;
	struct completion exited;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	atomic_t msg_bytes;
	atomic_t msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
	int: 32;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct pin_cookie {};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

typedef struct __call_single_data call_single_data_t;

struct dl_bw {
	raw_spinlock_t lock;
	int: 32;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_gen;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int next_decay_max_lb_cost;
	int: 32;
	u64 avg_scan_cost;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
	int: 32;
};

struct sched_group_capacity;

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	int id;
	long unsigned int cpumask[0];
};

struct em_perf_state {
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
};

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	int milliwatts;
	long unsigned int cpus[0];
};

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_USER = 1,
	CONTEXT_GUEST = 2,
};

struct kernel_cpustat {
	u64 cpustat[10];
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int success;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int: 32;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	long unsigned int caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct rt_prio_array {
	long unsigned int bitmap[4];
	struct list_head queue[100];
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	int: 32;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
	int: 32;
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	int: 32;
	u64 dl_runtime;
	u64 dl_period;
};

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_h_nr_running;
	int: 32;
	u64 exec_clock;
	u64 min_vruntime;
	u64 min_vruntime_copy;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	unsigned int nr_spread_over;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_avg avg;
	u64 load_last_update_time_copy;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	} removed;
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	long unsigned int rt_nr_migratory;
	long unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	int: 32;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
	int: 32;
};

struct dl_rq {
	struct rb_root_cached root;
	long unsigned int dl_nr_running;
	int: 32;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	long unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct rq {
	raw_spinlock_t lock;
	unsigned int nr_running;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	int: 32;
	u64 nr_switches;
	int: 32;
	int: 32;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	long unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	int: 32;
	u64 clock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	struct callback_head *balance_callback;
	unsigned char balance_push;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	struct sched_avg avg_thermal;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	long unsigned int calc_load_update;
	long int calc_load_active;
	int: 32;
	int: 32;
	int: 32;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
	unsigned int clock_update_flags;
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_DOUBLE_TICK = 7,
	__SCHED_FEAT_NONTASK_CAPACITY = 8,
	__SCHED_FEAT_TTWU_QUEUE = 9,
	__SCHED_FEAT_SIS_AVG_CPU = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 12,
	__SCHED_FEAT_RT_PUSH_IPI = 13,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 14,
	__SCHED_FEAT_LB_MIN = 15,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 16,
	__SCHED_FEAT_WA_IDLE = 17,
	__SCHED_FEAT_WA_WEIGHT = 18,
	__SCHED_FEAT_WA_BIAS = 19,
	__SCHED_FEAT_UTIL_EST = 20,
	__SCHED_FEAT_UTIL_EST_FASTUP = 21,
	__SCHED_FEAT_NR = 22,
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct set_affinity_pending {
	refcount_t refs;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_SHARE_CPUCAPACITY = 64,
	SD_SHARE_PKG_RESOURCES = 128,
	SD_SERIALIZE = 256,
	SD_ASYM_PACKING = 512,
	SD_PREFER_SIBLING = 1024,
	SD_OVERLAP = 2048,
	SD_NUMA = 4096,
};

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
	int: 32;
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

struct cfs_bandwidth {};

enum schedutil_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_asym_packing = 3,
	group_imbalanced = 4,
	group_overloaded = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	long unsigned int group_misfit_task_load;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct task_group;

typedef struct rt_rq *rt_rq_iter_t;

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct sd_flag_debug {
	unsigned int meta_flags;
	char *name;
};

struct sched_domain_attr {
	int relax_domain_level;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	int: 32;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
	int: 8;
	int: 32;
};

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	int: 32;
	u64 last_update;
	long unsigned int util;
	long unsigned int bw_dl;
	long unsigned int max;
	long unsigned int saved_idle_calls;
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

enum mutex_trylock_recursive_enum {
	MUTEX_TRYLOCK_FAILED = 0,
	MUTEX_TRYLOCK_SUCCESS = 1,
	MUTEX_TRYLOCK_RECURSIVE = 2,
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum writer_wait_state {
	WRITER_NOT_FIRST = 0,
	WRITER_FIRST = 1,
	WRITER_HANDOFF = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
	int: 32;
};

struct rt_mutex_waiter {
	struct rb_node tree_entry;
	struct rb_node pi_tree_entry;
	struct task_struct *task;
	struct rt_mutex *lock;
	int prio;
	int: 32;
	u64 deadline;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	enum suspend_stat_step failed_steps[2];
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct sysrq_key_op {
	void (* const handler)(int);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	void *data;
	struct console *next;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool active;
	bool registered;
	u32 cur_idx;
	u32 next_idx;
	int: 32;
	u64 cur_seq;
	u64 next_seq;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

enum desc_state {
	desc_miss = 4294967295,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum log_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

struct devkmsg_user {
	u64 seq;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
	struct printk_info info;
	char text_buf[8192];
	struct printk_record record;
	int: 32;
};

struct printk_safe_seq_buf {
	atomic_t len;
	atomic_t message_lost;
	struct irq_work work;
	unsigned char buffer[8172];
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 3072,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQF_MODIFY_MASK = 2096911,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

struct arch_msi_msg_addr_lo {
	u32 address_lo;
};

typedef struct arch_msi_msg_addr_lo arch_msi_msg_addr_lo_t;

struct arch_msi_msg_addr_hi {
	u32 address_hi;
};

typedef struct arch_msi_msg_addr_hi arch_msi_msg_addr_hi_t;

struct arch_msi_msg_data {
	u32 data;
};

typedef struct arch_msi_msg_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct platform_msi_priv_data;

struct platform_msi_desc {
	struct platform_msi_priv_data *msi_priv_data;
	u16 msi_index;
};

struct fsl_mc_msi_desc {
	u16 msi_index;
};

struct ti_sci_inta_msi_desc {
	u16 dev_index;
};

struct msi_desc {
	struct list_head list;
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	union {
		struct {
			u32 masked;
			struct {
				u8 is_msix: 1;
				u8 multiple: 3;
				u8 multi_cap: 3;
				u8 maskbit: 1;
				u8 is_64: 1;
				u8 is_virtual: 1;
				u16 entry_nr;
				unsigned int default_irq;
			} msi_attrib;
			union {
				u8 mask_pos;
				void *mask_base;
			};
		};
		struct platform_msi_desc platform;
		struct fsl_mc_msi_desc fsl_mc;
		struct ti_sci_inta_msi_desc inta;
	};
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irq_generic_chip_devres {
	struct irq_chip_generic *gc;
	u32 msk;
	unsigned int clr;
	unsigned int set;
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct msi_alloc_info {
	struct msi_desc *desc;
	irq_hw_number_t hwirq;
	long unsigned int flags;
	union {
		long unsigned int ul;
		void *ptr;
	} scratchpad[2];
};

typedef struct msi_alloc_info msi_alloc_info_t;

struct msi_domain_info;

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*msi_finish)(msi_alloc_info_t *, int);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*handle_error)(struct irq_domain *, struct msi_desc *, int);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
};

struct msi_domain_info {
	u32 flags;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_MULTI_PCI_MSI = 4,
	MSI_FLAG_PCI_MSIX = 8,
	MSI_FLAG_ACTIVATE_EARLY = 16,
	MSI_FLAG_MUST_REACTIVATE = 32,
	MSI_FLAG_LEVEL_CAPABLE = 64,
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

typedef void (*rcu_callback_t)(struct callback_head *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_future_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long int gp_seq_req;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period_init {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	u8 level;
	int grplo;
	int grphi;
	long unsigned int qsmask;
	char __data[0];
};

struct trace_event_raw_rcu_exp_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gpseq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_exp_funnel_lock {
	struct trace_entry ent;
	const char *rcuname;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_preempt_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_unlock_preempted_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_quiescent_state_report {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long unsigned int mask;
	long unsigned int qsmask;
	u8 level;
	int grplo;
	int grphi;
	u8 gp_tasks;
	char __data[0];
};

struct trace_event_raw_rcu_fqs {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int cpu;
	const char *qsevent;
	char __data[0];
};

struct trace_event_raw_rcu_dyntick {
	struct trace_entry ent;
	const char *polarity;
	long int oldnesting;
	long int newnesting;
	int dynticks;
	char __data[0];
};

struct trace_event_raw_rcu_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_batch_start {
	struct trace_entry ent;
	const char *rcuname;
	long int qlen;
	long int blimit;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kfree_bulk_callback {
	struct trace_entry ent;
	const char *rcuname;
	long unsigned int nr_records;
	void **p;
	char __data[0];
};

struct trace_event_raw_rcu_batch_end {
	struct trace_entry ent;
	const char *rcuname;
	int callbacks_invoked;
	char cb;
	char nr;
	char iit;
	char risk;
	char __data[0];
};

struct trace_event_raw_rcu_torture_read {
	struct trace_entry ent;
	char rcutorturename[8];
	struct callback_head *rhp;
	long unsigned int secs;
	long unsigned int c_old;
	long unsigned int c;
	char __data[0];
};

struct trace_event_raw_rcu_barrier {
	struct trace_entry ent;
	const char *rcuname;
	const char *s;
	int cpu;
	int cnt;
	long unsigned int done;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_grace_period {};

struct trace_event_data_offsets_rcu_future_grace_period {};

struct trace_event_data_offsets_rcu_grace_period_init {};

struct trace_event_data_offsets_rcu_exp_grace_period {};

struct trace_event_data_offsets_rcu_exp_funnel_lock {};

struct trace_event_data_offsets_rcu_preempt_task {};

struct trace_event_data_offsets_rcu_unlock_preempted_task {};

struct trace_event_data_offsets_rcu_quiescent_state_report {};

struct trace_event_data_offsets_rcu_fqs {};

struct trace_event_data_offsets_rcu_dyntick {};

struct trace_event_data_offsets_rcu_callback {};

struct trace_event_data_offsets_rcu_kvfree_callback {};

struct trace_event_data_offsets_rcu_batch_start {};

struct trace_event_data_offsets_rcu_invoke_callback {};

struct trace_event_data_offsets_rcu_invoke_kvfree_callback {};

struct trace_event_data_offsets_rcu_invoke_kfree_bulk_callback {};

struct trace_event_data_offsets_rcu_batch_end {};

struct trace_event_data_offsets_rcu_torture_read {};

struct trace_event_data_offsets_rcu_barrier {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_future_grace_period)(void *, const char *, long unsigned int, long unsigned int, u8, int, int, const char *);

typedef void (*btf_trace_rcu_grace_period_init)(void *, const char *, long unsigned int, u8, int, int, long unsigned int);

typedef void (*btf_trace_rcu_exp_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_exp_funnel_lock)(void *, const char *, u8, int, int, const char *);

typedef void (*btf_trace_rcu_preempt_task)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_rcu_unlock_preempted_task)(void *, const char *, long unsigned int, int);

typedef void (*btf_trace_rcu_quiescent_state_report)(void *, const char *, long unsigned int, long unsigned int, long unsigned int, u8, int, int, int);

typedef void (*btf_trace_rcu_fqs)(void *, const char *, long unsigned int, int, const char *);

typedef void (*btf_trace_rcu_dyntick)(void *, const char *, long int, long int, int);

typedef void (*btf_trace_rcu_callback)(void *, const char *, struct callback_head *, long int);

typedef void (*btf_trace_rcu_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int, long int);

typedef void (*btf_trace_rcu_batch_start)(void *, const char *, long int, long int);

typedef void (*btf_trace_rcu_invoke_callback)(void *, const char *, struct callback_head *);

typedef void (*btf_trace_rcu_invoke_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int);

typedef void (*btf_trace_rcu_invoke_kfree_bulk_callback)(void *, const char *, long unsigned int, void **);

typedef void (*btf_trace_rcu_batch_end)(void *, const char *, int, char, char, char, char);

typedef void (*btf_trace_rcu_torture_read)(void *, const char *, struct callback_head *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_rcu_barrier)(void *, const char *, const char *, int, int, long unsigned int);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)();

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

struct rcu_tasks {
	struct callback_head *cbs_head;
	struct callback_head **cbs_tail;
	struct wait_queue_head cbs_wq;
	raw_spinlock_t cbs_lock;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int n_gps;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	char *name;
	char *kname;
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

typedef long unsigned int ulong;

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int ofl_seq;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	int: 32;
	raw_spinlock_t fqslock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool exp_deferred_qs;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
	atomic_t dynticks;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[1];
	struct rcu_node *level[2];
	int ncpus;
	int n_online_cpus;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u8 boost;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	raw_spinlock_t ofl_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct kvfree_rcu_bulk_data {
	long unsigned int nr_records;
	struct kvfree_rcu_bulk_data *next;
	void *records[0];
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct kvfree_rcu_bulk_data *bkvhead_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	struct kvfree_rcu_bulk_data *bkvhead[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool monitor_todo;
	bool initialized;
	int count;
	struct work_struct page_cache_work;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

enum swiotlb_force {
	SWIOTLB_NORMAL = 0,
	SWIOTLB_FORCE = 1,
	SWIOTLB_NO_FORCE = 2,
};

enum dma_sync_target {
	SYNC_FOR_CPU = 0,
	SYNC_FOR_DEVICE = 1,
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct reserved_mem_ops;

struct reserved_mem {
	const char *name;
	long unsigned int fdt_node;
	long unsigned int phandle;
	const struct reserved_mem_ops *ops;
	phys_addr_t base;
	phys_addr_t size;
	void *priv;
};

struct reserved_mem_ops {
	int (*device_init)(struct reserved_mem *, struct device *);
	void (*device_release)(struct reserved_mem *, struct device *);
};

typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

struct dma_coherent_mem {
	void *virt_base;
	dma_addr_t device_base;
	long unsigned int pfn_base;
	int size;
	long unsigned int *bitmap;
	spinlock_t spinlock;
	bool use_dev_dma_pfn_offset;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_suseconds_t suseconds_t;

typedef __kernel_clock_t clock_t;

typedef __u64 timeu64_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	int: 32;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	int: 32;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	int: 32;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
	int: 32;
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	int: 32;
	s64 now;
	void *function;
	char __data[0];
	int: 32;
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	int: 32;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	long unsigned int pending_map[16];
	struct hlist_head vectors[512];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
	int: 32;
};

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct tk_read_base {
	struct clocksource *clock;
	int: 32;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	int: 32;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	int: 24;
	int: 32;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
	int: 32;
};

struct audit_ntp_data {};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_latch_t seq;
	int: 32;
	struct tk_read_base base[2];
};

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
	int: 32;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	int uie_unsupported;
	long unsigned int set_offset_nsec;
	int: 32;
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
	int: 24;
	int: 32;
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	int: 27;
	int: 32;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	int: 32;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	int: 32;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
	int: 32;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	int: 32;
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	int: 32;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

typedef __kernel_timer_t timer_t;

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
	int: 32;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	int: 32;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	int: 32;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[13];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

typedef unsigned int uint;

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

typedef s64 int64_t;

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

struct clock_read_data {
	u64 epoch_ns;
	u64 epoch_cyc;
	u64 sched_clock_mask;
	u64 (*read_sched_clock)();
	u32 mult;
	u32 shift;
	int: 32;
};

struct clock_data {
	seqcount_latch_t seq;
	int: 32;
	struct clock_read_data read_data[2];
	ktime_t wrap_kt;
	long unsigned int rate;
	u64 (*actual_read_sched_clock)();
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	int: 32;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

typedef bool (*smp_cond_func_t)(int, void *);

struct call_function_data {
	call_single_data_t *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

typedef short unsigned int __kernel_uid_t;

typedef short unsigned int __kernel_gid_t;

typedef __kernel_uid_t __kernel_old_uid_t;

typedef __kernel_gid_t __kernel_old_gid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef __kernel_old_gid_t old_gid_t;

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
	WILL_BE_GPL_ONLY = 2,
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
	bool unused;
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int flags: 8;
	int: 6;
	int: 32;
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf32_Ehdr *hdr;
	long unsigned int len;
	Elf32_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug *debug;
	unsigned int num_debug;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[128];
	char module_name[60];
	int exported;
	int show_value;
};

struct elf_note_section {
	struct elf32_note n_hdr;
	u8 n_data[0];
};

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[18];

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

typedef u32 note_buf_t[45];

typedef __kernel_ulong_t __kernel_ino_t;

typedef __kernel_ino_t ino_t;

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

struct static_key_true {
	struct static_key key;
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	MAX_BPF_LINK_TYPE = 7,
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	int: 32;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
			int: 32;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
			int: 32;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
	};
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_CPUSET_V2_MODE = 16,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 32,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 64,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int id;
	int level;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_id;
	int dst_level;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int id;
	int level;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_memory_localevents = 1,
	Opt_memory_recursiveprot = 2,
	nr__cgroup2_params = 3,
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	long unsigned int caller;
	cpu_stop_fn_t fn;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct action_cache {
	long unsigned int allow_native[14];
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct ctl_path {
	const char *procname;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	int: 32;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
	int: 32;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	int ret;
	struct completion completion;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

enum {
	TRACE_FTRACE_BIT = 0,
	TRACE_FTRACE_NMI_BIT = 1,
	TRACE_FTRACE_IRQ_BIT = 2,
	TRACE_FTRACE_SIRQ_BIT = 3,
	TRACE_INTERNAL_BIT = 4,
	TRACE_INTERNAL_NMI_BIT = 5,
	TRACE_INTERNAL_IRQ_BIT = 6,
	TRACE_INTERNAL_SIRQ_BIT = 7,
	TRACE_BRANCH_BIT = 8,
	TRACE_IRQ_BIT = 9,
	TRACE_GRAPH_BIT = 10,
	TRACE_GRAPH_DEPTH_START_BIT = 11,
	TRACE_GRAPH_DEPTH_END_BIT = 12,
	TRACE_GRAPH_NOTRACE_BIT = 13,
	TRACE_TRANSITION_BIT = 14,
	TRACE_RECORD_RECURSION_BIT = 15,
};

enum {
	TRACE_CTX_NMI = 0,
	TRACE_CTX_IRQ = 1,
	TRACE_CTX_SOFTIRQ = 2,
	TRACE_CTX_NORMAL = 3,
};

enum {
	FTRACE_OPS_FL_ENABLED = 1,
	FTRACE_OPS_FL_DYNAMIC = 2,
	FTRACE_OPS_FL_SAVE_REGS = 4,
	FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED = 8,
	FTRACE_OPS_FL_RECURSION = 16,
	FTRACE_OPS_FL_STUB = 32,
	FTRACE_OPS_FL_INITIALIZED = 64,
	FTRACE_OPS_FL_DELETED = 128,
	FTRACE_OPS_FL_ADDING = 256,
	FTRACE_OPS_FL_REMOVING = 512,
	FTRACE_OPS_FL_MODIFYING = 1024,
	FTRACE_OPS_FL_ALLOC_TRAMP = 2048,
	FTRACE_OPS_FL_IPMODIFY = 4096,
	FTRACE_OPS_FL_PID = 8192,
	FTRACE_OPS_FL_RCU = 16384,
	FTRACE_OPS_FL_TRACE_ARRAY = 32768,
	FTRACE_OPS_FL_PERMANENT = 65536,
	FTRACE_OPS_FL_DIRECT = 131072,
};

struct ftrace_hash {
	long unsigned int size_bits;
	struct hlist_head *buckets;
	long unsigned int count;
	long unsigned int flags;
	struct callback_head rcu;
};

struct ftrace_func_entry {
	struct hlist_node hlist;
	long unsigned int ip;
	long unsigned int direct;
};

enum ftrace_bug_type {
	FTRACE_BUG_UNKNOWN = 0,
	FTRACE_BUG_INIT = 1,
	FTRACE_BUG_NOP = 2,
	FTRACE_BUG_CALL = 3,
	FTRACE_BUG_UPDATE = 4,
};

enum {
	FTRACE_FL_ENABLED = 2147483648,
	FTRACE_FL_REGS = 1073741824,
	FTRACE_FL_REGS_EN = 536870912,
	FTRACE_FL_TRAMP = 268435456,
	FTRACE_FL_TRAMP_EN = 134217728,
	FTRACE_FL_IPMODIFY = 67108864,
	FTRACE_FL_DISABLED = 33554432,
	FTRACE_FL_DIRECT = 16777216,
	FTRACE_FL_DIRECT_EN = 8388608,
};

enum {
	FTRACE_UPDATE_CALLS = 1,
	FTRACE_DISABLE_CALLS = 2,
	FTRACE_UPDATE_TRACE_FUNC = 4,
	FTRACE_START_FUNC_RET = 8,
	FTRACE_STOP_FUNC_RET = 16,
	FTRACE_MAY_SLEEP = 32,
};

enum {
	FTRACE_UPDATE_IGNORE = 0,
	FTRACE_UPDATE_MAKE_CALL = 1,
	FTRACE_UPDATE_MODIFY_CALL = 2,
	FTRACE_UPDATE_MAKE_NOP = 3,
};

enum {
	FTRACE_ITER_FILTER = 1,
	FTRACE_ITER_NOTRACE = 2,
	FTRACE_ITER_PRINTALL = 4,
	FTRACE_ITER_DO_PROBES = 8,
	FTRACE_ITER_PROBE = 16,
	FTRACE_ITER_MOD = 32,
	FTRACE_ITER_ENABLED = 64,
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	int: 32;
	u64 time_start;
	int cpu;
	int: 32;
};

struct trace_pid_list;

struct trace_options;

struct trace_array {
	struct list_head list;
	char *name;
	int: 32;
	struct array_buffer array_buffer;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file *enter_syscall_files[444];
	struct trace_event_file *exit_syscall_files[444];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	struct ftrace_ops *ops;
	struct trace_pid_list *function_pids;
	struct trace_pid_list *function_no_pids;
	struct list_head func_probes;
	struct list_head mod_trace;
	struct list_head mod_notrace;
	int function_enabled;
	int time_stamp_abs_ref;
	struct list_head hist_vars;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	int: 32;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	int ftrace_ignore_pid;
	bool ignore_pid;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_pid_list {
	int pid_max;
	long unsigned int *pids;
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct ftrace_mod_load {
	struct list_head list;
	char *func;
	char *module;
	int enable;
};

enum {
	FTRACE_HASH_FL_MOD = 1,
};

struct ftrace_func_command {
	struct list_head list;
	char *name;
	int (*func)(struct trace_array *, struct ftrace_hash *, char *, char *, char *, int);
};

struct ftrace_probe_ops {
	void (*func)(long unsigned int, long unsigned int, struct trace_array *, struct ftrace_probe_ops *, void *);
	int (*init)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *, void **);
	void (*free)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *);
	int (*print)(struct seq_file *, long unsigned int, struct ftrace_probe_ops *, void *);
};

typedef int (*ftrace_mapper_func)(void *);

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 22,
	TRACE_ITER_FUNCTION_BIT = 23,
	TRACE_ITER_FUNC_FORK_BIT = 24,
	TRACE_ITER_DISPLAY_GRAPH_BIT = 25,
	TRACE_ITER_STACKTRACE_BIT = 26,
	TRACE_ITER_LAST_BIT = 27,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum {
	FTRACE_MODIFY_ENABLE_FL = 1,
	FTRACE_MODIFY_MAY_SLEEP_FL = 2,
};

struct ftrace_func_probe {
	struct ftrace_probe_ops *probe_ops;
	struct ftrace_ops ops;
	struct trace_array *tr;
	struct list_head list;
	void *data;
	int ref;
};

struct ftrace_page {
	struct ftrace_page *next;
	struct dyn_ftrace *records;
	int index;
	int size;
};

struct ftrace_rec_iter {
	struct ftrace_page *pg;
	int index;
};

struct ftrace_iterator {
	loff_t pos;
	loff_t func_pos;
	loff_t mod_pos;
	struct ftrace_page *pg;
	struct dyn_ftrace *func;
	struct ftrace_func_probe *probe;
	struct ftrace_func_entry *probe_entry;
	struct trace_parser parser;
	struct ftrace_hash *hash;
	struct ftrace_ops *ops;
	struct trace_array *tr;
	struct list_head *mod_list;
	int pidx;
	int idx;
	unsigned int flags;
	int: 32;
};

struct ftrace_glob {
	char *search;
	unsigned int len;
	int type;
};

struct ftrace_func_map {
	struct ftrace_func_entry entry;
	void *data;
};

struct ftrace_func_mapper {
	struct ftrace_hash hash;
};

enum graph_filter_type {
	GRAPH_FILTER_NOTRACE = 0,
	GRAPH_FILTER_FUNCTION = 1,
};

struct ftrace_graph_data {
	struct ftrace_hash *hash;
	struct ftrace_func_entry *entry;
	int idx;
	enum graph_filter_type type;
	struct ftrace_hash *new_hash;
	const struct seq_operations *seq_ops;
	struct trace_parser parser;
};

struct ftrace_mod_func {
	struct list_head list;
	char *name;
	long unsigned int ip;
	unsigned int size;
};

struct ftrace_mod_map {
	struct callback_head rcu;
	struct list_head list;
	struct module *mod;
	long unsigned int start_addr;
	long unsigned int end_addr;
	struct list_head funcs;
	unsigned int num_funcs;
};

struct ftrace_init_func {
	struct list_head list;
	long unsigned int ip;
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

typedef struct {
	atomic_long_t a;
} local_t;

struct ring_buffer_per_cpu;

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct trace_buffer___2 {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
	int: 32;
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
	int: 32;
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct rb_time_struct {
	local_t cnt;
	local_t top;
	local_t bottom;
};

typedef struct rb_time_struct rb_time_t;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer___2 *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 read_stamp;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
	int: 32;
};

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_PARENT = 1,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 2,
	FSNOTIFY_OBJ_TYPE_SB = 3,
	FSNOTIFY_OBJ_TYPE_COUNT = 4,
	FSNOTIFY_OBJ_TYPE_DETACHED = 4,
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_RAW_DATA = 16,
	__TRACE_LAST_TYPE = 17,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_PAUSE_ON_TRACE = 4194304,
	TRACE_ITER_FUNCTION = 8388608,
	TRACE_ITER_FUNC_FORK = 16777216,
	TRACE_ITER_DISPLAY_GRAPH = 33554432,
	TRACE_ITER_STACKTRACE = 67108864,
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
	int: 32;
};

struct err_info {
	const char **errs;
	u8 type;
	u8 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char cmd[256];
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct trace_print_flags_u64 {
	long long unsigned int mask;
	const char *name;
	int: 32;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
	int: 32;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
	int: 24;
	int: 32;
};

typedef int (*cmp_func_t)(const void *, const void *);

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

enum {
	TRACE_FUNC_OPT_STACK = 1,
};

struct ftrace_func_mapper___2;

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

struct ftrace_graph_ent {
	long unsigned int func;
	int depth;
};

struct ftrace_graph_ret {
	long unsigned int func;
	int depth;
	unsigned int overrun;
	long long unsigned int calltime;
	long long unsigned int rettime;
};

typedef void (*trace_func_graph_ret_t)(struct ftrace_graph_ret *);

typedef int (*trace_func_graph_ent_t)(struct ftrace_graph_ent *);

struct fgraph_ops {
	trace_func_graph_ent_t entryfunc;
	trace_func_graph_ret_t retfunc;
};

struct ftrace_graph_ent_entry {
	struct trace_entry ent;
	struct ftrace_graph_ent graph_ent;
};

struct ftrace_graph_ret_entry {
	struct trace_entry ent;
	struct ftrace_graph_ret ret;
};

struct fgraph_cpu_data {
	pid_t last_pid;
	int depth;
	int depth_irq;
	int ignore;
	long unsigned int enter_funcs[50];
};

struct fgraph_data {
	struct fgraph_cpu_data *cpu_data;
	struct ftrace_graph_ent_entry ent;
	struct ftrace_graph_ret_entry ret;
	int failed;
	int cpu;
};

enum {
	FLAGS_FILL_FULL = 268435456,
	FLAGS_FILL_START = 536870912,
	FLAGS_FILL_END = 805306368,
};

enum req_opf {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_SAME = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_SCSI_IN = 32,
	REQ_OP_SCSI_OUT = 33,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_CGROUP_PUNT = 22,
	__REQ_NOUNMAP = 23,
	__REQ_HIPRI = 24,
	__REQ_DRV = 25,
	__REQ_SWAP = 26,
	__REQ_NR_BITS = 27,
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

struct event_probe_data {
	struct trace_event_file *file;
	long unsigned int count;
	int ref;
	bool enable;
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	long unsigned int args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long int ret;
};

struct syscall_tp_t {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int ret;
};

struct syscall_tp_t___2 {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int args[6];
	int: 32;
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_MAX = 16777216,
	__PERF_SAMPLE_CALLCHAIN_EARLY = 0,
};

typedef long unsigned int perf_trace_t[512];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

typedef int (*filter_pred_fn_t)(struct filter_pred *, void *);

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_pred {
	filter_pred_fn_t fn;
	int: 32;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct function_filter_data {
	struct ftrace_ops *ops;
	int first_filter;
	int first_notrace;
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*func)(struct event_trigger_data *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_ops *, struct event_trigger_data *);
	void (*free)(struct event_trigger_ops *, struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_ops *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*func)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	__BPF_FUNC_MAX_ID = 163,
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_UNINIT_MAP_VALUE = 4,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 5,
	ARG_PTR_TO_MEM = 6,
	ARG_PTR_TO_MEM_OR_NULL = 7,
	ARG_PTR_TO_UNINIT_MEM = 8,
	ARG_CONST_SIZE = 9,
	ARG_CONST_SIZE_OR_ZERO = 10,
	ARG_PTR_TO_CTX = 11,
	ARG_PTR_TO_CTX_OR_NULL = 12,
	ARG_ANYTHING = 13,
	ARG_PTR_TO_SPIN_LOCK = 14,
	ARG_PTR_TO_SOCK_COMMON = 15,
	ARG_PTR_TO_INT = 16,
	ARG_PTR_TO_LONG = 17,
	ARG_PTR_TO_SOCKET = 18,
	ARG_PTR_TO_SOCKET_OR_NULL = 19,
	ARG_PTR_TO_BTF_ID = 20,
	ARG_PTR_TO_ALLOC_MEM = 21,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 22,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 23,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 24,
	ARG_PTR_TO_PERCPU_BTF_ID = 25,
	__BPF_ARG_TYPE_MAX = 26,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 3,
	RET_PTR_TO_SOCKET_OR_NULL = 4,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 5,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 6,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 7,
	RET_PTR_TO_BTF_ID_OR_NULL = 8,
	RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL = 9,
	RET_PTR_TO_MEM_OR_BTF_ID = 10,
	RET_PTR_TO_BTF_ID = 11,
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf *, const struct btf_type *, int, int, enum bpf_access_type, u32 *);
};

struct bpf_array_aux {
	enum bpf_prog_type type;
	bool jited;
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	int: 32;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef struct pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	int: 32;
	u8 data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

struct bpf_seq_printf_buf {
	char buf[768];
};

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_get_current_task_btf)();

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
	int: 32;
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(int, const char **);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct dynevent_arg {
	const char *str;
	char separator;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_MOD_BF = 17,
	FETCH_OP_LP_ARRAY = 18,
	FETCH_OP_END = 19,
	FETCH_NOP_SYMBOL = 20,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	int is_signed;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_BAD_ADDR_SUFFIX = 11,
	TP_ERR_NO_GROUP_NAME = 12,
	TP_ERR_GROUP_TOO_LONG = 13,
	TP_ERR_BAD_GROUP_NAME = 14,
	TP_ERR_NO_EVENT_NAME = 15,
	TP_ERR_EVENT_TOO_LONG = 16,
	TP_ERR_BAD_EVENT_NAME = 17,
	TP_ERR_RETVAL_ON_PROBE = 18,
	TP_ERR_BAD_STACK_NUM = 19,
	TP_ERR_BAD_ARG_NUM = 20,
	TP_ERR_BAD_VAR = 21,
	TP_ERR_BAD_REG_NAME = 22,
	TP_ERR_BAD_MEM_ADDR = 23,
	TP_ERR_BAD_IMM = 24,
	TP_ERR_IMMSTR_NO_CLOSE = 25,
	TP_ERR_FILE_ON_KPROBE = 26,
	TP_ERR_BAD_FILE_OFFS = 27,
	TP_ERR_SYM_ON_UPROBE = 28,
	TP_ERR_TOO_MANY_OPS = 29,
	TP_ERR_DEREF_NEED_BRACE = 30,
	TP_ERR_BAD_DEREF_OFFS = 31,
	TP_ERR_DEREF_OPEN_BRACE = 32,
	TP_ERR_COMM_CANT_DEREF = 33,
	TP_ERR_BAD_FETCH_ARG = 34,
	TP_ERR_ARRAY_NO_CLOSE = 35,
	TP_ERR_BAD_ARRAY_SUFFIX = 36,
	TP_ERR_BAD_ARRAY_NUM = 37,
	TP_ERR_ARRAY_TOO_BIG = 38,
	TP_ERR_BAD_TYPE = 39,
	TP_ERR_BAD_STRING = 40,
	TP_ERR_BAD_BITFIELD = 41,
	TP_ERR_ARG_NAME_TOO_LONG = 42,
	TP_ERR_NO_ARG_NAME = 43,
	TP_ERR_BAD_ARG_NAME = 44,
	TP_ERR_USED_ARG_NAME = 45,
	TP_ERR_ARG_TOO_LONG = 46,
	TP_ERR_NO_ARG_BODY = 47,
	TP_ERR_BAD_INSN_BNDRY = 48,
	TP_ERR_FAIL_REG_PROBE = 49,
	TP_ERR_DIFF_PROBE_TYPE = 50,
	TP_ERR_DIFF_ARG_TYPE = 51,
	TP_ERR_SAME_PROBE = 52,
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	int: 32;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	int: 32;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	int: 32;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef int (*dynevent_check_arg_fn_t)(void *);

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int nhit;
	struct trace_probe tp;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct rhash_lock_head *buckets[0];
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct rhash_lock_head {};

struct zero_copy_allocator;

struct page_pool;

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
		struct zero_copy_allocator *zc_alloc;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
	int: 32;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_tracing_link {
	struct bpf_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
	int: 32;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
	int: 32;
};

struct audit_buffer;

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	u32 used_map_cnt;
	u32 id_gen;
	bool allow_ptr_leaks;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	int: 32;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct bpf_map *map_ptr;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		u32 mem_size;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
	};
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
	int: 24;
	int: 32;
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
};

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
	int: 32;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
	};
	int: 32;
	u64 map_key_state;
	int ctx_field_size;
	int sanitize_stack_off;
	u32 seen;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	MAX_BTF_SOCK_TYPE = 13,
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	int regno;
	int access_size;
	int mem_size;
	int: 32;
	u64 msize_max_value;
	int ref_obj_id;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum {
	AT_PKT_END = 4294967295,
	BEYOND_PKT_END = 4294967294,
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

struct idpair {
	u32 old;
	u32 cur;
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct umd_info {
	const char *driver_name;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct path wd;
	struct pid *tgid;
};

struct bpf_preload_info {
	char link_name[16];
	int link_id;
};

struct bpf_preload_ops {
	struct umd_info info;
	int (*preload)(struct bpf_preload_info *);
	int (*finish)();
	struct module *owner;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_ktime_get_coarse_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long int *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, long unsigned int *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	int: 32;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	int: 24;
	int: 32;
	u8 target_private[0];
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	int: 32;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	raw_spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bucket {
	struct hlist_nulls_head head;
	union {
		raw_spinlock_t raw_lock;
		spinlock_t lock;
	};
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bucket *buckets;
	void *elems;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	atomic_t count;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	int: 32;
	int: 32;
	int: 32;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct bpf_htab *htab;
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		struct callback_head rcu;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t spinlock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int consumer_pos;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int producer_pos;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

struct bpf_tramp_progs {
	struct bpf_prog *progs[40];
	int nr_progs;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_var {
	__u32 linkage;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__u32 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
	int: 32;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
	int: 32;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	int: 32;
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sk_lookup {
	union {
		struct bpf_sock *sk;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__u32 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	void *data;
	void *data_end;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	unsigned int count;
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct inet_listen_hashbucket listening_hash[32];
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
	int: 32;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
	int: 32;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	int: 8;
	int: 32;
	u64 temp;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	int: 32;
	u64 tmp_reg;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	s32 retval;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	bool no_reuseport;
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	s32 delivered;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy;
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, va_list);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	int: 32;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	int: 32;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	int: 32;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	int: 32;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	int: 32;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
	__ctx_convert_unused = 28,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	u32 image_off;
	struct bpf_ksym ksym;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	unsigned int count;
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_hwtstamps {
	ktime_t hwtstamp;
};

struct skb_shared_info {
	__u8 __unused;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	int: 32;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	void *destructor_arg;
	skb_frag_t frags[17];
	int: 32;
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int size;
	int batch;
	void **queue;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	atomic_t refcnt;
	struct callback_head rcu;
	struct work_struct kthread_stop_wq;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct bpf_local_storage_data sdata;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	int: 32;
	u64 idx_usage_counts[16];
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
	int: 32;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u64 Elf64_Off;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

typedef struct elf32_note Elf32_Nhdr;

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	int: 32;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct stack_map_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

struct bpf_prog_list {
	struct list_head node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
	u16 mru;
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_prog **progs;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct tcp_congestion_ops data;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_MAX = 262144,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_MAX = 16,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_MAX = 21,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	struct work_struct work;
	int page_order;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct *task;
	int: 32;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_cgroup_event {
	char *path;
	int path_size;
	struct {
		struct perf_event_header header;
		u64 id;
		char path[0];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	int: 32;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	unsigned int *tsk_pinned;
	unsigned int flexible;
};

struct bp_busy_slots {
	unsigned int pinned;
	unsigned int flexible;
};

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
	int: 32;
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	long unsigned int *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page *pages[2];
	long unsigned int vaddr;
};

typedef long unsigned int vm_flags_t;

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct page_vma_mapped_walk {
	struct page *page;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct mmu_notifier_range {
	long unsigned int start;
	long unsigned int end;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
	bool alloc_contig;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct map_info {
	struct map_info *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = 4294967295,
	RSEQ_CPU_ID_REGISTRATION_FAILED = 4294967294,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rseq_ip_fixup {};

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	int: 32;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

struct pkcs7_message;

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
};

typedef int __kernel_rwf_t;

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

struct vm_event_state {
	long unsigned int event[67];
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_THP_SUPPORT = 6,
};

struct wait_page_key {
	struct page *page;
	int bit_nr;
	int page_match;
};

enum iter_type {
	ITER_IOVEC = 4,
	ITER_KVEC = 8,
	ITER_BVEC = 16,
	ITER_PIPE = 32,
	ITER_DISCARD = 64,
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page *pages[15];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct page *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct page *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects max;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[1];
};

struct kmem_cache_cpu {
	void **freelist;
	long unsigned int tid;
	struct page *page;
	struct page *partial;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_SWAP_HIGH = 5,
	MEMCG_SWAP_MAX = 6,
	MEMCG_SWAP_FAIL = 7,
	MEMCG_NR_MEMORY_EVENTS = 8,
};

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_gather {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum wb_congested_state {
	WB_async_congested = 0,
	WB_sync_congested = 1,
};

enum {
	XA_CHECK_SCHED = 4096,
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum {
	BLK_RW_ASYNC = 0,
	BLK_RW_SYNC = 1,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

struct wb_domain {
	spinlock_t lock;
	int: 32;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);

struct dirty_throttle_control {
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

typedef void compound_page_dtor(struct page *);

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	int lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct page *, int);

typedef void (*btf_trace_mm_lru_activate)(void *, struct page *);

struct lru_rotate {
	local_lock_t lock;
	struct pagevec pvec;
};

struct lru_pvecs {
	local_lock_t lock;
	struct pagevec lru_add;
	struct pagevec lru_deactivate_file;
	struct pagevec lru_deactivate;
	struct pagevec lru_lazyfree;
	struct pagevec activate_page;
};

typedef struct {
	long unsigned int val;
} swp_entry_t;

enum lruvec_flags {
	LRUVEC_CONGESTED = 0,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

enum ttu_flags {
	TTU_MIGRATION = 1,
	TTU_MUNLOCK = 2,
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
	TTU_SPLIT_FREEZE = 256,
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_TYPES = 7,
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	gfp_t gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	isolate_mode_t isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_writepage {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_inactive_list_is_low {
	struct trace_entry ent;
	int nid;
	int reclaim_idx;
	long unsigned int total_inactive;
	long unsigned int inactive;
	long unsigned int total_active;
	long unsigned int active;
	long unsigned int ratio;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_writepage {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_inactive_list_is_low {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_writepage)(void *, struct page *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_inactive_list_is_low)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum page_references {
	PAGEREF_RECLAIM = 0,
	PAGEREF_RECLAIM_CLEAN = 1,
	PAGEREF_KEEP = 2,
	PAGEREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
	int: 32;
};

struct xattr;

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct constant_table {
	const char *name;
	int value;
};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct shared_policy {};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	int: 32;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	int: 32;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_CACHE = 1,
	SGP_NOHUGE = 2,
	SGP_HUGE = 3,
	SGP_WRITE = 4,
	SGP_FALLOC = 5,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);

typedef void (*pcpu_fc_free_fn_t)(void *, size_t);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, bool, bool, size_t, size_t, void *, int, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

enum pcpu_chunk_type {
	PCPU_CHUNK_ROOT = 0,
	PCPU_NR_CHUNK_TYPES = 1,
	PCPU_FAIL_ALLOC = 1,
};

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	int start_offset;
	int end_offset;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

struct obj_cgroup;

struct trace_event_raw_kmem_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_kmem_alloc_node {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kmem_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	gfp_t gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_alloc {};

struct trace_event_data_offsets_kmem_alloc_node {};

struct trace_event_data_offsets_kmem_free {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmalloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int, long int);

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name[3];
	unsigned int size;
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	gfp_t gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, long unsigned int, int, struct list_head *);

typedef void (*btf_trace_mm_compaction_begin)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct trace_event_raw_mmap_lock_start_locking {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_raw_mmap_lock_released {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_data_offsets_mmap_lock_start_locking {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_acquire_returned {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_released {
	u32 memcg_path;
};

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, const char *, bool, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, const char *, bool);

struct page_address_map {
	struct page *page;
	void *virtual;
	struct list_head list;
};

struct page_address_slot {
	struct list_head lh;
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct {
	u64 val;
} pfn_t;

typedef unsigned int pgtbl_mod_mask;

struct zap_details {
	struct address_space *check_mapping;
	long unsigned int first_index;
	long unsigned int last_index;
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_VALID = 8192,
	SWP_SCANNING = 16384,
};

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct hstate {};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_data_offsets_vm_unmapped_area {};

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

struct mmap_arg_struct {
	long unsigned int addr;
	long unsigned int len;
	long unsigned int prot;
	long unsigned int flags;
	long unsigned int fd;
	long unsigned int offset;
};

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
};

struct rmap_walk_control {
	void *arg;
	bool (*rmap_one)(struct page *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct page *);
	struct anon_vma * (*anon_lock)(struct page *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct page_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
	};
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

typedef int fpi_t;

struct pcpu_drain {
	struct zone *zone;
	struct work_struct work;
};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_WORKINGSET = 3,
	BIO_QUIET = 4,
	BIO_CHAIN = 5,
	BIO_REFFED = 6,
	BIO_THROTTLED = 7,
	BIO_TRACE_COMPLETION = 8,
	BIO_CGROUP_ACCT = 9,
	BIO_TRACKED = 10,
	BIO_FLAG_LAST = 11,
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t ptes[8];
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	int: 32;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

struct track {
	long unsigned int addr;
	long unsigned int addrs[16];
	int cpu;
	int pid;
	long unsigned int when;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

struct detached_freelist {
	struct page *page;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct location {
	long unsigned int count;
	long unsigned int addr;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[1];
	nodemask_t nodes;
};

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FULL = 2,
	M_FREE = 3,
};

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page *b_page;
	int: 32;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

typedef struct page *new_page_t(struct page *, long unsigned int);

typedef void free_page_t(struct page *, long unsigned int);

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

struct cma {
	long unsigned int base_pfn;
	long unsigned int count;
	long unsigned int *bitmap;
	unsigned int order_per_bit;
	struct mutex lock;
	char name[64];
};

struct trace_event_raw_cma_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	const struct page *page;
	unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	long unsigned int pfn;
	const struct page *page;
	unsigned int count;
	char __data[0];
};

struct trace_event_data_offsets_cma_alloc {};

struct trace_event_data_offsets_cma_release {};

typedef void (*btf_trace_cma_alloc)(void *, long unsigned int, const struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_cma_release)(void *, long unsigned int, const struct page *, unsigned int);

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

typedef __kernel_rwf_t rwf_t;

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

struct kobj_map;

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	long unsigned int st_dev;
	long unsigned int st_ino;
	short unsigned int st_mode;
	short unsigned int st_nlink;
	short unsigned int st_uid;
	short unsigned int st_gid;
	long unsigned int st_rdev;
	long unsigned int st_size;
	long unsigned int st_blksize;
	long unsigned int st_blocks;
	long unsigned int st_atime;
	long unsigned int st_atime_nsec;
	long unsigned int st_mtime;
	long unsigned int st_mtime_nsec;
	long unsigned int st_ctime;
	long unsigned int st_ctime_nsec;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct stat64 {
	long long unsigned int st_dev;
	unsigned char __pad0[4];
	long unsigned int __st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	long unsigned int st_uid;
	long unsigned int st_gid;
	long long unsigned int st_rdev;
	unsigned char __pad3[4];
	int: 32;
	long long int st_size;
	long unsigned int st_blksize;
	int: 32;
	long long unsigned int st_blocks;
	long unsigned int st_atime;
	long unsigned int st_atime_nsec;
	long unsigned int st_mtime;
	long unsigned int st_mtime_nsec;
	long unsigned int st_ctime;
	long unsigned int st_ctime_nsec;
	long long unsigned int st_ino;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u64 __spare2;
	__u64 __spare3[12];
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	int: 32;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	union {
		const char * const *native;
	} ptr;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[36];
	int: 32;
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	kuid_t dir_uid;
	umode_t dir_mode;
	int: 16;
	int: 32;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	int: 32;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
	int: 32;
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	int: 32;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
	int: 8;
	int: 32;
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[32];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[18];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct sel_arg_struct {
	long unsigned int n;
	fd_set *inp;
	fd_set *outp;
	fd_set *exp;
	struct __kernel_old_timeval *tvp;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_page_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_congest_waited_template {
	struct trace_entry ent;
	unsigned int usec_timeout;
	unsigned int usec_delayed;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_page_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_congest_waited_template {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_page)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_wait_on_page_writeback)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_congestion_wait)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_wait_iff_congested)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
	int: 24;
	int: 32;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	__kernel_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__u32 f_type;
	__u32 f_bsize;
	__u32 f_blocks;
	__u32 f_bfree;
	__u32 f_bavail;
	__u32 f_files;
	__u32 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
};

struct statfs64 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
};

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

typedef struct ns_common *ns_get_path_helper_t(void *);

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

struct dax_device;

struct iomap_page_ops;

struct iomap___2 {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int, struct iomap___2 *);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *, struct iomap___2 *);
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

struct decrypt_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
	int: 32;
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	bool multi_bio: 1;
	bool should_dirty: 1;
	bool is_sync: 1;
	struct bio bio;
};

struct bd_holder_disk {
	struct list_head list;
	struct gendisk *disk;
	int refcnt;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	int: 32;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	int: 32;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	int: 32;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
	int: 32;
};

struct dio {
	int flags;
	int op;
	int op_flags;
	blk_qc_t bio_cookie;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct page *page;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	int: 32;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	unsigned int use_writepage;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	int: 32;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
	int: 32;
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	int: 32;
	struct inode vfs_inode;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	struct mutex mark_mutex;
	atomic_t num_marks;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[4];
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignored_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
	long unsigned int objectid;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct epoll_event {
	__poll_t events;
	int: 32;
	__u64 data;
};

struct epoll_filefd {
	struct file *file;
	int fd;
};

struct epitem;

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source *ws;
	int: 32;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	unsigned int napi_id;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	int: 32;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		atomic_t reqs_available;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool done;
	bool cancelled;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct eventfd_ctx___2;

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx___2 *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 consumed;
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	bool eventfd;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	int fd;
	char __data[0];
};

struct io_wq_work;

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	int rw;
	void *req;
	struct io_wq_work *work;
	unsigned int flags;
	char __data[0];
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work {
	struct io_wq_work_node list;
	struct io_identity *identity;
	unsigned int flags;
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *req;
	void *link;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	int: 32;
	u64 user_data;
	long int res;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_submit_sqe {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	bool force_nonblock;
	bool sq_thread;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	int events;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_wake {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_task_run {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	char __data[0];
};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_queue_async_work {};

struct trace_event_data_offsets_io_uring_defer {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_fail_link {};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_submit_sqe {};

struct trace_event_data_offsets_io_uring_poll_arm {};

struct trace_event_data_offsets_io_uring_poll_wake {};

struct trace_event_data_offsets_io_uring_task_add {};

struct trace_event_data_offsets_io_uring_task_run {};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, bool, long int);

typedef void (*btf_trace_io_uring_file_get)(void *, void *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, void *, int, void *, struct io_wq_work *, unsigned int);

typedef void (*btf_trace_io_uring_defer)(void *, void *, void *, long long unsigned int);

typedef void (*btf_trace_io_uring_link)(void *, void *, void *, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, void *, void *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, u64, long int);

typedef void (*btf_trace_io_uring_submit_sqe)(void *, void *, u8, u64, bool, bool);

typedef void (*btf_trace_io_uring_poll_arm)(void *, void *, u8, u64, int, int);

typedef void (*btf_trace_io_uring_poll_wake)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_add)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_run)(void *, void *, u8, u64);

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
	};
	__u64 user_data;
	union {
		struct {
			union {
				__u16 buf_index;
				__u16 buf_group;
			};
			__u16 personality;
			__s32 splice_fd_in;
		};
		__u64 __pad2[3];
	};
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
};

enum {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_LAST = 37,
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
};

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 resv2;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_LAST = 13,
};

struct io_uring_files_update {
	__u32 offset;
	__u32 resv;
	__u64 fds;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad;
	__u64 ts;
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_NO_CANCEL = 8,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_WORK_FILES = 32,
	IO_WQ_WORK_FS = 64,
	IO_WQ_WORK_MM = 128,
	IO_WQ_WORK_CREDS = 256,
	IO_WQ_WORK_BLKCG = 512,
	IO_WQ_WORK_FSIZE = 1024,
	IO_WQ_HASH_SHIFT = 24,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

typedef void free_work_fn(struct io_wq_work *);

typedef struct io_wq_work *io_wq_work_fn(struct io_wq_work *);

struct io_wq_data {
	struct user_struct *user;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_uring {
	u32 head;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 tail;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	u32 sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct io_uring_cqe cqes[0];
};

struct io_mapped_ubuf {
	u64 ubuf;
	size_t len;
	struct bio_vec *bvec;
	unsigned int nr_bvecs;
	long unsigned int acct_pages;
};

struct fixed_file_table {
	struct file **files;
};

struct fixed_file_data;

struct fixed_file_ref_node {
	struct percpu_ref refs;
	struct list_head node;
	struct list_head file_list;
	struct fixed_file_data *file_data;
	struct llist_node llist;
	bool done;
};

struct io_ring_ctx;

struct fixed_file_data {
	struct fixed_file_table *table;
	struct io_ring_ctx *ctx;
	struct fixed_file_ref_node *node;
	struct percpu_ref refs;
	struct completion done;
	struct list_head ref_list;
	spinlock_t lock;
};

struct io_wq;

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[2];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_sq_data;

struct io_kiocb;

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		unsigned int flags;
		unsigned int compat: 1;
		unsigned int limit_mem: 1;
		unsigned int cq_overflow_flushed: 1;
		unsigned int drain_next: 1;
		unsigned int eventfd_async: 1;
		unsigned int restricted: 1;
		unsigned int sqo_dead: 1;
		u32 *sq_array;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		unsigned int sq_mask;
		unsigned int sq_thread_idle;
		unsigned int cached_sq_dropped;
		unsigned int cached_cq_overflow;
		long unsigned int sq_check_overflow;
		struct list_head defer_list;
		struct list_head timeout_list;
		struct list_head cq_overflow_list;
		struct io_uring_sqe *sq_sqes;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct io_rings *rings;
	struct io_wq *io_wq;
	struct task_struct *sqo_task;
	struct mm_struct *mm_account;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	struct fixed_file_data *file_data;
	unsigned int nr_user_files;
	unsigned int nr_user_bufs;
	struct io_mapped_ubuf *user_bufs;
	struct user_struct *user;
	const struct cred *creds;
	struct completion ref_comp;
	struct completion sq_thread_comp;
	struct io_kiocb *fallback_req;
	struct socket *ring_sock;
	struct idr io_buffer_idr;
	struct idr personality_idr;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		unsigned int cq_mask;
		atomic_t cq_timeouts;
		unsigned int cq_last_tm_flush;
		long unsigned int cq_check_overflow;
		struct wait_queue_head cq_wait;
		struct fasync_struct *cq_fasync;
		struct eventfd_ctx___2 *cq_ev_fd;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		struct mutex uring_lock;
		wait_queue_head_t wait;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		spinlock_t completion_lock;
		struct list_head iopoll_list;
		struct hlist_head *cancel_hash;
		unsigned int cancel_hash_bits;
		bool poll_multi_file;
		spinlock_t inflight_lock;
		struct list_head inflight_list;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct delayed_work file_put_work;
	struct llist_head file_put_llist;
	struct work_struct exit_work;
	struct io_restriction restrictions;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__s32 len;
	__u16 bid;
};

struct io_sq_data {
	refcount_t refs;
	struct mutex lock;
	struct list_head ctx_list;
	struct list_head ctx_new_list;
	struct mutex ctx_lock;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u64 len;
};

struct io_poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool done;
	bool canceled;
	struct wait_queue_entry wait;
};

struct io_poll_remove {
	struct file *file;
	int: 32;
	u64 addr;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	long unsigned int nofile;
};

struct io_sync {
	struct file *file;
	int: 32;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_cancel {
	struct file *file;
	int: 32;
	u64 addr;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	struct list_head list;
	struct io_kiocb *head;
};

struct io_timeout_rem {
	struct file *file;
	int: 32;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
	int: 32;
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
};

struct io_sr_msg {
	struct file *file;
	union {
		struct user_msghdr *umsg;
		void *buf;
	};
	int msg_flags;
	int bgid;
	size_t len;
	struct io_buffer *kbuf;
};

struct io_open {
	struct file *file;
	int dfd;
	bool ignore_nonblock;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
	int: 32;
};

struct io_close {
	struct file *file;
	struct file *put_file;
	int fd;
};

struct io_files_update {
	struct file *file;
	int: 32;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_fadvise {
	struct file *file;
	int: 32;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_madvise {
	struct file *file;
	int: 32;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_splice {
	struct file *file_out;
	struct file *file_in;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	unsigned int flags;
	int: 32;
};

struct io_provide_buf {
	struct file *file;
	int: 32;
	__u64 addr;
	__s32 len;
	__u32 bgid;
	__u16 nbufs;
	__u16 bid;
	int: 32;
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	const char *filename;
	struct statx *buffer;
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_completion {
	struct file *file;
	struct list_head list;
	int cflags;
};

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_rw rw;
		struct io_poll_iocb poll;
		struct io_poll_remove poll_remove;
		struct io_accept accept;
		struct io_sync sync;
		struct io_cancel cancel;
		struct io_timeout timeout;
		struct io_timeout_rem timeout_rem;
		struct io_connect connect;
		struct io_sr_msg sr_msg;
		struct io_open open;
		struct io_close close;
		struct io_files_update files_update;
		struct io_fadvise fadvise;
		struct io_madvise madvise;
		struct io_epoll epoll;
		struct io_splice splice;
		struct io_provide_buf pbuf;
		struct io_statx statx;
		struct io_shutdown shutdown;
		struct io_rename rename;
		struct io_unlink unlink;
		struct io_completion compl;
	};
	void *async_data;
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	u32 result;
	struct io_ring_ctx *ctx;
	unsigned int flags;
	refcount_t refs;
	struct task_struct *task;
	int: 32;
	u64 user_data;
	struct io_kiocb *link;
	struct percpu_ref *fixed_file_refs;
	struct list_head inflight_entry;
	struct callback_head task_work;
	struct hlist_node hash_node;
	struct async_poll *apoll;
	struct io_wq_work work;
};

struct io_timeout_data {
	struct io_kiocb *req;
	int: 32;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
	int: 32;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

struct io_async_msghdr {
	struct iovec fast_iov[8];
	struct iovec *iov;
	struct sockaddr *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_rw {
	struct iovec fast_iov[8];
	const struct iovec *free_iovec;
	struct iov_iter iter;
	size_t bytes_done;
	struct wait_page_queue wpq;
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_FAIL_LINK_BIT = 6,
	REQ_F_INFLIGHT_BIT = 7,
	REQ_F_CUR_POS_BIT = 8,
	REQ_F_NOWAIT_BIT = 9,
	REQ_F_LINK_TIMEOUT_BIT = 10,
	REQ_F_ISREG_BIT = 11,
	REQ_F_NEED_CLEANUP_BIT = 12,
	REQ_F_POLLED_BIT = 13,
	REQ_F_BUFFER_SELECTED_BIT = 14,
	REQ_F_NO_FILE_TABLE_BIT = 15,
	REQ_F_WORK_INITIALIZED_BIT = 16,
	REQ_F_LTIMEOUT_ACTIVE_BIT = 17,
	__REQ_F_LAST_BIT = 18,
};

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_FAIL_LINK = 64,
	REQ_F_INFLIGHT = 128,
	REQ_F_CUR_POS = 256,
	REQ_F_NOWAIT = 512,
	REQ_F_LINK_TIMEOUT = 1024,
	REQ_F_ISREG = 2048,
	REQ_F_NEED_CLEANUP = 4096,
	REQ_F_POLLED = 8192,
	REQ_F_BUFFER_SELECTED = 16384,
	REQ_F_NO_FILE_TABLE = 32768,
	REQ_F_WORK_INITIALIZED = 65536,
	REQ_F_LTIMEOUT_ACTIVE = 131072,
};

struct async_poll {
	struct io_poll_iocb poll;
	struct io_poll_iocb *double_poll;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_comp_state {
	unsigned int nr;
	struct list_head list;
	struct io_ring_ctx *ctx;
};

struct io_submit_state {
	struct blk_plug plug;
	void *reqs[8];
	unsigned int free_reqs;
	bool plug_started;
	struct io_comp_state comp;
	struct file *file;
	unsigned int fd;
	unsigned int file_refs;
	unsigned int ios_left;
};

struct io_op_def {
	unsigned int needs_file: 1;
	unsigned int needs_file_no_error: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int not_supported: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int buffer_select: 1;
	unsigned int needs_async_data: 1;
	unsigned int plug: 1;
	short unsigned int async_size;
	unsigned int work_flags;
};

enum io_mem_account {
	ACCT_LOCKED = 0,
	ACCT_PINNED = 1,
};

struct req_batch {
	void *reqs[8];
	int to_free;
	struct task_struct *task;
	int task_refs;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int error;
};

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int to_wait;
	unsigned int nr_timeouts;
};

struct io_file_put {
	struct list_head list;
	struct file *file;
};

struct io_task_cancel {
	struct task_struct *task;
	struct files_struct *files;
};

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

typedef bool work_cancel_fn(struct io_wq_work *, void *);

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_FIXED = 8,
	IO_WORKER_F_BOUND = 16,
};

enum {
	IO_WQ_BIT_EXIT = 0,
	IO_WQ_BIT_ERROR = 1,
};

enum {
	IO_WQE_FLAG_STALLED = 1,
};

struct io_wqe;

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wqe *wqe;
	struct io_wq_work *cur_work;
	spinlock_t lock;
	struct callback_head rcu;
	struct mm_struct *mm;
	const struct cred *cur_creds;
	const struct cred *saved_creds;
	struct files_struct *restore_files;
	struct nsproxy *restore_nsproxy;
	struct fs_struct *restore_fs;
};

struct io_wqe_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	atomic_t nr_running;
};

struct io_wq___2;

struct io_wqe {
	struct {
		raw_spinlock_t lock;
		struct io_wq_work_list work_list;
		long unsigned int hash_map;
		unsigned int flags;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	int node;
	struct io_wqe_acct acct[2];
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct io_wq___2 *wq;
	struct io_wq_work *hash_tail[32];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
};

struct io_wq___2 {
	struct io_wqe **wqes;
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct task_struct *manager;
	struct user_struct *user;
	refcount_t refs;
	struct completion done;
	struct hlist_node cpuhp_node;
	refcount_t use_refs;
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
	int: 32;
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	int: 32;
	loff_t li_pos;
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
};

struct arch_elf_state {};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	u32 e_referenced: 1;
	u32 e_reusable: 1;
	int: 30;
	int: 32;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

struct nfsacl_encode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
	int typeflag;
	kuid_t uid;
	kgid_t gid;
};

struct nfsacl_simple_acl {
	struct posix_acl acl;
	struct posix_acl_entry ace[4];
};

struct nfsacl_decode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		void *ptr[0];
	};
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	short unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	int owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct nfs4_state;

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
	int: 32;
};

struct rpc_rqst;

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct rpc_xprt;

struct rpc_task;

struct rpc_cred;

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
	struct list_head rq_bc_list;
	long unsigned int rq_bc_pa_state;
	struct list_head rq_bc_pa_list;
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_call_ops;

struct rpc_clnt;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	int tk_rpc_status;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	int: 32;
	ktime_t tk_start;
	pid_t tk_owner;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
	unsigned char tk_rebind_retry: 2;
	int: 8;
	int: 32;
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_switch;

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_auth;

struct rpc_stat;

struct rpc_iostats;

struct rpc_program;

struct rpc_clnt {
	atomic_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
};

struct rpc_xprt_ops;

struct svc_xprt;

struct svc_serv;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	struct svc_xprt *bc_xprt;
	struct svc_serv *bc_serv;
	unsigned int bc_alloc_max;
	unsigned int bc_alloc_count;
	atomic_t bc_slot_count;
	spinlock_t bc_pa_lock;
	struct list_head bc_pa_list;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

typedef u32 rpc_authflavor_t;

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_auth_create_args;

struct rpcsec_gss_info;

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	void (*prepare_request)(struct rpc_rqst *);
	int (*send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct callback_head xps_rcu;
};

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct rpc_version;

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = 4294967295,
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 len;
	char *label;
};

typedef struct {
	char data[8];
} nfs4_verifier;

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	__u32 xattr_support;
	int: 32;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	int: 32;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs4_change_info {
	u32 atomic;
	int: 32;
	u64 before;
	u64 after;
};

struct nfs4_slot;

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_open_context;

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	long unsigned int flags;
	int error;
	struct list_head list;
	struct nfs4_threshold *mdsthreshold;
	struct callback_head callback_head;
};

struct nlm_host;

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct nfs_client;

struct nfs_iostats;

struct pnfs_layoutdriver_type;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	atomic_long_t writeback;
	int flags;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int gxasize;
	unsigned int sxasize;
	unsigned int lxasize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	struct nfs_fsid fsid;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	struct ida openowner_id;
	struct ida lockowner_id;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
	int: 32;
};

struct nfs_rpc_ops;

struct nfs_subversion;

struct idmap;

struct nfs4_minor_version_ops;

struct nfs4_slot_table;

struct nfs4_session;

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	const char *cl_principal;
	struct list_head cl_ds_clients;
	int: 32;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	wait_queue_head_t cl_lock_waitq;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
	int: 32;
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			u32 *bitmask;
			enum nfs3_stable_how stable;
		};
	};
	int: 32;
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	int: 32;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
	int: 32;
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	int: 32;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	int: 32;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	int: 32;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	int: 32;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
	int: 32;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	__u64 prev_cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfs_readdir_arg {
	struct dentry *dentry;
	const struct cred *cred;
	__be32 *verf;
	int: 32;
	u64 cookie;
	struct page **pages;
	unsigned int page_len;
	bool plus;
	int: 24;
	int: 32;
};

struct nfs_readdir_res {
	__be32 *verf;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
	int: 32;
};

struct nfstime4 {
	u64 seconds;
	u32 nseconds;
	int: 32;
};

struct pnfs_commit_ops;

struct pnfs_ds_commit_info {
	struct list_head commits;
	unsigned int nwritten;
	unsigned int ncommitting;
	const struct pnfs_commit_ops *ops;
};

struct pnfs_layout_segment;

struct nfs_commit_info;

struct nfs_page;

struct pnfs_commit_ops {
	void (*setup_ds_info)(struct pnfs_ds_commit_info *, struct pnfs_layout_segment *);
	void (*release_ds_info)(struct pnfs_ds_commit_info *, struct inode *);
	int (*commit_pagelist)(struct inode *, struct list_head *, int, struct nfs_commit_info *);
	void (*mark_request_commit)(struct nfs_page *, struct pnfs_layout_segment *, struct nfs_commit_info *, u32);
	void (*clear_request_commit)(struct nfs_page *, struct nfs_commit_info *);
	int (*scan_commit_lists)(struct nfs_commit_info *, int);
	void (*recover_commit_reqs)(struct list_head *, struct nfs_commit_info *);
	struct nfs_page * (*search_commit_reqs)(struct nfs_commit_info *, struct page *);
};

struct nfs41_server_owner {
	uint64_t minor_id;
	uint32_t major_id_sz;
	char major_id[1024];
	int: 32;
};

struct nfs41_server_scope {
	uint32_t server_scope_sz;
	char server_scope[1024];
};

struct nfs41_impl_id {
	char domain[1025];
	char name[1025];
	int: 16;
	int: 32;
	struct nfstime4 date;
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_pgio_completion_ops;

struct nfs_rw_ops;

struct nfs_io_completion;

struct nfs_direct_req;

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
	int: 32;
};

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)();
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct nfs_commit_data;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	int: 32;
	struct nfs_fattr dir_attr;
	long int timeout;
	int: 32;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	int: 32;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
	int: 24;
	int: 32;
};

struct nlmclnt_operations;

struct nfs_access_entry;

struct nfs_client_initdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*access)(struct inode *, struct nfs_access_entry *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct page *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	const struct cred *cred;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_client_initdata {
	long unsigned int init_flags;
	const char *hostname;
	const struct sockaddr *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
};

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_mig_recovery_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs4_state_owner;

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs4_ssc_client_ops;

struct nfs_ssc_client_ops;

struct nfs_ssc_client_ops_tbl {
	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
	const struct nfs_ssc_client_ops *ssc_nfs_ops;
};

struct nfs4_ssc_client_ops {
	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
	void (*sco_close)(struct file *);
};

struct nfs_ssc_client_ops {
	void (*sco_sb_deactive)(struct super_block *);
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct inode *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	int: 32;
	struct nfs_seqid_counter so_seqid;
	seqcount_spinlock_t so_reclaim_seqcount;
	struct mutex so_delegreturn_mutex;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	int nr_pages;
	char __data[0];
	int: 32;
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	loff_t size;
	long unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_apply {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	loff_t pos;
	loff_t length;
	unsigned int flags;
	const void *ops;
	void *actor;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_apply {};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_releasepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_invalidatepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_apply_dstmap)(void *, struct inode *, struct iomap___2 *);

typedef void (*btf_trace_iomap_apply_srcmap)(void *, struct inode *, struct iomap___2 *);

typedef void (*btf_trace_iomap_apply)(void *, struct inode *, loff_t, loff_t, unsigned int, const void *, void *, long unsigned int);

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap___2 *, struct iomap___2 *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap___2 *);
};

typedef loff_t (*iomap_actor_t)(struct inode *, loff_t, loff_t, void *, struct iomap___2 *, struct iomap___2 *);

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	int: 32;
	loff_t io_offset;
	void *io_private;
	struct bio *io_bio;
	struct bio io_inline_bio;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_page)(struct page *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap___2 iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

struct iomap_page {
	atomic_t read_bytes_pending;
	atomic_t write_bytes_pending;
	spinlock_t uptodate_lock;
	long unsigned int uptodate[0];
};

struct iomap_readpage_ctx {
	struct page *cur_page;
	bool cur_page_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

enum {
	IOMAP_WRITE_F_UNSHARE = 1,
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	blk_qc_t (*submit_io)(struct inode *, struct iomap___2 *, struct bio *, loff_t);
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct request_queue *last_queue;
			blk_qc_t cookie;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct fiemap_ctx {
	struct fiemap_extent_info *fi;
	int: 32;
	struct iomap___2 prev;
};

struct iomap_swapfile_info {
	struct iomap___2 iomap;
	struct swap_info_struct *sis;
	int: 32;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *tail_vma;
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_locked;
	u64 swap_pss;
	bool check_shmem_swap;
	int: 24;
	int: 32;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

struct clear_refs_private {
	enum clear_refs_types type;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct seq_net_private {};

struct bpf_iter_aux_info___2;

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
	int: 32;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
};

struct kernfs_open_node {
	atomic_t refcnt;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	int (*commit_item)(struct config_item *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_buffer {
	size_t count;
	int: 32;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
	int: 32;
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_checkpoint_io_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__crt_ctx[0];
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_shash {
	unsigned int descsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	int: 32;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	int: 32;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__u32 s_padding[41];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct blockgroup_lock {
	struct bgl_lock locks[64];
};

struct fscrypt_dummy_policy {};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	int: 32;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
	int: 32;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	int: 32;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	int: 32;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	int: 32;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_state_flags;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	struct list_head i_orphan;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	int: 32;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct rw_semaphore i_mmap_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_reserved[95];
	__le32 s_checksum;
};

struct mb_cache___2;

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	int: 32;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	int: 32;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	int: 32;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct journal_s *s_journal;
	struct list_head s_orphan;
	struct mutex s_orphan_lock;
	long unsigned int s_ext4_flags;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *s_journal_bdev;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	long unsigned int s_stripe;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	spinlock_t s_bal_lock;
	long unsigned int s_mb_buddies_generated;
	long long unsigned int s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	atomic_t s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	int: 32;
	struct ext4_es_stats s_es_stats;
	struct mb_cache___2 *s_ea_block_cache;
	struct mb_cache___2 *s_ea_inode_cache;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t s_es_lock;
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	int: 32;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	int: 32;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	int: 32;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	int: 32;
	time64_t s_last_error_time;
	struct work_struct s_error_work;
	atomic_t s_fc_subtid;
	atomic_t s_fc_ineligible_updates;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	u64 s_fc_avg_commit_time;
	struct ext4_fc_replay_state s_fc_replay_state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	ext4_grpblk_t bb_largest_free_order;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct shash_desc {
	struct crypto_shash *tfm;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
	int: 32;
};

struct ext4_system_zone {
	struct rb_node node;
	int: 32;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_FC_REASON_OK = 0,
	EXT4_FC_REASON_INELIGIBLE = 1,
	EXT4_FC_REASON_ALREADY_COMMITTED = 2,
	EXT4_FC_REASON_FC_START_FAILED = 3,
	EXT4_FC_REASON_FC_FAILED = 4,
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_COMMIT_FAILED = 9,
	EXT4_FC_REASON_MAX = 10,
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	int: 32;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
	int: 32;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
	int: 32;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	atomic_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_MAY_INLINE_DATA = 7,
	EXT4_STATE_EXT_PRECACHED = 8,
	EXT4_STATE_LUSTRE_EA_INODE = 9,
	EXT4_STATE_VERITY_IN_PROGRESS = 10,
	EXT4_STATE_FC_COMMITTING = 11,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
	int: 32;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FS_ABORTED = 1,
	EXT4_MF_FC_INELIGIBLE = 2,
	EXT4_MF_FC_COMMITTING = 3,
};

struct fsverity_info;

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	int: 32;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
	int: 24;
	int: 32;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

typedef short unsigned int __kernel_mode_t;

typedef __kernel_mode_t mode_t;

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	int: 32;
	sector_t io_next_block;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
} ext4_iget_flags;

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	int: 32;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
	int: 30;
	int: 32;
};

struct fscrypt_info;

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	int: 32;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct ext4_new_group_data {
	__u32 group;
	int: 32;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
	int: 32;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	int: 32;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	__u16 ac_groups_scanned;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u16 ac_flags;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	int: 32;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct mmpd_data {
	struct buffer_head *bh;
	struct super_block *sb;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidatepage_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	int ret;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int: 32;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	int: 32;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	int: 32;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_put_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	ext4_fsblk_t start;
	char __data[0];
};

struct trace_event_raw_ext4_ext_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_find_delalloc_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	int reverse;
	int found;
	ext4_lblk_t found_blk;
	char __data[0];
};

struct trace_event_raw_ext4_get_reserved_cluster_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	int: 16;
	int: 32;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	int: 32;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	int: 32;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	struct ext4_sb_info *sbi;
	int count;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_create {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_link {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_unlink {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidatepage_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4_direct_IO_enter {};

struct trace_event_data_offsets_ext4_direct_IO_exit {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_put_in_cache {};

struct trace_event_data_offsets_ext4_ext_in_cache {};

struct trace_event_data_offsets_ext4_find_delalloc_range {};

struct trace_event_data_offsets_ext4_get_reserved_cluster_alloc {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_create {};

struct trace_event_data_offsets_ext4_fc_track_link {};

struct trace_event_data_offsets_ext4_fc_track_unlink {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_direct_IO_enter)(void *, struct inode *, loff_t, long unsigned int, int);

typedef void (*btf_trace_ext4_direct_IO_exit)(void *, struct inode *, loff_t, long unsigned int, int, int);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_put_in_cache)(void *, struct inode *, ext4_lblk_t, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_in_cache)(void *, struct inode *, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_find_delalloc_range)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, int, ext4_lblk_t);

typedef void (*btf_trace_ext4_get_reserved_cluster_alloc)(void *, struct inode *, ext4_lblk_t, unsigned int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, struct inode *, long int, long int, int);

struct ext4_err_translation {
	int code;
	int errno;
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32 = 10,
	Opt_debug = 11,
	Opt_removed = 12,
	Opt_user_xattr = 13,
	Opt_nouser_xattr = 14,
	Opt_acl = 15,
	Opt_noacl = 16,
	Opt_auto_da_alloc = 17,
	Opt_noauto_da_alloc = 18,
	Opt_noload = 19,
	Opt_commit = 20,
	Opt_min_batch_time = 21,
	Opt_max_batch_time = 22,
	Opt_journal_dev = 23,
	Opt_journal_path = 24,
	Opt_journal_checksum = 25,
	Opt_journal_async_commit = 26,
	Opt_abort = 27,
	Opt_data_journal = 28,
	Opt_data_ordered = 29,
	Opt_data_writeback = 30,
	Opt_data_err_abort = 31,
	Opt_data_err_ignore = 32,
	Opt_test_dummy_encryption = 33,
	Opt_inlinecrypt = 34,
	Opt_usrjquota = 35,
	Opt_grpjquota = 36,
	Opt_offusrjquota = 37,
	Opt_offgrpjquota = 38,
	Opt_jqfmt_vfsold = 39,
	Opt_jqfmt_vfsv0 = 40,
	Opt_jqfmt_vfsv1 = 41,
	Opt_quota = 42,
	Opt_noquota = 43,
	Opt_barrier = 44,
	Opt_nobarrier = 45,
	Opt_err___2 = 46,
	Opt_usrquota = 47,
	Opt_grpquota = 48,
	Opt_prjquota = 49,
	Opt_i_version = 50,
	Opt_dax = 51,
	Opt_dax_always = 52,
	Opt_dax_inode = 53,
	Opt_dax_never = 54,
	Opt_stripe = 55,
	Opt_delalloc = 56,
	Opt_nodelalloc = 57,
	Opt_warn_on_error = 58,
	Opt_nowarn_on_error = 59,
	Opt_mblk_io_submit = 60,
	Opt_lazytime = 61,
	Opt_nolazytime = 62,
	Opt_debug_want_extra_isize = 63,
	Opt_nomblk_io_submit = 64,
	Opt_block_validity = 65,
	Opt_noblock_validity = 66,
	Opt_inode_readahead_blks = 67,
	Opt_journal_ioprio = 68,
	Opt_dioread_nolock = 69,
	Opt_dioread_lock = 70,
	Opt_discard = 71,
	Opt_nodiscard = 72,
	Opt_init_itable = 73,
	Opt_noinit_itable = 74,
	Opt_max_dir_size_kb = 75,
	Opt_nojournal_checksum = 76,
	Opt_nombcache = 77,
	Opt_prefetch_block_bitmaps = 78,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_inode_readahead = 5,
	attr_trigger_test_error = 6,
	attr_first_error_time = 7,
	attr_last_error_time = 8,
	attr_feature = 9,
	attr_pointer_ui = 10,
	attr_pointer_ul = 11,
	attr_pointer_u64 = 12,
	attr_pointer_u8 = 13,
	attr_pointer_string = 14,
	attr_pointer_atomic = 15,
	attr_journal_task = 16,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	int: 32;
	struct qstr fcd_name;
	unsigned char fcd_iname[36];
	struct list_head fcd_list;
	int: 32;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
	int: 32;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	int: 32;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	int head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	int write_op;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, long unsigned int, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, long unsigned int, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct meta_entry {
	u64 data_block;
	unsigned int index_block;
	short unsigned int offset;
	short unsigned int pad;
};

struct meta_index {
	unsigned int inode_number;
	unsigned int offset;
	short unsigned int entries;
	short unsigned int skip;
	short unsigned int locked;
	short unsigned int pad;
	struct meta_entry meta_entry[127];
};

struct squashfs_cache_entry;

struct squashfs_cache {
	char *name;
	int entries;
	int curr_blk;
	int next_blk;
	int num_waiters;
	int unused;
	int block_size;
	int pages;
	spinlock_t lock;
	wait_queue_head_t wait_queue;
	struct squashfs_cache_entry *entry;
};

struct squashfs_page_actor;

struct squashfs_cache_entry {
	u64 block;
	int length;
	int refcount;
	u64 next_index;
	int pending;
	int error;
	int num_waiters;
	wait_queue_head_t wait_queue;
	struct squashfs_cache *cache;
	void **data;
	struct squashfs_page_actor *actor;
	int: 32;
};

struct squashfs_page_actor {
	void **page;
	int pages;
	int length;
	int next_page;
};

struct squashfs_decompressor;

struct squashfs_stream;

struct squashfs_sb_info {
	const struct squashfs_decompressor *decompressor;
	int devblksize;
	int devblksize_log2;
	struct squashfs_cache *block_cache;
	struct squashfs_cache *fragment_cache;
	struct squashfs_cache *read_page;
	int next_meta_index;
	__le64 *id_table;
	__le64 *fragment_index;
	__le64 *xattr_id_table;
	struct mutex meta_index_mutex;
	struct meta_index *meta_index;
	struct squashfs_stream *stream;
	__le64 *inode_lookup_table;
	u64 inode_table;
	u64 directory_table;
	u64 xattr_table;
	unsigned int block_size;
	short unsigned int block_log;
	long long int bytes_used;
	unsigned int inodes;
	unsigned int fragments;
	int xattr_ids;
	unsigned int ids;
};

struct squashfs_decompressor {
	void * (*init)(struct squashfs_sb_info *, void *);
	void * (*comp_opts)(struct squashfs_sb_info *, void *, int);
	void (*free)(void *);
	int (*decompress)(struct squashfs_sb_info *, void *, struct bio *, int, int, struct squashfs_page_actor *);
	int id;
	char *name;
	int supported;
};

struct squashfs_dir_index {
	__le32 index;
	__le32 start_block;
	__le32 size;
	unsigned char name[0];
};

struct squashfs_dir_entry {
	__le16 offset;
	__le16 inode_number;
	__le16 type;
	__le16 size;
	char name[0];
};

struct squashfs_dir_header {
	__le32 count;
	__le32 start_block;
	__le32 inode_number;
};

struct squashfs_inode_info {
	u64 start;
	int offset;
	int: 32;
	u64 xattr;
	unsigned int xattr_size;
	int xattr_count;
	union {
		struct {
			u64 fragment_block;
			int fragment_size;
			int fragment_offset;
			u64 block_list_start;
		};
		struct {
			u64 dir_idx_start;
			int dir_idx_offset;
			int dir_idx_cnt;
			int parent;
			int: 32;
		};
	};
	struct inode vfs_inode;
};

struct squashfs_fragment_entry {
	__le64 start_block;
	__le32 size;
	unsigned int unused;
};

struct squashfs_base_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
};

struct squashfs_ipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
};

struct squashfs_lipc_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 xattr;
};

struct squashfs_dev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
};

struct squashfs_ldev_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 rdev;
	__le32 xattr;
};

struct squashfs_symlink_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 symlink_size;
	char symlink[0];
};

struct squashfs_reg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 fragment;
	__le32 offset;
	__le32 file_size;
	__le16 block_list[0];
};

struct squashfs_lreg_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le64 start_block;
	__le64 file_size;
	__le64 sparse;
	__le32 nlink;
	__le32 fragment;
	__le32 offset;
	__le32 xattr;
	__le16 block_list[0];
};

struct squashfs_dir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 start_block;
	__le32 nlink;
	__le16 file_size;
	__le16 offset;
	__le32 parent_inode;
};

struct squashfs_ldir_inode {
	__le16 inode_type;
	__le16 mode;
	__le16 uid;
	__le16 guid;
	__le32 mtime;
	__le32 inode_number;
	__le32 nlink;
	__le32 file_size;
	__le32 start_block;
	__le32 parent_inode;
	__le16 i_count;
	__le16 offset;
	__le32 xattr;
	struct squashfs_dir_index index[0];
};

union squashfs_inode {
	struct squashfs_base_inode base;
	struct squashfs_dev_inode dev;
	struct squashfs_ldev_inode ldev;
	struct squashfs_symlink_inode symlink;
	struct squashfs_reg_inode reg;
	struct squashfs_lreg_inode lreg;
	struct squashfs_dir_inode dir;
	struct squashfs_ldir_inode ldir;
	struct squashfs_ipc_inode ipc;
	struct squashfs_lipc_inode lipc;
};

struct squashfs_xattr_id_table {
	__le64 xattr_table_start;
	__le32 xattr_ids;
	__le32 unused;
};

struct squashfs_stream {
	void *stream;
	struct mutex mutex;
};

struct squashfs_lzo {
	void *input;
	void *output;
};

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

struct xz_dec;

struct squashfs_xz {
	struct xz_dec *state;
	struct xz_buf buf;
};

struct disk_comp_opts {
	__le32 dictionary_size;
	__le32 flags;
};

struct comp_opts {
	int dict_size;
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
};

struct fatent_operations;

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct fat_entry;

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	int: 32;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	int: 32;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct inode vfs_inode;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
	int: 32;
};

typedef long long unsigned int llu;

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	int: 32;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct __una_u16 {
	u16 x;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

enum {
	Opt_check_n = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_uid___3 = 3,
	Opt_gid___4 = 4,
	Opt_umask = 5,
	Opt_dmask = 6,
	Opt_fmask = 7,
	Opt_allow_utime = 8,
	Opt_codepage = 9,
	Opt_usefree = 10,
	Opt_nocase = 11,
	Opt_quiet = 12,
	Opt_showexec = 13,
	Opt_debug___2 = 14,
	Opt_immutable = 15,
	Opt_dots = 16,
	Opt_nodots = 17,
	Opt_charset = 18,
	Opt_shortname_lower = 19,
	Opt_shortname_win95 = 20,
	Opt_shortname_winnt = 21,
	Opt_shortname_mixed = 22,
	Opt_utf8_no = 23,
	Opt_utf8_yes = 24,
	Opt_uni_xl_no = 25,
	Opt_uni_xl_yes = 26,
	Opt_nonumtail_no = 27,
	Opt_nonumtail_yes = 28,
	Opt_obsolete = 29,
	Opt_flush = 30,
	Opt_tz_utc = 31,
	Opt_rodir = 32,
	Opt_err_cont___2 = 33,
	Opt_err_panic___2 = 34,
	Opt_err_ro___2 = 35,
	Opt_discard___2 = 36,
	Opt_nfs = 37,
	Opt_time_offset = 38,
	Opt_nfs_stale_rw = 39,
	Opt_nfs_nostale_ro = 40,
	Opt_err___3 = 41,
	Opt_dos1xfloppy = 42,
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct in_addr {
	__be32 s_addr;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	short unsigned int flags;
	signed char priority;
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = 2147483654,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = 2147483904,
	XPRT_TRANSPORT_LOCAL = 257,
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct list_head xpt_ready;
	long unsigned int xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct svc_program;

struct svc_stat;

struct svc_pool;

struct svc_serv_ops;

struct svc_serv {
	struct svc_program *sv_program;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	unsigned int sv_nrthreads;
	unsigned int sv_maxconn;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	struct svc_pool *sv_pools;
	const struct svc_serv_ops *sv_ops;
	struct list_head sv_cb_list;
	spinlock_t sv_cb_lock;
	wait_queue_head_t sv_cb_waitq;
	bool sv_bc_enabled;
};

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_version;

struct svc_rqst;

struct svc_process_info;

struct svc_program {
	struct svc_program *pg_next;
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	struct svc_stat *pg_stats;
	int (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char *, size_t);
	ssize_t (*downcall)(struct file *, const char *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_iostats {
	spinlock_t om_lock;
	long unsigned int om_ops;
	long unsigned int om_ntrans;
	long unsigned int om_timeouts;
	long long unsigned int om_bytes_sent;
	long long unsigned int om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	long unsigned int om_error_status;
	int: 32;
};

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	long unsigned int flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
};

enum pnfs_iomode {
	IOMODE_READ = 1,
	IOMODE_RW = 2,
	IOMODE_ANY = 3,
};

struct nfs4_deviceid {
	char data[16];
};

struct gss_api_mech;

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct auth_domain;

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct auth_ops;

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct nfs4_xdr_opaque_data;

struct nfs4_xdr_opaque_ops {
	void (*encode)(struct xdr_stream *, const void *, const struct nfs4_xdr_opaque_data *);
	void (*free)(struct nfs4_xdr_opaque_data *);
};

struct nfs4_xdr_opaque_data {
	const struct nfs4_xdr_opaque_ops *ops;
	void *data;
};

struct nfs4_layoutdriver_data {
	struct page **pages;
	__u32 pglen;
	__u32 len;
};

struct pnfs_layout_range {
	u32 iomode;
	int: 32;
	u64 offset;
	u64 length;
};

struct nfs4_layoutget_res {
	struct nfs4_sequence_res seq_res;
	int status;
	__u32 return_on_close;
	struct pnfs_layout_range range;
	__u32 type;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data *layoutp;
	int: 32;
};

struct pnfs_device {
	struct nfs4_deviceid dev_id;
	unsigned int layout_type;
	unsigned int mincount;
	unsigned int maxcount;
	struct page **pages;
	unsigned int pgbase;
	unsigned int pglen;
	unsigned char nocache: 1;
};

struct nfs4_layoutcommit_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
	int: 32;
	__u64 lastbytewritten;
	struct inode *inode;
	const u32 *bitmask;
	size_t layoutupdate_len;
	struct page *layoutupdate_page;
	struct page **layoutupdate_pages;
	__be32 *start_p;
};

struct nfs4_layoutcommit_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	int status;
};

struct nfs4_layoutcommit_data {
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct list_head lseg_list;
	const struct cred *cred;
	struct inode *inode;
	struct nfs4_layoutcommit_args args;
	struct nfs4_layoutcommit_res res;
	int: 32;
};

struct pnfs_layout_hdr;

struct nfs4_layoutreturn_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_layout_hdr *layout;
	struct inode *inode;
	struct pnfs_layout_range range;
	nfs4_stateid stateid;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data *ld_private;
	int: 32;
};

struct pnfs_layout_hdr {
	refcount_t plh_refcount;
	atomic_t plh_outstanding;
	struct list_head plh_layouts;
	struct list_head plh_bulk_destroy;
	struct list_head plh_segs;
	struct list_head plh_return_segs;
	long unsigned int plh_block_lgets;
	long unsigned int plh_retry_timestamp;
	long unsigned int plh_flags;
	nfs4_stateid plh_stateid;
	u32 plh_barrier;
	u32 plh_return_seq;
	enum pnfs_iomode plh_return_iomode;
	int: 32;
	loff_t plh_lwb;
	const struct cred *plh_lc_cred;
	struct inode *plh_inode;
	struct callback_head plh_rcu;
};

struct nfs42_layoutstat_devinfo;

struct nfs42_layoutstat_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct inode *inode;
	nfs4_stateid stateid;
	int num_dev;
	struct nfs42_layoutstat_devinfo *devinfo;
};

struct nfs42_layoutstat_devinfo {
	struct nfs4_deviceid dev_id;
	__u64 offset;
	__u64 length;
	__u64 read_count;
	__u64 read_bytes;
	__u64 write_count;
	__u64 write_bytes;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data ld_private;
	int: 32;
};

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	long unsigned int pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

struct nfs_page {
	struct list_head wb_list;
	struct page *wb_page;
	struct nfs_lock_context *wb_lock_context;
	long unsigned int wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	long unsigned int wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	short unsigned int wb_nio;
};

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler **xattr;
	struct list_head list;
};

struct nfs_iostats {
	long long unsigned int bytes[8];
	long unsigned int events[27];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

struct nfs_pageio_ops;

struct nfs4_deviceid_node;

struct pnfs_layoutdriver_type {
	struct list_head pnfs_tblid;
	const u32 id;
	const char *name;
	struct module *owner;
	unsigned int flags;
	unsigned int max_deviceinfo_size;
	unsigned int max_layoutget_response;
	int (*set_layoutdriver)(struct nfs_server *, const struct nfs_fh *);
	int (*clear_layoutdriver)(struct nfs_server *);
	struct pnfs_layout_hdr * (*alloc_layout_hdr)(struct inode *, gfp_t);
	void (*free_layout_hdr)(struct pnfs_layout_hdr *);
	struct pnfs_layout_segment * (*alloc_lseg)(struct pnfs_layout_hdr *, struct nfs4_layoutget_res *, gfp_t);
	void (*free_lseg)(struct pnfs_layout_segment *);
	void (*add_lseg)(struct pnfs_layout_hdr *, struct pnfs_layout_segment *, struct list_head *);
	void (*return_range)(struct pnfs_layout_hdr *, struct pnfs_layout_range *);
	const struct nfs_pageio_ops *pg_read_ops;
	const struct nfs_pageio_ops *pg_write_ops;
	struct pnfs_ds_commit_info * (*get_ds_info)(struct inode *);
	int (*sync)(struct inode *, bool);
	enum pnfs_try_status (*read_pagelist)(struct nfs_pgio_header *);
	enum pnfs_try_status (*write_pagelist)(struct nfs_pgio_header *, int);
	void (*free_deviceid_node)(struct nfs4_deviceid_node *);
	struct nfs4_deviceid_node * (*alloc_deviceid_node)(struct nfs_server *, struct pnfs_device *, gfp_t);
	int (*prepare_layoutreturn)(struct nfs4_layoutreturn_args *);
	void (*cleanup_layoutcommit)(struct nfs4_layoutcommit_data *);
	int (*prepare_layoutcommit)(struct nfs4_layoutcommit_args *);
	int (*prepare_layoutstats)(struct nfs42_layoutstat_args *);
};

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct cache_deferred_req;

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	int thread_wait;
};

struct svc_cacherep;

struct svc_procedure;

struct svc_deferred_req;

struct svc_rqst {
	struct list_head rq_all;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	size_t rq_xprt_hlen;
	struct xdr_buf rq_arg;
	struct xdr_stream rq_arg_stream;
	struct page *rq_scratch_page;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	long unsigned int rq_flags;
	int: 32;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	void *rq_auth_data;
	int rq_auth_slack;
	int rq_reserved;
	int: 32;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct svc_cacherep *rq_cacherep;
	struct task_struct *rq_task;
	spinlock_t rq_lock;
	struct net *rq_bc_net;
	void **rq_lease_breaker;
	int: 32;
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	short unsigned int protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	long unsigned int flags;
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)();
	void (*flush)();
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	int (*accept)(struct svc_rqst *, __be32 *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	int (*set_client)(struct svc_rqst *);
};

struct svc_pool_stats {
	atomic_long_t packets;
	long unsigned int sockets_queued;
	atomic_long_t threads_woken;
	atomic_long_t threads_timedout;
};

struct svc_pool {
	unsigned int sp_id;
	spinlock_t sp_lock;
	struct list_head sp_sockets;
	unsigned int sp_nrthreads;
	struct list_head sp_all_threads;
	struct svc_pool_stats sp_stats;
	long unsigned int sp_flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct svc_serv_ops {
	void (*svo_shutdown)(struct svc_serv *, struct net *);
	int (*svo_function)(void *);
	void (*svo_enqueue_xprt)(struct svc_xprt *);
	int (*svo_setup)(struct svc_serv *, struct svc_pool *, int);
	struct module *svo_module;
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	int (*pc_decode)(struct svc_rqst *, __be32 *);
	int (*pc_encode)(struct svc_rqst *, __be32 *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	struct cache_deferred_req handle;
	size_t xprt_hlen;
	int argslen;
	__be32 args[0];
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *, __be32 *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	unsigned int *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *, __be32 *);
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_result_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_rqst)(struct svc_rqst *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_secure_port)(struct svc_rqst *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

struct nfs_pageio_descriptor;

struct nfs_pgio_mirror;

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
	struct nfs_pgio_mirror * (*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);
	u32 (*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	long unsigned int pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	short unsigned int pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	short unsigned int protofamily;
	short unsigned int mountfamily;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		short unsigned int protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		short unsigned int protocol;
		short unsigned int nconnect;
		short unsigned int export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

struct nfs4_deviceid_node {
	struct hlist_node node;
	struct hlist_node tmpnode;
	const struct pnfs_layoutdriver_type *ld;
	const struct nfs_client *nfs_client;
	long unsigned int flags;
	long unsigned int timestamp_unavailable;
	struct nfs4_deviceid deviceid;
	struct callback_head rcu;
	atomic_t ref;
};

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	short unsigned int nfs_callback_tcpport;
	short unsigned int nfs_callback_tcpport6;
	int cb_users[3];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct proc_dir_entry *proc_nfsfs;
	int: 32;
};

struct nfs_netns_client {
	struct kobject kobject;
	struct net *net;
	const char *identifier;
};

struct nfs_open_dir_context {
	struct list_head list;
	long unsigned int attr_gencount;
	__be32 verf[2];
	int: 32;
	__u64 dir_cookie;
	__u64 dup_cookie;
	signed char duped;
	int: 24;
	int: 32;
};

struct nfs4_cached_acl;

struct nfs_delegation;

struct nfs4_xattr_cache;

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	long unsigned int flags;
	long unsigned int cache_validity;
	long unsigned int read_cache_jiffies;
	long unsigned int attrtimeo;
	long unsigned int attrtimeo_timestamp;
	long unsigned int attr_gencount;
	long unsigned int cache_change_attribute;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	__be32 cookieverf[2];
	atomic_long_t nrequests;
	struct nfs_mds_commit_info commit_info;
	struct list_head open_files;
	struct rw_semaphore rmdir_sem;
	struct mutex commit_mutex;
	long unsigned int page_index;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	int: 32;
	__u64 write_io;
	__u64 read_io;
	struct inode vfs_inode;
	struct nfs4_xattr_cache *xattr_cache;
	int: 32;
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	long unsigned int pagemod_limit;
	int: 32;
	__u64 change_attr;
	long unsigned int flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
	int: 32;
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	const char *name;
	unsigned int name_len;
	unsigned char d_type;
	int: 24;
	int: 32;
};

struct nfs_cache_array {
	u64 last_cookie;
	unsigned int size;
	unsigned char page_full: 1;
	unsigned char page_is_eof: 1;
	unsigned char cookies_are_ordered: 1;
	struct nfs_cache_array_entry array[0];
};

struct nfs_readdir_descriptor {
	struct file *file;
	struct page *page;
	struct dir_context *ctx;
	long unsigned int page_index;
	u64 dir_cookie;
	u64 last_cookie;
	u64 dup_cookie;
	loff_t current_index;
	loff_t prev_index;
	__be32 verf[2];
	long unsigned int dir_verifier;
	long unsigned int timestamp;
	long unsigned int gencount;
	long unsigned int attr_gencount;
	unsigned int cache_entry_index;
	signed char duped;
	bool plus;
	bool eof;
};

enum layoutdriver_policy_flags {
	PNFS_LAYOUTRET_ON_SETATTR = 1,
	PNFS_LAYOUTRET_ON_ERROR = 2,
	PNFS_READ_WHOLE_PAGE = 4,
	PNFS_LAYOUTGET_ON_OPEN = 8,
};

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	long unsigned int generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	long unsigned int used_slots[32];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	long unsigned int generation;
	struct completion complete;
	long unsigned int slot_tbl_state;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	long unsigned int session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct nfs_mount_request {
	struct sockaddr *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	short unsigned int protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

struct pnfs_commit_bucket {
	struct list_head written;
	struct list_head committing;
	struct pnfs_layout_segment *lseg;
	struct nfs_writeverf direct_verf;
};

struct pnfs_commit_array {
	struct list_head cinfo_list;
	struct list_head lseg_list;
	struct pnfs_layout_segment *lseg;
	struct callback_head rcu;
	refcount_t refcount;
	unsigned int nbuckets;
	struct pnfs_commit_bucket buckets[0];
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	int: 32;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t bytes_left;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_CLEAN = 2,
	PG_COMMIT_TO_DS = 3,
	PG_INODE_REF = 4,
	PG_HEADLOCK = 5,
	PG_TEARDOWN = 6,
	PG_UNLOCKPAGE = 7,
	PG_UPTODATE = 8,
	PG_WB_END = 9,
	PG_REMOVE = 10,
	PG_CONTENDED1 = 11,
	PG_CONTENDED2 = 12,
};

struct nfs_readdesc {
	struct nfs_pageio_descriptor *pgio;
	struct nfs_open_context *ctx;
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum mountstat {
	MNT_OK = 0,
	MNT_EPERM = 1,
	MNT_ENOENT = 2,
	MNT_EACCES = 13,
	MNT_EINVAL = 22,
};

enum mountstat3 {
	MNT3_OK = 0,
	MNT3ERR_PERM = 1,
	MNT3ERR_NOENT = 2,
	MNT3ERR_IO = 5,
	MNT3ERR_ACCES = 13,
	MNT3ERR_NOTDIR = 20,
	MNT3ERR_INVAL = 22,
	MNT3ERR_NAMETOOLONG = 63,
	MNT3ERR_NOTSUPP = 10004,
	MNT3ERR_SERVERFAULT = 10006,
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_OPNOTSUPP = 45,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	long unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 old_dir;
	u32 __data_loc_old_name;
	int: 32;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int status;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	enum nfs3_stable_how stable;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int status;
	enum nfs3_stable_how stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	const void *req;
	long unsigned int index;
	unsigned int offset;
	unsigned int pgbase;
	unsigned int bytes;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int status;
	enum nfs3_stable_how stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_xdr_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	long unsigned int error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct trace_event_data_offsets_nfs_xdr_status {
	u32 program;
	u32 procedure;
};

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_page_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_page_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_rename)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_write_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

typedef s32 compat_int_t;

typedef u32 compat_uint_t;

typedef u32 compat_uptr_t;

struct nfs2_fh {
	char data[32];
};

struct nfs3_fh {
	short unsigned int size;
	unsigned char data[64];
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___2 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_fg = 12,
	Opt_fscache = 13,
	Opt_fscache_flag = 14,
	Opt_hard = 15,
	Opt_intr = 16,
	Opt_local_lock = 17,
	Opt_lock = 18,
	Opt_lookupcache = 19,
	Opt_migration = 20,
	Opt_minorversion = 21,
	Opt_mountaddr = 22,
	Opt_mounthost = 23,
	Opt_mountport = 24,
	Opt_mountproto = 25,
	Opt_mountvers = 26,
	Opt_namelen = 27,
	Opt_nconnect = 28,
	Opt_port = 29,
	Opt_posix = 30,
	Opt_proto = 31,
	Opt_rdirplus = 32,
	Opt_rdma = 33,
	Opt_resvport = 34,
	Opt_retrans = 35,
	Opt_retry = 36,
	Opt_rsize = 37,
	Opt_sec = 38,
	Opt_sharecache = 39,
	Opt_sloppy = 40,
	Opt_soft = 41,
	Opt_softerr = 42,
	Opt_softreval = 43,
	Opt_source = 44,
	Opt_tcp = 45,
	Opt_timeo = 46,
	Opt_udp = 47,
	Opt_v = 48,
	Opt_vers = 49,
	Opt_wsize = 50,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

struct nfs2_fsstat {
	__u32 tsize;
	__u32 bsize;
	__u32 blocks;
	__u32 bfree;
	__u32 bavail;
};

struct nfs_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
};

struct nfs_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs_readdirargs {
	struct nfs_fh *fh;
	__u32 cookie;
	unsigned int count;
	struct page **pages;
};

struct nfs_diropok {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs_createdata {
	struct nfs_createargs arg;
	struct nfs_diropok res;
	struct nfs_fh fhandle;
	int: 16;
	int: 32;
	struct nfs_fattr fattr;
};

enum nfs_ftype {
	NFNON = 0,
	NFREG = 1,
	NFDIR = 2,
	NFBLK = 3,
	NFCHR = 4,
	NFLNK = 5,
	NFSOCK = 6,
	NFBAD = 7,
	NFFIFO = 8,
};

enum nfs2_ftype {
	NF2NON = 0,
	NF2REG = 1,
	NF2DIR = 2,
	NF2BLK = 3,
	NF2CHR = 4,
	NF2LNK = 5,
	NF2SOCK = 6,
	NF2BAD = 7,
	NF2FIFO = 8,
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	int: 32;
	struct timespec64 guardtime;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	int: 32;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
	int: 32;
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	int: 16;
	int: 32;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

struct nfs3_getaclargs {
	struct nfs_fh *fh;
	int mask;
	struct page **pages;
};

struct nfs3_setaclargs {
	struct inode *inode;
	int mask;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
	size_t len;
	unsigned int npages;
	struct page **pages;
};

struct nfs3_getaclres {
	struct nfs_fattr *fattr;
	int mask;
	unsigned int acl_access_count;
	unsigned int acl_default_count;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
};

enum nfsstat4 {
	NFS4_OK = 0,
	NFS4ERR_PERM = 1,
	NFS4ERR_NOENT = 2,
	NFS4ERR_IO = 5,
	NFS4ERR_NXIO = 6,
	NFS4ERR_ACCESS = 13,
	NFS4ERR_EXIST = 17,
	NFS4ERR_XDEV = 18,
	NFS4ERR_NOTDIR = 20,
	NFS4ERR_ISDIR = 21,
	NFS4ERR_INVAL = 22,
	NFS4ERR_FBIG = 27,
	NFS4ERR_NOSPC = 28,
	NFS4ERR_ROFS = 30,
	NFS4ERR_MLINK = 31,
	NFS4ERR_NAMETOOLONG = 63,
	NFS4ERR_NOTEMPTY = 66,
	NFS4ERR_DQUOT = 69,
	NFS4ERR_STALE = 70,
	NFS4ERR_BADHANDLE = 10001,
	NFS4ERR_BAD_COOKIE = 10003,
	NFS4ERR_NOTSUPP = 10004,
	NFS4ERR_TOOSMALL = 10005,
	NFS4ERR_SERVERFAULT = 10006,
	NFS4ERR_BADTYPE = 10007,
	NFS4ERR_DELAY = 10008,
	NFS4ERR_SAME = 10009,
	NFS4ERR_DENIED = 10010,
	NFS4ERR_EXPIRED = 10011,
	NFS4ERR_LOCKED = 10012,
	NFS4ERR_GRACE = 10013,
	NFS4ERR_FHEXPIRED = 10014,
	NFS4ERR_SHARE_DENIED = 10015,
	NFS4ERR_WRONGSEC = 10016,
	NFS4ERR_CLID_INUSE = 10017,
	NFS4ERR_RESOURCE = 10018,
	NFS4ERR_MOVED = 10019,
	NFS4ERR_NOFILEHANDLE = 10020,
	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
	NFS4ERR_STALE_CLIENTID = 10022,
	NFS4ERR_STALE_STATEID = 10023,
	NFS4ERR_OLD_STATEID = 10024,
	NFS4ERR_BAD_STATEID = 10025,
	NFS4ERR_BAD_SEQID = 10026,
	NFS4ERR_NOT_SAME = 10027,
	NFS4ERR_LOCK_RANGE = 10028,
	NFS4ERR_SYMLINK = 10029,
	NFS4ERR_RESTOREFH = 10030,
	NFS4ERR_LEASE_MOVED = 10031,
	NFS4ERR_ATTRNOTSUPP = 10032,
	NFS4ERR_NO_GRACE = 10033,
	NFS4ERR_RECLAIM_BAD = 10034,
	NFS4ERR_RECLAIM_CONFLICT = 10035,
	NFS4ERR_BADXDR = 10036,
	NFS4ERR_LOCKS_HELD = 10037,
	NFS4ERR_OPENMODE = 10038,
	NFS4ERR_BADOWNER = 10039,
	NFS4ERR_BADCHAR = 10040,
	NFS4ERR_BADNAME = 10041,
	NFS4ERR_BAD_RANGE = 10042,
	NFS4ERR_LOCK_NOTSUPP = 10043,
	NFS4ERR_OP_ILLEGAL = 10044,
	NFS4ERR_DEADLOCK = 10045,
	NFS4ERR_FILE_OPEN = 10046,
	NFS4ERR_ADMIN_REVOKED = 10047,
	NFS4ERR_CB_PATH_DOWN = 10048,
	NFS4ERR_BADIOMODE = 10049,
	NFS4ERR_BADLAYOUT = 10050,
	NFS4ERR_BAD_SESSION_DIGEST = 10051,
	NFS4ERR_BADSESSION = 10052,
	NFS4ERR_BADSLOT = 10053,
	NFS4ERR_COMPLETE_ALREADY = 10054,
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
	NFS4ERR_BACK_CHAN_BUSY = 10057,
	NFS4ERR_LAYOUTTRYLATER = 10058,
	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
	NFS4ERR_NOMATCHING_LAYOUT = 10060,
	NFS4ERR_RECALLCONFLICT = 10061,
	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
	NFS4ERR_SEQ_MISORDERED = 10063,
	NFS4ERR_SEQUENCE_POS = 10064,
	NFS4ERR_REQ_TOO_BIG = 10065,
	NFS4ERR_REP_TOO_BIG = 10066,
	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
	NFS4ERR_RETRY_UNCACHED_REP = 10068,
	NFS4ERR_UNSAFE_COMPOUND = 10069,
	NFS4ERR_TOO_MANY_OPS = 10070,
	NFS4ERR_OP_NOT_IN_SESSION = 10071,
	NFS4ERR_HASH_ALG_UNSUPP = 10072,
	NFS4ERR_CLIENTID_BUSY = 10074,
	NFS4ERR_PNFS_IO_HOLE = 10075,
	NFS4ERR_SEQ_FALSE_RETRY = 10076,
	NFS4ERR_BAD_HIGH_SLOT = 10077,
	NFS4ERR_DEADSESSION = 10078,
	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
	NFS4ERR_PNFS_NO_LAYOUT = 10080,
	NFS4ERR_NOT_ONLY_OP = 10081,
	NFS4ERR_WRONG_CRED = 10082,
	NFS4ERR_WRONG_TYPE = 10083,
	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
	NFS4ERR_REJECT_DELEG = 10085,
	NFS4ERR_RETURNCONFLICT = 10086,
	NFS4ERR_DELEG_REVOKED = 10087,
	NFS4ERR_PARTNER_NOTSUPP = 10088,
	NFS4ERR_PARTNER_NO_AUTH = 10089,
	NFS4ERR_UNION_NOTSUPP = 10090,
	NFS4ERR_OFFLOAD_DENIED = 10091,
	NFS4ERR_WRONG_LFS = 10092,
	NFS4ERR_BADLABEL = 10093,
	NFS4ERR_OFFLOAD_NO_REQS = 10094,
	NFS4ERR_NOXATTR = 10095,
	NFS4ERR_XATTR2BIG = 10096,
};

enum nfs_ftype4 {
	NF4BAD = 0,
	NF4REG = 1,
	NF4DIR = 2,
	NF4BLK = 3,
	NF4CHR = 4,
	NF4LNK = 5,
	NF4SOCK = 6,
	NF4FIFO = 7,
	NF4ATTRDIR = 8,
	NF4NAMEDATTR = 9,
};

enum open_claim_type4 {
	NFS4_OPEN_CLAIM_NULL = 0,
	NFS4_OPEN_CLAIM_PREVIOUS = 1,
	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
	NFS4_OPEN_CLAIM_FH = 4,
	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5,
	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6,
};

enum createmode4 {
	NFS4_CREATE_UNCHECKED = 0,
	NFS4_CREATE_GUARDED = 1,
	NFS4_CREATE_EXCLUSIVE = 2,
	NFS4_CREATE_EXCLUSIVE4_1 = 3,
};

enum {
	NFSPROC4_CLNT_NULL = 0,
	NFSPROC4_CLNT_READ = 1,
	NFSPROC4_CLNT_WRITE = 2,
	NFSPROC4_CLNT_COMMIT = 3,
	NFSPROC4_CLNT_OPEN = 4,
	NFSPROC4_CLNT_OPEN_CONFIRM = 5,
	NFSPROC4_CLNT_OPEN_NOATTR = 6,
	NFSPROC4_CLNT_OPEN_DOWNGRADE = 7,
	NFSPROC4_CLNT_CLOSE = 8,
	NFSPROC4_CLNT_SETATTR = 9,
	NFSPROC4_CLNT_FSINFO = 10,
	NFSPROC4_CLNT_RENEW = 11,
	NFSPROC4_CLNT_SETCLIENTID = 12,
	NFSPROC4_CLNT_SETCLIENTID_CONFIRM = 13,
	NFSPROC4_CLNT_LOCK = 14,
	NFSPROC4_CLNT_LOCKT = 15,
	NFSPROC4_CLNT_LOCKU = 16,
	NFSPROC4_CLNT_ACCESS = 17,
	NFSPROC4_CLNT_GETATTR = 18,
	NFSPROC4_CLNT_LOOKUP = 19,
	NFSPROC4_CLNT_LOOKUP_ROOT = 20,
	NFSPROC4_CLNT_REMOVE = 21,
	NFSPROC4_CLNT_RENAME = 22,
	NFSPROC4_CLNT_LINK = 23,
	NFSPROC4_CLNT_SYMLINK = 24,
	NFSPROC4_CLNT_CREATE = 25,
	NFSPROC4_CLNT_PATHCONF = 26,
	NFSPROC4_CLNT_STATFS = 27,
	NFSPROC4_CLNT_READLINK = 28,
	NFSPROC4_CLNT_READDIR = 29,
	NFSPROC4_CLNT_SERVER_CAPS = 30,
	NFSPROC4_CLNT_DELEGRETURN = 31,
	NFSPROC4_CLNT_GETACL = 32,
	NFSPROC4_CLNT_SETACL = 33,
	NFSPROC4_CLNT_FS_LOCATIONS = 34,
	NFSPROC4_CLNT_RELEASE_LOCKOWNER = 35,
	NFSPROC4_CLNT_SECINFO = 36,
	NFSPROC4_CLNT_FSID_PRESENT = 37,
	NFSPROC4_CLNT_EXCHANGE_ID = 38,
	NFSPROC4_CLNT_CREATE_SESSION = 39,
	NFSPROC4_CLNT_DESTROY_SESSION = 40,
	NFSPROC4_CLNT_SEQUENCE = 41,
	NFSPROC4_CLNT_GET_LEASE_TIME = 42,
	NFSPROC4_CLNT_RECLAIM_COMPLETE = 43,
	NFSPROC4_CLNT_LAYOUTGET = 44,
	NFSPROC4_CLNT_GETDEVICEINFO = 45,
	NFSPROC4_CLNT_LAYOUTCOMMIT = 46,
	NFSPROC4_CLNT_LAYOUTRETURN = 47,
	NFSPROC4_CLNT_SECINFO_NO_NAME = 48,
	NFSPROC4_CLNT_TEST_STATEID = 49,
	NFSPROC4_CLNT_FREE_STATEID = 50,
	NFSPROC4_CLNT_GETDEVICELIST = 51,
	NFSPROC4_CLNT_BIND_CONN_TO_SESSION = 52,
	NFSPROC4_CLNT_DESTROY_CLIENTID = 53,
	NFSPROC4_CLNT_SEEK = 54,
	NFSPROC4_CLNT_ALLOCATE = 55,
	NFSPROC4_CLNT_DEALLOCATE = 56,
	NFSPROC4_CLNT_LAYOUTSTATS = 57,
	NFSPROC4_CLNT_CLONE = 58,
	NFSPROC4_CLNT_COPY = 59,
	NFSPROC4_CLNT_OFFLOAD_CANCEL = 60,
	NFSPROC4_CLNT_LOOKUPP = 61,
	NFSPROC4_CLNT_LAYOUTERROR = 62,
	NFSPROC4_CLNT_COPY_NOTIFY = 63,
	NFSPROC4_CLNT_GETXATTR = 64,
	NFSPROC4_CLNT_SETXATTR = 65,
	NFSPROC4_CLNT_LISTXATTRS = 66,
	NFSPROC4_CLNT_REMOVEXATTR = 67,
	NFSPROC4_CLNT_READ_PLUS = 68,
};

enum state_protect_how4 {
	SP4_NONE = 0,
	SP4_MACH_CRED = 1,
	SP4_SSV = 2,
};

enum pnfs_notify_deviceid_type4 {
	NOTIFY_DEVICEID4_CHANGE = 2,
	NOTIFY_DEVICEID4_DELETE = 4,
};

struct nfs4_op_map {
	union {
		long unsigned int longs[3];
		u32 words[3];
	} u;
};

struct nfs4_get_lease_time_args {
	struct nfs4_sequence_args la_seq_args;
};

struct nfs4_get_lease_time_res {
	struct nfs4_sequence_res lr_seq_res;
	struct nfs_fsinfo *lr_fsinfo;
};

struct nfs4_layoutget_args {
	struct nfs4_sequence_args seq_args;
	__u32 type;
	int: 32;
	struct pnfs_layout_range range;
	__u64 minlength;
	__u32 maxcount;
	struct inode *inode;
	struct nfs_open_context *ctx;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data layout;
	int: 32;
};

struct nfs4_layoutget {
	struct nfs4_layoutget_args args;
	struct nfs4_layoutget_res res;
	const struct cred *cred;
	gfp_t gfp_flags;
};

struct nfs4_getdeviceinfo_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_device *pdev;
	__u32 notify_types;
};

struct nfs4_getdeviceinfo_res {
	struct nfs4_sequence_res seq_res;
	struct pnfs_device *pdev;
	__u32 notification;
};

struct nfs4_layoutreturn_res {
	struct nfs4_sequence_res seq_res;
	u32 lrs_present;
	nfs4_stateid stateid;
};

struct nfs4_layoutreturn {
	struct nfs4_layoutreturn_args args;
	struct nfs4_layoutreturn_res res;
	const struct cred *cred;
	struct nfs_client *clp;
	struct inode *inode;
	int rpc_status;
	struct nfs4_xdr_opaque_data ld_private;
};

struct stateowner_id {
	__u64 create_time;
	__u32 uniquifier;
	int: 32;
};

struct nfs_openargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct nfs_seqid *seqid;
	int open_flags;
	fmode_t fmode;
	u32 share_access;
	u32 access;
	__u64 clientid;
	struct stateowner_id id;
	union {
		struct {
			struct iattr *attrs;
			nfs4_verifier verifier;
		};
		nfs4_stateid delegation;
		fmode_t delegation_type;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const u32 *bitmask;
	const u32 *open_bitmap;
	enum open_claim_type4 claim;
	enum createmode4 createmode;
	const struct nfs4_label *label;
	umode_t umask;
	struct nfs4_layoutget_args *lg_args;
};

struct nfs_openres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fh fh;
	struct nfs4_change_info cinfo;
	__u32 rflags;
	struct nfs_fattr *f_attr;
	struct nfs4_label *f_label;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	fmode_t delegation_type;
	nfs4_stateid delegation;
	long unsigned int pagemod_limit;
	__u32 do_recall;
	__u32 attrset[3];
	struct nfs4_string *owner;
	struct nfs4_string *group_owner;
	__u32 access_request;
	__u32 access_supported;
	__u32 access_result;
	struct nfs4_layoutget_res *lg_res;
};

struct nfs_open_confirmargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	nfs4_stateid *stateid;
	struct nfs_seqid *seqid;
};

struct nfs_open_confirmres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_closeargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
	fmode_t fmode;
	u32 share_access;
	u32 *bitmask;
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs_closeres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fattr *fattr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs_lowner {
	__u64 clientid;
	__u64 id;
	dev_t s_dev;
	int: 32;
};

struct nfs_lock_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *lock_seqid;
	nfs4_stateid lock_stateid;
	struct nfs_seqid *open_seqid;
	nfs4_stateid open_stateid;
	struct nfs_lowner lock_owner;
	unsigned char block: 1;
	unsigned char reclaim: 1;
	unsigned char new_lock: 1;
	unsigned char new_lock_owner: 1;
	int: 28;
	int: 32;
};

struct nfs_lock_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *lock_seqid;
	struct nfs_seqid *open_seqid;
};

struct nfs_locku_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *seqid;
	nfs4_stateid stateid;
};

struct nfs_locku_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_lockt_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_lowner lock_owner;
};

struct nfs_lockt_res {
	struct nfs4_sequence_res seq_res;
	struct file_lock *denied;
};

struct nfs_release_lockowner_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_lowner lock_owner;
};

struct nfs_release_lockowner_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_delegreturnargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fhandle;
	const nfs4_stateid *stateid;
	u32 *bitmask;
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_delegreturnres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs_setattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct iattr *iap;
	const struct nfs_server *server;
	const u32 *bitmask;
	const struct nfs4_label *label;
};

struct nfs_setaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_setaclres {
	struct nfs4_sequence_res seq_res;
};

struct nfs_getaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_getaclres {
	struct nfs4_sequence_res seq_res;
	size_t acl_len;
	size_t acl_data_offset;
	int acl_flags;
	struct page *acl_scratch;
};

struct nfs_setattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	const struct nfs_server *server;
};

typedef u64 clientid4;

struct nfs4_accessargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
	u32 access;
};

struct nfs4_accessres {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	u32 supported;
	u32 access;
};

struct nfs4_create_arg {
	struct nfs4_sequence_args seq_args;
	u32 ftype;
	union {
		struct {
			struct page **pages;
			unsigned int len;
		} symlink;
		struct {
			u32 specdata1;
			u32 specdata2;
		} device;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const struct iattr *attrs;
	const struct nfs_fh *dir_fh;
	const u32 *bitmask;
	const struct nfs4_label *label;
	umode_t umask;
};

struct nfs4_create_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	struct nfs4_change_info dir_cinfo;
};

struct nfs4_fsinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_fsinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsinfo *fsinfo;
};

struct nfs4_getattr_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_getattr_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
};

struct nfs4_link_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_link_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	int: 32;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *dir_attr;
	int: 32;
};

struct nfs4_lookup_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_lookup_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
	struct nfs4_label *label;
};

struct nfs4_lookupp_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_lookupp_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
	struct nfs4_label *label;
};

struct nfs4_lookup_root_arg {
	struct nfs4_sequence_args seq_args;
	const u32 *bitmask;
};

struct nfs4_pathconf_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_pathconf_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_pathconf *pathconf;
};

struct nfs4_readdir_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	int: 32;
	u64 cookie;
	nfs4_verifier verifier;
	u32 count;
	struct page **pages;
	unsigned int pgbase;
	const u32 *bitmask;
	bool plus;
	int: 24;
	int: 32;
};

struct nfs4_readdir_res {
	struct nfs4_sequence_res seq_res;
	nfs4_verifier verifier;
	unsigned int pgbase;
};

struct nfs4_readlink {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs4_readlink_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_setclientid {
	const nfs4_verifier *sc_verifier;
	u32 sc_prog;
	unsigned int sc_netid_len;
	char sc_netid[6];
	unsigned int sc_uaddr_len;
	char sc_uaddr[58];
	struct nfs_client *sc_clnt;
	struct rpc_cred *sc_cred;
};

struct nfs4_setclientid_res {
	u64 clientid;
	nfs4_verifier confirm;
};

struct nfs4_statfs_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_statfs_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsstat *fsstat;
};

struct nfs4_server_caps_arg {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fhandle;
	const u32 *bitmask;
};

struct nfs4_server_caps_res {
	struct nfs4_sequence_res seq_res;
	u32 attr_bitmask[3];
	u32 exclcreat_bitmask[3];
	u32 acl_bitmask;
	u32 has_links;
	u32 has_symlinks;
	u32 fh_expire_type;
};

struct nfs4_fs_locations_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct nfs_fh *fh;
	const struct qstr *name;
	struct page *page;
	const u32 *bitmask;
	int: 32;
	clientid4 clientid;
	unsigned char migration: 1;
	unsigned char renew: 1;
	int: 30;
	int: 32;
};

struct nfs4_fs_locations_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_fs_locations *fs_locations;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_secinfo4 {
	u32 flavor;
	struct rpcsec_gss_info flavor_info;
};

struct nfs4_secinfo_flavors {
	unsigned int num_flavors;
	struct nfs4_secinfo4 flavors[0];
};

struct nfs4_secinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
};

struct nfs4_secinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_secinfo_flavors *flavors;
};

struct nfs4_fsid_present_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	int: 32;
	clientid4 clientid;
	unsigned char renew: 1;
	int: 31;
	int: 32;
};

struct nfs4_fsid_present_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fh *fh;
	unsigned char renew: 1;
};

struct nfs41_state_protection {
	u32 how;
	struct nfs4_op_map enforce;
	struct nfs4_op_map allow;
};

struct nfs41_exchange_id_args {
	struct nfs_client *client;
	nfs4_verifier verifier;
	u32 flags;
	struct nfs41_state_protection state_protect;
};

struct nfs41_bind_conn_to_session_args {
	struct nfs_client *client;
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
	int retries;
};

struct nfs41_bind_conn_to_session_res {
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
};

struct nfs41_exchange_id_res {
	u64 clientid;
	u32 seqid;
	u32 flags;
	struct nfs41_server_owner *server_owner;
	struct nfs41_server_scope *server_scope;
	struct nfs41_impl_id *impl_id;
	struct nfs41_state_protection state_protect;
};

struct nfs41_create_session_args {
	struct nfs_client *client;
	int: 32;
	u64 clientid;
	uint32_t seqid;
	uint32_t flags;
	uint32_t cb_program;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
	int: 32;
};

struct nfs41_create_session_res {
	struct nfs4_sessionid sessionid;
	uint32_t seqid;
	uint32_t flags;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
};

struct nfs41_reclaim_complete_args {
	struct nfs4_sequence_args seq_args;
	unsigned char one_fs: 1;
};

struct nfs41_reclaim_complete_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs41_secinfo_no_name_args {
	struct nfs4_sequence_args seq_args;
	int style;
};

struct nfs41_test_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid *stateid;
};

struct nfs41_test_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs41_free_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
};

struct nfs41_free_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs4_cached_acl {
	int cached;
	size_t len;
	char data[0];
};

enum nfs4_client_state {
	NFS4CLNT_MANAGER_RUNNING = 0,
	NFS4CLNT_CHECK_LEASE = 1,
	NFS4CLNT_LEASE_EXPIRED = 2,
	NFS4CLNT_RECLAIM_REBOOT = 3,
	NFS4CLNT_RECLAIM_NOGRACE = 4,
	NFS4CLNT_DELEGRETURN = 5,
	NFS4CLNT_SESSION_RESET = 6,
	NFS4CLNT_LEASE_CONFIRM = 7,
	NFS4CLNT_SERVER_SCOPE_MISMATCH = 8,
	NFS4CLNT_PURGE_STATE = 9,
	NFS4CLNT_BIND_CONN_TO_SESSION = 10,
	NFS4CLNT_MOVED = 11,
	NFS4CLNT_LEASE_MOVED = 12,
	NFS4CLNT_DELEGATION_EXPIRED = 13,
	NFS4CLNT_RUN_MANAGER = 14,
	NFS4CLNT_RECALL_RUNNING = 15,
	NFS4CLNT_RECALL_ANY_LAYOUT_READ = 16,
	NFS4CLNT_RECALL_ANY_LAYOUT_RW = 17,
};

enum {
	NFS_OWNER_RECLAIM_REBOOT = 0,
	NFS_OWNER_RECLAIM_NOGRACE = 1,
};

enum {
	LK_STATE_IN_USE = 0,
	NFS_DELEGATED_STATE = 1,
	NFS_OPEN_STATE = 2,
	NFS_O_RDONLY_STATE = 3,
	NFS_O_WRONLY_STATE = 4,
	NFS_O_RDWR_STATE = 5,
	NFS_STATE_RECLAIM_REBOOT = 6,
	NFS_STATE_RECLAIM_NOGRACE = 7,
	NFS_STATE_POSIX_LOCKS = 8,
	NFS_STATE_RECOVERY_FAILED = 9,
	NFS_STATE_MAY_NOTIFY_LOCK = 10,
	NFS_STATE_CHANGE_WAIT = 11,
	NFS_CLNT_DST_SSC_COPY_STATE = 12,
	NFS_CLNT_SRC_SSC_COPY_STATE = 13,
	NFS_SRV_SSC_COPY_STATE = 14,
};

struct nfs4_exception {
	struct nfs4_state *state;
	struct inode *inode;
	nfs4_stateid *stateid;
	long int timeout;
	unsigned char delay: 1;
	unsigned char recovering: 1;
	unsigned char retry: 1;
	bool interruptible;
};

struct nfs4_opendata {
	struct kref kref;
	int: 32;
	struct nfs_openargs o_arg;
	struct nfs_openres o_res;
	struct nfs_open_confirmargs c_arg;
	struct nfs_open_confirmres c_res;
	struct nfs4_string owner_name;
	struct nfs4_string group_name;
	struct nfs4_label *a_label;
	struct nfs_fattr f_attr;
	struct nfs4_label *f_label;
	struct dentry *dir;
	struct dentry *dentry;
	struct nfs4_state_owner *owner;
	struct nfs4_state *state;
	int: 32;
	struct iattr attrs;
	struct nfs4_layoutget *lgp;
	long unsigned int timestamp;
	bool rpc_done;
	bool file_created;
	bool is_recover;
	bool cancelled;
	int rpc_status;
};

struct nfs4_add_xprt_data {
	struct nfs_client *clp;
	const struct cred *cred;
};

enum {
	NFS_DELEGATION_NEED_RECLAIM = 0,
	NFS_DELEGATION_RETURN = 1,
	NFS_DELEGATION_RETURN_IF_CLOSED = 2,
	NFS_DELEGATION_REFERENCED = 3,
	NFS_DELEGATION_RETURNING = 4,
	NFS_DELEGATION_REVOKED = 5,
	NFS_DELEGATION_TEST_EXPIRED = 6,
	NFS_DELEGATION_INODE_FREEING = 7,
};

struct cb_notify_lock_args {
	struct nfs_fh cbnl_fh;
	int: 16;
	int: 32;
	struct nfs_lowner cbnl_owner;
	bool cbnl_valid;
	int: 24;
	int: 32;
};

enum {
	NFS_LAYOUT_RO_FAILED = 0,
	NFS_LAYOUT_RW_FAILED = 1,
	NFS_LAYOUT_BULK_RECALL = 2,
	NFS_LAYOUT_RETURN = 3,
	NFS_LAYOUT_RETURN_LOCK = 4,
	NFS_LAYOUT_RETURN_REQUESTED = 5,
	NFS_LAYOUT_INVALID_STID = 6,
	NFS_LAYOUT_FIRST_LAYOUTGET = 7,
	NFS_LAYOUT_INODE_FREEING = 8,
	NFS_LAYOUT_HASHED = 9,
};

enum nfs4_slot_tbl_state {
	NFS4_SLOT_TBL_DRAINING = 0,
};

enum nfs4_session_state {
	NFS4_SESSION_INITING = 0,
	NFS4_SESSION_ESTABLISHED = 1,
};

struct nfs4_call_sync_data {
	const struct nfs_server *seq_server;
	struct nfs4_sequence_args *seq_args;
	struct nfs4_sequence_res *seq_res;
};

struct nfs4_open_createattrs {
	struct nfs4_label *label;
	struct iattr *sattr;
	const __u32 verf[2];
};

struct nfs4_closedata {
	struct inode *inode;
	struct nfs4_state *state;
	struct nfs_closeargs arg;
	struct nfs_closeres res;
	int: 32;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	long unsigned int timestamp;
	int: 32;
};

struct nfs4_createdata {
	struct rpc_message msg;
	struct nfs4_create_arg arg;
	struct nfs4_create_res res;
	struct nfs_fh fh;
	int: 16;
	int: 32;
	struct nfs_fattr fattr;
	struct nfs4_label *label;
	int: 32;
};

struct nfs4_renewdata {
	struct nfs_client *client;
	long unsigned int timestamp;
};

struct nfs4_delegreturndata {
	struct nfs4_delegreturnargs args;
	struct nfs4_delegreturnres res;
	struct nfs_fh fh;
	nfs4_stateid stateid;
	long unsigned int timestamp;
	int: 32;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	int rpc_status;
	struct inode *inode;
};

struct nfs4_unlockdata {
	struct nfs_locku_args arg;
	struct nfs_locku_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	int: 32;
	struct file_lock fl;
	struct nfs_server *server;
	long unsigned int timestamp;
};

struct nfs4_lockdata {
	struct nfs_lock_args arg;
	struct nfs_lock_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	int: 32;
	struct file_lock fl;
	long unsigned int timestamp;
	int rpc_status;
	int cancelled;
	struct nfs_server *server;
};

struct nfs4_lock_waiter {
	struct task_struct *task;
	struct inode *inode;
	struct nfs_lowner *owner;
};

struct nfs_release_lockowner_data {
	struct nfs4_lock_state *lsp;
	struct nfs_server *server;
	struct nfs_release_lockowner_args args;
	struct nfs_release_lockowner_res res;
	long unsigned int timestamp;
	int: 32;
};

struct rpc_bind_conn_calldata {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct nfs41_exchange_id_data {
	struct nfs41_exchange_id_res res;
	struct nfs41_exchange_id_args args;
	int: 32;
};

struct nfs4_get_lease_time_data {
	struct nfs4_get_lease_time_args *args;
	struct nfs4_get_lease_time_res *res;
	struct nfs_client *clp;
};

struct nfs4_sequence_data {
	struct nfs_client *clp;
	struct nfs4_sequence_args args;
	struct nfs4_sequence_res res;
};

struct nfs4_reclaim_complete_data {
	struct nfs_client *clp;
	struct nfs41_reclaim_complete_args arg;
	struct nfs41_reclaim_complete_res res;
};

struct nfs_free_stateid_data {
	struct nfs_server *server;
	struct nfs41_free_stateid_args args;
	struct nfs41_free_stateid_res res;
};

enum opentype4 {
	NFS4_OPEN_NOCREATE = 0,
	NFS4_OPEN_CREATE = 1,
};

enum limit_by4 {
	NFS4_LIMIT_SIZE = 1,
	NFS4_LIMIT_BLOCKS = 2,
};

enum open_delegation_type4 {
	NFS4_OPEN_DELEGATE_NONE = 0,
	NFS4_OPEN_DELEGATE_READ = 1,
	NFS4_OPEN_DELEGATE_WRITE = 2,
	NFS4_OPEN_DELEGATE_NONE_EXT = 3,
};

enum why_no_delegation4 {
	WND4_NOT_WANTED = 0,
	WND4_CONTENTION = 1,
	WND4_RESOURCE = 2,
	WND4_NOT_SUPP_FTYPE = 3,
	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
	WND4_NOT_SUPP_UPGRADE = 5,
	WND4_NOT_SUPP_DOWNGRADE = 6,
	WND4_CANCELLED = 7,
	WND4_IS_DIR = 8,
};

enum lock_type4 {
	NFS4_UNLOCK_LT = 0,
	NFS4_READ_LT = 1,
	NFS4_WRITE_LT = 2,
	NFS4_READW_LT = 3,
	NFS4_WRITEW_LT = 4,
};

enum pnfs_layoutreturn_type {
	RETURN_FILE = 1,
	RETURN_FSID = 2,
	RETURN_ALL = 3,
};

enum data_content4 {
	NFS4_CONTENT_DATA = 0,
	NFS4_CONTENT_HOLE = 1,
};

struct nfs42_netaddr {
	char netid[5];
	char addr[58];
	u32 netid_len;
	u32 addr_len;
};

enum netloc_type4 {
	NL4_NAME = 1,
	NL4_URL = 2,
	NL4_NETADDR = 3,
};

struct nl4_server {
	enum netloc_type4 nl4_type;
	union {
		struct {
			int nl4_str_sz;
			char nl4_str[1025];
		};
		struct nfs42_netaddr nl4_addr;
	} u;
};

enum nfs4_setxattr_options {
	SETXATTR4_EITHER = 0,
	SETXATTR4_CREATE = 1,
	SETXATTR4_REPLACE = 2,
};

struct nfs42_layoutstat_res {
	struct nfs4_sequence_res seq_res;
	int num_dev;
	int rpc_status;
};

struct nfs42_device_error {
	struct nfs4_deviceid dev_id;
	int status;
	enum nfs_opnum4 opnum;
};

struct nfs42_layout_error {
	__u64 offset;
	__u64 length;
	nfs4_stateid stateid;
	struct nfs42_device_error errors[1];
	int: 32;
};

struct nfs42_layouterror_args {
	struct nfs4_sequence_args seq_args;
	struct inode *inode;
	unsigned int num_errors;
	struct nfs42_layout_error errors[5];
};

struct nfs42_layouterror_res {
	struct nfs4_sequence_res seq_res;
	unsigned int num_errors;
	int rpc_status;
};

struct nfs42_clone_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	struct nfs_fh *dst_fh;
	nfs4_stateid src_stateid;
	nfs4_stateid dst_stateid;
	__u64 src_offset;
	__u64 dst_offset;
	__u64 count;
	const u32 *dst_bitmask;
	int: 32;
};

struct nfs42_clone_res {
	struct nfs4_sequence_res seq_res;
	unsigned int rpc_status;
	struct nfs_fattr *dst_fattr;
	const struct nfs_server *server;
};

struct nfs42_falloc_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *falloc_fh;
	nfs4_stateid falloc_stateid;
	u64 falloc_offset;
	u64 falloc_length;
	const u32 *falloc_bitmask;
	int: 32;
};

struct nfs42_falloc_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	struct nfs_fattr *falloc_fattr;
	const struct nfs_server *falloc_server;
};

struct nfs42_copy_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	nfs4_stateid src_stateid;
	u64 src_pos;
	struct nfs_fh *dst_fh;
	nfs4_stateid dst_stateid;
	u64 dst_pos;
	u64 count;
	bool sync;
	struct nl4_server *cp_src;
};

struct nfs42_write_res {
	nfs4_stateid stateid;
	int: 32;
	u64 count;
	struct nfs_writeverf verifier;
	int: 32;
};

struct nfs42_copy_res {
	struct nfs4_sequence_res seq_res;
	struct nfs42_write_res write_res;
	bool consecutive;
	bool synchronous;
	struct nfs_commitres commit_res;
	int: 32;
};

struct nfs42_offload_status_args {
	struct nfs4_sequence_args osa_seq_args;
	struct nfs_fh *osa_src_fh;
	nfs4_stateid osa_stateid;
};

struct nfs42_offload_status_res {
	struct nfs4_sequence_res osr_seq_res;
	uint64_t osr_count;
	int osr_status;
	int: 32;
};

struct nfs42_copy_notify_args {
	struct nfs4_sequence_args cna_seq_args;
	struct nfs_fh *cna_src_fh;
	nfs4_stateid cna_src_stateid;
	struct nl4_server cna_dst;
};

struct nfs42_copy_notify_res {
	struct nfs4_sequence_res cnr_seq_res;
	struct nfstime4 cnr_lease_time;
	nfs4_stateid cnr_stateid;
	struct nl4_server cnr_src;
};

struct nfs42_seek_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *sa_fh;
	nfs4_stateid sa_stateid;
	u64 sa_offset;
	u32 sa_what;
	int: 32;
};

struct nfs42_seek_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	u32 sr_eof;
	u64 sr_offset;
};

struct nfs42_setxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	u32 xattr_flags;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_setxattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct nfs42_getxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_getxattrres {
	struct nfs4_sequence_res seq_res;
	size_t xattr_len;
};

struct nfs42_listxattrsargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	u32 count;
	u64 cookie;
	struct page **xattr_pages;
	int: 32;
};

struct nfs42_listxattrsres {
	struct nfs4_sequence_res seq_res;
	struct page *scratch;
	void *xattr_buf;
	size_t xattr_len;
	int: 32;
	u64 cookie;
	bool eof;
	size_t copied;
};

struct nfs42_removexattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
};

struct nfs42_removexattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct compound_hdr {
	int32_t status;
	uint32_t nops;
	__be32 *nops_p;
	uint32_t taglen;
	char *tag;
	uint32_t replen;
	u32 minorversion;
};

struct nfs4_copy_state {
	struct list_head copies;
	struct list_head src_copies;
	nfs4_stateid stateid;
	struct completion completion;
	int: 32;
	uint64_t count;
	struct nfs_writeverf verf;
	int error;
	int flags;
	struct nfs4_state *parent_src_state;
	struct nfs4_state *parent_dst_state;
	int: 32;
};

struct nfs_referral_count {
	struct list_head list;
	const struct task_struct *task;
	unsigned int referral_count;
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
	int: 32;
};

struct idmap_legacy_upcalldata;

struct idmap {
	struct rpc_pipe_dir_object idmap_pdo;
	struct rpc_pipe *idmap_pipe;
	struct idmap_legacy_upcalldata *idmap_upcall_data;
	struct mutex idmap_mutex;
	struct user_namespace *user_ns;
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	int: 16;
	int: 32;
	char data[0];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct idmap_msg {
	__u8 im_type;
	__u8 im_conv;
	char im_name[128];
	__u32 im_id;
	__u8 im_status;
};

struct idmap_legacy_upcalldata {
	struct rpc_pipe_msg pipe_msg;
	struct idmap_msg idmap_msg;
	struct key *authkey;
	struct idmap *idmap;
};

enum {
	Opt_find_uid = 0,
	Opt_find_gid = 1,
	Opt_find_user = 2,
	Opt_find_group = 3,
	Opt_find_err = 4,
};

enum nfs4_callback_procnum {
	CB_NULL = 0,
	CB_COMPOUND = 1,
};

struct nfs_callback_data {
	unsigned int users;
	struct svc_serv *serv;
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

enum nfs4_callback_opnum {
	OP_CB_GETATTR = 3,
	OP_CB_RECALL = 4,
	OP_CB_LAYOUTRECALL = 5,
	OP_CB_NOTIFY = 6,
	OP_CB_PUSH_DELEG = 7,
	OP_CB_RECALL_ANY = 8,
	OP_CB_RECALLABLE_OBJ_AVAIL = 9,
	OP_CB_RECALL_SLOT = 10,
	OP_CB_SEQUENCE = 11,
	OP_CB_WANTS_CANCELLED = 12,
	OP_CB_NOTIFY_LOCK = 13,
	OP_CB_NOTIFY_DEVICEID = 14,
	OP_CB_OFFLOAD = 15,
	OP_CB_ILLEGAL = 10044,
};

struct cb_process_state {
	__be32 drc_status;
	struct nfs_client *clp;
	struct nfs4_slot *slot;
	u32 minorversion;
	struct net *net;
};

struct cb_compound_hdr_arg {
	unsigned int taglen;
	const char *tag;
	unsigned int minorversion;
	unsigned int cb_ident;
	unsigned int nops;
};

struct cb_compound_hdr_res {
	__be32 *status;
	unsigned int taglen;
	const char *tag;
	__be32 *nops;
};

struct cb_getattrargs {
	struct nfs_fh fh;
	uint32_t bitmap[2];
};

struct cb_getattrres {
	__be32 status;
	uint32_t bitmap[2];
	int: 32;
	uint64_t size;
	uint64_t change_attr;
	struct timespec64 ctime;
	struct timespec64 mtime;
};

struct cb_recallargs {
	struct nfs_fh fh;
	nfs4_stateid stateid;
	uint32_t truncate;
};

struct referring_call {
	uint32_t rc_sequenceid;
	uint32_t rc_slotid;
};

struct referring_call_list {
	struct nfs4_sessionid rcl_sessionid;
	uint32_t rcl_nrefcalls;
	struct referring_call *rcl_refcalls;
};

struct cb_sequenceargs {
	struct sockaddr *csa_addr;
	struct nfs4_sessionid csa_sessionid;
	uint32_t csa_sequenceid;
	uint32_t csa_slotid;
	uint32_t csa_highestslotid;
	uint32_t csa_cachethis;
	uint32_t csa_nrclists;
	struct referring_call_list *csa_rclists;
};

struct cb_sequenceres {
	__be32 csr_status;
	struct nfs4_sessionid csr_sessionid;
	uint32_t csr_sequenceid;
	uint32_t csr_slotid;
	uint32_t csr_highestslotid;
	uint32_t csr_target_highestslotid;
};

struct cb_recallanyargs {
	uint32_t craa_objs_to_keep;
	uint32_t craa_type_mask;
};

struct cb_recallslotargs {
	uint32_t crsa_target_highest_slotid;
};

struct cb_layoutrecallargs {
	uint32_t cbl_recall_type;
	uint32_t cbl_layout_type;
	uint32_t cbl_layoutchanged;
	int: 32;
	union {
		struct {
			struct nfs_fh cbl_fh;
			int: 16;
			int: 32;
			struct pnfs_layout_range cbl_range;
			nfs4_stateid cbl_stateid;
			int: 32;
		};
		struct nfs_fsid cbl_fsid;
	};
};

struct cb_devicenotifyitem {
	uint32_t cbd_notify_type;
	uint32_t cbd_layout_type;
	struct nfs4_deviceid cbd_dev_id;
	uint32_t cbd_immediate;
};

struct cb_devicenotifyargs {
	int ndevs;
	struct cb_devicenotifyitem *devs;
};

struct cb_offloadargs {
	struct nfs_fh coa_fh;
	nfs4_stateid coa_stateid;
	uint32_t error;
	int: 32;
	uint64_t wr_count;
	struct nfs_writeverf wr_writeverf;
	int: 32;
};

struct callback_op {
	__be32 (*process_op)(void *, void *, struct cb_process_state *);
	__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);
	__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *, const void *);
	long int res_maxsize;
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
};

struct nfs4_ds_server {
	struct list_head list;
	struct rpc_clnt *rpc_clnt;
};

enum pnfs_update_layout_reason {
	PNFS_UPDATE_LAYOUT_UNKNOWN = 0,
	PNFS_UPDATE_LAYOUT_NO_PNFS = 1,
	PNFS_UPDATE_LAYOUT_RD_ZEROLEN = 2,
	PNFS_UPDATE_LAYOUT_MDSTHRESH = 3,
	PNFS_UPDATE_LAYOUT_NOMEM = 4,
	PNFS_UPDATE_LAYOUT_BULK_RECALL = 5,
	PNFS_UPDATE_LAYOUT_IO_TEST_FAIL = 6,
	PNFS_UPDATE_LAYOUT_FOUND_CACHED = 7,
	PNFS_UPDATE_LAYOUT_RETURN = 8,
	PNFS_UPDATE_LAYOUT_RETRY = 9,
	PNFS_UPDATE_LAYOUT_BLOCKED = 10,
	PNFS_UPDATE_LAYOUT_INVALID_OPEN = 11,
	PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET = 12,
	PNFS_UPDATE_LAYOUT_EXIT = 13,
};

struct trace_event_raw_nfs4_clientid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_sequence_done {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int target_highest_slotid;
	unsigned int status_flags;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_seqid_err {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_setup_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_used_slotid;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_hostname;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr_failed {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int state;
	u32 __data_loc_hostname;
	u32 __data_loc_section;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_error_class {
	struct trace_entry ent;
	u32 xid;
	u32 cbident;
	char __data[0];
};

struct trace_event_raw_nfs4_open_event {
	struct trace_entry ent;
	long unsigned int error;
	unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	int stateid_seq;
	u32 stateid_hash;
	int openstateid_seq;
	u32 openstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_cached_open {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_close {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lock_event {
	struct trace_entry ent;
	long unsigned int error;
	int cmd;
	char type;
	int: 24;
	int: 32;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_lock {
	struct trace_entry ent;
	long unsigned int error;
	int cmd;
	char type;
	int: 24;
	int: 32;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	int lockstateid_seq;
	u32 lockstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_state_lock_reclaim {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int state_flags;
	long unsigned int lock_flags;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_delegation_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_delegreturn_exit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_test_stateid_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lookup_event {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_lookupp {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	long unsigned int error;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_rename {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 olddir;
	u32 __data_loc_oldname;
	int: 32;
	u64 newdir;
	u32 __data_loc_newname;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_inode_stateid_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_getattr_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int valid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u32 __data_loc_dstaddr;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_inode_stateid_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u32 __data_loc_dstaddr;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_idmap_event {
	struct trace_entry ent;
	long unsigned int error;
	u32 id;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_read_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_write_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_commit_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int: 32;
	loff_t offset;
	u32 count;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_layoutget {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 iomode;
	int: 32;
	u64 offset;
	u64 count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_pnfs_update_layout {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u32 fhandle;
	int: 32;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long int lseg;
	enum pnfs_update_layout_reason reason;
	char __data[0];
	int: 32;
};

struct trace_event_raw_pnfs_layout_event {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u32 fhandle;
	int: 32;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long int lseg;
	char __data[0];
};

struct trace_event_raw_nfs4_deviceid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	unsigned char deviceid[16];
	char __data[0];
};

struct trace_event_raw_nfs4_deviceid_status {
	struct trace_entry ent;
	dev_t dev;
	int status;
	u32 __data_loc_dstaddr;
	unsigned char deviceid[16];
	char __data[0];
};

struct trace_event_raw_nfs4_flexfiles_io_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	loff_t offset;
	u32 count;
	int stateid_seq;
	u32 stateid_hash;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_ff_layout_commit_error {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	loff_t offset;
	u32 count;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_data_offsets_nfs4_clientid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_sequence_done {};

struct trace_event_data_offsets_nfs4_cb_sequence {};

struct trace_event_data_offsets_nfs4_cb_seqid_err {};

struct trace_event_data_offsets_nfs4_setup_sequence {};

struct trace_event_data_offsets_nfs4_state_mgr {
	u32 hostname;
};

struct trace_event_data_offsets_nfs4_state_mgr_failed {
	u32 hostname;
	u32 section;
};

struct trace_event_data_offsets_nfs4_xdr_status {};

struct trace_event_data_offsets_nfs4_cb_error_class {};

struct trace_event_data_offsets_nfs4_open_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_cached_open {};

struct trace_event_data_offsets_nfs4_close {};

struct trace_event_data_offsets_nfs4_lock_event {};

struct trace_event_data_offsets_nfs4_set_lock {};

struct trace_event_data_offsets_nfs4_state_lock_reclaim {};

struct trace_event_data_offsets_nfs4_set_delegation_event {};

struct trace_event_data_offsets_nfs4_delegreturn_exit {};

struct trace_event_data_offsets_nfs4_test_stateid_event {};

struct trace_event_data_offsets_nfs4_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_lookupp {};

struct trace_event_data_offsets_nfs4_rename {
	u32 oldname;
	u32 newname;
};

struct trace_event_data_offsets_nfs4_inode_event {};

struct trace_event_data_offsets_nfs4_inode_stateid_event {};

struct trace_event_data_offsets_nfs4_getattr_event {};

struct trace_event_data_offsets_nfs4_inode_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_inode_stateid_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_idmap_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_read_event {};

struct trace_event_data_offsets_nfs4_write_event {};

struct trace_event_data_offsets_nfs4_commit_event {};

struct trace_event_data_offsets_nfs4_layoutget {};

struct trace_event_data_offsets_pnfs_update_layout {};

struct trace_event_data_offsets_pnfs_layout_event {};

struct trace_event_data_offsets_nfs4_deviceid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_deviceid_status {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_flexfiles_io_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_ff_layout_commit_error {
	u32 dstaddr;
};

typedef void (*btf_trace_nfs4_setclientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setclientid_confirm)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew_async)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_exchange_id)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_create_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_clientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_bind_conn_to_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_reclaim_complete)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence_done)(void *, const struct nfs4_session *, const struct nfs4_sequence_res *);

typedef void (*btf_trace_nfs4_cb_sequence)(void *, const struct cb_sequenceargs *, const struct cb_sequenceres *, __be32);

typedef void (*btf_trace_nfs4_cb_seqid_err)(void *, const struct cb_sequenceargs *, __be32);

typedef void (*btf_trace_nfs4_setup_sequence)(void *, const struct nfs4_session *, const struct nfs4_sequence_args *);

typedef void (*btf_trace_nfs4_state_mgr)(void *, const struct nfs_client *);

typedef void (*btf_trace_nfs4_state_mgr_failed)(void *, const struct nfs_client *, const char *, int);

typedef void (*btf_trace_nfs4_xdr_status)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs_cb_no_clp)(void *, __be32, u32);

typedef void (*btf_trace_nfs_cb_badprinc)(void *, __be32, u32);

typedef void (*btf_trace_nfs4_open_reclaim)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_expired)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_file)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_cached_open)(void *, const struct nfs4_state *);

typedef void (*btf_trace_nfs4_close)(void *, const struct nfs4_state *, const struct nfs_closeargs *, const struct nfs_closeres *, int);

typedef void (*btf_trace_nfs4_get_lock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_unlock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_set_lock)(void *, const struct file_lock *, const struct nfs4_state *, const nfs4_stateid *, int, int);

typedef void (*btf_trace_nfs4_state_lock_reclaim)(void *, const struct nfs4_state *, const struct nfs4_lock_state *);

typedef void (*btf_trace_nfs4_set_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_reclaim_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_delegreturn_exit)(void *, const struct nfs4_delegreturnargs *, const struct nfs4_delegreturnres *, int);

typedef void (*btf_trace_nfs4_test_delegation_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_open_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_lock_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_lookup)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_symlink)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mkdir)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mknod)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_remove)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_get_fs_locations)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_secinfo)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_lookupp)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_rename)(void *, const struct inode *, const struct qstr *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_access)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readlink)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readdir)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_setattr)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_delegreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_close_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_getattr)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookup_root)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_fsinfo)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_cb_getattr)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cb_recall)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_cb_layoutrecall_file)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_map_name_to_uid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_group_to_gid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_uid_to_name)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_gid_to_group)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_commit)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_pnfs_commit_ds)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_layoutget)(void *, const struct nfs_open_context *, const struct pnfs_layout_range *, const struct pnfs_layout_range *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutcommit)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn_on_close)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layouterror)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutstats)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_pnfs_update_layout)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *, enum pnfs_update_layout_reason);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_read)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_write)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_get_mirror_count)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_nfs4_deviceid_free)(void *, const struct nfs_client *, const struct nfs4_deviceid *);

typedef void (*btf_trace_nfs4_getdeviceinfo)(void *, const struct nfs_server *, const struct nfs4_deviceid *, int);

typedef void (*btf_trace_nfs4_find_deviceid)(void *, const struct nfs_server *, const struct nfs4_deviceid *, int);

typedef void (*btf_trace_ff_layout_read_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_write_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_commit_error)(void *, const struct nfs_commit_data *);

enum pnfs_layouttype {
	LAYOUT_NFSV4_1_FILES = 1,
	LAYOUT_OSD2_OBJECTS = 2,
	LAYOUT_BLOCK_VOLUME = 3,
	LAYOUT_FLEX_FILES = 4,
	LAYOUT_SCSI = 5,
	LAYOUT_TYPE_MAX = 6,
};

struct nfs42_layoutstat_data {
	struct inode *inode;
	struct nfs42_layoutstat_args args;
	struct nfs42_layoutstat_res res;
};

enum {
	NFS_LSEG_VALID = 0,
	NFS_LSEG_ROC = 1,
	NFS_LSEG_LAYOUTCOMMIT = 2,
	NFS_LSEG_LAYOUTRETURN = 3,
	NFS_LSEG_UNAVAILABLE = 4,
};

enum {
	NFS_DEVICEID_INVALID = 0,
	NFS_DEVICEID_UNAVAILABLE = 1,
	NFS_DEVICEID_NOCACHE = 2,
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

struct nfs4_pnfs_ds_addr {
	struct __kernel_sockaddr_storage da_addr;
	size_t da_addrlen;
	struct list_head da_node;
	char *da_remotestr;
	const char *da_netid;
	int da_transport;
};

struct nfs4_pnfs_ds {
	struct list_head ds_node;
	char *ds_remotestr;
	struct list_head ds_addrs;
	struct nfs_client *ds_clp;
	refcount_t ds_count;
	long unsigned int ds_state;
};

struct nfs42_layouterror_data {
	struct nfs42_layouterror_args args;
	struct nfs42_layouterror_res res;
	struct inode *inode;
	struct pnfs_layout_segment *lseg;
};

struct nfs42_offloadcancel_data {
	struct nfs_server *seq_server;
	struct nfs42_offload_status_args args;
	int: 32;
	struct nfs42_offload_status_res res;
};

struct nfs4_xattr_bucket {
	spinlock_t lock;
	struct hlist_head hlist;
	struct nfs4_xattr_cache *cache;
	bool draining;
};

struct nfs4_xattr_entry;

struct nfs4_xattr_cache {
	struct kref ref;
	struct nfs4_xattr_bucket buckets[64];
	struct list_head lru;
	struct list_head dispose;
	atomic_long_t nent;
	spinlock_t listxattr_lock;
	struct inode *inode;
	struct nfs4_xattr_entry *listxattr;
};

struct nfs4_xattr_entry {
	struct kref ref;
	struct hlist_node hnode;
	struct list_head lru;
	struct list_head dispose;
	char *xattr_name;
	void *xattr_value;
	size_t xattr_size;
	struct nfs4_xattr_bucket *bucket;
	uint32_t flags;
};

enum stripetype4 {
	STRIPE_SPARSE = 1,
	STRIPE_DENSE = 2,
};

struct nfs4_file_layout_dsaddr {
	struct nfs4_deviceid_node id_node;
	u32 stripe_count;
	u8 *stripe_indices;
	u32 ds_num;
	struct nfs4_pnfs_ds *ds_list[1];
};

struct nfs4_filelayout_segment {
	struct pnfs_layout_segment generic_hdr;
	u32 stripe_type;
	u32 commit_through_mds;
	u32 stripe_unit;
	u32 first_stripe_index;
	u64 pattern_offset;
	struct nfs4_deviceid deviceid;
	struct nfs4_file_layout_dsaddr *dsaddr;
	unsigned int num_fh;
	struct nfs_fh **fh_array;
	int: 32;
};

struct nfs4_filelayout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
	int: 32;
};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	int: 32;
	u64 ino;
	int found;
	int sequence;
};

struct nlm_host___2;

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host___2 *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nsm_handle;

struct nlm_host___2 {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	short unsigned int h_proto;
	short unsigned int h_reclaiming: 1;
	short unsigned int h_server: 1;
	short unsigned int h_noresvport: 1;
	short unsigned int h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	long unsigned int h_nextrebind;
	long unsigned int h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

struct nsm_private {
	unsigned char data[16];
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	struct file_lock fl;
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_args {
	struct nlm_cookie cookie;
	int: 32;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nlm_block;

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host___2 *a_host;
	int: 32;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_file;

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host___2 *b_host;
	long unsigned int b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

struct nlm_share;

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file;
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host___2 *b_host;
	struct file_lock *b_lock;
	short unsigned int b_reclaim;
	__be32 b_status;
};

struct nlm_wait___2;

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct lockd_net {
	unsigned int nlmsvc_users;
	long unsigned int next_gc;
	long unsigned int nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const short unsigned int protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

struct ipv4_devconf {
	void *sysctl;
	int data[32];
	long unsigned int state[1];
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	unsigned char mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	int: 32;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **);
	void (*fclose)(struct file *);
};

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host___2 *);

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host___2 *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

struct __una_u64 {
	u64 x;
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_res {
	u32 status;
	u32 state;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

typedef __le16 le16;

typedef __le32 le32;

typedef __le64 le64;

typedef __u64 sle64;

typedef le16 ntfschar;

typedef s64 VCN;

typedef sle64 leVCN;

typedef s64 LCN;

typedef le32 NTFS_RECORD_TYPE;

typedef struct {
	NTFS_RECORD_TYPE magic;
	le16 usa_ofs;
	le16 usa_count;
} NTFS_RECORD;

typedef le16 MFT_RECORD_FLAGS;

typedef le64 leMFT_REF;

typedef struct {
	NTFS_RECORD_TYPE magic;
	le16 usa_ofs;
	le16 usa_count;
	le64 lsn;
	le16 sequence_number;
	le16 link_count;
	le16 attrs_offset;
	MFT_RECORD_FLAGS flags;
	le32 bytes_in_use;
	le32 bytes_allocated;
	leMFT_REF base_mft_record;
	le16 next_attr_instance;
	le16 reserved;
	le32 mft_record_number;
} MFT_RECORD;

enum {
	AT_UNUSED = 0,
	AT_STANDARD_INFORMATION = 16,
	AT_ATTRIBUTE_LIST = 32,
	AT_FILE_NAME = 48,
	AT_OBJECT_ID = 64,
	AT_SECURITY_DESCRIPTOR = 80,
	AT_VOLUME_NAME = 96,
	AT_VOLUME_INFORMATION = 112,
	AT_DATA = 128,
	AT_INDEX_ROOT = 144,
	AT_INDEX_ALLOCATION = 160,
	AT_BITMAP = 176,
	AT_REPARSE_POINT = 192,
	AT_EA_INFORMATION = 208,
	AT_EA = 224,
	AT_PROPERTY_SET = 240,
	AT_LOGGED_UTILITY_STREAM = 256,
	AT_FIRST_USER_DEFINED_ATTRIBUTE = 4096,
	AT_END = 4294967295,
};

typedef le32 ATTR_TYPE;

typedef le32 COLLATION_RULE;

typedef le32 ATTR_DEF_FLAGS;

typedef struct {
	ntfschar name[64];
	ATTR_TYPE type;
	le32 display_rule;
	COLLATION_RULE collation_rule;
	ATTR_DEF_FLAGS flags;
	sle64 min_size;
	sle64 max_size;
} ATTR_DEF;

typedef le16 ATTR_FLAGS;

typedef u8 RESIDENT_ATTR_FLAGS;

typedef struct {
	ATTR_TYPE type;
	le32 length;
	u8 non_resident;
	u8 name_length;
	le16 name_offset;
	ATTR_FLAGS flags;
	le16 instance;
	union {
		struct {
			le32 value_length;
			le16 value_offset;
			RESIDENT_ATTR_FLAGS flags;
			s8 reserved;
		} resident;
		struct {
			leVCN lowest_vcn;
			leVCN highest_vcn;
			le16 mapping_pairs_offset;
			u8 compression_unit;
			u8 reserved[5];
			sle64 allocated_size;
			sle64 data_size;
			sle64 initialized_size;
			sle64 compressed_size;
		} non_resident;
	} data;
} ATTR_RECORD;

typedef struct {
	ATTR_TYPE type;
	le16 length;
	u8 name_length;
	u8 name_offset;
	leVCN lowest_vcn;
	leMFT_REF mft_reference;
	le16 instance;
	ntfschar name[0];
} __attribute__((packed)) ATTR_LIST_ENTRY;

typedef le16 VOLUME_FLAGS;

typedef struct {
	struct super_block *sb;
	int: 32;
	LCN nr_blocks;
	long unsigned int flags;
	kuid_t uid;
	kgid_t gid;
	umode_t fmask;
	umode_t dmask;
	u8 mft_zone_multiplier;
	u8 on_errors;
	u16 sector_size;
	u8 sector_size_bits;
	u32 cluster_size;
	u32 cluster_size_mask;
	u8 cluster_size_bits;
	u32 mft_record_size;
	u32 mft_record_size_mask;
	u8 mft_record_size_bits;
	u32 index_record_size;
	u32 index_record_size_mask;
	u8 index_record_size_bits;
	int: 24;
	int: 32;
	LCN nr_clusters;
	LCN mft_lcn;
	LCN mftmirr_lcn;
	u64 serial_no;
	u32 upcase_len;
	ntfschar *upcase;
	s32 attrdef_size;
	ATTR_DEF *attrdef;
	struct inode *mft_ino;
	struct inode *mftbmp_ino;
	struct rw_semaphore mftbmp_lock;
	struct inode *lcnbmp_ino;
	struct rw_semaphore lcnbmp_lock;
	struct inode *vol_ino;
	VOLUME_FLAGS vol_flags;
	u8 major_ver;
	u8 minor_ver;
	struct inode *root_ino;
	struct inode *secure_ino;
	struct inode *extend_ino;
	struct nls_table *nls_map;
	int: 32;
} ntfs_volume;

typedef struct {
	VCN vcn;
	LCN lcn;
	s64 length;
} runlist_element;

typedef struct {
	runlist_element *rl;
	struct rw_semaphore lock;
} runlist;

enum {
	LCN_HOLE = 4294967295,
	LCN_RL_NOT_MAPPED = 4294967294,
	LCN_ENOENT = 4294967293,
	LCN_ENOMEM = 4294967292,
	LCN_EIO = 4294967291,
};

struct _ntfs_inode;

typedef struct _ntfs_inode ntfs_inode;

struct _ntfs_inode {
	rwlock_t size_lock;
	int: 32;
	s64 initialized_size;
	s64 allocated_size;
	long unsigned int state;
	long unsigned int mft_no;
	u16 seq_no;
	atomic_t count;
	ntfs_volume *vol;
	ATTR_TYPE type;
	ntfschar *name;
	u32 name_len;
	runlist runlist;
	struct mutex mrec_lock;
	struct page *page;
	int page_ofs;
	u32 attr_list_size;
	u8 *attr_list;
	runlist attr_list_rl;
	int: 32;
	union {
		struct {
			u32 block_size;
			u32 vcn_size;
			COLLATION_RULE collation_rule;
			u8 block_size_bits;
			u8 vcn_size_bits;
		} index;
		struct {
			s64 size;
			u32 block_size;
			u8 block_size_bits;
			u8 block_clusters;
		} compressed;
	} itype;
	struct mutex extent_lock;
	s32 nr_extents;
	union {
		ntfs_inode **extent_ntfs_inos;
		ntfs_inode *base_ntfs_ino;
	} ext;
	int: 32;
};

enum {
	NI_Dirty = 0,
	NI_AttrList = 1,
	NI_AttrListNonResident = 2,
	NI_Attr = 3,
	NI_MstProtected = 4,
	NI_NonResident = 5,
	NI_IndexAllocPresent = 5,
	NI_Compressed = 6,
	NI_Encrypted = 7,
	NI_Sparse = 8,
	NI_SparseDisabled = 9,
	NI_TruncateFailed = 10,
};

typedef struct {
	ntfs_inode ntfs_inode;
	struct inode vfs_inode;
} big_ntfs_inode;

typedef struct {
	MFT_RECORD *mrec;
	ATTR_RECORD *attr;
	bool is_first;
	ntfs_inode *ntfs_ino;
	ATTR_LIST_ENTRY *al_entry;
	ntfs_inode *base_ntfs_ino;
	MFT_RECORD *base_mrec;
	ATTR_RECORD *base_attr;
} ntfs_attr_search_ctx;

typedef enum {
	CASE_SENSITIVE = 0,
	IGNORE_CASE = 1,
} IGNORE_CASE_BOOL;

enum {
	NV_Errors = 0,
	NV_ShowSystemFiles = 1,
	NV_CaseSensitive = 2,
	NV_LogFileEmpty = 3,
	NV_QuotaOutOfDate = 4,
	NV_UsnJrnlStamped = 5,
	NV_SparseEnabled = 6,
};

enum {
	COLLATION_BINARY = 0,
	COLLATION_FILE_NAME = 1,
	COLLATION_UNICODE_STRING = 2,
	COLLATION_NTOFS_ULONG = 16,
	COLLATION_NTOFS_SID = 17,
	COLLATION_NTOFS_SECURITY_HASH = 18,
	COLLATION_NTOFS_ULONGS = 19,
};

typedef int (*ntfs_collate_func_t)(ntfs_volume *, const void *, const int, const void *, const int);

enum {
	NTFS_SYMBOL_TOKEN = 0,
	NTFS_PHRASE_TOKEN = 1,
	NTFS_TOKEN_MASK = 1,
	NTFS_SB_SIZE_MASK = 4095,
	NTFS_SB_SIZE = 4096,
	NTFS_SB_IS_COMPRESSED = 32768,
	NTFS_MAX_CB_SIZE = 65536,
};

enum {
	magic_FILE = 1162627398,
	magic_INDX = 1480871497,
	magic_HOLE = 1162628936,
	magic_RSTR = 1381258066,
	magic_RCRD = 1146241874,
	magic_CHKD = 1145784387,
	magic_BAAD = 1145127234,
	magic_empty = 4294967295,
};

enum {
	FILE_MFT = 0,
	FILE_MFTMirr = 1,
	FILE_LogFile = 2,
	FILE_Volume = 3,
	FILE_AttrDef = 4,
	FILE_root = 5,
	FILE_Bitmap = 6,
	FILE_Boot = 7,
	FILE_BadClus = 8,
	FILE_Secure = 9,
	FILE_UpCase = 10,
	FILE_Extend = 11,
	FILE_reserved12 = 12,
	FILE_reserved13 = 13,
	FILE_reserved14 = 14,
	FILE_reserved15 = 15,
	FILE_first_user = 16,
};

typedef u64 MFT_REF;

enum {
	FILE_ATTR_READONLY = 1,
	FILE_ATTR_HIDDEN = 2,
	FILE_ATTR_SYSTEM = 4,
	FILE_ATTR_DIRECTORY = 16,
	FILE_ATTR_ARCHIVE = 32,
	FILE_ATTR_DEVICE = 64,
	FILE_ATTR_NORMAL = 128,
	FILE_ATTR_TEMPORARY = 256,
	FILE_ATTR_SPARSE_FILE = 512,
	FILE_ATTR_REPARSE_POINT = 1024,
	FILE_ATTR_COMPRESSED = 2048,
	FILE_ATTR_OFFLINE = 4096,
	FILE_ATTR_NOT_CONTENT_INDEXED = 8192,
	FILE_ATTR_ENCRYPTED = 16384,
	FILE_ATTR_VALID_FLAGS = 32695,
	FILE_ATTR_VALID_SET_FLAGS = 12711,
	FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT = 268435456,
	FILE_ATTR_DUP_VIEW_INDEX_PRESENT = 536870912,
};

typedef le32 FILE_ATTR_FLAGS;

enum {
	FILE_NAME_POSIX = 0,
	FILE_NAME_WIN32 = 1,
	FILE_NAME_DOS = 2,
	FILE_NAME_WIN32_AND_DOS = 3,
};

typedef u8 FILE_NAME_TYPE_FLAGS;

typedef struct {
	leMFT_REF parent_directory;
	sle64 creation_time;
	sle64 last_data_change_time;
	sle64 last_mft_change_time;
	sle64 last_access_time;
	sle64 allocated_size;
	sle64 data_size;
	FILE_ATTR_FLAGS file_attributes;
	union {
		struct {
			le16 packed_ea_size;
			le16 reserved;
		} ea;
		struct {
			le32 reparse_point_tag;
		} rp;
	} type;
	u8 file_name_length;
	FILE_NAME_TYPE_FLAGS file_name_type;
	ntfschar file_name[0];
} __attribute__((packed)) FILE_NAME_ATTR;

typedef struct {
	le32 data1;
	le16 data2;
	le16 data3;
	u8 data4[8];
} GUID;

typedef union {
	struct {
		u16 high_part;
		u32 low_part;
	} __attribute__((packed)) parts;
	u8 value[6];
} SID_IDENTIFIER_AUTHORITY;

typedef struct {
	u8 revision;
	u8 sub_authority_count;
	SID_IDENTIFIER_AUTHORITY identifier_authority;
	le32 sub_authority[1];
} __attribute__((packed)) SID;

typedef struct {
	le32 security_id;
} SII_INDEX_KEY;

typedef struct {
	le32 hash;
	le32 security_id;
} SDH_INDEX_KEY;

enum {
	SMALL_INDEX = 0,
	LARGE_INDEX = 1,
	LEAF_NODE = 0,
	INDEX_NODE = 1,
	NODE_MASK = 1,
};

typedef u8 INDEX_HEADER_FLAGS;

typedef struct {
	le32 entries_offset;
	le32 index_length;
	le32 allocated_size;
	INDEX_HEADER_FLAGS flags;
	u8 reserved[3];
} INDEX_HEADER;

typedef struct {
	ATTR_TYPE type;
	COLLATION_RULE collation_rule;
	le32 index_block_size;
	u8 clusters_per_index_block;
	u8 reserved[3];
	INDEX_HEADER index;
} INDEX_ROOT;

typedef struct {
	NTFS_RECORD_TYPE magic;
	le16 usa_ofs;
	le16 usa_count;
	sle64 lsn;
	leVCN index_block_vcn;
	INDEX_HEADER index;
} INDEX_BLOCK;

typedef INDEX_BLOCK INDEX_ALLOCATION;

typedef struct {
	le32 reparse_tag;
	leMFT_REF file_id;
} REPARSE_INDEX_KEY;

enum {
	INDEX_ENTRY_NODE = 1,
	INDEX_ENTRY_END = 2,
	INDEX_ENTRY_SPACE_FILLER = 65535,
};

typedef le16 INDEX_ENTRY_FLAGS;

typedef struct {
	union {
		struct {
			leMFT_REF indexed_file;
		} dir;
		struct {
			le16 data_offset;
			le16 data_length;
			le32 reservedV;
		} vi;
	} data;
	le16 length;
	le16 key_length;
	INDEX_ENTRY_FLAGS flags;
	le16 reserved;
	union {
		FILE_NAME_ATTR file_name;
		SII_INDEX_KEY sii;
		SDH_INDEX_KEY sdh;
		GUID object_id;
		REPARSE_INDEX_KEY reparse;
		SID sid;
		le32 owner_id;
	} key;
} __attribute__((packed)) INDEX_ENTRY;

typedef struct {
	MFT_REF mref;
	FILE_NAME_TYPE_FLAGS type;
	u8 len;
	ntfschar name[0];
} __attribute__((packed)) ntfs_name;

enum {
	NTFS_BLOCK_SIZE = 512,
	NTFS_BLOCK_SIZE_BITS = 9,
	NTFS_SB_MAGIC = 1397118030,
	NTFS_MAX_NAME_LEN = 255,
	NTFS_MAX_ATTR_NAME_LEN = 255,
	NTFS_MAX_CLUSTER_SIZE = 65536,
	NTFS_MAX_PAGES_PER_CLUSTER = 16,
};

typedef struct {
	ntfs_inode *idx_ni;
	INDEX_ENTRY *entry;
	void *data;
	u16 data_len;
	bool is_in_root;
	INDEX_ROOT *ir;
	ntfs_attr_search_ctx *actx;
	ntfs_inode *base_ni;
	INDEX_ALLOCATION *ia;
	struct page *page;
} ntfs_index_context;

typedef sle64 leUSN;

enum {
	MFT_RECORD_IN_USE = 1,
	MFT_RECORD_IS_DIRECTORY = 2,
};

enum {
	ATTR_IS_COMPRESSED = 1,
	ATTR_COMPRESSION_MASK = 255,
	ATTR_IS_ENCRYPTED = 16384,
	ATTR_IS_SPARSE = 32768,
};

enum {
	RESIDENT_ATTR_IS_INDEXED = 1,
};

typedef struct {
	sle64 creation_time;
	sle64 last_data_change_time;
	sle64 last_mft_change_time;
	sle64 last_access_time;
	FILE_ATTR_FLAGS file_attributes;
	union {
		struct {
			u8 reserved12[12];
		} v1;
		struct {
			le32 maximum_versions;
			le32 version_number;
			le32 class_id;
			le32 owner_id;
			le32 security_id;
			le64 quota_charged;
			leUSN usn;
		} v3;
	} ver;
} STANDARD_INFORMATION;

typedef struct {
	long unsigned int mft_no;
	ntfschar *name;
	u32 name_len;
	ATTR_TYPE type;
} ntfs_attr;

typedef struct {
	int val;
	char *str;
} option_t;

typedef struct {
	le16 bytes_per_sector;
	u8 sectors_per_cluster;
	le16 reserved_sectors;
	u8 fats;
	le16 root_entries;
	le16 sectors;
	u8 media_type;
	le16 sectors_per_fat;
	le16 sectors_per_track;
	le16 heads;
	le32 hidden_sectors;
	le32 large_sectors;
} __attribute__((packed)) BIOS_PARAMETER_BLOCK;

typedef struct {
	u8 jump[3];
	le64 oem_id;
	BIOS_PARAMETER_BLOCK bpb;
	u8 unused[4];
	sle64 number_of_sectors;
	sle64 mft_lcn;
	sle64 mftmirr_lcn;
	s8 clusters_per_mft_record;
	u8 reserved0[3];
	s8 clusters_per_index_record;
	u8 reserved1[3];
	le64 volume_serial_number;
	le32 checksum;
	u8 bootstrap[426];
	le16 end_of_sector_marker;
} __attribute__((packed)) NTFS_BOOT_SECTOR;

typedef struct {
	le64 reserved;
	u8 major_ver;
	u8 minor_ver;
	VOLUME_FLAGS flags;
} VOLUME_INFORMATION;

enum {
	ON_ERRORS_PANIC = 1,
	ON_ERRORS_REMOUNT_RO = 2,
	ON_ERRORS_CONTINUE = 4,
	ON_ERRORS_RECOVER = 16,
};

struct ubi_volume_info {
	int ubi_num;
	int vol_id;
	int size;
	int: 32;
	long long int used_bytes;
	int used_ebs;
	int vol_type;
	int corrupted;
	int upd_marker;
	int alignment;
	int usable_leb_size;
	int name_len;
	const char *name;
	dev_t cdev;
	int: 32;
};

struct ubi_device_info {
	int ubi_num;
	int leb_size;
	int leb_start;
	int min_io_size;
	int max_write_size;
	int ro_mode;
	dev_t cdev;
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

enum {
	UBIFS_COMPR_NONE = 0,
	UBIFS_COMPR_LZO = 1,
	UBIFS_COMPR_ZLIB = 2,
	UBIFS_COMPR_ZSTD = 3,
	UBIFS_COMPR_TYPES_CNT = 4,
};

enum {
	UBIFS_INO_NODE = 0,
	UBIFS_DATA_NODE = 1,
	UBIFS_DENT_NODE = 2,
	UBIFS_XENT_NODE = 3,
	UBIFS_TRUN_NODE = 4,
	UBIFS_PAD_NODE = 5,
	UBIFS_SB_NODE = 6,
	UBIFS_MST_NODE = 7,
	UBIFS_REF_NODE = 8,
	UBIFS_IDX_NODE = 9,
	UBIFS_CS_NODE = 10,
	UBIFS_ORPH_NODE = 11,
	UBIFS_AUTH_NODE = 12,
	UBIFS_SIG_NODE = 13,
	UBIFS_NODE_TYPES_CNT = 14,
};

struct ubifs_ch {
	__le32 magic;
	__le32 crc;
	__le64 sqnum;
	__le32 len;
	__u8 node_type;
	__u8 group_type;
	__u8 padding[2];
};

struct ubifs_sb_node {
	struct ubifs_ch ch;
	__u8 padding[2];
	__u8 key_hash;
	__u8 key_fmt;
	__le32 flags;
	__le32 min_io_size;
	__le32 leb_size;
	__le32 leb_cnt;
	__le32 max_leb_cnt;
	__le64 max_bud_bytes;
	__le32 log_lebs;
	__le32 lpt_lebs;
	__le32 orph_lebs;
	__le32 jhead_cnt;
	__le32 fanout;
	__le32 lsave_cnt;
	__le32 fmt_version;
	__le16 default_compr;
	__u8 padding1[2];
	__le32 rp_uid;
	__le32 rp_gid;
	__le64 rp_size;
	__le32 time_gran;
	__u8 uuid[16];
	__le32 ro_compat_version;
	__u8 hmac[64];
	__u8 hmac_wkm[64];
	__le16 hash_algo;
	__u8 hash_mst[64];
	__u8 padding2[3774];
};

struct ubifs_mst_node {
	struct ubifs_ch ch;
	__le64 highest_inum;
	__le64 cmt_no;
	__le32 flags;
	__le32 log_lnum;
	__le32 root_lnum;
	__le32 root_offs;
	__le32 root_len;
	__le32 gc_lnum;
	__le32 ihead_lnum;
	__le32 ihead_offs;
	__le64 index_size;
	__le64 total_free;
	__le64 total_dirty;
	__le64 total_used;
	__le64 total_dead;
	__le64 total_dark;
	__le32 lpt_lnum;
	__le32 lpt_offs;
	__le32 nhead_lnum;
	__le32 nhead_offs;
	__le32 ltab_lnum;
	__le32 ltab_offs;
	__le32 lsave_lnum;
	__le32 lsave_offs;
	__le32 lscan_lnum;
	__le32 empty_lebs;
	__le32 idx_lebs;
	__le32 leb_cnt;
	__u8 hash_root_idx[64];
	__u8 hash_lpt[64];
	__u8 hmac[64];
	__u8 padding[152];
};

enum {
	DIRTY_ZNODE = 0,
	COW_ZNODE = 1,
	OBSOLETE_ZNODE = 2,
};

enum {
	COMMIT_RESTING = 0,
	COMMIT_BACKGROUND = 1,
	COMMIT_REQUIRED = 2,
	COMMIT_RUNNING_BACKGROUND = 3,
	COMMIT_RUNNING_REQUIRED = 4,
	COMMIT_BROKEN = 5,
};

union ubifs_key {
	uint8_t u8[8];
	uint32_t u32[2];
	uint64_t u64[1];
	__le32 j32[2];
};

enum {
	LPROPS_UNCAT = 0,
	LPROPS_DIRTY = 1,
	LPROPS_DIRTY_IDX = 2,
	LPROPS_FREE = 3,
	LPROPS_HEAP_CNT = 3,
	LPROPS_EMPTY = 4,
	LPROPS_FREEABLE = 5,
	LPROPS_FRDI_IDX = 6,
	LPROPS_CAT_MASK = 15,
	LPROPS_TAKEN = 16,
	LPROPS_INDEX = 32,
};

struct ubifs_lprops {
	int free;
	int dirty;
	int flags;
	int lnum;
	union {
		struct list_head list;
		int hpos;
	};
};

struct ubifs_lpt_lprops {
	int free;
	int dirty;
	unsigned int tgc: 1;
	unsigned int cmt: 1;
};

struct ubifs_lp_stats {
	int empty_lebs;
	int taken_empty_lebs;
	int idx_lebs;
	int: 32;
	long long int total_free;
	long long int total_dirty;
	long long int total_used;
	long long int total_dead;
	long long int total_dark;
};

struct ubifs_nnode;

struct ubifs_cnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
};

struct ubifs_pnode;

struct ubifs_nbranch {
	int lnum;
	int offs;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	};
};

struct ubifs_nnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_nbranch nbranch[4];
};

struct ubifs_pnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_lprops lprops[4];
};

struct ubifs_lpt_heap {
	struct ubifs_lprops **arr;
	int cnt;
	int max_cnt;
};

struct ubifs_znode;

struct ubifs_zbranch {
	union ubifs_key key;
	union {
		struct ubifs_znode *znode;
		void *leaf;
	};
	int lnum;
	int offs;
	int len;
	u8 hash[0];
};

struct bu_info {
	union ubifs_key key;
	struct ubifs_zbranch zbranch[32];
	void *buf;
	int buf_len;
	int gc_seq;
	int cnt;
	int blk_cnt;
	int eof;
};

struct ubifs_budg_info {
	long long int idx_growth;
	long long int data_growth;
	long long int dd_growth;
	long long int uncommitted_idx;
	long long unsigned int old_idx_sz;
	int min_idx_lebs;
	unsigned int nospace: 1;
	unsigned int nospace_rp: 1;
	int page_budget;
	int inode_budget;
	int dent_budget;
	int: 32;
};

struct ubifs_node_range {
	union {
		int len;
		int min_len;
	};
	int max_len;
};

struct ubi_volume_desc;

struct ubifs_mount_opts {
	unsigned int unmount_mode: 2;
	unsigned int bulk_read: 2;
	unsigned int chk_data_crc: 2;
	unsigned int override_compr: 1;
	unsigned int compr_type: 2;
};

struct ubifs_jhead;

struct ubifs_orphan;

struct ubifs_debug_info;

struct ubifs_info {
	struct super_block *vfs_sb;
	struct ubifs_sb_node *sup_node;
	ino_t highest_inum;
	int: 32;
	long long unsigned int max_sqnum;
	long long unsigned int cmt_no;
	spinlock_t cnt_lock;
	int fmt_version;
	int ro_compat_version;
	unsigned char uuid[16];
	int lhead_lnum;
	int lhead_offs;
	int ltail_lnum;
	struct mutex log_mutex;
	int min_log_bytes;
	long long int cmt_bud_bytes;
	struct rb_root buds;
	int: 32;
	long long int bud_bytes;
	spinlock_t buds_lock;
	int jhead_cnt;
	struct ubifs_jhead *jheads;
	int: 32;
	long long int max_bud_bytes;
	long long int bg_bud_bytes;
	struct list_head old_buds;
	int max_bud_cnt;
	struct rw_semaphore commit_sem;
	int cmt_state;
	spinlock_t cs_lock;
	wait_queue_head_t cmt_wq;
	unsigned int big_lpt: 1;
	unsigned int space_fixup: 1;
	unsigned int double_hash: 1;
	unsigned int encrypted: 1;
	unsigned int no_chk_data_crc: 1;
	unsigned int bulk_read: 1;
	unsigned int default_compr: 2;
	unsigned int rw_incompat: 1;
	unsigned int assert_action: 2;
	unsigned int authenticated: 1;
	unsigned int superblock_need_write: 1;
	struct mutex tnc_mutex;
	struct ubifs_zbranch zroot;
	struct ubifs_znode *cnext;
	struct ubifs_znode *enext;
	int *gap_lebs;
	void *cbuf;
	void *ileb_buf;
	int ileb_len;
	int ihead_lnum;
	int ihead_offs;
	int *ilebs;
	int ileb_cnt;
	int ileb_nxt;
	struct rb_root old_idx;
	int *bottom_up_buf;
	struct ubifs_mst_node *mst_node;
	int mst_offs;
	int max_bu_buf_len;
	struct mutex bu_mutex;
	int: 32;
	struct bu_info bu;
	struct mutex write_reserve_mutex;
	void *write_reserve_buf;
	int log_lebs;
	int: 32;
	long long int log_bytes;
	int log_last;
	int lpt_lebs;
	int lpt_first;
	int lpt_last;
	int orph_lebs;
	int orph_first;
	int orph_last;
	int main_lebs;
	int main_first;
	int: 32;
	long long int main_bytes;
	uint8_t key_hash_type;
	uint32_t (*key_hash)(const char *, int);
	int key_fmt;
	int key_len;
	int hash_len;
	int fanout;
	int min_io_size;
	int min_io_shift;
	int max_write_size;
	int max_write_shift;
	int leb_size;
	int leb_start;
	int half_leb_size;
	int idx_leb_size;
	int leb_cnt;
	int max_leb_cnt;
	unsigned int ro_media: 1;
	unsigned int ro_mount: 1;
	unsigned int ro_error: 1;
	atomic_long_t dirty_pg_cnt;
	atomic_long_t dirty_zn_cnt;
	atomic_long_t clean_zn_cnt;
	spinlock_t space_lock;
	int: 32;
	struct ubifs_lp_stats lst;
	struct ubifs_budg_info bi;
	long long unsigned int calc_idx_sz;
	int ref_node_alsz;
	int mst_node_alsz;
	int min_idx_node_sz;
	int max_idx_node_sz;
	long long int max_inode_sz;
	int max_znode_sz;
	int leb_overhead;
	int dead_wm;
	int dark_wm;
	int block_cnt;
	struct ubifs_node_range ranges[14];
	struct ubi_volume_desc *ubi;
	struct ubi_device_info di;
	int: 32;
	struct ubi_volume_info vi;
	struct rb_root orph_tree;
	struct list_head orph_list;
	struct list_head orph_new;
	struct ubifs_orphan *orph_cnext;
	struct ubifs_orphan *orph_dnext;
	spinlock_t orphan_lock;
	void *orph_buf;
	int new_orphans;
	int cmt_orphans;
	int tot_orphans;
	int max_orphans;
	int ohead_lnum;
	int ohead_offs;
	int no_orphs;
	struct task_struct *bgt;
	char bgt_name[24];
	int need_bgt;
	int need_wbuf_sync;
	int gc_lnum;
	void *sbuf;
	struct list_head idx_gc;
	int idx_gc_cnt;
	int gc_seq;
	int gced_lnum;
	struct list_head infos_list;
	struct mutex umount_mutex;
	unsigned int shrinker_run_no;
	int space_bits;
	int lpt_lnum_bits;
	int lpt_offs_bits;
	int lpt_spc_bits;
	int pcnt_bits;
	int lnum_bits;
	int nnode_sz;
	int pnode_sz;
	int ltab_sz;
	int lsave_sz;
	int pnode_cnt;
	int nnode_cnt;
	int lpt_hght;
	int pnodes_have;
	struct mutex lp_mutex;
	int lpt_lnum;
	int lpt_offs;
	int nhead_lnum;
	int nhead_offs;
	int lpt_drty_flgs;
	int dirty_nn_cnt;
	int dirty_pn_cnt;
	int check_lpt_free;
	int: 32;
	long long int lpt_sz;
	void *lpt_nod_buf;
	void *lpt_buf;
	struct ubifs_nnode *nroot;
	struct ubifs_cnode *lpt_cnext;
	struct ubifs_lpt_heap lpt_heap[3];
	struct ubifs_lpt_heap dirty_idx;
	struct list_head uncat_list;
	struct list_head empty_list;
	struct list_head freeable_list;
	struct list_head frdi_idx_list;
	int freeable_cnt;
	int in_a_category_cnt;
	int ltab_lnum;
	int ltab_offs;
	struct ubifs_lpt_lprops *ltab;
	struct ubifs_lpt_lprops *ltab_cmt;
	int lsave_cnt;
	int lsave_lnum;
	int lsave_offs;
	int *lsave;
	int lscan_lnum;
	int: 32;
	long long int rp_size;
	long long int report_rp_size;
	kuid_t rp_uid;
	kgid_t rp_gid;
	struct crypto_shash *hash_tfm;
	struct crypto_shash *hmac_tfm;
	int hmac_desc_len;
	char *auth_key_name;
	char *auth_hash_name;
	enum hash_algo auth_hash_algo;
	struct shash_desc *log_hash;
	unsigned int empty: 1;
	unsigned int need_recovery: 1;
	unsigned int replaying: 1;
	unsigned int mounting: 1;
	unsigned int remounting_rw: 1;
	unsigned int probing: 1;
	struct list_head replay_list;
	struct list_head replay_buds;
	long long unsigned int cs_sqnum;
	struct list_head unclean_leb_list;
	struct ubifs_mst_node *rcvrd_mst_node;
	struct rb_root size_tree;
	struct ubifs_mount_opts mount_opts;
	struct ubifs_debug_info *dbg;
};

struct ubifs_wbuf {
	struct ubifs_info *c;
	void *buf;
	int lnum;
	int offs;
	int avail;
	int used;
	int size;
	int jhead;
	int (*sync_callback)(struct ubifs_info *, int, int, int);
	struct mutex io_mutex;
	spinlock_t lock;
	int: 32;
	struct hrtimer timer;
	unsigned int no_timer: 1;
	unsigned int need_sync: 1;
	int next_ino;
	ino_t *inodes;
	int: 32;
};

struct ubifs_jhead {
	struct ubifs_wbuf wbuf;
	struct list_head buds_list;
	unsigned int grouped: 1;
	struct shash_desc *log_hash;
};

struct ubifs_znode {
	struct ubifs_znode *parent;
	struct ubifs_znode *cnext;
	struct ubifs_znode *cparent;
	int ciip;
	long unsigned int flags;
	int: 32;
	time64_t time;
	int level;
	int child_cnt;
	int iip;
	int alt;
	int lnum;
	int offs;
	int len;
	int: 32;
	struct ubifs_zbranch zbranch[0];
};

struct ubifs_orphan {
	struct rb_node rb;
	struct list_head list;
	struct list_head new_list;
	struct list_head child_list;
	struct ubifs_orphan *cnext;
	struct ubifs_orphan *dnext;
	ino_t inum;
	unsigned int new: 1;
	unsigned int cmt: 1;
	unsigned int del: 1;
};

struct ubifs_debug_info {
	struct ubifs_zbranch old_zroot;
	int old_zroot_level;
	int: 32;
	long long unsigned int old_zroot_sqnum;
	int pc_happened;
	int pc_delay;
	long unsigned int pc_timeout;
	unsigned int pc_cnt;
	unsigned int pc_cnt_max;
	int: 32;
	long long int chk_lpt_sz;
	long long int chk_lpt_sz2;
	long long int chk_lpt_wastage;
	int chk_lpt_lebs;
	int new_nhead_offs;
	int new_ihead_lnum;
	int new_ihead_offs;
	struct ubifs_lp_stats saved_lst;
	struct ubifs_budg_info saved_bi;
	long long int saved_free;
	int saved_idx_gc_cnt;
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
	char dfs_dir_name[10];
	struct dentry *dfs_dir;
	struct dentry *dfs_dump_lprops;
	struct dentry *dfs_dump_budg;
	struct dentry *dfs_dump_tnc;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_index;
	struct dentry *dfs_chk_orph;
	struct dentry *dfs_chk_lprops;
	struct dentry *dfs_chk_fs;
	struct dentry *dfs_tst_rcvry;
	struct dentry *dfs_ro_error;
	int: 32;
};

enum {
	UBIFS_ITYPE_REG = 0,
	UBIFS_ITYPE_DIR = 1,
	UBIFS_ITYPE_LNK = 2,
	UBIFS_ITYPE_BLK = 3,
	UBIFS_ITYPE_CHR = 4,
	UBIFS_ITYPE_FIFO = 5,
	UBIFS_ITYPE_SOCK = 6,
	UBIFS_ITYPES_CNT = 7,
};

enum {
	UBIFS_INO_KEY = 0,
	UBIFS_DATA_KEY = 1,
	UBIFS_DENT_KEY = 2,
	UBIFS_XENT_KEY = 3,
	UBIFS_KEY_TYPES_CNT = 4,
};

enum {
	UBIFS_COMPR_FL = 1,
	UBIFS_SYNC_FL = 2,
	UBIFS_IMMUTABLE_FL = 4,
	UBIFS_APPEND_FL = 8,
	UBIFS_DIRSYNC_FL = 16,
	UBIFS_XATTR_FL = 32,
	UBIFS_CRYPT_FL = 64,
};

struct ubifs_ino_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 creat_sqnum;
	__le64 size;
	__le64 atime_sec;
	__le64 ctime_sec;
	__le64 mtime_sec;
	__le32 atime_nsec;
	__le32 ctime_nsec;
	__le32 mtime_nsec;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le32 flags;
	__le32 data_len;
	__le32 xattr_cnt;
	__le32 xattr_size;
	__u8 padding1[4];
	__le32 xattr_names;
	__le16 compr_type;
	__u8 padding2[26];
	__u8 data[0];
};

struct ubifs_dent_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 inum;
	__u8 padding1;
	__u8 type;
	__le16 nlen;
	__le32 cookie;
	__u8 name[0];
};

struct ubifs_data_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le32 size;
	__le16 compr_type;
	__le16 compr_size;
	__u8 data[0];
};

struct ubifs_trun_node {
	struct ubifs_ch ch;
	__le32 inum;
	__u8 padding[12];
	__le64 old_size;
	__le64 new_size;
};

struct ubifs_inode {
	struct inode vfs_inode;
	long long unsigned int creat_sqnum;
	long long unsigned int del_cmtno;
	unsigned int xattr_size;
	unsigned int xattr_cnt;
	unsigned int xattr_names;
	unsigned int dirty: 1;
	unsigned int xattr: 1;
	unsigned int bulk_read: 1;
	unsigned int compr_type: 2;
	struct mutex ui_mutex;
	spinlock_t ui_lock;
	loff_t synced_i_size;
	loff_t ui_size;
	int flags;
	long unsigned int last_page_read;
	long unsigned int read_in_a_row;
	int data_len;
	void *data;
	int: 32;
};

struct ubifs_budget_req {
	unsigned int fast: 1;
	unsigned int recalculate: 1;
	unsigned int new_page: 1;
	unsigned int dirtied_page: 1;
	unsigned int new_dent: 1;
	unsigned int mod_dent: 1;
	unsigned int new_ino: 1;
	unsigned int new_ino_d: 13;
	unsigned int dirtied_ino: 4;
	char: 8;
	unsigned int dirtied_ino_d: 15;
	int idx_growth;
	int data_growth;
	int dd_growth;
};

union ubifs_dev_desc {
	__le32 new;
	__le64 huge;
};

struct ubifs_global_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
};

enum {
	UBI_DYNAMIC_VOLUME = 3,
	UBI_STATIC_VOLUME = 4,
};

enum {
	UBI_READONLY = 1,
	UBI_READWRITE = 2,
	UBI_EXCLUSIVE = 3,
	UBI_METAONLY = 4,
};

struct crypto_comp {
	struct crypto_tfm base;
};

enum {
	UBIFS_SIMPLE_KEY_FMT = 0,
};

enum {
	UBIFS_MST_DIRTY = 1,
	UBIFS_MST_NO_ORPHS = 2,
	UBIFS_MST_RCVRY = 4,
};

enum {
	ASSACT_REPORT = 0,
	ASSACT_RO = 1,
	ASSACT_PANIC = 2,
};

struct ubifs_unclean_leb {
	struct list_head list;
	int lnum;
	int endpt;
};

struct ubifs_bud {
	int lnum;
	int start;
	int jhead;
	struct list_head list;
	struct rb_node rb;
	struct shash_desc *log_hash;
};

struct ubifs_compressor {
	int compr_type;
	struct crypto_comp *cc;
	struct mutex *comp_mutex;
	struct mutex *decomp_mutex;
	const char *name;
	const char *capi_name;
};

struct fscrypt_operations;

enum {
	Opt_fast_unmount = 0,
	Opt_norm_unmount = 1,
	Opt_bulk_read = 2,
	Opt_no_bulk_read = 3,
	Opt_chk_data_crc = 4,
	Opt_no_chk_data_crc = 5,
	Opt_override_compr = 6,
	Opt_assert = 7,
	Opt_auth_key = 8,
	Opt_auth_hash_name = 9,
	Opt_ignore = 10,
	Opt_err___4 = 11,
};

enum {
	UBIFS_KEY_HASH_R5 = 0,
	UBIFS_KEY_HASH_TEST = 1,
};

enum {
	UBIFS_FLG_BIGLPT = 2,
	UBIFS_FLG_SPACE_FIXUP = 4,
	UBIFS_FLG_DOUBLE_HASH = 8,
	UBIFS_FLG_ENCRYPTION = 16,
	UBIFS_FLG_AUTHENTICATION = 32,
};

struct ubifs_branch {
	__le32 lnum;
	__le32 offs;
	__le32 len;
	__u8 key[0];
};

struct ubifs_idx_node {
	struct ubifs_ch ch;
	__le16 child_cnt;
	__le16 level;
	__u8 branches[0];
};

struct ubifs_cs_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
};

enum {
	UBIFS_NO_NODE_GROUP = 0,
	UBIFS_IN_NODE_GROUP = 1,
	UBIFS_LAST_OF_NODE_GROUP = 2,
};

struct ubifs_pad_node {
	struct ubifs_ch ch;
	__le32 pad_len;
};

struct ubifs_old_idx {
	struct rb_node rb;
	int lnum;
	int offs;
};

enum {
	NAME_LESS = 0,
	NAME_MATCHES = 1,
	NAME_GREATER = 2,
	NOT_ON_MEDIA = 3,
};

struct ubifs_scan_node {
	struct list_head list;
	union ubifs_key key;
	long long unsigned int sqnum;
	int type;
	int offs;
	int len;
	void *node;
};

struct ubifs_scan_leb {
	int lnum;
	int nodes_cnt;
	struct list_head nodes;
	int endpt;
	void *buf;
};

enum {
	SCANNED_GARBAGE = 0,
	SCANNED_EMPTY_SPACE = 4294967295,
	SCANNED_A_NODE = 4294967294,
	SCANNED_A_CORRUPT_NODE = 4294967293,
	SCANNED_A_BAD_PAD_NODE = 4294967292,
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	unsigned int descsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	unsigned int digestsize;
	unsigned int statesize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct ubifs_ref_node {
	struct ubifs_ch ch;
	__le32 lnum;
	__le32 offs;
	__le32 jhead;
	__u8 padding[28];
};

struct ubifs_auth_node {
	struct ubifs_ch ch;
	__u8 hmac[0];
};

struct replay_entry {
	int lnum;
	int offs;
	int len;
	u8 hash[0];
	unsigned int deletion: 1;
	long long unsigned int sqnum;
	struct list_head list;
	union ubifs_key key;
	union {
		struct fscrypt_name nm;
		struct {
			loff_t old_size;
			loff_t new_size;
		};
	};
};

struct bud_entry {
	struct list_head list;
	struct ubifs_bud *bud;
	int: 32;
	long long unsigned int sqnum;
	int free;
	int dirty;
};

struct done_ref {
	struct rb_node rb;
	int lnum;
};

enum {
	DIRTY_CNODE = 0,
	OBSOLETE_CNODE = 1,
	COW_CNODE = 2,
};

struct idx_node {
	struct list_head list;
	int iip;
	int: 32;
	union ubifs_key upper_key;
	struct ubifs_idx_node idx;
	int: 32;
};

enum {
	LEB_FREED = 0,
	LEB_FREED_IDX = 1,
	LEB_RETAINED = 2,
};

struct ubifs_gced_idx_leb {
	struct list_head list;
	int lnum;
	int unmap;
};

struct ubifs_orph_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
	__le64 inos[0];
};

struct check_orphan {
	struct rb_node rb;
	ino_t inum;
};

struct check_info {
	long unsigned int last_ino;
	long unsigned int tot_inos;
	long unsigned int missing;
	int: 32;
	long long unsigned int leaf_cnt;
	struct ubifs_ino_node *node;
	struct rb_root root;
};

enum {
	LPT_SCAN_CONTINUE = 0,
	LPT_SCAN_ADD = 1,
	LPT_SCAN_STOP = 2,
};

typedef int (*ubifs_lpt_scan_callback)(struct ubifs_info *, const struct ubifs_lprops *, int, void *);

struct scan_data {
	int min_space;
	int pick_free;
	int lnum;
	int exclude_index;
};

typedef u16 uint16_t;

enum {
	UBIFS_LPT_PNODE = 0,
	UBIFS_LPT_NNODE = 1,
	UBIFS_LPT_LTAB = 2,
	UBIFS_LPT_LSAVE = 3,
	UBIFS_LPT_NODE_CNT = 4,
	UBIFS_LPT_NOT_A_NODE = 15,
};

enum {
	LTAB_DIRTY = 1,
	LSAVE_DIRTY = 2,
};

struct lpt_scan_node {
	union {
		struct ubifs_nnode nnode;
		struct ubifs_pnode pnode;
		struct ubifs_cnode cnode;
	};
	int in_tree;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	} ptr;
};

struct size_entry {
	struct rb_node rb;
	ino_t inum;
	loff_t i_size;
	loff_t d_size;
	int exists;
	struct inode *inode;
};

typedef int (*dbg_leaf_callback)(struct ubifs_info *, struct ubifs_zbranch *, void *);

typedef int (*dbg_znode_callback)(struct ubifs_info *, struct ubifs_znode *, void *);

struct fsck_inode {
	struct rb_node rb;
	ino_t inum;
	umode_t mode;
	unsigned int nlink;
	unsigned int xattr_cnt;
	int references;
	int calc_cnt;
	int: 32;
	long long int size;
	unsigned int xattr_sz;
	int: 32;
	long long int calc_sz;
	long long int calc_xcnt;
	long long int calc_xsz;
	unsigned int xattr_nms;
	int: 32;
	long long int calc_xnms;
};

struct fsck_data {
	struct rb_root inodes;
};

typedef unsigned int autofs_wqt_t;

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	struct inode *inode;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	int: 32;
	struct qstr name;
	u32 dev;
	int: 32;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

enum {
	Opt_err___5 = 0,
	Opt_fd = 1,
	Opt_uid___4 = 2,
	Opt_gid___5 = 3,
	Opt_pgrp = 4,
	Opt_minproto = 5,
	Opt_maxproto = 6,
	Opt_indirect = 7,
	Opt_direct = 8,
	Opt_offset = 9,
	Opt_strictexpire = 10,
	Opt_ignore___2 = 11,
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
	int: 32;
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum {
	Opt_uid___5 = 0,
	Opt_gid___6 = 1,
	Opt_mode___4 = 2,
	Opt_err___6 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

enum pstore_type_id {
	PSTORE_TYPE_DMESG = 0,
	PSTORE_TYPE_MCE = 1,
	PSTORE_TYPE_CONSOLE = 2,
	PSTORE_TYPE_FTRACE = 3,
	PSTORE_TYPE_PPC_RTAS = 4,
	PSTORE_TYPE_PPC_OF = 5,
	PSTORE_TYPE_PPC_COMMON = 6,
	PSTORE_TYPE_PMSG = 7,
	PSTORE_TYPE_PPC_OPAL = 8,
	PSTORE_TYPE_MAX = 9,
};

struct pstore_info;

struct pstore_record {
	struct pstore_info *psi;
	enum pstore_type_id type;
	u64 id;
	struct timespec64 time;
	char *buf;
	ssize_t size;
	ssize_t ecc_notice_size;
	int count;
	enum kmsg_dump_reason reason;
	unsigned int part;
	bool compressed;
	int: 24;
	int: 32;
};

struct pstore_info {
	struct module *owner;
	const char *name;
	struct semaphore buf_lock;
	char *buf;
	size_t bufsize;
	struct mutex read_mutex;
	int flags;
	int max_reason;
	void *data;
	int (*open)(struct pstore_info *);
	int (*close)(struct pstore_info *);
	ssize_t (*read)(struct pstore_record *);
	int (*write)(struct pstore_record *);
	int (*write_user)(struct pstore_record *, const char *);
	int (*erase)(struct pstore_record *);
};

struct pstore_ftrace_record {
	long unsigned int ip;
	long unsigned int parent_ip;
	u64 ts;
};

struct pstore_private {
	struct list_head list;
	struct dentry *dentry;
	struct pstore_record *record;
	size_t total_size;
};

struct pstore_ftrace_seq_data {
	const void *ptr;
	size_t off;
	size_t size;
};

enum {
	Opt_kmsg_bytes = 0,
	Opt_err___7 = 1,
};

struct pstore_zbackend {
	int (*zbufsize)(size_t);
	const char *name;
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

struct persistent_ram_ecc_info {
	int block_size;
	int ecc_size;
	int symsize;
	int poly;
	uint16_t *par;
};

struct persistent_ram_buffer;

struct rs_control;

struct persistent_ram_zone {
	phys_addr_t paddr;
	size_t size;
	void *vaddr;
	char *label;
	enum pstore_type_id type;
	u32 flags;
	raw_spinlock_t buffer_lock;
	struct persistent_ram_buffer *buffer;
	size_t buffer_size;
	char *par_buffer;
	char *par_header;
	struct rs_control *rs_decoder;
	int corrected_bytes;
	int bad_blocks;
	struct persistent_ram_ecc_info ecc_info;
	char *old_log;
	size_t old_log_size;
};

struct ramoops_platform_data {
	long unsigned int mem_size;
	phys_addr_t mem_address;
	unsigned int mem_type;
	long unsigned int record_size;
	long unsigned int console_size;
	long unsigned int ftrace_size;
	long unsigned int pmsg_size;
	int max_reason;
	u32 flags;
	struct persistent_ram_ecc_info ecc_info;
};

struct ramoops_context {
	struct persistent_ram_zone **dprzs;
	struct persistent_ram_zone *cprz;
	struct persistent_ram_zone **fprzs;
	struct persistent_ram_zone *mprz;
	phys_addr_t phys_addr;
	long unsigned int size;
	unsigned int memtype;
	size_t record_size;
	size_t console_size;
	size_t ftrace_size;
	size_t pmsg_size;
	u32 flags;
	struct persistent_ram_ecc_info ecc_info;
	unsigned int max_dump_cnt;
	unsigned int dump_write_cnt;
	unsigned int dump_read_cnt;
	unsigned int console_read_cnt;
	unsigned int max_ftrace_cnt;
	unsigned int ftrace_read_cnt;
	unsigned int pmsg_read_cnt;
	struct pstore_info pstore;
};

struct persistent_ram_buffer {
	uint32_t sig;
	atomic_t start;
	atomic_t size;
	uint8_t data[0];
};

struct rs_codec;

struct rs_control {
	struct rs_codec *codec;
	uint16_t buffers[0];
};

struct rs_codec {
	int mm;
	int nn;
	uint16_t *alpha_to;
	uint16_t *index_of;
	uint16_t *genpoly;
	int nroots;
	int fcr;
	int prim;
	int iprim;
	int gfpoly;
	int (*gffunc)(int);
	int users;
	struct list_head list;
};

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[2];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	int: 32;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef short unsigned int __kernel_ipc_pid_t;

typedef __kernel_long_t __kernel_old_time_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long unsigned int msg_stime;
	long unsigned int msg_stime_high;
	long unsigned int msg_rtime;
	long unsigned int msg_rtime_high;
	long unsigned int msg_ctime;
	long unsigned int msg_ctime_high;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	int: 32;
	time64_t sem_otime;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sembuf;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	long unsigned int sem_otime;
	long unsigned int sem_otime_high;
	long unsigned int sem_ctime;
	long unsigned int sem_ctime_high;
	long unsigned int sem_nsems;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sem sems[0];
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	size_t shm_segsz;
	long unsigned int shm_atime;
	long unsigned int shm_atime_high;
	long unsigned int shm_dtime;
	long unsigned int shm_dtime_high;
	long unsigned int shm_ctime;
	long unsigned int shm_ctime_high;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	int: 32;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct user_struct *mlock_user;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

struct assoc_array_edit;

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit___2 {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	int: 32;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

enum {
	Opt_err___8 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_engine {
	char name[30];
	bool idling;
	bool busy;
	bool running;
	bool retry_support;
	struct list_head list;
	spinlock_t queue_lock;
	struct crypto_queue queue;
	struct device *dev;
	bool rt;
	int (*prepare_crypt_hardware)(struct crypto_engine *);
	int (*unprepare_crypt_hardware)(struct crypto_engine *);
	int (*do_batch_requests)(struct crypto_engine *);
	struct kthread_worker *kworker;
	struct kthread_work pump_requests;
	void *priv_data;
	struct crypto_async_request *cur_req;
};

struct crypto_engine_op {
	int (*prepare_request)(struct crypto_engine *, void *);
	int (*unprepare_request)(struct crypto_engine *, void *);
	int (*do_one_request)(struct crypto_engine *, void *);
};

struct crypto_engine_ctx {
	struct crypto_engine_op op;
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	CRYPTOA_U32 = 3,
	__CRYPTOA_MAX = 4,
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_attr_u32 {
	u32 num;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_skcipher {
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher___2 {
	struct crypto_skcipher base;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_ahash;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct hash_alg_common halg;
};

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *ubuf[0];
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_kpp {
	struct crypto_tfm base;
};

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
};

struct asn1_decoder___2;

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	union {
		struct rtattr attr;
		struct {
			struct rtattr attr;
			struct crypto_attr_alg data;
		} alg;
		struct {
			struct rtattr attr;
			struct crypto_attr_u32 data;
		} nu32;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct cmac_tfm_ctx {
	struct crypto_cipher *child;
	u8 ctx[0];
};

struct cmac_desc_ctx {
	unsigned int len;
	u8 ctx[0];
};

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

typedef struct {
	u64 a;
	u64 b;
} u128;

typedef struct {
	__be64 a;
	__be64 b;
} be128;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct skcipher_request subreq;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	int: 32;
	int: 32;
	struct aead_request subreq;
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher___2 *null;
	u8 nonce[4];
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct ccm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn mac;
};

struct crypto_ccm_ctx {
	struct crypto_ahash *mac;
	struct crypto_skcipher *ctr;
};

struct crypto_rfc4309_ctx {
	struct crypto_aead *child;
	u8 nonce[3];
};

struct crypto_rfc4309_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	int: 32;
	int: 32;
	struct aead_request subreq;
};

struct crypto_ccm_req_priv_ctx {
	u8 odata[16];
	u8 idata[16];
	u8 auth_tag[16];
	u32 flags;
	struct scatterlist src[3];
	struct scatterlist dst[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	};
};

struct cbcmac_tfm_ctx {
	struct crypto_cipher *child;
};

struct cbcmac_desc_ctx {
	unsigned int len;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct deflate_ctx {
	struct z_stream_s comp_stream;
	struct z_stream_s decomp_stream;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx {
	u8 buffer[16];
	u32 bytes;
};

typedef enum {
	ZSTD_fast = 0,
	ZSTD_dfast = 1,
	ZSTD_greedy = 2,
	ZSTD_lazy = 3,
	ZSTD_lazy2 = 4,
	ZSTD_btlazy2 = 5,
	ZSTD_btopt = 6,
	ZSTD_btopt2 = 7,
} ZSTD_strategy;

typedef struct {
	unsigned int windowLog;
	unsigned int chainLog;
	unsigned int hashLog;
	unsigned int searchLog;
	unsigned int searchLength;
	unsigned int targetLength;
	ZSTD_strategy strategy;
} ZSTD_compressionParameters;

typedef struct {
	unsigned int contentSizeFlag;
	unsigned int checksumFlag;
	unsigned int noDictIDFlag;
} ZSTD_frameParameters;

typedef struct {
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
} ZSTD_parameters;

struct ZSTD_CCtx_s;

typedef struct ZSTD_CCtx_s ZSTD_CCtx;

struct ZSTD_DCtx_s;

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

struct zstd_ctx {
	ZSTD_CCtx *cctx;
	ZSTD_DCtx *dctx;
	void *cwksp;
	void *dwksp;
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[2];
};

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[2];
	u8 *s;
	u32 s_size;
	u8 *digest;
	u8 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
	const void *data;
	unsigned int data_size;
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecdsa_with_sha1 = 2,
	OID_id_ecPublicKey = 3,
	OID_rsaEncryption = 4,
	OID_md2WithRSAEncryption = 5,
	OID_md3WithRSAEncryption = 6,
	OID_md4WithRSAEncryption = 7,
	OID_sha1WithRSAEncryption = 8,
	OID_sha256WithRSAEncryption = 9,
	OID_sha384WithRSAEncryption = 10,
	OID_sha512WithRSAEncryption = 11,
	OID_sha224WithRSAEncryption = 12,
	OID_data = 13,
	OID_signed_data = 14,
	OID_email_address = 15,
	OID_contentType = 16,
	OID_messageDigest = 17,
	OID_signingTime = 18,
	OID_smimeCapabilites = 19,
	OID_smimeAuthenticatedAttrs = 20,
	OID_md2 = 21,
	OID_md4 = 22,
	OID_md5 = 23,
	OID_msIndirectData = 24,
	OID_msStatementType = 25,
	OID_msSpOpusInfo = 26,
	OID_msPeImageDataObjId = 27,
	OID_msIndividualSPKeyPurpose = 28,
	OID_msOutlookExpress = 29,
	OID_certAuthInfoAccess = 30,
	OID_sha1 = 31,
	OID_sha256 = 32,
	OID_sha384 = 33,
	OID_sha512 = 34,
	OID_sha224 = 35,
	OID_commonName = 36,
	OID_surname = 37,
	OID_countryName = 38,
	OID_locality = 39,
	OID_stateOrProvinceName = 40,
	OID_organizationName = 41,
	OID_organizationUnitName = 42,
	OID_title = 43,
	OID_description = 44,
	OID_name = 45,
	OID_givenName = 46,
	OID_initials = 47,
	OID_generationalQualifier = 48,
	OID_subjectKeyIdentifier = 49,
	OID_keyUsage = 50,
	OID_subjectAltName = 51,
	OID_issuerAltName = 52,
	OID_basicConstraints = 53,
	OID_crlDistributionPoints = 54,
	OID_certPolicies = 55,
	OID_authorityKeyIdentifier = 56,
	OID_extKeyUsage = 57,
	OID_gostCPSignA = 58,
	OID_gostCPSignB = 59,
	OID_gostCPSignC = 60,
	OID_gost2012PKey256 = 61,
	OID_gost2012PKey512 = 62,
	OID_gost2012Digest256 = 63,
	OID_gost2012Digest512 = 64,
	OID_gost2012Signature256 = 65,
	OID_gost2012Signature512 = 66,
	OID_gostTC26Sign256A = 67,
	OID_gostTC26Sign256B = 68,
	OID_gostTC26Sign256C = 69,
	OID_gostTC26Sign256D = 70,
	OID_gostTC26Sign512A = 71,
	OID_gostTC26Sign512B = 72,
	OID_gostTC26Sign512C = 73,
	OID_sm2 = 74,
	OID_sm3 = 75,
	OID_SM2_with_SM3 = 76,
	OID_sm3WithRSAEncryption = 77,
	OID__NR = 78,
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_pkey_algo = 7,
	ACT_x509_note_serial = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_key;
	bool unsupported_sig;
	bool blacklisted;
	int: 16;
	int: 32;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *cert_start;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID algo_oid;
	unsigned char nr_mpi;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	int: 32;
	time64_t signing_time;
	struct public_key_signature *sig;
	int: 32;
};

struct pkcs7_message___2 {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message___2 *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

typedef __u32 blk_mq_req_flags_t;

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	long unsigned int rq_dispatched[2];
	long unsigned int rq_merged;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int rq_completed[2];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	int: 32;
	int: 32;
	int: 32;
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	struct sbitmap_word *map;
};

struct blk_mq_tags;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	long unsigned int dispatched[7];
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	atomic_t elevator_queued;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	long unsigned int poll_considered;
	long unsigned int poll_invoked;
	long unsigned int poll_success;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	struct srcu_struct srcu[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	unsigned int cmd_flags;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_flush_queue {
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	spinlock_t mq_flush_lock;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int *alloc_hint;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	bool round_robin;
	unsigned int min_shallow_depth;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	atomic_t active_queues_shared_sbitmap;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct blk_mq_tags **tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
};

enum {
	sysctl_hung_task_timeout_secs = 0,
};

struct sbitmap_word {
	long unsigned int depth;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int word;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int cleared;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue *bitmap_tags;
	struct sbitmap_queue *breserved_tags;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
	int: 32;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	size_t size;
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_complete {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_complete {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, int, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 500,
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct rq_map_data {
	struct page **pages;
	int page_order;
	int nr_entries;
	long unsigned int offset;
	int null_mapped;
	int from_user;
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

typedef bool busy_iter_fn(struct blk_mq_hw_ctx *, struct request *, void *, bool);

typedef bool busy_tag_iter_fn(struct request *, void *, bool);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	busy_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	bool enable_accounting;
};

struct blk_mq_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_ctx *, char *);
	ssize_t (*store)(struct blk_mq_ctx *, const char *, size_t);
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
	int: 32;
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct disk_part_iter {
	struct gendisk *disk;
	struct block_device *part;
	int idx;
	unsigned int flags;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct parsed_partitions {
	struct block_device *bdev;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
		int: 16;
		int: 32;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct page *v;
} Sector;

struct cmdline_subpart {
	char name[32];
	sector_t from;
	sector_t size;
	int flags;
	struct cmdline_subpart *next_subpart;
};

struct cmdline_parts {
	char name[32];
	unsigned int nr_subparts;
	struct cmdline_subpart *subpart;
	struct cmdline_parts *next_parts;
};

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

typedef struct {
	__u8 b[16];
} guid_t;

typedef guid_t efi_guid_t;

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
};

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct cdrom_device_ops;

struct cdrom_device_info {
	const struct cdrom_device_ops *ops;
	struct list_head list;
	struct gendisk *disk;
	void *handle;
	int mask;
	int speed;
	int capacity;
	unsigned int options: 30;
	unsigned int mc_flags: 2;
	unsigned int vfs_events;
	unsigned int ioctl_events;
	int use_count;
	char name[20];
	__u8 sanyo_slot: 2;
	__u8 keeplocked: 1;
	__u8 reserved: 5;
	int cdda_method;
	__u8 last_sense;
	__u8 media_written;
	short unsigned int mmc3_profile;
	int for_data;
	int (*exit)(struct cdrom_device_info *);
	int mrw_mode_page;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

struct cdrom_msf0 {
	__u8 minute;
	__u8 second;
	__u8 frame;
};

union cdrom_addr {
	struct cdrom_msf0 msf;
	int lba;
};

struct cdrom_multisession {
	union cdrom_addr addr;
	__u8 xa_flag;
	__u8 addr_format;
};

struct cdrom_mcn {
	__u8 medium_catalog_number[14];
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct packet_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct scsi_sense_hdr *sshdr;
	unsigned char data_direction;
	int quiet;
	int timeout;
	void *reserved[1];
};

struct cdrom_device_ops {
	int (*open)(struct cdrom_device_info *, int);
	void (*release)(struct cdrom_device_info *);
	int (*drive_status)(struct cdrom_device_info *, int);
	unsigned int (*check_events)(struct cdrom_device_info *, unsigned int, int);
	int (*tray_move)(struct cdrom_device_info *, int);
	int (*lock_door)(struct cdrom_device_info *, int);
	int (*select_speed)(struct cdrom_device_info *, int);
	int (*select_disc)(struct cdrom_device_info *, int);
	int (*get_last_session)(struct cdrom_device_info *, struct cdrom_multisession *);
	int (*get_mcn)(struct cdrom_device_info *, struct cdrom_mcn *);
	int (*reset)(struct cdrom_device_info *);
	int (*audio_ioctl)(struct cdrom_device_info *, unsigned int, void *);
	const int capability;
	int (*generic_packet)(struct cdrom_device_info *, struct packet_command *);
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct scsi_request {
	unsigned char __cmd[16];
	unsigned char *cmd;
	short unsigned int cmd_len;
	int result;
	unsigned int sense_len;
	unsigned int resid_len;
	int retries;
	void *sense;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

struct blk_cmd_filter {
	long unsigned int read_ok[8];
	long unsigned int write_ok[8];
};

enum {
	OMAX_SB_LEN = 16,
};

struct bsg_device {
	struct request_queue *queue;
	spinlock_t lock;
	struct hlist_node dev_list;
	refcount_t ref_count;
	char name[20];
	int max_queue;
};

struct deadline_data {
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	struct request *next_rq[2];
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	spinlock_t lock;
	spinlock_t zone_lock;
	struct list_head dispatch;
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_throttled {};

typedef void (*btf_trace_kyber_latency)(void *, struct request_queue *, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_adjust)(void *, struct request_queue *, const char *, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, struct request_queue *, const char *);

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct kyber_queue_data {
	struct request_queue *q;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_device;

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	void *priv;
};

struct vringh_config_ops;

struct virtio_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	int: 32;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
	int: 32;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

typedef void (*swap_func_t)(void *, void *, int);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct random_ready_callback {
	struct list_head list;
	void (*func)(struct random_ready_callback *);
	struct module *owner;
};

struct siprand_state {
	long unsigned int v0;
	long unsigned int v1;
	long unsigned int v2;
	long unsigned int v3;
};

typedef int __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

typedef int (*cmp_func)(void *, const struct list_head *, const struct list_head *);

struct csum_state {
	__wsum csum;
	size_t off;
};

typedef u32 compat_size_t;

typedef s32 compat_ssize_t;

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct rhltable {
	struct rhashtable ht;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[1024];
		u8 data[4096];
	};
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

struct arc4_ctx {
	u32 S[256];
	u32 x;
	u32 y;
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
};

struct pcim_iomap_devres {
	void *table[6];
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct linear_range {
	unsigned int min;
	unsigned int min_sel;
	unsigned int max_sel;
	unsigned int step;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
	int: 32;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef z_stream *z_streamp;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

enum {
	RS_DECODE_LAMBDA = 0,
	RS_DECODE_SYN = 1,
	RS_DECODE_B = 2,
	RS_DECODE_T = 3,
	RS_DECODE_OMEGA = 4,
	RS_DECODE_ROOT = 5,
	RS_DECODE_REG = 6,
	RS_DECODE_LOC = 7,
	RS_DECODE_NUM_BUFFERS = 8,
};

struct gf_poly;

struct bch_control {
	unsigned int m;
	unsigned int n;
	unsigned int t;
	unsigned int ecc_bits;
	unsigned int ecc_bytes;
	uint16_t *a_pow_tab;
	uint16_t *a_log_tab;
	uint32_t *mod8_tab;
	uint32_t *ecc_buf;
	uint32_t *ecc_buf2;
	unsigned int *xi_tab;
	unsigned int *syn;
	int *cache;
	struct gf_poly *elp;
	struct gf_poly *poly_2t[4];
	bool swap_bits;
};

struct gf_poly {
	unsigned int deg;
	unsigned int c[0];
};

struct gf_poly_deg1 {
	struct gf_poly poly;
	unsigned int c[2];
};

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

typedef uint8_t BYTE;

typedef uint16_t U16;

typedef uint32_t U32;

typedef uintptr_t uptrval;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef uint64_t U64;

typedef struct {
	size_t bitContainer;
	int bitPos;
	char *startPtr;
	char *ptr;
	char *endPtr;
} BIT_CStream_t;

typedef unsigned int FSE_CTable;

typedef struct {
	ptrdiff_t value;
	const void *stateTable;
	const void *symbolTT;
	unsigned int stateLog;
} FSE_CState_t;

typedef struct {
	int deltaFindState;
	U32 deltaNbBits;
} FSE_symbolCompressionTransform;

typedef s16 int16_t;

typedef int16_t S16;

struct HUF_CElt_s {
	U16 val;
	BYTE nbBits;
};

typedef struct HUF_CElt_s HUF_CElt;

typedef enum {
	HUF_repeat_none = 0,
	HUF_repeat_check = 1,
	HUF_repeat_valid = 2,
} HUF_repeat;

struct nodeElt_s {
	U32 count;
	U16 parent;
	BYTE byte;
	BYTE nbBits;
};

typedef struct nodeElt_s nodeElt;

typedef struct {
	U32 base;
	U32 curr;
} rankPos;

typedef enum {
	ZSTDcs_created = 0,
	ZSTDcs_init = 1,
	ZSTDcs_ongoing = 2,
	ZSTDcs_ending = 3,
} ZSTD_compressionStage_e;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef struct {
	U32 price;
	U32 off;
	U32 mlen;
	U32 litlen;
	U32 rep[3];
} ZSTD_optimal_t;

typedef struct {
	U32 off;
	U32 len;
} ZSTD_match_t;

struct seqDef_s;

typedef struct seqDef_s seqDef;

typedef struct {
	seqDef *sequencesStart;
	seqDef *sequences;
	BYTE *litStart;
	BYTE *lit;
	BYTE *llCode;
	BYTE *mlCode;
	BYTE *ofCode;
	U32 longLengthID;
	U32 longLengthPos;
	ZSTD_optimal_t *priceTable;
	ZSTD_match_t *matchTable;
	U32 *matchLengthFreq;
	U32 *litLengthFreq;
	U32 *litFreq;
	U32 *offCodeFreq;
	U32 matchLengthSum;
	U32 matchSum;
	U32 litLengthSum;
	U32 litSum;
	U32 offCodeSum;
	U32 log2matchLengthSum;
	U32 log2matchSum;
	U32 log2litLengthSum;
	U32 log2litSum;
	U32 log2offCodeSum;
	U32 factor;
	U32 staticPrices;
	U32 cachedPrice;
	U32 cachedLitLength;
	const BYTE *cachedLiterals;
} seqStore_t;

struct HUF_CElt_s___2;

typedef struct HUF_CElt_s___2 HUF_CElt___2;

struct ZSTD_CCtx_s___2 {
	const BYTE *nextSrc;
	const BYTE *base;
	const BYTE *dictBase;
	U32 dictLimit;
	U32 lowLimit;
	U32 nextToUpdate;
	U32 nextToUpdate3;
	U32 hashLog3;
	U32 loadedDictEnd;
	U32 forceWindow;
	U32 forceRawDict;
	ZSTD_compressionStage_e stage;
	U32 rep[3];
	U32 repToConfirm[3];
	U32 dictID;
	ZSTD_parameters params;
	void *workSpace;
	size_t workSpaceSize;
	size_t blockSize;
	U64 frameContentSize;
	struct xxh64_state xxhState;
	ZSTD_customMem customMem;
	seqStore_t seqStore;
	U32 *hashTable;
	U32 *hashTable3;
	U32 *chainTable;
	HUF_CElt___2 *hufTable;
	U32 flagStaticTables;
	HUF_repeat flagStaticHufTable;
	FSE_CTable offcodeCTable[187];
	FSE_CTable matchlengthCTable[363];
	FSE_CTable litlengthCTable[329];
	unsigned int tmpCounters[1536];
};

typedef struct ZSTD_CCtx_s___2 ZSTD_CCtx___2;

struct ZSTD_CDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictContentSize;
	ZSTD_CCtx___2 *refContext;
};

typedef struct ZSTD_CDict_s ZSTD_CDict;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

typedef enum {
	zcss_init = 0,
	zcss_load = 1,
	zcss_flush = 2,
	zcss_final = 3,
} ZSTD_cStreamStage;

struct ZSTD_CStream_s {
	ZSTD_CCtx___2 *cctx;
	ZSTD_CDict *cdictLocal;
	const ZSTD_CDict *cdict;
	char *inBuff;
	size_t inBuffSize;
	size_t inToCompress;
	size_t inBuffPos;
	size_t inBuffTarget;
	size_t blockSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outBuffContentSize;
	size_t outBuffFlushedSize;
	ZSTD_cStreamStage stage;
	U32 checksum;
	U32 frameEnded;
	U64 pledgedSrcSize;
	U64 inputProcessed;
	ZSTD_parameters params;
	ZSTD_customMem customMem;
	int: 32;
};

typedef struct ZSTD_CStream_s ZSTD_CStream;

typedef int32_t S32;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

struct seqDef_s {
	U32 offset;
	U16 litLength;
	U16 matchLength;
};

typedef enum {
	ZSTDcrp_continue = 0,
	ZSTDcrp_noMemset = 1,
	ZSTDcrp_fullReset = 2,
} ZSTD_compResetPolicy_e;

typedef void (*ZSTD_blockCompressor)(ZSTD_CCtx___2 *, const void *, size_t);

typedef enum {
	zsf_gather = 0,
	zsf_flush = 1,
	zsf_end = 2,
} ZSTD_flush_e;

typedef size_t (*searchMax_f)(ZSTD_CCtx___2 *, const BYTE *, const BYTE *, size_t *, U32, U32);

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef unsigned int FSE_DTable;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	void *ptr;
	const void *end;
} ZSTD_stack;

typedef U32 HUF_DTable;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	BYTE byte;
	BYTE nbBits;
} HUF_DEltX2;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX4;

typedef struct {
	BYTE symbol;
	BYTE weight;
} sortedSymbol_t;

typedef U32 rankValCol_t[13];

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef struct {
	FSE_DTable LLTable[513];
	FSE_DTable OFTable[257];
	FSE_DTable MLTable[513];
	HUF_DTable hufTable[4097];
	U64 workspace[384];
	U32 rep[3];
	int: 32;
} ZSTD_entropyTables_t;

typedef struct {
	long long unsigned int frameContentSize;
	unsigned int windowSize;
	unsigned int dictID;
	unsigned int checksumFlag;
	int: 32;
} ZSTD_frameParams;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

struct ZSTD_DCtx_s___2 {
	const FSE_DTable *LLTptr;
	const FSE_DTable *MLTptr;
	const FSE_DTable *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyTables_t entropy;
	const void *previousDstEnd;
	const void *base;
	const void *vBase;
	const void *dictEnd;
	size_t expected;
	int: 32;
	ZSTD_frameParams fParams;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	U32 dictID;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	BYTE litBuffer[131080];
	BYTE headerBuffer[18];
	int: 16;
	int: 32;
};

typedef struct ZSTD_DCtx_s___2 ZSTD_DCtx___2;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	int: 32;
	ZSTD_entropyTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
	int: 32;
};

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

struct ZSTD_DStream_s {
	ZSTD_DCtx___2 *dctx;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	int: 32;
	ZSTD_frameParams fParams;
	ZSTD_dStreamStage stage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t blockSize;
	BYTE headerBuffer[18];
	size_t lhSize;
	ZSTD_customMem customMem;
	void *legacyContext;
	U32 previousLegacyVersion;
	U32 legacyVersion;
	U32 hostageByte;
	int: 32;
};

typedef struct ZSTD_DStream_s ZSTD_DStream;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef uintptr_t uPtrDiff;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef union {
	FSE_decode_t realData;
	U32 alignedBy4;
} FSE_decode_t4;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
	const BYTE *match;
} seq_t;

typedef struct {
	BIT_DStream_t DStream;
	FSE_DState_t stateLL;
	FSE_DState_t stateOffb;
	FSE_DState_t stateML;
	size_t prevOffset[3];
	const BYTE *base;
	size_t pos;
	uPtrDiff gotoDict;
} seqState_t;

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
	int: 32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec___2 {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
		int: 32;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		int: 32;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
	int: 24;
	int: 32;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2___2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj___2 {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	__NLA_TYPE_MAX = 18,
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef unsigned int USItype;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct gcry_mpi_point *MPI_POINT;

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct barrett_ctx_s___2;

typedef struct barrett_ctx_s___2 *mpi_barrett_t___2;

struct barrett_ctx_s___2 {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

typedef mpi_limb_t UWtype;

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
	int: 16;
	int: 32;
};

enum dim_tune_state {
	DIM_PARKING_ON_TOP = 0,
	DIM_PARKING_TIRED = 1,
	DIM_GOING_RIGHT = 2,
	DIM_GOING_LEFT = 3,
};

struct dim_cq_moder {
	u16 usec;
	u16 pkts;
	u16 comps;
	u8 cq_period_mode;
};

enum dim_cq_period_mode {
	DIM_CQ_PERIOD_MODE_START_FROM_EQE = 0,
	DIM_CQ_PERIOD_MODE_START_FROM_CQE = 1,
	DIM_CQ_PERIOD_NUM_MODES = 2,
};

enum dim_state {
	DIM_START_MEASURE = 0,
	DIM_MEASURE_IN_PROGRESS = 1,
	DIM_APPLY_NEW_PROFILE = 2,
};

enum dim_stats_state {
	DIM_STATS_WORSE = 0,
	DIM_STATS_SAME = 1,
	DIM_STATS_BETTER = 2,
};

enum dim_step_result {
	DIM_STEPPED = 0,
	DIM_TOO_TIRED = 1,
	DIM_ON_EDGE = 2,
};

struct sg_splitter {
	struct scatterlist *in_sg0;
	int nents;
	off_t skip_sg0;
	unsigned int length_last_sg;
	struct scatterlist *out_sg;
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

typedef u16 ucs2_char_t;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 2,
	ZSTD_error_version_unsupported = 3,
	ZSTD_error_parameter_unknown = 4,
	ZSTD_error_frameParameter_unsupported = 5,
	ZSTD_error_frameParameter_unsupportedBy32bits = 6,
	ZSTD_error_frameParameter_windowTooLarge = 7,
	ZSTD_error_compressionParameter_unsupported = 8,
	ZSTD_error_init_missing = 9,
	ZSTD_error_memory_allocation = 10,
	ZSTD_error_stage_wrong = 11,
	ZSTD_error_dstSize_tooSmall = 12,
	ZSTD_error_srcSize_wrong = 13,
	ZSTD_error_corruption_detected = 14,
	ZSTD_error_checksum_wrong = 15,
	ZSTD_error_tableLog_tooLarge = 16,
	ZSTD_error_maxSymbolValue_tooLarge = 17,
	ZSTD_error_maxSymbolValue_tooSmall = 18,
	ZSTD_error_dictionary_corrupted = 19,
	ZSTD_error_dictionary_wrong = 20,
	ZSTD_error_dictionaryCreation_failed = 21,
	ZSTD_error_maxCode = 22,
} ZSTD_ErrorCode;

struct ZSTD_DStream_s___2;

typedef struct ZSTD_DStream_s___2 ZSTD_DStream___2;

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum {
	ASSUME_PERFECT = 255,
	ASSUME_VALID_DTB = 1,
	ASSUME_VALID_INPUT = 2,
	ASSUME_LATEST = 4,
	ASSUME_NO_ROLLBACK = 8,
	ASSUME_LIBFDT_ORDER = 16,
	ASSUME_LIBFDT_FLAWLESS = 32,
};

typedef __be64 fdt64_t;

struct fdt_reserve_entry {
	fdt64_t address;
	fdt64_t size;
};

struct fdt_node_header {
	fdt32_t tag;
	char name[0];
};

struct fdt_property {
	fdt32_t tag;
	fdt32_t len;
	fdt32_t nameoff;
	char data[0];
};

struct fdt_errtabent {
	const char *str;
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

struct ida_bitmap {
	long unsigned int bitmap[32];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct xa_limit {
	u32 max;
	u32 min;
};

typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);

struct alpine_msix_data {
	spinlock_t msi_map_lock;
	phys_addr_t addr;
	u32 spi_first;
	u32 num_spis;
	long unsigned int *msi_map;
};

struct armctrl_ic {
	void *base;
	void *pending[3];
	void *enable[3];
	void *disable[3];
	struct irq_domain *domain;
};

struct bcm2836_arm_irqchip_intc {
	struct irq_domain *domain;
	void *base;
};

struct combiner_chip_data {
	unsigned int hwirq_offset;
	unsigned int irq_mask;
	void *base;
	unsigned int parent_irq;
	u32 pm_save;
};

struct hip04_irq_data {
	void *dist_base;
	void *cpu_base;
	struct irq_domain *domain;
	unsigned int nr_irqs;
};

struct icu_chip_data {
	int nr_irqs;
	unsigned int virq_base;
	unsigned int cascade_irq;
	void *reg_status;
	void *reg_mask;
	unsigned int conf_enable;
	unsigned int conf_disable;
	unsigned int conf_mask;
	unsigned int conf2_mask;
	unsigned int clr_mfp_irq_base;
	unsigned int clr_mfp_hwirq;
	struct irq_domain *domain;
};

struct mmp_intc_conf {
	unsigned int conf_enable;
	unsigned int conf_disable;
	unsigned int conf_mask;
	unsigned int conf2_mask;
};

struct tegra_ictlr_soc {
	unsigned int num_ictlrs;
};

struct tegra_ictlr_info {
	void *base[6];
	u32 cop_ier[6];
	u32 cop_iep[6];
	u32 cpu_ier[6];
	u32 cpu_iep[6];
	u32 ictlr_wake_mask[6];
};

struct omap_intc_regs {
	u32 sysconfig;
	u32 protection;
	u32 idle;
	u32 threshold;
	u32 ilr[128];
	u32 mir[4];
};

struct sun4i_irq_chip_data {
	void *irq_base;
	struct irq_domain *irq_domain;
	u32 enable_reg_offset;
	u32 mask_reg_offset;
};

enum {
	SUNXI_SRC_TYPE_LEVEL_LOW = 0,
	SUNXI_SRC_TYPE_EDGE_FALLING = 1,
	SUNXI_SRC_TYPE_LEVEL_HIGH = 2,
	SUNXI_SRC_TYPE_EDGE_RISING = 3,
};

struct sunxi_sc_nmi_reg_offs {
	u32 ctrl;
	u32 pend;
	u32 enable;
};

enum gic_type {
	GIC_V2 = 0,
	GIC_V3 = 1,
};

struct gic_kvm_info {
	enum gic_type type;
	struct resource vcpu;
	unsigned int maint_irq;
	struct resource vctrl;
	bool has_v4;
	bool has_v4_1;
};

union gic_base {
	void *common_base;
	void **percpu_base;
};

struct gic_chip_data {
	struct irq_chip chip;
	union gic_base dist_base;
	union gic_base cpu_base;
	void *raw_dist_base;
	void *raw_cpu_base;
	u32 percpu_offset;
	u32 saved_spi_enable[32];
	u32 saved_spi_active[32];
	u32 saved_spi_conf[64];
	u32 saved_spi_target[255];
	u32 *saved_ppi_enable;
	u32 *saved_ppi_active;
	u32 *saved_ppi_conf;
	struct irq_domain *domain;
	unsigned int gic_irqs;
};

struct gic_quirk {
	const char *desc;
	const char *compatible;
	bool (*init)(void *);
	u32 iidr;
	u32 mask;
};

struct v2m_data {
	struct list_head entry;
	struct fwnode_handle *fwnode;
	struct resource res;
	void *base;
	u32 spi_start;
	u32 nr_spis;
	u32 spi_offset;
	long unsigned int *bm;
	u32 flags;
};

struct rdists {
	struct {
		raw_spinlock_t rd_lock;
		void *rd_base;
		struct page *pend_page;
		phys_addr_t phys_base;
		bool lpi_enabled;
		cpumask_t *vpe_table_mask;
		void *vpe_l1_base;
	} *rdist;
	phys_addr_t prop_table_pa;
	void *prop_table_va;
	int: 32;
	u64 flags;
	u32 gicd_typer;
	u32 gicd_typer2;
	bool has_vlpis;
	bool has_rvpeid;
	bool has_direct_lpi;
	bool has_vpend_valid_dirty;
	int: 32;
};

struct partition_affinity {
	cpumask_t mask;
	void *partition_id;
};

struct redist_region {
	void *redist_base;
	phys_addr_t phys_base;
	bool single_redist;
};

struct partition_desc;

struct gic_chip_data___2 {
	struct fwnode_handle *fwnode;
	void *dist_base;
	struct redist_region *redist_regions;
	int: 32;
	struct rdists rdists;
	struct irq_domain *domain;
	int: 32;
	u64 redist_stride;
	u32 nr_redist_regions;
	int: 32;
	u64 flags;
	bool has_rss;
	unsigned int ppi_nr;
	struct partition_desc **ppi_descs;
	int: 32;
};

enum gic_intid_range {
	SGI_RANGE = 0,
	PPI_RANGE = 1,
	SPI_RANGE = 2,
	EPPI_RANGE = 3,
	ESPI_RANGE = 4,
	LPI_RANGE = 5,
	__INVALID_RANGE__ = 6,
};

struct mbi_range {
	u32 spi_start;
	u32 nr_spis;
	long unsigned int *bm;
};

typedef long unsigned int efi_status_t;

typedef u8 efi_bool_t;

typedef u16 efi_char16_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

typedef efi_status_t efi_set_virtual_address_map_t(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_get_time_t *get_time;
		efi_set_time_t *set_time;
		efi_get_wakeup_time_t *get_wakeup_time;
		efi_set_wakeup_time_t *set_wakeup_time;
		efi_set_virtual_address_map_t *set_virtual_address_map;
		void *convert_pointer;
		efi_get_variable_t *get_variable;
		efi_get_next_variable_t *get_next_variable;
		efi_set_variable_t *set_variable;
		efi_get_next_high_mono_count_t *get_next_high_mono_count;
		efi_reset_system_t *reset_system;
		efi_update_capsule_t *update_capsule;
		efi_query_capsule_caps_t *query_capsule_caps;
		efi_query_variable_info_t *query_variable_info;
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int esrt;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mokvar_table;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

struct its_vpe;

struct its_vm {
	struct fwnode_handle *fwnode;
	struct irq_domain *domain;
	struct page *vprop_page;
	struct its_vpe **vpes;
	int nr_vpes;
	irq_hw_number_t db_lpi_base;
	long unsigned int *db_bitmap;
	int nr_db_lpis;
	u32 vlpi_count[16];
};

struct its_vpe {
	struct page *vpt_page;
	struct its_vm *its_vm;
	atomic_t vlpi_count;
	int irq;
	irq_hw_number_t vpe_db_lpi;
	bool resident;
	bool ready;
	union {
		struct {
			int vpe_proxy_event;
			bool idai;
		};
		struct {
			struct fwnode_handle *fwnode;
			struct irq_domain *sgi_domain;
			struct {
				u8 priority;
				bool enabled;
				bool group;
			} sgi_config[16];
			atomic_t vmapp_count;
		};
	};
	raw_spinlock_t vpe_lock;
	u16 col_idx;
	u16 vpe_id;
	bool pending_last;
};

struct its_vlpi_map {
	struct its_vm *vm;
	struct its_vpe *vpe;
	u32 vintid;
	u8 properties;
	bool db_enabled;
};

enum its_vcpu_info_cmd_type {
	MAP_VLPI = 0,
	GET_VLPI = 1,
	PROP_UPDATE_VLPI = 2,
	PROP_UPDATE_AND_INV_VLPI = 3,
	SCHEDULE_VPE = 4,
	DESCHEDULE_VPE = 5,
	COMMIT_VPE = 6,
	INVALL_VPE = 7,
	PROP_UPDATE_VSGI = 8,
};

struct its_cmd_info {
	enum its_vcpu_info_cmd_type cmd_type;
	union {
		struct its_vlpi_map *map;
		u8 config;
		bool req_db;
		struct {
			bool g0en;
			bool g1en;
		};
		struct {
			u8 priority;
			bool group;
		};
	};
};

struct its_collection {
	u64 target_address;
	u16 col_id;
	int: 16;
	int: 32;
};

struct its_baser {
	void *base;
	int: 32;
	u64 val;
	u32 order;
	u32 psz;
};

struct its_cmd_block;

struct its_device;

struct its_node {
	raw_spinlock_t lock;
	struct mutex dev_alloc_lock;
	struct list_head entry;
	void *base;
	void *sgir_base;
	phys_addr_t phys_base;
	struct its_cmd_block *cmd_base;
	struct its_cmd_block *cmd_write;
	int: 32;
	struct its_baser tables[8];
	struct its_collection *collections;
	struct fwnode_handle *fwnode_handle;
	u64 (*get_msi_base)(struct its_device *);
	int: 32;
	u64 typer;
	u64 cbaser_save;
	u32 ctlr_save;
	u32 mpidr;
	struct list_head its_device_list;
	u64 flags;
	long unsigned int list_nr;
	int numa_node;
	unsigned int msi_domain_flags;
	u32 pre_its_base;
	int vlpi_redist_offset;
	int: 32;
};

struct its_cmd_block {
	union {
		u64 raw_cmd[4];
		__le64 raw_cmd_le[4];
	};
};

struct event_lpi_map {
	long unsigned int *lpi_map;
	u16 *col_map;
	irq_hw_number_t lpi_base;
	int nr_lpis;
	raw_spinlock_t vlpi_lock;
	struct its_vm *vm;
	struct its_vlpi_map *vlpi_maps;
	int nr_vlpis;
};

struct its_device {
	struct list_head entry;
	struct its_node *its;
	struct event_lpi_map event_map;
	void *itt;
	u32 nr_ites;
	u32 device_id;
	bool shared;
};

struct cpu_lpi_count {
	atomic_t managed;
	atomic_t unmanaged;
};

struct its_cmd_desc {
	union {
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_inv_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_clear_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_int_cmd;
		struct {
			struct its_device *dev;
			int valid;
		} its_mapd_cmd;
		struct {
			struct its_collection *col;
			int valid;
		} its_mapc_cmd;
		struct {
			struct its_device *dev;
			u32 phys_id;
			u32 event_id;
		} its_mapti_cmd;
		struct {
			struct its_device *dev;
			struct its_collection *col;
			u32 event_id;
		} its_movi_cmd;
		struct {
			struct its_device *dev;
			u32 event_id;
		} its_discard_cmd;
		struct {
			struct its_collection *col;
		} its_invall_cmd;
		struct {
			struct its_vpe *vpe;
		} its_vinvall_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection *col;
			bool valid;
		} its_vmapp_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device *dev;
			u32 virt_id;
			u32 event_id;
			bool db_enabled;
		} its_vmapti_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_device *dev;
			u32 event_id;
			bool db_enabled;
		} its_vmovi_cmd;
		struct {
			struct its_vpe *vpe;
			struct its_collection *col;
			u16 seq_num;
			u16 its_list;
		} its_vmovp_cmd;
		struct {
			struct its_vpe *vpe;
		} its_invdb_cmd;
		struct {
			struct its_vpe *vpe;
			u8 sgi;
			u8 priority;
			bool enable;
			bool group;
			bool clear;
		} its_vsgi_cmd;
	};
};

typedef struct its_collection * (*its_cmd_builder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

typedef struct its_vpe * (*its_cmd_vbuilder_t)(struct its_node *, struct its_cmd_block *, struct its_cmd_desc *);

struct lpi_range {
	struct list_head entry;
	u32 base_id;
	u32 span;
};

struct msi_controller {
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct list_head list;
	int (*setup_irq)(struct msi_controller *, struct pci_dev *, struct msi_desc *);
	int (*setup_irqs)(struct msi_controller *, struct pci_dev *, int, int);
	void (*teardown_irq)(struct msi_controller *, unsigned int);
};

struct partition_desc___2 {
	int nr_parts;
	struct partition_affinity *parts;
	struct irq_domain *domain;
	struct irq_desc *chained_desc;
	long unsigned int *bitmap;
	struct irq_domain_ops ops;
};

struct aic_chip_data {
	u32 ext_irqs;
};

struct sirfsoc_irq_status {
	u32 mask0;
	u32 mask1;
	u32 level0;
	u32 level1;
};

struct intc_irqpin_iomem {
	void *iomem;
	long unsigned int (*read)(void *);
	void (*write)(void *, long unsigned int);
	int width;
};

struct intc_irqpin_priv;

struct intc_irqpin_irq {
	int hw_irq;
	int requested_irq;
	int domain_irq;
	struct intc_irqpin_priv *p;
};

struct intc_irqpin_priv {
	struct intc_irqpin_iomem iomem[6];
	struct intc_irqpin_irq irq[8];
	unsigned int sense_bitfield_width;
	struct platform_device *pdev;
	struct irq_chip irq_chip;
	struct irq_domain *irq_domain;
	atomic_t wakeup_path;
	unsigned int shared_irqs: 1;
	u8 shared_irq_mask;
};

struct intc_irqpin_config {
	int irlm_bit;
};

struct irqc_priv;

struct irqc_irq {
	int hw_irq;
	int requested_irq;
	struct irqc_priv *p;
};

struct irqc_priv {
	void *iomem;
	void *cpu_int_base;
	struct irqc_irq irq[32];
	unsigned int number_of_irqs;
	struct device *dev;
	struct irq_chip_generic *gc;
	struct irq_domain *irq_domain;
	atomic_t wakeup_path;
};

struct rza1_irqc_priv {
	struct device *dev;
	void *base;
	struct irq_chip chip;
	struct irq_domain *irq_domain;
	struct of_phandle_args map[8];
};

struct vt8500_irq_data {
	void *base;
	struct irq_domain *domain;
};

struct st_irq_syscfg {
	struct regmap *regmap;
	unsigned int syscfg;
	unsigned int config;
	bool ext_inverted;
};

struct crossbar_device {
	raw_spinlock_t lock;
	uint int_max;
	uint safe_map;
	uint max_crossbar_sources;
	uint *irq_map;
	void *crossbar_base;
	int *register_offsets;
	void (*write)(int, int);
};

struct vf610_mscm_ir_chip_data {
	void *mscm_ir_base;
	u16 cpu_mask;
	u16 saved_irsprc[112];
	bool is_nvic;
};

struct bcm7038_l1_cpu;

struct bcm7038_l1_chip {
	raw_spinlock_t lock;
	unsigned int n_words;
	struct irq_domain *domain;
	struct bcm7038_l1_cpu *cpus[16];
	struct list_head list;
	u32 wake_mask[8];
	u32 irq_fwd_mask[8];
	u8 affinity[256];
};

struct bcm7038_l1_cpu {
	void *map_base;
	u32 mask_cache[0];
};

struct bcm7120_l2_intc_data;

struct bcm7120_l1_intc_data {
	struct bcm7120_l2_intc_data *b;
	u32 irq_map_mask[4];
};

struct bcm7120_l2_intc_data {
	unsigned int n_words;
	void *map_base[8];
	void *pair_base[4];
	int en_offset[4];
	int stat_offset[4];
	struct irq_domain *domain;
	bool can_wake;
	u32 irq_fwd_mask[4];
	struct bcm7120_l1_intc_data *l1_data;
	int num_parent_irqs;
	const __be32 *map_mask_prop;
};

struct brcmstb_intc_init_params {
	irq_flow_handler_t handler;
	int cpu_status;
	int cpu_clear;
	int cpu_mask_status;
	int cpu_mask_set;
	int cpu_mask_clear;
};

struct brcmstb_l2_intc_data {
	struct irq_domain *domain;
	struct irq_chip_generic *gc;
	int status_offset;
	int mask_offset;
	bool can_wake;
	u32 saved_mask;
};

struct keystone_irq_device {
	struct device *dev;
	struct irq_chip chip;
	u32 mask;
	int irq;
	struct irq_domain *irqd;
	struct regmap *devctrl_regs;
	u32 devctrl_offset;
	raw_spinlock_t wa_lock;
};

struct mtk_sysirq_chip_data {
	raw_spinlock_t lock;
	u32 nr_intpol_bases;
	void **intpol_bases;
	u32 *intpol_words;
	u8 *intpol_idx;
	u16 *which_word;
};

struct mtk_cirq_chip_data {
	void *base;
	unsigned int ext_irq_start;
	unsigned int ext_irq_end;
	struct irq_domain *domain;
};

struct gpcv2_irqchip_data {
	struct raw_spinlock rlock;
	void *gpc_base;
	u32 wakeup_sources[4];
	u32 saved_irq_mask[4];
	u32 cpu2wakeup;
};

struct ls_extirq_data {
	struct regmap *syscon;
	u32 intpcr;
	bool is_ls1021a_or_ls1043a;
	u32 nirq;
	struct irq_fwspec map[12];
};

struct ls_scfg_msi_cfg {
	u32 ibs_shift;
	u32 msir_irqs;
	u32 msir_base;
};

struct ls_scfg_msi;

struct ls_scfg_msir {
	struct ls_scfg_msi *msi_data;
	unsigned int index;
	unsigned int gic_irq;
	unsigned int bit_start;
	unsigned int bit_end;
	unsigned int srs;
	void *reg;
};

struct ls_scfg_msi {
	spinlock_t lock;
	struct platform_device *pdev;
	struct irq_domain *parent;
	struct irq_domain *msi_domain;
	void *regs;
	phys_addr_t msiir_addr;
	struct ls_scfg_msi_cfg *cfg;
	u32 msir_num;
	struct ls_scfg_msir *msir;
	u32 irqs_num;
	long unsigned int *used;
};

struct aspeed_vic {
	void *base;
	u32 edge_sources[2];
	struct irq_domain *dom;
};

struct aspeed_i2c_ic {
	void *base;
	int parent_irq;
	struct irq_domain *irq_domain;
};

struct aspeed_scu_ic {
	long unsigned int irq_enable;
	long unsigned int irq_shift;
	unsigned int num_irqs;
	unsigned int reg;
	struct regmap *scu;
	struct irq_domain *irq_domain;
};

struct stm32_exti_bank {
	u32 imr_ofst;
	u32 emr_ofst;
	u32 rtsr_ofst;
	u32 ftsr_ofst;
	u32 swier_ofst;
	u32 rpr_ofst;
	u32 fpr_ofst;
};

struct stm32_desc_irq {
	u32 exti;
	u32 irq_parent;
	struct irq_chip *chip;
};

struct stm32_exti_drv_data {
	const struct stm32_exti_bank **exti_banks;
	const struct stm32_desc_irq *desc_irqs;
	u32 bank_nr;
	u32 irq_nr;
};

struct stm32_exti_host_data;

struct stm32_exti_chip_data {
	struct stm32_exti_host_data *host_data;
	const struct stm32_exti_bank *reg_bank;
	struct raw_spinlock rlock;
	u32 wake_active;
	u32 mask_cache;
	u32 rtsr_cache;
	u32 ftsr_cache;
};

struct hwspinlock;

struct stm32_exti_host_data {
	void *base;
	struct stm32_exti_chip_data *chips_data;
	const struct stm32_exti_drv_data *drv_data;
	struct hwspinlock *hwlock;
};

struct uniphier_aidet_priv {
	struct irq_domain *domain;
	void *reg_base;
	spinlock_t lock;
	u32 saved_vals[8];
};

struct meson_gpio_irq_controller;

struct irq_ctl_ops {
	void (*gpio_irq_sel_pin)(struct meson_gpio_irq_controller *, unsigned int, long unsigned int);
	void (*gpio_irq_init)(struct meson_gpio_irq_controller *);
};

struct meson_gpio_irq_params;

struct meson_gpio_irq_controller {
	const struct meson_gpio_irq_params *params;
	void *base;
	u32 channel_irqs[8];
	long unsigned int channel_map[1];
	spinlock_t lock;
};

struct meson_gpio_irq_params {
	unsigned int nr_hwirq;
	bool support_edge_both;
	unsigned int edge_both_offset;
	unsigned int edge_single_offset;
	unsigned int pol_low_offset;
	unsigned int pin_sel_mask;
	struct irq_ctl_ops ops;
};

struct irqsteer_data {
	void *regs;
	struct clk *ipg_clk;
	int irq[8];
	int irq_count;
	raw_spinlock_t lock;
	int reg_num;
	int channel;
	struct irq_domain *domain;
	u32 *saved_reg;
};

struct intmux_irqchip_data {
	struct irq_chip chip;
	u32 saved_reg;
	int chanidx;
	int irq;
	struct irq_domain *domain;
};

struct intmux_data {
	raw_spinlock_t lock;
	void *regs;
	struct clk *ipg_clk;
	int channum;
	struct intmux_irqchip_data irqchip_data[0];
};

struct mst_intc_chip_data {
	raw_spinlock_t lock;
	unsigned int irq_start;
	unsigned int nr_irqs;
	void *base;
	bool no_eoi;
};

struct cci_nb_ports {
	unsigned int nb_ace;
	unsigned int nb_ace_lite;
};

enum cci_ace_port_type {
	ACE_INVALID_PORT = 0,
	ACE_PORT = 1,
	ACE_LITE_PORT = 2,
};

struct cci_ace_port {
	void *base;
	long unsigned int phys;
	enum cci_ace_port_type type;
	struct device_node *dn;
};

struct cpu_port {
	u64 mpidr;
	u32 port;
	int: 32;
};

enum {
	ARB_TIMER = 0,
	ARB_BP_CAP_CLR = 1,
	ARB_BP_CAP_HI_ADDR = 2,
	ARB_BP_CAP_ADDR = 3,
	ARB_BP_CAP_STATUS = 4,
	ARB_BP_CAP_MASTER = 5,
	ARB_ERR_CAP_CLR = 6,
	ARB_ERR_CAP_HI_ADDR = 7,
	ARB_ERR_CAP_ADDR = 8,
	ARB_ERR_CAP_STATUS = 9,
	ARB_ERR_CAP_MASTER = 10,
};

struct brcmstb_gisb_arb_device {
	void *base;
	const int *gisb_offsets;
	bool big_endian;
	struct mutex lock;
	struct list_head next;
	u32 valid_mask;
	const char *master_names[32];
	u32 saved_timeout;
};

struct mbus_dram_window {
	u8 cs_index;
	u8 mbus_attr;
	int: 16;
	int: 32;
	u64 base;
	u64 size;
};

struct mbus_dram_target_info {
	u8 mbus_dram_target_id;
	int num_cs;
	struct mbus_dram_window cs[4];
};

struct mvebu_mbus_state;

struct mvebu_mbus_soc_data {
	unsigned int num_wins;
	bool has_mbus_bridge;
	unsigned int (*win_cfg_offset)(const int);
	unsigned int (*win_remap_offset)(const int);
	void (*setup_cpu_target)(struct mvebu_mbus_state *);
	int (*save_cpu_target)(struct mvebu_mbus_state *, u32 *);
	int (*show_cpu_target)(struct mvebu_mbus_state *, struct seq_file *, void *);
};

struct mvebu_mbus_win_data {
	u32 ctrl;
	u32 base;
	u32 remap_lo;
	u32 remap_hi;
};

struct mvebu_mbus_state {
	void *mbuswins_base;
	void *sdramwins_base;
	void *mbusbridge_base;
	phys_addr_t sdramwins_phys_base;
	struct dentry *debugfs_root;
	struct dentry *debugfs_sdram;
	struct dentry *debugfs_devs;
	struct resource pcie_mem_aperture;
	struct resource pcie_io_aperture;
	const struct mvebu_mbus_soc_data *soc;
	int hw_io_coherency;
	u32 mbus_bridge_ctrl;
	u32 mbus_bridge_base;
	struct mvebu_mbus_win_data wins[20];
};

enum omap3_l3_initiator_id {
	OMAP_L3_LCD = 29,
	OMAP_L3_SAD2D = 28,
	OMAP_L3_IA_MPU_SS_1 = 27,
	OMAP_L3_IA_MPU_SS_2 = 26,
	OMAP_L3_IA_MPU_SS_3 = 25,
	OMAP_L3_IA_MPU_SS_4 = 24,
	OMAP_L3_IA_MPU_SS_5 = 23,
	OMAP_L3_IA_IVA_SS_1 = 22,
	OMAP_L3_IA_IVA_SS_2 = 21,
	OMAP_L3_IA_IVA_SS_3 = 20,
	OMAP_L3_IA_IVA_SS_DMA_1 = 19,
	OMAP_L3_IA_IVA_SS_DMA_2 = 18,
	OMAP_L3_IA_IVA_SS_DMA_3 = 17,
	OMAP_L3_IA_IVA_SS_DMA_4 = 16,
	OMAP_L3_IA_IVA_SS_DMA_5 = 15,
	OMAP_L3_IA_IVA_SS_DMA_6 = 14,
	OMAP_L3_IA_SGX = 13,
	OMAP_L3_IA_CAM_1 = 12,
	OMAP_L3_IA_CAM_2 = 11,
	OMAP_L3_IA_CAM_3 = 10,
	OMAP_L3_IA_DAP = 9,
	OMAP_L3_SDMA_WR_1 = 8,
	OMAP_L3_SDMA_WR_2 = 7,
	OMAP_L3_SDMA_RD_1 = 6,
	OMAP_L3_SDMA_RD_2 = 5,
	OMAP_L3_SDMA_RD_3 = 4,
	OMAP_L3_SDMA_RD_4 = 3,
	OMAP_L3_USBOTG = 2,
	OMAP_L3_USBHOST = 1,
};

enum omap3_l3_code {
	OMAP_L3_CODE_NOERROR = 0,
	OMAP_L3_CODE_UNSUP_CMD = 1,
	OMAP_L3_CODE_ADDR_HOLE = 2,
	OMAP_L3_CODE_PROTECT_VIOLATION = 3,
	OMAP_L3_CODE_IN_BAND_ERR = 4,
	OMAP_L3_CODE_REQ_TOUT_NOT_ACCEPT = 7,
	OMAP_L3_CODE_REQ_TOUT_NO_RESP = 8,
};

struct omap3_l3 {
	struct device *dev;
	struct clk *ick;
	void *rt;
	int debug_irq;
	int app_irq;
	unsigned int inband: 1;
};

struct l3_masters_data {
	u32 id;
	char *name;
};

struct l3_target_data {
	u32 offset;
	char *name;
};

struct l3_flagmux_data {
	u32 offset;
	struct l3_target_data *l3_targ;
	u8 num_targ_data;
	u32 mask_app_bits;
	u32 mask_dbg_bits;
};

struct omap_l3 {
	struct device *dev;
	void *l3_base[3];
	struct l3_flagmux_data **l3_flagmux;
	int num_modules;
	struct l3_masters_data *l3_masters;
	int num_masters;
	u32 mst_addr_mask;
	int debug_irq;
	int app_irq;
};

struct cs_data {
	u32 enable_mask;
	u16 slow_cfg;
	u16 fast_cfg;
};

struct ebi2_xmem_prop {
	const char *prop;
	u32 max;
	bool slowreg;
	u16 shift;
};

struct sunxi_rsb;

struct sunxi_rsb_device {
	struct device dev;
	struct sunxi_rsb *rsb;
	int irq;
	u8 rtaddr;
	u16 hwaddr;
	int: 32;
};

struct sunxi_rsb {
	struct device *dev;
	void *regs;
	struct clk *clk;
	struct reset_control *rstc;
	struct completion complete;
	struct mutex lock;
	unsigned int status;
};

struct sunxi_rsb_driver {
	struct device_driver driver;
	int (*probe)(struct sunxi_rsb_device *);
	int (*remove)(struct sunxi_rsb_device *);
};

struct sunxi_rsb_addr_map {
	u16 hwaddr;
	u8 rtaddr;
};

struct sunxi_rsb_ctx {
	struct sunxi_rsb_device *rdev;
	int size;
};

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

enum sysc_soc {
	SOC_UNKNOWN = 0,
	SOC_2420 = 1,
	SOC_2430 = 2,
	SOC_3430 = 3,
	SOC_3630 = 4,
	SOC_4430 = 5,
	SOC_4460 = 6,
	SOC_4470 = 7,
	SOC_5430 = 8,
	SOC_AM3 = 9,
	SOC_AM4 = 10,
	SOC_DRA7 = 11,
};

struct sysc_address {
	long unsigned int base;
	struct list_head node;
};

struct sysc_soc_info {
	long unsigned int general_purpose: 1;
	enum sysc_soc soc;
	struct mutex list_lock;
	struct list_head disabled_modules;
};

enum sysc_clocks {
	SYSC_FCK = 0,
	SYSC_ICK = 1,
	SYSC_OPTFCK0 = 2,
	SYSC_OPTFCK1 = 3,
	SYSC_OPTFCK2 = 4,
	SYSC_OPTFCK3 = 5,
	SYSC_OPTFCK4 = 6,
	SYSC_OPTFCK5 = 7,
	SYSC_OPTFCK6 = 8,
	SYSC_OPTFCK7 = 9,
	SYSC_MAX_CLOCKS = 10,
};

struct sysc {
	struct device *dev;
	int: 32;
	u64 module_pa;
	u32 module_size;
	void *module_va;
	int offsets[3];
	struct ti_sysc_module_data *mdata;
	struct clk **clocks;
	const char **clock_roles;
	int nr_clocks;
	struct reset_control *rsts;
	const char *legacy_mode;
	const struct sysc_capabilities *cap;
	struct sysc_config cfg;
	struct ti_sysc_cookie cookie;
	const char *name;
	u32 revision;
	unsigned int enabled: 1;
	unsigned int needs_resume: 1;
	unsigned int child_needs_resume: 1;
	struct delayed_work idle_work;
	void (*pre_reset_quirk)(struct sysc *);
	void (*post_reset_quirk)(struct sysc *);
	void (*reset_done_quirk)(struct sysc *);
	void (*module_enable_quirk)(struct sysc *);
	void (*module_disable_quirk)(struct sysc *);
	void (*module_unlock_quirk)(struct sysc *);
	void (*module_lock_quirk)(struct sysc *);
	int: 32;
};

struct sysc_revision_quirk {
	const char *name;
	u32 base;
	int rev_offset;
	int sysc_offset;
	int syss_offset;
	u32 revision;
	u32 revision_mask;
	u32 quirks;
};

struct sysc_dts_quirk {
	const char *name;
	u32 mask;
};

struct uniphier_system_bus_bank {
	u32 base;
	u32 end;
};

struct uniphier_system_bus_priv {
	struct device *dev;
	void *membase;
	struct uniphier_system_bus_bank bank[8];
};

struct vexpress_syscfg {
	struct device *dev;
	void *base;
	struct list_head funcs;
};

struct vexpress_syscfg_func {
	struct list_head list;
	struct vexpress_syscfg *syscfg;
	struct regmap *regmap;
	int num_templates;
	u32 template[0];
};

struct vexpress_config_bridge_ops {
	struct regmap * (*regmap_init)(struct device *, void *);
	void (*regmap_exit)(struct regmap *, void *);
};

struct vexpress_config_bridge {
	struct vexpress_config_bridge_ops *ops;
	void *context;
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct callback_head callback_head;
	bool supplier_preactivated;
	int: 24;
	int: 32;
};

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct regulator;

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
	int: 32;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

struct extcon_dev;

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_pattern;

struct led_trigger;

struct led_classdev {
	const char *name;
	enum led_brightness brightness;
	enum led_brightness max_brightness;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	struct led_hw_trigger_type *trigger_type;
	rwlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 37,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 39,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 40,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 43,
	POWER_SUPPLY_PROP_ENERGY_NOW = 44,
	POWER_SUPPLY_PROP_ENERGY_AVG = 45,
	POWER_SUPPLY_PROP_CAPACITY = 46,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 48,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 50,
	POWER_SUPPLY_PROP_TEMP = 51,
	POWER_SUPPLY_PROP_TEMP_MAX = 52,
	POWER_SUPPLY_PROP_TEMP_MIN = 53,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 55,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 58,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 60,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 62,
	POWER_SUPPLY_PROP_TYPE = 63,
	POWER_SUPPLY_PROP_USB_TYPE = 64,
	POWER_SUPPLY_PROP_SCOPE = 65,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 66,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 67,
	POWER_SUPPLY_PROP_CALIBRATE = 68,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 71,
	POWER_SUPPLY_PROP_MODEL_NAME = 72,
	POWER_SUPPLY_PROP_MANUFACTURER = 73,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 74,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct thermal_zone_device;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	int: 32;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *charging_full_trig;
	char *charging_full_trig_name;
	struct led_trigger *charging_trig;
	char *charging_trig_name;
	struct led_trigger *full_trig;
	char *full_trig_name;
	struct led_trigger *online_trig;
	char *online_trig_name;
	struct led_trigger *charging_blink_full_solid_trig;
	char *charging_blink_full_solid_trig_name;
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

enum sun4i_usb_phy_type {
	sun4i_a10_phy = 0,
	sun6i_a31_phy = 1,
	sun8i_a33_phy = 2,
	sun8i_a83t_phy = 3,
	sun8i_h3_phy = 4,
	sun8i_r40_phy = 5,
	sun8i_v3s_phy = 6,
	sun50i_a64_phy = 7,
	sun50i_h6_phy = 8,
};

struct sun4i_usb_phy_cfg {
	int num_phys;
	int hsic_index;
	enum sun4i_usb_phy_type type;
	u32 disc_thresh;
	u8 phyctl_offset;
	bool dedicated_clocks;
	bool enable_pmu_unk1;
	bool phy0_dual_route;
	int missing_phys;
};

struct sun4i_usb_phy {
	struct phy *phy;
	void *pmu;
	struct regulator *vbus;
	struct reset_control *reset;
	struct clk *clk;
	struct clk *clk2;
	bool regulator_on;
	int index;
};

struct sun4i_usb_phy_data {
	void *base;
	const struct sun4i_usb_phy_cfg *cfg;
	enum usb_dr_mode dr_mode;
	spinlock_t reg_lock;
	struct sun4i_usb_phy phys[4];
	struct extcon_dev *extcon;
	bool phy0_init;
	struct gpio_desc *id_det_gpio;
	struct gpio_desc *vbus_det_gpio;
	struct power_supply *vbus_power_supply;
	struct notifier_block vbus_power_nb;
	bool vbus_power_nb_registered;
	bool force_session_end;
	int id_det_irq;
	int vbus_det_irq;
	int id_det;
	int vbus_det;
	struct delayed_work detect;
};

enum usb_phy_interface {
	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
	USBPHY_INTERFACE_MODE_UTMI = 1,
	USBPHY_INTERFACE_MODE_UTMIW = 2,
	USBPHY_INTERFACE_MODE_ULPI = 3,
	USBPHY_INTERFACE_MODE_SERIAL = 4,
	USBPHY_INTERFACE_MODE_HSIC = 5,
};

struct sun9i_usb_phy {
	struct phy *phy;
	void *pmu;
	struct reset_control *reset;
	struct clk *clk;
	struct clk *hsic_clk;
	enum usb_phy_interface type;
};

struct phy_meson8b_usb2_match_data {
	bool host_enable_aca;
};

struct phy_meson8b_usb2_priv {
	struct regmap *regmap;
	enum usb_dr_mode dr_mode;
	struct clk *clk_usb_general;
	struct clk *clk_usb;
	struct reset_control *reset;
	const struct phy_meson8b_usb2_match_data *match;
};

struct phy_meson_gxl_usb2_priv {
	struct regmap *regmap;
	enum phy_mode mode;
	int is_enabled;
	struct clk *clk;
	struct reset_control *reset;
};

enum meson_soc_id {
	MESON_SOC_G12A = 0,
	MESON_SOC_A1 = 1,
};

struct phy_meson_g12a_usb2_priv {
	struct device *dev;
	struct regmap *regmap;
	struct clk *clk;
	struct reset_control *reset;
	int soc_id;
};

struct phy_g12a_usb3_pcie_priv {
	struct regmap *regmap;
	struct regmap *regmap_cr;
	struct clk *clk_ref;
	struct reset_control *reset;
	struct phy *phy;
	unsigned int mode;
};

struct phy_axg_pcie_priv {
	struct phy *phy;
	struct phy *analog;
	struct regmap *regmap;
	struct reset_control *reset;
};

struct phy_axg_mipi_pcie_analog_priv {
	struct phy *phy;
	struct regmap *regmap;
	bool dsi_configured;
	bool dsi_enabled;
	bool powered;
	struct phy_configure_opts_mipi_dphy config;
};

struct phy_meson_axg_mipi_dphy_priv {
	struct device *dev;
	struct regmap *regmap;
	struct clk *clk;
	struct reset_control *reset;
	struct phy *analog;
	struct phy_configure_opts_mipi_dphy config;
};

enum cygnus_pcie_phy_id {
	CYGNUS_PHY_PCIE0 = 0,
	CYGNUS_PHY_PCIE1 = 1,
	MAX_NUM_PHYS = 2,
};

struct cygnus_pcie_phy_core;

struct cygnus_pcie_phy {
	struct cygnus_pcie_phy_core *core;
	enum cygnus_pcie_phy_id id;
	struct phy *phy;
};

struct cygnus_pcie_phy_core {
	struct device *dev;
	void *base;
	struct mutex lock;
	struct cygnus_pcie_phy phys[2];
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
};

struct ns2_phy_data;

struct ns2_phy_driver {
	void *icfgdrd_regs;
	void *idmdrd_rst_ctrl;
	void *crmu_usb2_ctrl;
	void *usb2h_strap_reg;
	struct ns2_phy_data *data;
	struct extcon_dev *edev;
	struct gpio_desc *vbus_gpiod;
	struct gpio_desc *id_gpiod;
	int id_irq;
	int vbus_irq;
	long unsigned int debounce_jiffies;
	struct delayed_work wq_extcon;
};

struct ns2_phy_data {
	struct ns2_phy_driver *driver;
	struct phy *phy;
	int new_state;
};

enum brcm_sata_phy_version {
	BRCM_SATA_PHY_STB_16NM = 0,
	BRCM_SATA_PHY_STB_28NM = 1,
	BRCM_SATA_PHY_STB_40NM = 2,
	BRCM_SATA_PHY_IPROC_NS2 = 3,
	BRCM_SATA_PHY_IPROC_NSP = 4,
	BRCM_SATA_PHY_IPROC_SR = 5,
	BRCM_SATA_PHY_DSL_28NM = 6,
};

enum brcm_sata_phy_rxaeq_mode {
	RXAEQ_MODE_OFF = 0,
	RXAEQ_MODE_AUTO = 1,
	RXAEQ_MODE_MANUAL = 2,
};

struct brcm_sata_phy;

struct brcm_sata_port {
	int portnum;
	struct phy *phy;
	struct brcm_sata_phy *phy_priv;
	bool ssc_en;
	enum brcm_sata_phy_rxaeq_mode rxaeq_mode;
	u32 rxaeq_val;
	u32 tx_amplitude_val;
};

struct brcm_sata_phy {
	struct device *dev;
	void *phy_base;
	void *ctrl_base;
	enum brcm_sata_phy_version version;
	struct brcm_sata_port phys[2];
};

enum sata_phy_regs {
	BLOCK0_REG_BANK = 0,
	BLOCK0_XGXSSTATUS = 129,
	BLOCK0_XGXSSTATUS_PLL_LOCK = 4096,
	BLOCK0_SPARE = 141,
	BLOCK0_SPARE_OOB_CLK_SEL_MASK = 3,
	BLOCK0_SPARE_OOB_CLK_SEL_REFBY2 = 1,
	BLOCK1_REG_BANK = 16,
	BLOCK1_TEST_TX = 131,
	BLOCK1_TEST_TX_AMP_SHIFT = 12,
	PLL_REG_BANK_0 = 80,
	PLL_REG_BANK_0_PLLCONTROL_0 = 129,
	PLLCONTROL_0_FREQ_DET_RESTART = 8192,
	PLLCONTROL_0_FREQ_MONITOR = 4096,
	PLLCONTROL_0_SEQ_START = 32768,
	PLL_CAP_CHARGE_TIME = 131,
	PLL_VCO_CAL_THRESH = 132,
	PLL_CAP_CONTROL = 133,
	PLL_FREQ_DET_TIME = 134,
	PLL_ACTRL2 = 139,
	PLL_ACTRL2_SELDIV_MASK = 31,
	PLL_ACTRL2_SELDIV_SHIFT = 9,
	PLL_ACTRL6 = 134,
	PLL1_REG_BANK = 96,
	PLL1_ACTRL2 = 130,
	PLL1_ACTRL3 = 131,
	PLL1_ACTRL4 = 132,
	PLL1_ACTRL5 = 133,
	PLL1_ACTRL6 = 134,
	PLL1_ACTRL7 = 135,
	PLL1_ACTRL8 = 136,
	TX_REG_BANK = 112,
	TX_ACTRL0 = 128,
	TX_ACTRL0_TXPOL_FLIP = 64,
	TX_ACTRL5 = 133,
	TX_ACTRL5_SSC_EN = 2048,
	AEQRX_REG_BANK_0 = 208,
	AEQ_CONTROL1 = 129,
	AEQ_CONTROL1_ENABLE = 4,
	AEQ_CONTROL1_FREEZE = 8,
	AEQ_FRC_EQ = 131,
	AEQ_FRC_EQ_FORCE = 1,
	AEQ_FRC_EQ_FORCE_VAL = 2,
	AEQ_RFZ_FRC_VAL = 256,
	AEQRX_REG_BANK_1 = 224,
	AEQRX_SLCAL0_CTRL0 = 130,
	AEQRX_SLCAL1_CTRL0 = 134,
	OOB_REG_BANK = 336,
	OOB1_REG_BANK = 352,
	OOB_CTRL1 = 128,
	OOB_CTRL1_BURST_MAX_MASK = 15,
	OOB_CTRL1_BURST_MAX_SHIFT = 12,
	OOB_CTRL1_BURST_MIN_MASK = 15,
	OOB_CTRL1_BURST_MIN_SHIFT = 8,
	OOB_CTRL1_WAKE_IDLE_MAX_MASK = 15,
	OOB_CTRL1_WAKE_IDLE_MAX_SHIFT = 4,
	OOB_CTRL1_WAKE_IDLE_MIN_MASK = 15,
	OOB_CTRL1_WAKE_IDLE_MIN_SHIFT = 0,
	OOB_CTRL2 = 129,
	OOB_CTRL2_SEL_ENA_SHIFT = 15,
	OOB_CTRL2_SEL_ENA_RC_SHIFT = 14,
	OOB_CTRL2_RESET_IDLE_MAX_MASK = 63,
	OOB_CTRL2_RESET_IDLE_MAX_SHIFT = 8,
	OOB_CTRL2_BURST_CNT_MASK = 3,
	OOB_CTRL2_BURST_CNT_SHIFT = 6,
	OOB_CTRL2_RESET_IDLE_MIN_MASK = 63,
	OOB_CTRL2_RESET_IDLE_MIN_SHIFT = 0,
	TXPMD_REG_BANK = 416,
	TXPMD_CONTROL1 = 129,
	TXPMD_CONTROL1_TX_SSC_EN_FRC = 1,
	TXPMD_CONTROL1_TX_SSC_EN_FRC_VAL = 2,
	TXPMD_TX_FREQ_CTRL_CONTROL1 = 130,
	TXPMD_TX_FREQ_CTRL_CONTROL2 = 131,
	TXPMD_TX_FREQ_CTRL_CONTROL2_FMIN_MASK = 1023,
	TXPMD_TX_FREQ_CTRL_CONTROL3 = 132,
	TXPMD_TX_FREQ_CTRL_CONTROL3_FMAX_MASK = 1023,
	RXPMD_REG_BANK = 448,
	RXPMD_RX_CDR_CONTROL1 = 129,
	RXPMD_RX_PPM_VAL_MASK = 511,
	RXPMD_RXPMD_EN_FRC = 4096,
	RXPMD_RXPMD_EN_FRC_VAL = 8192,
	RXPMD_RX_CDR_CDR_PROP_BW = 130,
	RXPMD_G_CDR_PROP_BW_MASK = 7,
	RXPMD_G1_CDR_PROP_BW_SHIFT = 0,
	RXPMD_G2_CDR_PROP_BW_SHIFT = 3,
	RXPMD_G3_CDR_PROB_BW_SHIFT = 6,
	RXPMD_RX_CDR_CDR_ACQ_INTEG_BW = 131,
	RXPMD_G_CDR_ACQ_INT_BW_MASK = 7,
	RXPMD_G1_CDR_ACQ_INT_BW_SHIFT = 0,
	RXPMD_G2_CDR_ACQ_INT_BW_SHIFT = 3,
	RXPMD_G3_CDR_ACQ_INT_BW_SHIFT = 6,
	RXPMD_RX_CDR_CDR_LOCK_INTEG_BW = 132,
	RXPMD_G_CDR_LOCK_INT_BW_MASK = 7,
	RXPMD_G1_CDR_LOCK_INT_BW_SHIFT = 0,
	RXPMD_G2_CDR_LOCK_INT_BW_SHIFT = 3,
	RXPMD_G3_CDR_LOCK_INT_BW_SHIFT = 6,
	RXPMD_RX_FREQ_MON_CONTROL1 = 135,
	RXPMD_MON_CORRECT_EN = 256,
	RXPMD_MON_MARGIN_VAL_MASK = 255,
};

enum sata_phy_ctrl_regs {
	PHY_CTRL_1 = 0,
	PHY_CTRL_1_RESET = 1,
};

enum brcmusb_reg_sel {
	BRCM_REGS_CTRL = 0,
	BRCM_REGS_XHCI_EC = 1,
	BRCM_REGS_XHCI_GBL = 2,
	BRCM_REGS_USB_PHY = 3,
	BRCM_REGS_USB_MDIO = 4,
	BRCM_REGS_BDC_EC = 5,
	BRCM_REGS_MAX = 6,
};

struct brcm_usb_init_params;

struct brcm_usb_init_ops {
	void (*init_ipp)(struct brcm_usb_init_params *);
	void (*init_common)(struct brcm_usb_init_params *);
	void (*init_eohci)(struct brcm_usb_init_params *);
	void (*init_xhci)(struct brcm_usb_init_params *);
	void (*uninit_common)(struct brcm_usb_init_params *);
	void (*uninit_eohci)(struct brcm_usb_init_params *);
	void (*uninit_xhci)(struct brcm_usb_init_params *);
	int (*get_dual_select)(struct brcm_usb_init_params *);
	void (*set_dual_select)(struct brcm_usb_init_params *, int);
};

struct brcm_usb_init_params {
	void *regs[6];
	int ioc;
	int ipp;
	int mode;
	u32 family_id;
	u32 product_id;
	int selected_family;
	const char *family_name;
	const u32 *usb_reg_bits_map;
	const struct brcm_usb_init_ops *ops;
	struct regmap *syscon_piarbctl;
	bool wake_enabled;
	bool suspend_with_clocks;
};

enum brcm_usb_phy_id {
	BRCM_USB_PHY_2_0 = 0,
	BRCM_USB_PHY_3_0 = 1,
	BRCM_USB_PHY_ID_MAX = 2,
};

struct value_to_name_map {
	int value;
	const char *name;
};

struct match_chip_info {
	void *init_func;
	u8 required_regs[7];
	u8 optional_reg;
};

struct brcm_usb_phy {
	struct phy *phy;
	unsigned int id;
	bool inited;
};

struct brcm_usb_phy_data {
	struct brcm_usb_init_params ini;
	bool has_eohci;
	bool has_xhci;
	struct clk *usb_20_clk;
	struct clk *usb_30_clk;
	struct clk *suspend_clk;
	struct mutex mutex;
	int init_count;
	int wake_irq;
	struct brcm_usb_phy phys[2];
};

enum brcm_family_type {
	BRCM_FAMILY_3390A0 = 0,
	BRCM_FAMILY_7250B0 = 1,
	BRCM_FAMILY_7271A0 = 2,
	BRCM_FAMILY_7364A0 = 3,
	BRCM_FAMILY_7366C0 = 4,
	BRCM_FAMILY_74371A0 = 5,
	BRCM_FAMILY_7439B0 = 6,
	BRCM_FAMILY_7445D0 = 7,
	BRCM_FAMILY_7260A0 = 8,
	BRCM_FAMILY_7278A0 = 9,
	BRCM_FAMILY_COUNT = 10,
};

enum {
	USB_CTRL_SETUP_SCB1_EN_SELECTOR = 0,
	USB_CTRL_SETUP_SCB2_EN_SELECTOR = 1,
	USB_CTRL_SETUP_SS_EHCI64BIT_EN_SELECTOR = 2,
	USB_CTRL_SETUP_STRAP_IPP_SEL_SELECTOR = 3,
	USB_CTRL_SETUP_OC3_DISABLE_SELECTOR = 4,
	USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_SELECTOR = 5,
	USB_CTRL_USB_PM_BDC_SOFT_RESETB_SELECTOR = 6,
	USB_CTRL_USB_PM_XHC_SOFT_RESETB_SELECTOR = 7,
	USB_CTRL_USB_PM_USB_PWRDN_SELECTOR = 8,
	USB_CTRL_USB30_CTL1_XHC_SOFT_RESETB_SELECTOR = 9,
	USB_CTRL_USB30_CTL1_USB3_IOC_SELECTOR = 10,
	USB_CTRL_USB30_CTL1_USB3_IPP_SELECTOR = 11,
	USB_CTRL_USB_DEVICE_CTL1_PORT_MODE_SELECTOR = 12,
	USB_CTRL_USB_PM_SOFT_RESET_SELECTOR = 13,
	USB_CTRL_SETUP_CC_DRD_MODE_ENABLE_SELECTOR = 14,
	USB_CTRL_SETUP_STRAP_CC_DRD_MODE_ENABLE_SEL_SELECTOR = 15,
	USB_CTRL_USB_PM_USB20_HC_RESETB_SELECTOR = 16,
	USB_CTRL_SETUP_ENDIAN_SELECTOR = 17,
	USB_CTRL_SELECTOR_COUNT = 18,
};

struct id_to_type {
	u32 id;
	int type;
};

struct sr_pcie_phy_core;

struct sr_pcie_phy {
	struct sr_pcie_phy_core *core;
	unsigned int index;
	struct phy *phy;
};

struct sr_pcie_phy_core {
	struct device *dev;
	void *base;
	struct regmap *cdru;
	struct regmap *mhb;
	u32 pipemux;
	struct sr_pcie_phy phys[9];
};

enum bcm_usb_phy_version {
	BCM_SR_USB_COMBO_PHY = 0,
	BCM_SR_USB_HS_PHY = 1,
};

enum bcm_usb_phy_reg {
	PLL_CTRL = 0,
	PHY_CTRL = 1,
	PHY_PLL_CTRL = 2,
};

enum pll_ctrl_bits {
	PLL_RESETB = 0,
	SSPLL_SUSPEND_EN = 1,
	PLL_SEQ_START = 2,
	PLL_LOCK = 3,
};

enum bcm_usb_phy_ctrl_bits {
	CORERDY = 0,
	PHY_RESETB = 1,
	PHY_PCTL = 2,
};

struct bcm_usb_phy_cfg {
	uint32_t type;
	uint32_t version;
	void *regs;
	struct phy *phy;
	const u8 *offset;
};

enum bcm_usb_phy_type {
	USB_HS_PHY = 0,
	USB_SS_PHY = 1,
};

struct hix5hd2_priv {
	void *base;
	struct regmap *peri_ctrl;
};

enum phy_speed_mode {
	SPEED_MODE_GEN1 = 0,
	SPEED_MODE_GEN2 = 1,
	SPEED_MODE_GEN3 = 2,
};

struct armada375_cluster_phy {
	struct phy *phy;
	void *reg;
	bool use_usb3;
	int phy_provided;
};

struct phy_berlin_desc {
	struct phy *phy;
	u32 power_bit;
	unsigned int index;
};

struct phy_berlin_priv {
	void *base;
	spinlock_t lock;
	struct clk *clk;
	struct phy_berlin_desc **phys;
	unsigned int nphys;
	u32 phy_base;
};

struct phy_berlin_usb_priv {
	void *base;
	struct reset_control *rst_ctrl;
	u32 pll_divider;
};

struct mvebu_a3700_comphy_conf {
	unsigned int lane;
	enum phy_mode mode;
	int submode;
	unsigned int port;
	u32 fw_mode;
};

struct mvebu_a3700_comphy_lane {
	struct device *dev;
	unsigned int id;
	enum phy_mode mode;
	int submode;
	int port;
};

struct mvebu_a3700_utmi_caps {
	int usb32;
	const struct phy_ops *ops;
};

struct mvebu_a3700_utmi {
	void *regs;
	struct regmap *usb_misc;
	const struct mvebu_a3700_utmi_caps *caps;
	struct phy *phy;
};

struct priv {
	struct clk *clk;
	void *base;
};

struct rockchip_usb_phys {
	int reg;
	const char *pll_name;
};

struct rockchip_usb_phy_pdata {
	struct rockchip_usb_phys *phys;
	int (*init_usb_uart)(struct regmap *, const struct rockchip_usb_phy_pdata *);
	int usb_uart_phy;
};

struct rockchip_usb_phy_base {
	struct device *dev;
	struct regmap *reg_base;
	const struct rockchip_usb_phy_pdata *pdata;
};

struct rockchip_usb_phy {
	struct rockchip_usb_phy_base *base;
	struct device_node *np;
	unsigned int reg_offset;
	struct clk *clk;
	struct clk *clk480m;
	struct clk_hw clk480m_hw;
	struct phy *phy;
	bool uart_enabled;
	struct reset_control *reset;
	struct regulator *vbus;
};

struct exynos_dp_video_phy_drvdata {
	u32 phy_ctrl_offset;
};

struct exynos_dp_video_phy {
	struct regmap *regs;
	const struct exynos_dp_video_phy_drvdata *drvdata;
};

enum exynos_mipi_phy_id {
	EXYNOS_MIPI_PHY_ID_NONE = 4294967295,
	EXYNOS_MIPI_PHY_ID_CSIS0 = 0,
	EXYNOS_MIPI_PHY_ID_DSIM0 = 1,
	EXYNOS_MIPI_PHY_ID_CSIS1 = 2,
	EXYNOS_MIPI_PHY_ID_DSIM1 = 3,
	EXYNOS_MIPI_PHY_ID_CSIS2 = 4,
	EXYNOS_MIPI_PHYS_NUM = 5,
};

enum exynos_mipi_phy_regmap_id {
	EXYNOS_MIPI_REGMAP_PMU = 0,
	EXYNOS_MIPI_REGMAP_DISP = 1,
	EXYNOS_MIPI_REGMAP_CAM0 = 2,
	EXYNOS_MIPI_REGMAP_CAM1 = 3,
	EXYNOS_MIPI_REGMAPS_NUM = 4,
};

struct exynos_mipi_phy_desc {
	enum exynos_mipi_phy_id coupled_phy_id;
	u32 enable_val;
	unsigned int enable_reg;
	enum exynos_mipi_phy_regmap_id enable_map;
	u32 resetn_val;
	unsigned int resetn_reg;
	enum exynos_mipi_phy_regmap_id resetn_map;
};

struct mipi_phy_device_desc {
	int num_phys;
	int num_regmaps;
	const char *regmap_names[4];
	struct exynos_mipi_phy_desc phys[5];
};

struct video_phy_desc {
	struct phy *phy;
	unsigned int index;
	const struct exynos_mipi_phy_desc *data;
};

struct exynos_mipi_video_phy {
	struct regmap *regmaps[4];
	int num_phys;
	struct video_phy_desc phys[5];
	spinlock_t slock;
};

enum exynos5_usbdrd_phy_id {
	EXYNOS5_DRDPHY_UTMI = 0,
	EXYNOS5_DRDPHY_PIPE3 = 1,
	EXYNOS5_DRDPHYS_NUM = 2,
};

struct phy_usb_instance;

struct exynos5_usbdrd_phy;

struct exynos5_usbdrd_phy_config {
	u32 id;
	void (*phy_isol)(struct phy_usb_instance *, u32);
	void (*phy_init)(struct exynos5_usbdrd_phy *);
	unsigned int (*set_refclk)(struct phy_usb_instance *);
};

struct phy_usb_instance {
	struct phy *phy;
	u32 index;
	struct regmap *reg_pmu;
	u32 pmu_offset;
	const struct exynos5_usbdrd_phy_config *phy_cfg;
};

struct exynos5_usbdrd_phy_drvdata;

struct exynos5_usbdrd_phy {
	struct device *dev;
	void *reg_phy;
	struct clk *clk;
	struct clk *pipeclk;
	struct clk *utmiclk;
	struct clk *itpclk;
	const struct exynos5_usbdrd_phy_drvdata *drv_data;
	struct phy_usb_instance phys[2];
	u32 extrefclk;
	struct clk *ref_clk;
	struct regulator *vbus;
	struct regulator *vbus_boost;
};

struct exynos5_usbdrd_phy_drvdata {
	const struct exynos5_usbdrd_phy_config *phy_cfg;
	u32 pmu_offset_usbdrd0_phy;
	u32 pmu_offset_usbdrd1_phy;
	bool has_common_clk_gate;
};

struct uniphier_u2phy_param {
	u32 offset;
	u32 value;
};

struct uniphier_u2phy_soc_data {
	struct uniphier_u2phy_param config0;
	struct uniphier_u2phy_param config1;
};

struct uniphier_u2phy_priv {
	struct regmap *regmap;
	struct phy *phy;
	struct regulator *vbus;
	const struct uniphier_u2phy_soc_data *data;
	struct uniphier_u2phy_priv *next;
};

struct uniphier_u3hsphy_param {
	struct {
		int reg_no;
		int msb;
		int lsb;
	} field;
	u8 value;
};

struct uniphier_u3hsphy_trim_param {
	unsigned int rterm;
	unsigned int sel_t;
	unsigned int hs_i;
};

struct uniphier_u3hsphy_soc_data;

struct uniphier_u3hsphy_priv {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct clk *clk_parent;
	struct clk *clk_ext;
	struct clk *clk_parent_gio;
	struct reset_control *rst;
	struct reset_control *rst_parent;
	struct reset_control *rst_parent_gio;
	struct regulator *vbus;
	const struct uniphier_u3hsphy_soc_data *data;
};

struct uniphier_u3hsphy_soc_data {
	bool is_legacy;
	int nparams;
	const struct uniphier_u3hsphy_param param[4];
	u32 config0;
	u32 config1;
	void (*trim_func)(struct uniphier_u3hsphy_priv *, u32 *, struct uniphier_u3hsphy_trim_param *);
};

struct nvmem_cell;

struct uniphier_u3ssphy_param {
	struct {
		int reg_no;
		int msb;
		int lsb;
	} field;
	u8 value;
};

struct uniphier_u3ssphy_soc_data;

struct uniphier_u3ssphy_priv {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct clk *clk_ext;
	struct clk *clk_parent;
	struct clk *clk_parent_gio;
	struct reset_control *rst;
	struct reset_control *rst_parent;
	struct reset_control *rst_parent_gio;
	struct regulator *vbus;
	const struct uniphier_u3ssphy_soc_data *data;
};

struct uniphier_u3ssphy_soc_data {
	bool is_legacy;
	int nparams;
	const struct uniphier_u3ssphy_param param[7];
};

struct uniphier_ahciphy_soc_data;

struct uniphier_ahciphy_priv {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct clk *clk_parent;
	struct reset_control *rst;
	struct reset_control *rst_parent;
	const struct uniphier_ahciphy_soc_data *data;
};

struct uniphier_ahciphy_soc_data {
	int (*init)(struct uniphier_ahciphy_priv *);
	int (*power_on)(struct uniphier_ahciphy_priv *);
	int (*power_off)(struct uniphier_ahciphy_priv *);
	bool is_ready_high;
	bool is_phy_clk;
};

enum {
	SYSCFG_CTRL = 0,
	SYSCFG_STATUS = 1,
	SYSCFG_PCI = 2,
	SYSCFG_SATA = 3,
	SYSCFG_REG_MAX = 4,
};

struct miphy28lp_dev;

struct miphy28lp_phy {
	struct phy *phy;
	struct miphy28lp_dev *phydev;
	void *base;
	void *pipebase;
	bool osc_force_ext;
	bool osc_rdy;
	bool px_rx_pol_inv;
	bool ssc;
	bool tx_impedance;
	struct reset_control *miphy_rst;
	u32 sata_gen;
	u32 syscfg_reg[4];
	u8 type;
};

struct miphy28lp_dev {
	struct device *dev;
	struct regmap *regmap;
	struct mutex miphy_mutex;
	struct miphy28lp_phy **phys;
	int nphys;
};

enum miphy_sata_gen {
	SATA_GEN1 = 0,
	SATA_GEN2 = 1,
	SATA_GEN3 = 2,
};

struct pll_ratio {
	int clk_ref;
	int calset_1;
	int calset_2;
	int calset_3;
	int calset_4;
	int cal_ctrl;
};

struct miphy28lp_pll_gen {
	int bank;
	int speed;
	int bias_boost_1;
	int bias_boost_2;
	int tx_ctrl_1;
	int tx_ctrl_2;
	int tx_ctrl_3;
	int rx_k_gain;
	int rx_vga_gain;
	int rx_equ_gain_1;
	int rx_equ_gain_2;
	int rx_equ_gain_3;
	int rx_buff_ctrl;
};

enum spear1310_miphy_mode {
	SATA = 0,
	PCIE = 1,
};

struct spear1310_miphy_priv {
	u32 id;
	enum spear1310_miphy_mode mode;
	struct regmap *misc;
	struct phy *phy;
};

enum spear1340_miphy_mode {
	SATA___2 = 0,
	PCIE___2 = 1,
};

struct spear1340_miphy_priv {
	enum spear1340_miphy_mode mode;
	struct regmap *misc;
	struct phy *phy;
};

struct stih407_usb2_picophy {
	struct phy *phy;
	struct regmap *regmap;
	struct device *dev;
	struct reset_control *rstc;
	struct reset_control *rstport;
	int ctrl;
	int param;
};

struct regulator_bulk_data {
	const char *supply;
	struct regulator *consumer;
	int ret;
};

struct pll_params {
	u8 ndiv;
	u16 frac;
};

struct stm32_usbphyc;

struct stm32_usbphyc_phy {
	struct phy *phy;
	struct stm32_usbphyc *usbphyc;
	struct regulator_bulk_data supplies[2];
	u32 index;
	bool active;
};

struct stm32_usbphyc {
	struct device *dev;
	void *base;
	struct clk *clk;
	struct reset_control *rst;
	struct stm32_usbphyc_phy **phys;
	int nphys;
	int switch_setup;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	char: 8;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	int: 24;
	int: 32;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
	int: 32;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[4];
};

struct usb_device;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
};

struct wusb_dev;

enum usb_device_removable {
	USB_DEVICE_REMOVABLE_UNKNOWN = 0,
	USB_DEVICE_REMOVABLE = 1,
	USB_DEVICE_FIXED = 2,
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	enum usb_device_removable removable;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

struct usb_phy;

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_otg;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

enum usb_role {
	USB_ROLE_NONE = 0,
	USB_ROLE_HOST = 1,
	USB_ROLE_DEVICE = 2,
};

struct usb_role_switch;

typedef int (*usb_role_switch_set_t)(struct usb_role_switch *, enum usb_role);

typedef enum usb_role (*usb_role_switch_get_t)(struct usb_role_switch *);

struct usb_role_switch_desc {
	struct fwnode_handle *fwnode;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
	void *driver_data;
	const char *name;
};

struct tegra_xusb_lane_soc {
	const char *name;
	unsigned int offset;
	unsigned int shift;
	unsigned int mask;
	const char * const *funcs;
	unsigned int num_funcs;
};

struct tegra_xusb_pad;

struct tegra_xusb_lane {
	const struct tegra_xusb_lane_soc *soc;
	struct tegra_xusb_pad *pad;
	struct device_node *np;
	struct list_head list;
	unsigned int function;
	unsigned int index;
};

struct tegra_xusb_pad_soc;

struct tegra_xusb_padctl;

struct tegra_xusb_lane_ops;

struct tegra_xusb_pad {
	const struct tegra_xusb_pad_soc *soc;
	struct tegra_xusb_padctl *padctl;
	struct phy_provider *provider;
	struct phy **lanes;
	struct device dev;
	const struct tegra_xusb_lane_ops *ops;
	struct list_head list;
	int: 32;
};

struct tegra_xusb_lane_ops {
	struct tegra_xusb_lane * (*probe)(struct tegra_xusb_pad *, struct device_node *, unsigned int);
	void (*remove)(struct tegra_xusb_lane *);
};

struct tegra_xusb_pad_ops {
	struct tegra_xusb_pad * (*probe)(struct tegra_xusb_padctl *, const struct tegra_xusb_pad_soc *, struct device_node *);
	void (*remove)(struct tegra_xusb_pad *);
};

struct tegra_xusb_padctl_soc;

struct tegra_xusb_padctl {
	struct device *dev;
	void *regs;
	struct mutex lock;
	struct reset_control *rst;
	const struct tegra_xusb_padctl_soc *soc;
	struct tegra_xusb_pad *pcie;
	struct tegra_xusb_pad *sata;
	struct tegra_xusb_pad *ulpi;
	struct tegra_xusb_pad *usb2;
	struct tegra_xusb_pad *hsic;
	struct list_head ports;
	struct list_head lanes;
	struct list_head pads;
	unsigned int enable;
	struct clk *clk;
	struct regulator_bulk_data *supplies;
};

struct tegra_xusb_pad_soc {
	const char *name;
	const struct tegra_xusb_lane_soc *lanes;
	unsigned int num_lanes;
	const struct tegra_xusb_pad_ops *ops;
};

struct tegra_xusb_port_ops;

struct tegra_xusb_port {
	struct tegra_xusb_padctl *padctl;
	struct tegra_xusb_lane *lane;
	unsigned int index;
	struct list_head list;
	int: 32;
	struct device dev;
	struct usb_role_switch *usb_role_sw;
	struct work_struct usb_phy_work;
	struct usb_phy usb_phy;
	const struct tegra_xusb_port_ops *ops;
};

struct tegra_xusb_port_ops {
	void (*release)(struct tegra_xusb_port *);
	void (*remove)(struct tegra_xusb_port *);
	int (*enable)(struct tegra_xusb_port *);
	void (*disable)(struct tegra_xusb_port *);
	struct tegra_xusb_lane * (*map)(struct tegra_xusb_port *);
};

struct tegra_xusb_lane_map {
	unsigned int port;
	const char *type;
	unsigned int index;
	const char *func;
};

struct tegra_xusb_usb2_port {
	struct tegra_xusb_port base;
	struct regulator *supply;
	enum usb_dr_mode mode;
	bool internal;
	int usb3_port_fake;
};

struct tegra_xusb_ulpi_port {
	struct tegra_xusb_port base;
	struct regulator *supply;
	bool internal;
};

struct tegra_xusb_hsic_port {
	struct tegra_xusb_port base;
};

struct tegra_xusb_usb3_port {
	struct tegra_xusb_port base;
	struct regulator *supply;
	bool context_saved;
	unsigned int port;
	bool internal;
	bool disable_gen2;
	u32 tap1;
	u32 amp;
	u32 ctle_z;
	u32 ctle_g;
};

struct tegra_xusb_padctl_ops {
	struct tegra_xusb_padctl * (*probe)(struct device *, const struct tegra_xusb_padctl_soc *);
	void (*remove)(struct tegra_xusb_padctl *);
	int (*usb3_save_context)(struct tegra_xusb_padctl *, unsigned int);
	int (*hsic_set_idle)(struct tegra_xusb_padctl *, unsigned int, bool);
	int (*usb3_set_lfps_detect)(struct tegra_xusb_padctl *, unsigned int, bool);
	int (*vbus_override)(struct tegra_xusb_padctl *, bool);
	int (*utmi_port_reset)(struct phy *);
};

struct tegra_xusb_padctl_soc {
	const struct tegra_xusb_pad_soc * const *pads;
	unsigned int num_pads;
	struct {
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} usb2;
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} ulpi;
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} hsic;
		struct {
			const struct tegra_xusb_port_ops *ops;
			unsigned int count;
		} usb3;
	} ports;
	const struct tegra_xusb_padctl_ops *ops;
	const char * const *supply_names;
	unsigned int num_supplies;
	bool supports_gen2;
	bool need_fake_usb3_port;
};

struct tegra_xusb_usb2_lane {
	struct tegra_xusb_lane base;
	u32 hs_curr_level_offset;
	bool powered_on;
};

struct tegra_xusb_ulpi_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_hsic_lane {
	struct tegra_xusb_lane base;
	u32 strobe_trim;
	u32 rx_strobe_trim;
	u32 rx_data_trim;
	u32 tx_rtune_n;
	u32 tx_rtune_p;
	u32 tx_rslew_n;
	u32 tx_rslew_p;
	bool auto_term;
};

struct tegra_xusb_pcie_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_sata_lane {
	struct tegra_xusb_lane base;
};

struct tegra_xusb_usb2_pad {
	struct tegra_xusb_pad base;
	struct clk *clk;
	unsigned int enable;
	struct mutex lock;
	int: 32;
};

struct tegra_xusb_ulpi_pad {
	struct tegra_xusb_pad base;
};

struct tegra_xusb_hsic_pad {
	struct tegra_xusb_pad base;
	struct regulator *supply;
	struct clk *clk;
};

struct tegra_xusb_pcie_pad {
	struct tegra_xusb_pad base;
	struct reset_control *rst;
	struct clk *pll;
	unsigned int enable;
	int: 32;
};

struct tegra_xusb_sata_pad {
	struct tegra_xusb_pad base;
	struct reset_control *rst;
	struct clk *pll;
	unsigned int enable;
	int: 32;
};

struct tegra124_xusb_fuse_calibration {
	u32 hs_curr_level[3];
	u32 hs_iref_cap;
	u32 hs_term_range_adj;
	u32 hs_squelch_level;
};

struct tegra124_xusb_padctl {
	struct tegra_xusb_padctl base;
	struct tegra124_xusb_fuse_calibration fuse;
};

enum omap_control_phy_type {
	OMAP_CTRL_TYPE_OTGHS = 1,
	OMAP_CTRL_TYPE_USB2 = 2,
	OMAP_CTRL_TYPE_PIPE3 = 3,
	OMAP_CTRL_TYPE_PCIE = 4,
	OMAP_CTRL_TYPE_DRA7USB2 = 5,
	OMAP_CTRL_TYPE_AM437USB2 = 6,
};

struct omap_control_phy {
	struct device *dev;
	u32 *otghs_control;
	u32 *power;
	u32 *power_aux;
	u32 *pcie_pcs;
	struct clk *sys_clk;
	enum omap_control_phy_type type;
};

enum omap_control_usb_mode {
	USB_MODE_UNDEFINED = 0,
	USB_MODE_HOST = 1,
	USB_MODE_DEVICE = 2,
	USB_MODE_DISCONNECT = 3,
};

struct phy_companion {
	int (*set_vbus)(struct phy_companion *, bool);
	int (*start_srp)(struct phy_companion *);
};

struct omap_usb {
	struct usb_phy phy;
	struct phy_companion *comparator;
	void *pll_ctrl_base;
	void *phy_base;
	struct device *dev;
	struct device *control_dev;
	struct clk *wkupclk;
	struct clk *optclk;
	u8 flags;
	struct regmap *syscon_phy_power;
	unsigned int power_reg;
	u32 mask;
	u32 power_on;
	u32 power_off;
};

struct usb_phy_data {
	const char *label;
	u8 flags;
	u32 mask;
	u32 power_on;
	u32 power_off;
};

enum pipe3_mode {
	PIPE3_MODE_PCIE = 1,
	PIPE3_MODE_SATA = 2,
	PIPE3_MODE_USBSS = 3,
};

struct pipe3_dpll_params {
	u16 m;
	u8 n;
	u8 freq: 3;
	u8 sd;
	u32 mf;
};

struct pipe3_dpll_map {
	long unsigned int rate;
	struct pipe3_dpll_params params;
};

struct pipe3_settings {
	u8 ana_interface;
	u8 ana_losd;
	u8 dig_fastlock;
	u8 dig_lbw;
	u8 dig_stepcnt;
	u8 dig_stl;
	u8 dig_thr;
	u8 dig_thr_mode;
	u8 dig_2ndo_sdm_mode;
	u8 dig_hs_rate;
	u8 dig_ovrd_hs_rate;
	u8 dll_trim_sel;
	u8 dll_phint_rate;
	u8 eq_lev;
	u8 eq_ftc;
	u8 eq_ctl;
	u8 eq_ovrd_lev;
	u8 eq_ovrd_ftc;
};

struct ti_pipe3 {
	void *pll_ctrl_base;
	void *phy_rx;
	void *phy_tx;
	struct device *dev;
	struct device *control_dev;
	struct clk *wkupclk;
	struct clk *sys_clk;
	struct clk *refclk;
	struct clk *div_clk;
	struct pipe3_dpll_map *dpll_map;
	struct regmap *phy_power_syscon;
	struct regmap *pcs_syscon;
	struct regmap *dpll_reset_syscon;
	unsigned int dpll_reset_reg;
	unsigned int power_reg;
	unsigned int pcie_pcs_reg;
	bool sata_refclk_enabled;
	enum pipe3_mode mode;
	struct pipe3_settings settings;
};

struct pipe3_data {
	enum pipe3_mode mode;
	struct pipe3_dpll_map *dpll_map;
	struct pipe3_settings settings;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

enum {
	PHY_GMII_SEL_PORT_MODE = 0,
	PHY_GMII_SEL_RGMII_ID_MODE = 1,
	PHY_GMII_SEL_RMII_IO_CLK_EN = 2,
	PHY_GMII_SEL_LAST = 3,
};

struct regmap_field;

struct phy_gmii_sel_priv;

struct phy_gmii_sel_phy_priv {
	struct phy_gmii_sel_priv *priv;
	u32 id;
	struct phy *if_phy;
	int rmii_clock_external;
	int phy_if_mode;
	struct regmap_field *fields[3];
};

struct phy_gmii_sel_soc_data;

struct phy_gmii_sel_priv {
	struct device *dev;
	const struct phy_gmii_sel_soc_data *soc_data;
	struct regmap *regmap;
	struct phy_provider *phy_provider;
	struct phy_gmii_sel_phy_priv *if_phys;
	u32 num_ports;
	u32 reg_offset;
};

struct phy_gmii_sel_soc_data {
	u32 num_ports;
	u32 features;
	const struct reg_field (*regfields)[3];
	bool use_of_data;
};

struct pinctrl {
	struct list_head node;
	struct device *dev;
	struct list_head states;
	struct pinctrl_state *state;
	struct list_head dt_maps;
	struct kref users;
};

struct pinctrl_state {
	struct list_head node;
	const char *name;
	struct list_head settings;
};

struct pinctrl_pin_desc {
	unsigned int number;
	const char *name;
	void *drv_data;
};

struct gpio_chip;

struct pinctrl_gpio_range {
	struct list_head node;
	const char *name;
	unsigned int id;
	unsigned int base;
	unsigned int pin_base;
	unsigned int npins;
	const unsigned int *pins;
	struct gpio_chip *gc;
};

struct gpio_irq_chip {
	struct irq_chip *chip;
	struct irq_domain *domain;
	const struct irq_domain_ops *domain_ops;
	struct fwnode_handle *fwnode;
	struct irq_domain *parent_domain;
	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
	void * (*populate_parent_alloc_arg)(struct gpio_chip *, unsigned int, unsigned int);
	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
	struct irq_domain_ops child_irq_domain_ops;
	irq_flow_handler_t handler;
	unsigned int default_type;
	struct lock_class_key *lock_key;
	struct lock_class_key *request_key;
	irq_flow_handler_t parent_handler;
	void *parent_handler_data;
	unsigned int num_parents;
	unsigned int *parents;
	unsigned int *map;
	bool threaded;
	int (*init_hw)(struct gpio_chip *);
	void (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	long unsigned int *valid_mask;
	unsigned int first;
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int base;
	u16 ngpio;
	const char * const *names;
	bool can_sleep;
	long unsigned int (*read_reg)(void *);
	void (*write_reg)(void *, long unsigned int);
	bool be_bits;
	void *reg_dat;
	void *reg_set;
	void *reg_clr;
	void *reg_dir_out;
	void *reg_dir_in;
	bool bgpio_dir_unreadable;
	int bgpio_bits;
	spinlock_t bgpio_lock;
	long unsigned int bgpio_data;
	long unsigned int bgpio_dir;
	struct gpio_irq_chip irq;
	long unsigned int *valid_mask;
	struct device_node *of_node;
	unsigned int of_gpio_n_cells;
	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
};

struct pinctrl_dev;

struct pinctrl_map;

struct pinctrl_ops {
	int (*get_groups_count)(struct pinctrl_dev *);
	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
};

struct pinctrl_desc;

struct pinctrl_dev {
	struct list_head node;
	struct pinctrl_desc *desc;
	struct xarray pin_desc_tree;
	struct xarray pin_group_tree;
	unsigned int num_groups;
	struct xarray pin_function_tree;
	unsigned int num_functions;
	struct list_head gpio_ranges;
	struct device *dev;
	struct module *owner;
	void *driver_data;
	struct pinctrl *p;
	struct pinctrl_state *hog_default;
	struct pinctrl_state *hog_sleep;
	struct mutex mutex;
	struct dentry *device_root;
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct pinmux_ops;

struct pinconf_ops;

struct pinconf_generic_params;

struct pin_config_item;

struct pinctrl_desc {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinctrl_ops *pctlops;
	const struct pinmux_ops *pmxops;
	const struct pinconf_ops *confops;
	struct module *owner;
	unsigned int num_custom_params;
	const struct pinconf_generic_params *custom_params;
	const struct pin_config_item *custom_conf_items;
	bool link_consumers;
};

struct pinmux_ops {
	int (*request)(struct pinctrl_dev *, unsigned int);
	int (*free)(struct pinctrl_dev *, unsigned int);
	int (*get_functions_count)(struct pinctrl_dev *);
	const char * (*get_function_name)(struct pinctrl_dev *, unsigned int);
	int (*get_function_groups)(struct pinctrl_dev *, unsigned int, const char * const **, unsigned int *);
	int (*set_mux)(struct pinctrl_dev *, unsigned int, unsigned int);
	int (*gpio_request_enable)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	void (*gpio_disable_free)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	bool strict;
};

struct pinconf_ops {
	bool is_generic;
	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, long unsigned int);
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_LOW_POWER_MODE = 15,
	PIN_CONFIG_OUTPUT_ENABLE = 16,
	PIN_CONFIG_OUTPUT = 17,
	PIN_CONFIG_POWER_SOURCE = 18,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 19,
	PIN_CONFIG_SLEW_RATE = 20,
	PIN_CONFIG_SKEW_DELAY = 21,
	PIN_CONFIG_PERSIST_STATE = 22,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct pinconf_generic_params {
	const char * const property;
	enum pin_config_param param;
	u32 default_value;
};

struct pin_config_item {
	const enum pin_config_param param;
	const char * const display;
	const char * const format;
	bool has_arg;
};

struct gpio_device {
	int id;
	int: 32;
	struct device dev;
	struct cdev chrdev;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head notifier;
	struct list_head pin_ranges;
};

struct gpio_desc {
	struct gpio_device *gdev;
	long unsigned int flags;
	const char *label;
	const char *name;
	struct device_node *hog;
	unsigned int debounce_period_us;
};

struct pinctrl_setting_mux {
	unsigned int group;
	unsigned int func;
};

struct pinctrl_setting_configs {
	unsigned int group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_setting {
	struct list_head node;
	enum pinctrl_map_type type;
	struct pinctrl_dev *pctldev;
	const char *dev_name;
	union {
		struct pinctrl_setting_mux mux;
		struct pinctrl_setting_configs configs;
	} data;
};

struct pin_desc {
	struct pinctrl_dev *pctldev;
	const char *name;
	bool dynamic_name;
	void *drv_data;
	unsigned int mux_usecount;
	const char *mux_owner;
	const struct pinctrl_setting_mux *mux_setting;
	const char *gpio_owner;
};

struct pinctrl_maps {
	struct list_head node;
	const struct pinctrl_map *maps;
	unsigned int num_maps;
};

struct group_desc {
	const char *name;
	int *pins;
	int num_pins;
	void *data;
};

struct pctldev;

struct function_desc {
	const char *name;
	const char **group_names;
	int num_group_names;
	void *data;
};

struct pinctrl_dt_map {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_map *map;
	unsigned int num_maps;
};

struct regmap_irq_chip_data;

struct as3722 {
	struct device *dev;
	struct regmap *regmap;
	int chip_irq;
	long unsigned int irq_flags;
	bool en_intern_int_pullup;
	bool en_intern_i2c_pullup;
	bool en_ac_ok_pwr_on;
	struct regmap_irq_chip_data *irq_data;
};

struct as3722_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
	int mux_option;
};

struct as3722_gpio_pin_control {
	unsigned int mode_prop;
	int io_function;
};

struct as3722_pingroup {
	const char *name;
	const unsigned int pins[1];
	unsigned int npins;
};

struct as3722_pctrl_info {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct as3722 *as3722;
	struct gpio_chip gpio_chip;
	int pins_current_opt[8];
	const struct as3722_pin_function *functions;
	unsigned int num_functions;
	const struct as3722_pingroup *pin_groups;
	int num_pin_groups;
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
	struct as3722_gpio_pin_control gpio_control[8];
};

enum as3722_pinmux_option {
	AS3722_PINMUX_GPIO = 0,
	AS3722_PINMUX_INTERRUPT_OUT = 1,
	AS3722_PINMUX_VSUB_VBAT_UNDEB_LOW_OUT = 2,
	AS3722_PINMUX_GPIO_INTERRUPT = 3,
	AS3722_PINMUX_PWM_INPUT = 4,
	AS3722_PINMUX_VOLTAGE_IN_STBY = 5,
	AS3722_PINMUX_OC_PG_SD0 = 6,
	AS3722_PINMUX_PG_OUT = 7,
	AS3722_PINMUX_CLK32K_OUT = 8,
	AS3722_PINMUX_WATCHDOG_INPUT = 9,
	AS3722_PINMUX_SOFT_RESET_IN = 11,
	AS3722_PINMUX_PWM_OUTPUT = 12,
	AS3722_PINMUX_VSUB_VBAT_LOW_DEB_OUT = 13,
	AS3722_PINMUX_OC_PG_SD6 = 14,
};

struct at91_pinctrl_mux_ops;

struct at91_gpio_chip {
	struct gpio_chip chip;
	struct pinctrl_gpio_range range;
	struct at91_gpio_chip *next;
	int pioc_hwirq;
	int pioc_virq;
	int pioc_idx;
	void *regbase;
	struct clk *clock;
	struct at91_pinctrl_mux_ops *ops;
};

enum at91_mux {
	AT91_MUX_GPIO = 0,
	AT91_MUX_PERIPH_A = 1,
	AT91_MUX_PERIPH_B = 2,
	AT91_MUX_PERIPH_C = 3,
	AT91_MUX_PERIPH_D = 4,
};

struct at91_pinctrl_mux_ops {
	enum at91_mux (*get_periph)(void *, unsigned int);
	void (*mux_A_periph)(void *, unsigned int);
	void (*mux_B_periph)(void *, unsigned int);
	void (*mux_C_periph)(void *, unsigned int);
	void (*mux_D_periph)(void *, unsigned int);
	bool (*get_deglitch)(void *, unsigned int);
	void (*set_deglitch)(void *, unsigned int, bool);
	bool (*get_debounce)(void *, unsigned int, u32 *);
	void (*set_debounce)(void *, unsigned int, bool, u32);
	bool (*get_pulldown)(void *, unsigned int);
	void (*set_pulldown)(void *, unsigned int, bool);
	bool (*get_schmitt_trig)(void *, unsigned int);
	void (*disable_schmitt_trig)(void *, unsigned int);
	unsigned int (*get_drivestrength)(void *, unsigned int);
	void (*set_drivestrength)(void *, unsigned int, u32);
	unsigned int (*get_slewrate)(void *, unsigned int);
	void (*set_slewrate)(void *, unsigned int, u32);
	int (*irq_type)(struct irq_data *, unsigned int);
};

enum drive_strength_bit {
	DRIVE_STRENGTH_BIT_DEF = 0,
	DRIVE_STRENGTH_BIT_LOW = 1,
	DRIVE_STRENGTH_BIT_MED = 2,
	DRIVE_STRENGTH_BIT_HI = 3,
};

enum slewrate_bit {
	SLEWRATE_BIT_ENA = 0,
	SLEWRATE_BIT_DIS = 1,
};

struct at91_pmx_func {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct at91_pmx_pin {
	uint32_t bank;
	uint32_t pin;
	enum at91_mux mux;
	long unsigned int conf;
};

struct at91_pin_group {
	const char *name;
	struct at91_pmx_pin *pins_conf;
	unsigned int *pins;
	unsigned int npins;
};

struct at91_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	int nactive_banks;
	uint32_t *mux_mask;
	int nmux;
	struct at91_pmx_func *functions;
	int nfunctions;
	struct at91_pin_group *groups;
	int ngroups;
	struct at91_pinctrl_mux_ops *ops;
};

struct atmel_pioctrl_data {
	unsigned int nbanks;
	unsigned int last_bank_count;
};

struct atmel_group {
	const char *name;
	u32 pin;
};

struct atmel_pin {
	unsigned int pin_id;
	unsigned int mux;
	unsigned int ioset;
	unsigned int bank;
	unsigned int line;
	const char *device;
};

struct atmel_pioctrl {
	void *reg_base;
	struct clk *clk;
	unsigned int nbanks;
	struct pinctrl_dev *pinctrl_dev;
	struct atmel_group *groups;
	const char * const *group_names;
	struct atmel_pin **pins;
	unsigned int npins;
	struct gpio_chip *gpio_chip;
	struct irq_domain *irq_domain;
	int *irqs;
	unsigned int *pm_wakeup_sources;
	struct {
		u32 imr;
		u32 odsr;
		u32 cfgr[32];
	} *pm_suspend_backup;
	struct device *dev;
	struct device_node *node;
};

struct dc_pinmap {
	void *regs;
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc *desc;
	const char *pin_names[144];
	struct gpio_chip chip;
	spinlock_t lock;
};

struct meson_pmx_group {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
	const void *data;
};

struct meson_pmx_func {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct meson_reg_desc {
	unsigned int reg;
	unsigned int bit;
};

enum meson_reg_type {
	REG_PULLEN = 0,
	REG_PULL = 1,
	REG_DIR = 2,
	REG_OUT = 3,
	REG_IN = 4,
	REG_DS = 5,
	NUM_REG = 6,
};

enum meson_pinconf_drv {
	MESON_PINCONF_DRV_500UA = 0,
	MESON_PINCONF_DRV_2500UA = 1,
	MESON_PINCONF_DRV_3000UA = 2,
	MESON_PINCONF_DRV_4000UA = 3,
};

struct meson_bank {
	const char *name;
	unsigned int first;
	unsigned int last;
	int irq_first;
	int irq_last;
	struct meson_reg_desc regs[6];
};

struct meson_pinctrl;

struct meson_pinctrl_data {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	struct meson_pmx_group *groups;
	struct meson_pmx_func *funcs;
	unsigned int num_pins;
	unsigned int num_groups;
	unsigned int num_funcs;
	struct meson_bank *banks;
	unsigned int num_banks;
	const struct pinmux_ops *pmx_ops;
	void *pmx_data;
	int (*parse_dt)(struct meson_pinctrl *);
};

struct meson_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pcdev;
	struct pinctrl_desc desc;
	struct meson_pinctrl_data *data;
	struct regmap *reg_mux;
	struct regmap *reg_pullen;
	struct regmap *reg_pull;
	struct regmap *reg_gpio;
	struct regmap *reg_ds;
	struct gpio_chip chip;
	struct device_node *of_node;
};

struct meson8_pmx_data {
	bool is_gpio;
	unsigned int reg;
	unsigned int bit;
};

struct regulator_dev;

struct regulator_ops {
	int (*list_voltage)(struct regulator_dev *, unsigned int);
	int (*set_voltage)(struct regulator_dev *, int, int, unsigned int *);
	int (*map_voltage)(struct regulator_dev *, int, int);
	int (*set_voltage_sel)(struct regulator_dev *, unsigned int);
	int (*get_voltage)(struct regulator_dev *);
	int (*get_voltage_sel)(struct regulator_dev *);
	int (*set_current_limit)(struct regulator_dev *, int, int);
	int (*get_current_limit)(struct regulator_dev *);
	int (*set_input_current_limit)(struct regulator_dev *, int);
	int (*set_over_current_protection)(struct regulator_dev *);
	int (*set_active_discharge)(struct regulator_dev *, bool);
	int (*enable)(struct regulator_dev *);
	int (*disable)(struct regulator_dev *);
	int (*is_enabled)(struct regulator_dev *);
	int (*set_mode)(struct regulator_dev *, unsigned int);
	unsigned int (*get_mode)(struct regulator_dev *);
	int (*get_error_flags)(struct regulator_dev *, unsigned int *);
	int (*enable_time)(struct regulator_dev *);
	int (*set_ramp_delay)(struct regulator_dev *, int);
	int (*set_voltage_time)(struct regulator_dev *, int, int);
	int (*set_voltage_time_sel)(struct regulator_dev *, unsigned int, unsigned int);
	int (*set_soft_start)(struct regulator_dev *);
	int (*get_status)(struct regulator_dev *);
	unsigned int (*get_optimum_mode)(struct regulator_dev *, int, int, int);
	int (*set_load)(struct regulator_dev *, int);
	int (*set_bypass)(struct regulator_dev *, bool);
	int (*get_bypass)(struct regulator_dev *, bool *);
	int (*set_suspend_voltage)(struct regulator_dev *, int);
	int (*set_suspend_enable)(struct regulator_dev *);
	int (*set_suspend_disable)(struct regulator_dev *);
	int (*set_suspend_mode)(struct regulator_dev *, unsigned int);
	int (*resume)(struct regulator_dev *);
	int (*set_pull_down)(struct regulator_dev *);
};

struct regulator_coupler;

struct coupling_desc {
	struct regulator_dev **coupled_rdevs;
	struct regulator_coupler *coupler;
	int n_resolved;
	int n_coupled;
};

struct regulator_desc;

struct regulation_constraints;

struct regulator_enable_gpio;

struct regulator_dev {
	const struct regulator_desc *desc;
	int exclusive;
	u32 use_count;
	u32 open_count;
	u32 bypass_count;
	struct list_head list;
	struct list_head consumer_list;
	struct coupling_desc coupling_desc;
	struct blocking_notifier_head notifier;
	struct ww_mutex mutex;
	struct task_struct *mutex_owner;
	int ref_cnt;
	struct module *owner;
	int: 32;
	struct device dev;
	struct regulation_constraints *constraints;
	struct regulator *supply;
	const char *supply_name;
	struct regmap *regmap;
	struct delayed_work disable_work;
	void *reg_data;
	struct dentry *debugfs;
	struct regulator_enable_gpio *ena_pin;
	unsigned int ena_gpio_state: 1;
	unsigned int is_switch: 1;
	long unsigned int last_off_jiffy;
};

enum regulator_type {
	REGULATOR_VOLTAGE = 0,
	REGULATOR_CURRENT = 1,
};

struct regulator_config;

struct regulator_desc {
	const char *name;
	const char *supply_name;
	const char *of_match;
	bool of_match_full_name;
	const char *regulators_node;
	int (*of_parse_cb)(struct device_node *, const struct regulator_desc *, struct regulator_config *);
	int id;
	unsigned int continuous_voltage_range: 1;
	unsigned int n_voltages;
	unsigned int n_current_limits;
	const struct regulator_ops *ops;
	int irq;
	enum regulator_type type;
	struct module *owner;
	unsigned int min_uV;
	unsigned int uV_step;
	unsigned int linear_min_sel;
	int fixed_uV;
	unsigned int ramp_delay;
	int min_dropout_uV;
	const struct linear_range *linear_ranges;
	const unsigned int *linear_range_selectors;
	int n_linear_ranges;
	const unsigned int *volt_table;
	const unsigned int *curr_table;
	unsigned int vsel_range_reg;
	unsigned int vsel_range_mask;
	unsigned int vsel_reg;
	unsigned int vsel_mask;
	unsigned int vsel_step;
	unsigned int csel_reg;
	unsigned int csel_mask;
	unsigned int apply_reg;
	unsigned int apply_bit;
	unsigned int enable_reg;
	unsigned int enable_mask;
	unsigned int enable_val;
	unsigned int disable_val;
	bool enable_is_inverted;
	unsigned int bypass_reg;
	unsigned int bypass_mask;
	unsigned int bypass_val_on;
	unsigned int bypass_val_off;
	unsigned int active_discharge_on;
	unsigned int active_discharge_off;
	unsigned int active_discharge_mask;
	unsigned int active_discharge_reg;
	unsigned int soft_start_reg;
	unsigned int soft_start_mask;
	unsigned int soft_start_val_on;
	unsigned int pull_down_reg;
	unsigned int pull_down_mask;
	unsigned int pull_down_val_on;
	unsigned int enable_time;
	unsigned int off_on_delay;
	unsigned int poll_enabled_time;
	unsigned int (*of_map_mode)(unsigned int);
};

struct regulator_init_data;

struct regulator_config {
	struct device *dev;
	const struct regulator_init_data *init_data;
	void *driver_data;
	struct device_node *of_node;
	struct regmap *regmap;
	struct gpio_desc *ena_gpiod;
};

struct regulator_state {
	int uV;
	int min_uV;
	int max_uV;
	unsigned int mode;
	int enabled;
	bool changeable;
};

struct regulation_constraints {
	const char *name;
	int min_uV;
	int max_uV;
	int uV_offset;
	int min_uA;
	int max_uA;
	int ilim_uA;
	int system_load;
	u32 *max_spread;
	int max_uV_step;
	unsigned int valid_modes_mask;
	unsigned int valid_ops_mask;
	int input_uV;
	struct regulator_state state_disk;
	struct regulator_state state_mem;
	struct regulator_state state_standby;
	suspend_state_t initial_state;
	unsigned int initial_mode;
	unsigned int ramp_delay;
	unsigned int settling_time;
	unsigned int settling_time_up;
	unsigned int settling_time_down;
	unsigned int enable_time;
	unsigned int active_discharge;
	unsigned int always_on: 1;
	unsigned int boot_on: 1;
	unsigned int apply_uV: 1;
	unsigned int ramp_disable: 1;
	unsigned int soft_start: 1;
	unsigned int pull_down: 1;
	unsigned int over_current_protection: 1;
};

struct regulator_consumer_supply;

struct regulator_init_data {
	const char *supply_regulator;
	struct regulation_constraints constraints;
	int num_consumer_supplies;
	struct regulator_consumer_supply *consumer_supplies;
	int (*regulator_init)(void *);
	void *driver_data;
};

enum palmas_usb_state {
	PALMAS_USB_STATE_DISCONNECT = 0,
	PALMAS_USB_STATE_VBUS = 1,
	PALMAS_USB_STATE_ID = 2,
};

struct palmas_gpadc;

struct palmas_pmic_driver_data;

struct palmas_pmic;

struct palmas_resource;

struct palmas_usb;

struct palmas {
	struct device *dev;
	struct i2c_client *i2c_clients[3];
	struct regmap *regmap[3];
	int id;
	unsigned int features;
	int irq;
	u32 irq_mask;
	struct mutex irq_lock;
	struct regmap_irq_chip_data *irq_data;
	struct palmas_pmic_driver_data *pmic_ddata;
	struct palmas_pmic *pmic;
	struct palmas_gpadc *gpadc;
	struct palmas_resource *resource;
	struct palmas_usb *usb;
	u8 gpio_muxed;
	u8 led_muxed;
	u8 pwm_muxed;
};

struct palmas_regs_info;

struct of_regulator_match;

struct palmas_sleep_requestor_info;

struct palmas_pmic_platform_data;

struct palmas_pmic_driver_data {
	int smps_start;
	int smps_end;
	int ldo_begin;
	int ldo_end;
	int max_reg;
	bool has_regen3;
	struct palmas_regs_info *palmas_regs_info;
	struct of_regulator_match *palmas_matches;
	struct palmas_sleep_requestor_info *sleep_req_info;
	int (*smps_register)(struct palmas_pmic *, struct palmas_pmic_driver_data *, struct palmas_pmic_platform_data *, const char *, struct regulator_config);
	int (*ldo_register)(struct palmas_pmic *, struct palmas_pmic_driver_data *, struct palmas_pmic_platform_data *, const char *, struct regulator_config);
};

struct palmas_pmic {
	struct palmas *palmas;
	struct device *dev;
	struct regulator_desc desc[27];
	struct mutex mutex;
	int smps123;
	int smps457;
	int smps12;
	int range[10];
	unsigned int ramp_delay[10];
	unsigned int current_reg_mode[10];
};

struct palmas_resource {
	struct palmas *palmas;
	struct device *dev;
};

struct palmas_usb {
	struct palmas *palmas;
	struct device *dev;
	struct extcon_dev *edev;
	int id_otg_irq;
	int id_irq;
	int vbus_otg_irq;
	int vbus_irq;
	int gpio_id_irq;
	int gpio_vbus_irq;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	long unsigned int sw_debounce_jiffies;
	struct delayed_work wq_detectid;
	enum palmas_usb_state linkstat;
	int wakeup;
	bool enable_vbus_detection;
	bool enable_id_detection;
	bool enable_gpio_id_detection;
	bool enable_gpio_vbus_detection;
};

struct palmas_sleep_requestor_info {
	int id;
	int reg_offset;
	int bit_pos;
};

struct palmas_regs_info {
	char *name;
	char *sname;
	u8 vsel_addr;
	u8 ctrl_addr;
	u8 tstep_addr;
	int sleep_id;
};

struct palmas_reg_init;

struct palmas_pmic_platform_data {
	struct regulator_init_data *reg_data[27];
	struct palmas_reg_init *reg_init[27];
	int ldo6_vibrator;
	bool enable_ldo8_tracking;
};

struct palmas_reg_init {
	int warm_reset;
	int roof_floor;
	int mode_sleep;
	u8 vsel;
};

enum palmas_regulators {
	PALMAS_REG_SMPS12 = 0,
	PALMAS_REG_SMPS123 = 1,
	PALMAS_REG_SMPS3 = 2,
	PALMAS_REG_SMPS45 = 3,
	PALMAS_REG_SMPS457 = 4,
	PALMAS_REG_SMPS6 = 5,
	PALMAS_REG_SMPS7 = 6,
	PALMAS_REG_SMPS8 = 7,
	PALMAS_REG_SMPS9 = 8,
	PALMAS_REG_SMPS10_OUT2 = 9,
	PALMAS_REG_SMPS10_OUT1 = 10,
	PALMAS_REG_LDO1 = 11,
	PALMAS_REG_LDO2 = 12,
	PALMAS_REG_LDO3 = 13,
	PALMAS_REG_LDO4 = 14,
	PALMAS_REG_LDO5 = 15,
	PALMAS_REG_LDO6 = 16,
	PALMAS_REG_LDO7 = 17,
	PALMAS_REG_LDO8 = 18,
	PALMAS_REG_LDO9 = 19,
	PALMAS_REG_LDOLN = 20,
	PALMAS_REG_LDOUSB = 21,
	PALMAS_REG_REGEN1 = 22,
	PALMAS_REG_REGEN2 = 23,
	PALMAS_REG_REGEN3 = 24,
	PALMAS_REG_SYSEN1 = 25,
	PALMAS_REG_SYSEN2 = 26,
	PALMAS_NUM_REGS = 27,
};

struct palmas_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct palmas_pingroup;

struct palmas_pctrl_chip_info {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct palmas *palmas;
	int pins_current_opt[26];
	const struct palmas_pin_function *functions;
	unsigned int num_functions;
	const struct palmas_pingroup *pin_groups;
	int num_pin_groups;
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
};

struct palmas_pin_info;

struct palmas_pingroup {
	const char *name;
	const unsigned int pins[1];
	unsigned int npins;
	unsigned int mux_reg_base;
	unsigned int mux_reg_add;
	unsigned int mux_reg_mask;
	unsigned int mux_bit_shift;
	const struct palmas_pin_info *opt[4];
};

enum palmas_pinmux {
	PALMAS_PINMUX_OPTION0 = 0,
	PALMAS_PINMUX_OPTION1 = 1,
	PALMAS_PINMUX_OPTION2 = 2,
	PALMAS_PINMUX_OPTION3 = 3,
	PALMAS_PINMUX_GPIO = 4,
	PALMAS_PINMUX_LED = 5,
	PALMAS_PINMUX_PWM = 6,
	PALMAS_PINMUX_REGEN = 7,
	PALMAS_PINMUX_SYSEN = 8,
	PALMAS_PINMUX_CLK32KGAUDIO = 9,
	PALMAS_PINMUX_ID = 10,
	PALMAS_PINMUX_VBUS_DET = 11,
	PALMAS_PINMUX_CHRG_DET = 12,
	PALMAS_PINMUX_VAC = 13,
	PALMAS_PINMUX_VACOK = 14,
	PALMAS_PINMUX_POWERGOOD = 15,
	PALMAS_PINMUX_USB_PSEL = 16,
	PALMAS_PINMUX_MSECURE = 17,
	PALMAS_PINMUX_PWRHOLD = 18,
	PALMAS_PINMUX_INT = 19,
	PALMAS_PINMUX_NRESWARM = 20,
	PALMAS_PINMUX_SIMRSTO = 21,
	PALMAS_PINMUX_SIMRSTI = 22,
	PALMAS_PINMUX_LOW_VBAT = 23,
	PALMAS_PINMUX_WIRELESS_CHRG1 = 24,
	PALMAS_PINMUX_RCM = 25,
	PALMAS_PINMUX_PWRDOWN = 26,
	PALMAS_PINMUX_GPADC_START = 27,
	PALMAS_PINMUX_RESET_IN = 28,
	PALMAS_PINMUX_NSLEEP = 29,
	PALMAS_PINMUX_ENABLE = 30,
	PALMAS_PINMUX_NA = 65535,
};

struct palmas_pins_pullup_dn_info {
	int pullup_dn_reg_base;
	int pullup_dn_reg_add;
	int pullup_dn_mask;
	int normal_val;
	int pull_up_val;
	int pull_dn_val;
};

struct palmas_pins_od_info {
	int od_reg_base;
	int od_reg_add;
	int od_mask;
	int od_enable;
	int od_disable;
};

struct palmas_pin_info {
	enum palmas_pinmux mux_opt;
	const struct palmas_pins_pullup_dn_info *pud_info;
	const struct palmas_pins_od_info *od_info;
};

struct palmas_pinctrl_data {
	const struct palmas_pingroup *pin_groups;
	int num_pin_groups;
};

enum rockchip_pinctrl_type {
	PX30 = 0,
	RV1108 = 1,
	RK2928 = 2,
	RK3066B = 3,
	RK3128 = 4,
	RK3188 = 5,
	RK3288 = 6,
	RK3308 = 7,
	RK3368 = 8,
	RK3399 = 9,
};

struct rockchip_iomux {
	int type;
	int offset;
};

enum rockchip_pin_drv_type {
	DRV_TYPE_IO_DEFAULT = 0,
	DRV_TYPE_IO_1V8_OR_3V0 = 1,
	DRV_TYPE_IO_1V8_ONLY = 2,
	DRV_TYPE_IO_1V8_3V0_AUTO = 3,
	DRV_TYPE_IO_3V3_ONLY = 4,
	DRV_TYPE_MAX = 5,
};

enum rockchip_pin_pull_type {
	PULL_TYPE_IO_DEFAULT = 0,
	PULL_TYPE_IO_1V8_ONLY = 1,
	PULL_TYPE_MAX = 2,
};

struct rockchip_drv {
	enum rockchip_pin_drv_type drv_type;
	int offset;
};

struct rockchip_pinctrl;

struct rockchip_pin_bank {
	void *reg_base;
	struct regmap *regmap_pull;
	struct clk *clk;
	int irq;
	u32 saved_masks;
	u32 pin_base;
	u8 nr_pins;
	char *name;
	u8 bank_num;
	struct rockchip_iomux iomux[4];
	struct rockchip_drv drv[4];
	enum rockchip_pin_pull_type pull_type[4];
	bool valid;
	struct device_node *of_node;
	struct rockchip_pinctrl *drvdata;
	struct irq_domain *domain;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range grange;
	raw_spinlock_t slock;
	u32 toggle_edge_mode;
	u32 recalced_mask;
	u32 route_mask;
};

struct rockchip_pin_ctrl;

struct rockchip_pin_group;

struct rockchip_pmx_func;

struct rockchip_pinctrl {
	struct regmap *regmap_base;
	int reg_size;
	struct regmap *regmap_pull;
	struct regmap *regmap_pmu;
	struct device *dev;
	struct rockchip_pin_ctrl *ctrl;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	struct rockchip_pin_group *groups;
	unsigned int ngroups;
	struct rockchip_pmx_func *functions;
	unsigned int nfunctions;
};

struct rockchip_mux_recalced_data {
	u8 num;
	u8 pin;
	u32 reg;
	u8 bit;
	u8 mask;
};

enum rockchip_mux_route_location {
	ROCKCHIP_ROUTE_SAME = 0,
	ROCKCHIP_ROUTE_PMU = 1,
	ROCKCHIP_ROUTE_GRF = 2,
};

struct rockchip_mux_route_data {
	u8 bank_num;
	u8 pin;
	u8 func;
	enum rockchip_mux_route_location route_location;
	u32 route_offset;
	u32 route_val;
};

struct rockchip_pin_ctrl {
	struct rockchip_pin_bank *pin_banks;
	u32 nr_banks;
	u32 nr_pins;
	char *label;
	enum rockchip_pinctrl_type type;
	int grf_mux_offset;
	int pmu_mux_offset;
	int grf_drv_offset;
	int pmu_drv_offset;
	struct rockchip_mux_recalced_data *iomux_recalced;
	u32 niomux_recalced;
	struct rockchip_mux_route_data *iomux_routes;
	u32 niomux_routes;
	void (*pull_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
	void (*drv_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
	int (*schmitt_calc_reg)(struct rockchip_pin_bank *, int, struct regmap **, int *, u8 *);
};

struct rockchip_pin_config {
	unsigned int func;
	long unsigned int *configs;
	unsigned int nconfigs;
};

struct rockchip_pin_group {
	const char *name;
	unsigned int npins;
	unsigned int *pins;
	struct rockchip_pin_config *data;
};

struct rockchip_pmx_func {
	const char *name;
	const char **groups;
	u8 ngroups;
};

struct pcs_func_vals {
	void *reg;
	unsigned int val;
	unsigned int mask;
};

struct pcs_conf_vals {
	enum pin_config_param param;
	unsigned int val;
	unsigned int enable;
	unsigned int disable;
	unsigned int mask;
};

struct pcs_conf_type {
	const char *name;
	enum pin_config_param param;
};

struct pcs_function {
	const char *name;
	struct pcs_func_vals *vals;
	unsigned int nvals;
	const char **pgnames;
	int npgnames;
	struct pcs_conf_vals *conf;
	int nconfs;
	struct list_head node;
};

struct pcs_gpiofunc_range {
	unsigned int offset;
	unsigned int npins;
	unsigned int gpiofunc;
	struct list_head node;
};

struct pcs_data {
	struct pinctrl_pin_desc *pa;
	int cur;
};

struct pcs_soc_data {
	unsigned int flags;
	int irq;
	unsigned int irq_enable_mask;
	unsigned int irq_status_mask;
	void (*rearm)();
};

struct pcs_device {
	struct resource *res;
	void *base;
	void *saved_vals;
	unsigned int size;
	struct device *dev;
	struct device_node *np;
	struct pinctrl_dev *pctl;
	unsigned int flags;
	struct property *missing_nr_pinctrl_cells;
	struct pcs_soc_data socdata;
	raw_spinlock_t lock;
	struct mutex mutex;
	unsigned int width;
	unsigned int fmask;
	unsigned int fshift;
	unsigned int foff;
	unsigned int fmax;
	bool bits_per_mux;
	unsigned int bits_per_pin;
	struct pcs_data pins;
	struct list_head gpiofuncs;
	struct list_head irqs;
	struct irq_chip chip;
	struct irq_domain *domain;
	struct pinctrl_desc desc;
	unsigned int (*read)(void *);
	void (*write)(unsigned int, void *);
};

struct pcs_interrupt {
	void *reg;
	irq_hw_number_t hwirq;
	unsigned int irq;
	struct list_head node;
};

struct of_mm_gpio_chip {
	struct gpio_chip gc;
	void (*save_regs)(struct of_mm_gpio_chip *);
	void *regs;
};

struct sirfsoc_pmx {
	struct device *dev;
	struct pinctrl_dev *pmx;
	void *gpio_virtbase;
	void *rsc_virtbase;
	u32 gpio_regs[160];
	u32 ints_regs[5];
	u32 paden_regs[5];
	u32 dspen_regs;
	u32 rsc_regs[3];
};

struct sirfsoc_muxmask {
	long unsigned int group;
	long unsigned int mask;
};

struct sirfsoc_padmux {
	long unsigned int muxmask_counts;
	const struct sirfsoc_muxmask *muxmask;
	long unsigned int ctrlreg;
	long unsigned int funcmask;
	long unsigned int funcval;
};

struct sirfsoc_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int num_pins;
};

struct sirfsoc_pmx_func {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
	const struct sirfsoc_padmux *padmux;
};

struct sirfsoc_pinctrl_data {
	struct pinctrl_pin_desc *pads;
	int pads_cnt;
	struct sirfsoc_pin_group *grps;
	int grps_cnt;
	struct sirfsoc_pmx_func *funcs;
	int funcs_cnt;
};

struct sirfsoc_gpio_bank {
	int id;
	int parent_irq;
	spinlock_t lock;
};

struct sirfsoc_gpio_chip {
	struct of_mm_gpio_chip chip;
	struct sirfsoc_gpio_bank sgpio_bank[5];
	spinlock_t lock;
};

enum altas7_pad_type {
	PAD_T_4WE_PD = 0,
	PAD_T_4WE_PU = 1,
	PAD_T_16ST = 2,
	PAD_T_M31_0204_PD = 3,
	PAD_T_M31_0204_PU = 4,
	PAD_T_M31_0610_PD = 5,
	PAD_T_M31_0610_PU = 6,
	PAD_T_AD = 7,
};

struct atlas7_pad_config {
	const u32 id;
	u32 type;
	u32 mux_reg;
	u32 pupd_reg;
	u32 drvstr_reg;
	u32 ad_ctrl_reg;
	u8 mux_bit;
	u8 pupd_bit;
	u8 drvstr_bit;
	u8 ad_ctrl_bit;
};

struct atlas7_pad_status {
	u8 func;
	u8 pull;
	u8 dstr;
	u8 reserved;
};

struct atlas7_pad_mux {
	u32 bank;
	u32 pin;
	u32 func;
	u32 dinput_reg;
	u32 dinput_bit;
	u32 dinput_val_reg;
	u32 dinput_val_bit;
};

struct atlas7_grp_mux {
	unsigned int group;
	unsigned int pad_mux_count;
	const struct atlas7_pad_mux *pad_mux_list;
};

struct atlas7_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int num_pins;
};

struct atlas7_pmx_func {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
	const struct atlas7_grp_mux *grpmux;
};

struct atlas7_pinctrl_data {
	struct pinctrl_pin_desc *pads;
	int pads_cnt;
	struct atlas7_pin_group *grps;
	int grps_cnt;
	struct atlas7_pmx_func *funcs;
	int funcs_cnt;
	struct atlas7_pad_config *confs;
	int confs_cnt;
};

struct atlas7_gpio_bank {
	int id;
	int irq;
	void *base;
	unsigned int gpio_offset;
	unsigned int ngpio;
	const unsigned int *gpio_pins;
	u32 sleep_data[32];
};

struct atlas7_gpio_chip {
	const char *name;
	void *reg;
	struct clk *clk;
	int nbank;
	raw_spinlock_t lock;
	struct gpio_chip chip;
	struct atlas7_gpio_bank banks[0];
};

struct atlas7_pmx {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctl_desc;
	struct atlas7_pinctrl_data *pctl_data;
	void *regs[2];
	void *sys2pci_base;
	u32 status_ds[2];
	u32 status_dsv[2];
	struct atlas7_pad_status sleep_data[159];
};

struct map_data {
	u8 idx;
	u8 data;
};

struct atlas7_pull_info {
	u8 pad_type;
	u8 mask;
	const struct map_data *v2s;
	const struct map_data *s2v;
};

struct atlas7_ds_ma_info {
	u32 ma;
	u32 ds_16st;
	u32 ds_4we;
	u32 ds_0204m31;
	u32 ds_0610m31;
};

struct atlas7_ds_info {
	u8 type;
	u8 mask;
	u8 imval;
	u8 reserved;
};

struct tegra_pinctrl_soc_data;

struct tegra_pmx {
	struct device *dev;
	struct pinctrl_dev *pctl;
	const struct tegra_pinctrl_soc_data *soc;
	const char **group_pins;
	int nbanks;
	void **regs;
	u32 *backup_regs;
};

struct tegra_function;

struct tegra_pingroup;

struct tegra_pinctrl_soc_data {
	unsigned int ngpios;
	const char *gpio_compatible;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	struct tegra_function *functions;
	unsigned int nfunctions;
	const struct tegra_pingroup *groups;
	unsigned int ngroups;
	bool hsm_in_mux;
	bool schmitt_in_mux;
	bool drvtype_in_mux;
	bool sfsel_in_mux;
};

enum tegra_pinconf_param {
	TEGRA_PINCONF_PARAM_PULL = 0,
	TEGRA_PINCONF_PARAM_TRISTATE = 1,
	TEGRA_PINCONF_PARAM_ENABLE_INPUT = 2,
	TEGRA_PINCONF_PARAM_OPEN_DRAIN = 3,
	TEGRA_PINCONF_PARAM_LOCK = 4,
	TEGRA_PINCONF_PARAM_IORESET = 5,
	TEGRA_PINCONF_PARAM_RCV_SEL = 6,
	TEGRA_PINCONF_PARAM_HIGH_SPEED_MODE = 7,
	TEGRA_PINCONF_PARAM_SCHMITT = 8,
	TEGRA_PINCONF_PARAM_LOW_POWER_MODE = 9,
	TEGRA_PINCONF_PARAM_DRIVE_DOWN_STRENGTH = 10,
	TEGRA_PINCONF_PARAM_DRIVE_UP_STRENGTH = 11,
	TEGRA_PINCONF_PARAM_SLEW_RATE_FALLING = 12,
	TEGRA_PINCONF_PARAM_SLEW_RATE_RISING = 13,
	TEGRA_PINCONF_PARAM_DRIVE_TYPE = 14,
};

struct tegra_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct tegra_pingroup {
	const char *name;
	const unsigned int *pins;
	u8 npins;
	u8 funcs[4];
	s32 mux_reg;
	s32 pupd_reg;
	s32 tri_reg;
	s32 drv_reg;
	u32 mux_bank: 2;
	u32 pupd_bank: 2;
	u32 tri_bank: 2;
	u32 drv_bank: 2;
	s32 mux_bit: 6;
	s32 pupd_bit: 6;
	s32 tri_bit: 6;
	s32 einput_bit: 6;
	s32 odrain_bit: 6;
	s32 lock_bit: 6;
	s32 ioreset_bit: 6;
	s32 rcv_sel_bit: 6;
	s32 hsm_bit: 6;
	char: 2;
	s32 sfsel_bit: 6;
	s32 schmitt_bit: 6;
	s32 lpmd_bit: 6;
	s32 drvdn_bit: 6;
	s32 drvup_bit: 6;
	char: 2;
	s32 slwr_bit: 6;
	s32 slwf_bit: 6;
	s32 drvtype_bit: 6;
	s32 drvdn_width: 6;
	s32 drvup_width: 6;
	char: 2;
	s32 slwr_width: 6;
	s32 slwf_width: 6;
	u32 parked_bitmask;
};

struct cfg_param {
	const char *property;
	enum tegra_pinconf_param param;
};

enum tegra_mux {
	TEGRA_MUX_AHB_CLK = 0,
	TEGRA_MUX_APB_CLK = 1,
	TEGRA_MUX_AUDIO_SYNC = 2,
	TEGRA_MUX_CRT = 3,
	TEGRA_MUX_DAP1 = 4,
	TEGRA_MUX_DAP2 = 5,
	TEGRA_MUX_DAP3 = 6,
	TEGRA_MUX_DAP4 = 7,
	TEGRA_MUX_DAP5 = 8,
	TEGRA_MUX_DISPLAYA = 9,
	TEGRA_MUX_DISPLAYB = 10,
	TEGRA_MUX_EMC_TEST0_DLL = 11,
	TEGRA_MUX_EMC_TEST1_DLL = 12,
	TEGRA_MUX_GMI = 13,
	TEGRA_MUX_GMI_INT = 14,
	TEGRA_MUX_HDMI = 15,
	TEGRA_MUX_I2CP = 16,
	TEGRA_MUX_I2C1 = 17,
	TEGRA_MUX_I2C2 = 18,
	TEGRA_MUX_I2C3 = 19,
	TEGRA_MUX_IDE = 20,
	TEGRA_MUX_IRDA = 21,
	TEGRA_MUX_KBC = 22,
	TEGRA_MUX_MIO = 23,
	TEGRA_MUX_MIPI_HS = 24,
	TEGRA_MUX_NAND = 25,
	TEGRA_MUX_OSC = 26,
	TEGRA_MUX_OWR = 27,
	TEGRA_MUX_PCIE = 28,
	TEGRA_MUX_PLLA_OUT = 29,
	TEGRA_MUX_PLLC_OUT1 = 30,
	TEGRA_MUX_PLLM_OUT1 = 31,
	TEGRA_MUX_PLLP_OUT2 = 32,
	TEGRA_MUX_PLLP_OUT3 = 33,
	TEGRA_MUX_PLLP_OUT4 = 34,
	TEGRA_MUX_PWM = 35,
	TEGRA_MUX_PWR_INTR = 36,
	TEGRA_MUX_PWR_ON = 37,
	TEGRA_MUX_RSVD1 = 38,
	TEGRA_MUX_RSVD2 = 39,
	TEGRA_MUX_RSVD3 = 40,
	TEGRA_MUX_RSVD4 = 41,
	TEGRA_MUX_RTCK = 42,
	TEGRA_MUX_SDIO1 = 43,
	TEGRA_MUX_SDIO2 = 44,
	TEGRA_MUX_SDIO3 = 45,
	TEGRA_MUX_SDIO4 = 46,
	TEGRA_MUX_SFLASH = 47,
	TEGRA_MUX_SPDIF = 48,
	TEGRA_MUX_SPI1 = 49,
	TEGRA_MUX_SPI2 = 50,
	TEGRA_MUX_SPI2_ALT = 51,
	TEGRA_MUX_SPI3 = 52,
	TEGRA_MUX_SPI4 = 53,
	TEGRA_MUX_TRACE = 54,
	TEGRA_MUX_TWC = 55,
	TEGRA_MUX_UARTA = 56,
	TEGRA_MUX_UARTB = 57,
	TEGRA_MUX_UARTC = 58,
	TEGRA_MUX_UARTD = 59,
	TEGRA_MUX_UARTE = 60,
	TEGRA_MUX_ULPI = 61,
	TEGRA_MUX_VI = 62,
	TEGRA_MUX_VI_SENSOR_CLK = 63,
	TEGRA_MUX_XIO = 64,
};

enum tegra_mux___2 {
	TEGRA_MUX_BLINK = 0,
	TEGRA_MUX_CEC = 1,
	TEGRA_MUX_CLK_12M_OUT = 2,
	TEGRA_MUX_CLK_32K_IN = 3,
	TEGRA_MUX_CORE_PWR_REQ = 4,
	TEGRA_MUX_CPU_PWR_REQ = 5,
	TEGRA_MUX_CRT___2 = 6,
	TEGRA_MUX_DAP = 7,
	TEGRA_MUX_DDR = 8,
	TEGRA_MUX_DEV3 = 9,
	TEGRA_MUX_DISPLAYA___2 = 10,
	TEGRA_MUX_DISPLAYB___2 = 11,
	TEGRA_MUX_DTV = 12,
	TEGRA_MUX_EXTPERIPH1 = 13,
	TEGRA_MUX_EXTPERIPH2 = 14,
	TEGRA_MUX_EXTPERIPH3 = 15,
	TEGRA_MUX_GMI___2 = 16,
	TEGRA_MUX_GMI_ALT = 17,
	TEGRA_MUX_HDA = 18,
	TEGRA_MUX_HDCP = 19,
	TEGRA_MUX_HDMI___2 = 20,
	TEGRA_MUX_HSI = 21,
	TEGRA_MUX_I2C1___2 = 22,
	TEGRA_MUX_I2C2___2 = 23,
	TEGRA_MUX_I2C3___2 = 24,
	TEGRA_MUX_I2C4 = 25,
	TEGRA_MUX_I2CPWR = 26,
	TEGRA_MUX_I2S0 = 27,
	TEGRA_MUX_I2S1 = 28,
	TEGRA_MUX_I2S2 = 29,
	TEGRA_MUX_I2S3 = 30,
	TEGRA_MUX_I2S4 = 31,
	TEGRA_MUX_INVALID = 32,
	TEGRA_MUX_KBC___2 = 33,
	TEGRA_MUX_MIO___2 = 34,
	TEGRA_MUX_NAND___2 = 35,
	TEGRA_MUX_NAND_ALT = 36,
	TEGRA_MUX_OWR___2 = 37,
	TEGRA_MUX_PCIE___2 = 38,
	TEGRA_MUX_PWM0 = 39,
	TEGRA_MUX_PWM1 = 40,
	TEGRA_MUX_PWM2 = 41,
	TEGRA_MUX_PWM3 = 42,
	TEGRA_MUX_PWR_INT_N = 43,
	TEGRA_MUX_RSVD1___2 = 44,
	TEGRA_MUX_RSVD2___2 = 45,
	TEGRA_MUX_RSVD3___2 = 46,
	TEGRA_MUX_RSVD4___2 = 47,
	TEGRA_MUX_RTCK___2 = 48,
	TEGRA_MUX_SATA = 49,
	TEGRA_MUX_SDMMC1 = 50,
	TEGRA_MUX_SDMMC2 = 51,
	TEGRA_MUX_SDMMC3 = 52,
	TEGRA_MUX_SDMMC4 = 53,
	TEGRA_MUX_SPDIF___2 = 54,
	TEGRA_MUX_SPI1___2 = 55,
	TEGRA_MUX_SPI2___2 = 56,
	TEGRA_MUX_SPI2_ALT___2 = 57,
	TEGRA_MUX_SPI3___2 = 58,
	TEGRA_MUX_SPI4___2 = 59,
	TEGRA_MUX_SPI5 = 60,
	TEGRA_MUX_SPI6 = 61,
	TEGRA_MUX_SYSCLK = 62,
	TEGRA_MUX_TEST = 63,
	TEGRA_MUX_TRACE___2 = 64,
	TEGRA_MUX_UARTA___2 = 65,
	TEGRA_MUX_UARTB___2 = 66,
	TEGRA_MUX_UARTC___2 = 67,
	TEGRA_MUX_UARTD___2 = 68,
	TEGRA_MUX_UARTE___2 = 69,
	TEGRA_MUX_ULPI___2 = 70,
	TEGRA_MUX_VGP1 = 71,
	TEGRA_MUX_VGP2 = 72,
	TEGRA_MUX_VGP3 = 73,
	TEGRA_MUX_VGP4 = 74,
	TEGRA_MUX_VGP5 = 75,
	TEGRA_MUX_VGP6 = 76,
	TEGRA_MUX_VI___2 = 77,
	TEGRA_MUX_VI_ALT1 = 78,
	TEGRA_MUX_VI_ALT2 = 79,
	TEGRA_MUX_VI_ALT3 = 80,
};

enum tegra_mux___3 {
	TEGRA_MUX_BLINK___2 = 0,
	TEGRA_MUX_CEC___2 = 1,
	TEGRA_MUX_CLDVFS = 2,
	TEGRA_MUX_CLK = 3,
	TEGRA_MUX_CLK12 = 4,
	TEGRA_MUX_CPU = 5,
	TEGRA_MUX_DAP___2 = 6,
	TEGRA_MUX_DAP1___2 = 7,
	TEGRA_MUX_DAP2___2 = 8,
	TEGRA_MUX_DEV3___2 = 9,
	TEGRA_MUX_DISPLAYA___3 = 10,
	TEGRA_MUX_DISPLAYA_ALT = 11,
	TEGRA_MUX_DISPLAYB___3 = 12,
	TEGRA_MUX_DTV___2 = 13,
	TEGRA_MUX_EMC_DLL = 14,
	TEGRA_MUX_EXTPERIPH1___2 = 15,
	TEGRA_MUX_EXTPERIPH2___2 = 16,
	TEGRA_MUX_EXTPERIPH3___2 = 17,
	TEGRA_MUX_GMI___3 = 18,
	TEGRA_MUX_GMI_ALT___2 = 19,
	TEGRA_MUX_HDA___2 = 20,
	TEGRA_MUX_HSI___2 = 21,
	TEGRA_MUX_I2C1___3 = 22,
	TEGRA_MUX_I2C2___3 = 23,
	TEGRA_MUX_I2C3___3 = 24,
	TEGRA_MUX_I2C4___2 = 25,
	TEGRA_MUX_I2CPWR___2 = 26,
	TEGRA_MUX_I2S0___2 = 27,
	TEGRA_MUX_I2S1___2 = 28,
	TEGRA_MUX_I2S2___2 = 29,
	TEGRA_MUX_I2S3___2 = 30,
	TEGRA_MUX_I2S4___2 = 31,
	TEGRA_MUX_IRDA___2 = 32,
	TEGRA_MUX_KBC___3 = 33,
	TEGRA_MUX_NAND___3 = 34,
	TEGRA_MUX_NAND_ALT___2 = 35,
	TEGRA_MUX_OWR___3 = 36,
	TEGRA_MUX_PMI = 37,
	TEGRA_MUX_PWM0___2 = 38,
	TEGRA_MUX_PWM1___2 = 39,
	TEGRA_MUX_PWM2___2 = 40,
	TEGRA_MUX_PWM3___2 = 41,
	TEGRA_MUX_PWRON = 42,
	TEGRA_MUX_RESET_OUT_N = 43,
	TEGRA_MUX_RSVD1___3 = 44,
	TEGRA_MUX_RSVD2___3 = 45,
	TEGRA_MUX_RSVD3___3 = 46,
	TEGRA_MUX_RSVD4___3 = 47,
	TEGRA_MUX_RTCK___3 = 48,
	TEGRA_MUX_SDMMC1___2 = 49,
	TEGRA_MUX_SDMMC2___2 = 50,
	TEGRA_MUX_SDMMC3___2 = 51,
	TEGRA_MUX_SDMMC4___2 = 52,
	TEGRA_MUX_SOC = 53,
	TEGRA_MUX_SPDIF___3 = 54,
	TEGRA_MUX_SPI1___3 = 55,
	TEGRA_MUX_SPI2___3 = 56,
	TEGRA_MUX_SPI3___3 = 57,
	TEGRA_MUX_SPI4___3 = 58,
	TEGRA_MUX_SPI5___2 = 59,
	TEGRA_MUX_SPI6___2 = 60,
	TEGRA_MUX_SYSCLK___2 = 61,
	TEGRA_MUX_TRACE___3 = 62,
	TEGRA_MUX_UARTA___3 = 63,
	TEGRA_MUX_UARTB___3 = 64,
	TEGRA_MUX_UARTC___3 = 65,
	TEGRA_MUX_UARTD___3 = 66,
	TEGRA_MUX_ULPI___3 = 67,
	TEGRA_MUX_USB = 68,
	TEGRA_MUX_VGP1___2 = 69,
	TEGRA_MUX_VGP2___2 = 70,
	TEGRA_MUX_VGP3___2 = 71,
	TEGRA_MUX_VGP4___2 = 72,
	TEGRA_MUX_VGP5___2 = 73,
	TEGRA_MUX_VGP6___2 = 74,
	TEGRA_MUX_VI___3 = 75,
	TEGRA_MUX_VI_ALT1___2 = 76,
	TEGRA_MUX_VI_ALT3___2 = 77,
};

enum tegra_mux___4 {
	TEGRA_MUX_BLINK___3 = 0,
	TEGRA_MUX_CCLA = 1,
	TEGRA_MUX_CEC___3 = 2,
	TEGRA_MUX_CLDVFS___2 = 3,
	TEGRA_MUX_CLK___2 = 4,
	TEGRA_MUX_CLK12___2 = 5,
	TEGRA_MUX_CPU___2 = 6,
	TEGRA_MUX_CSI = 7,
	TEGRA_MUX_DAP___3 = 8,
	TEGRA_MUX_DAP1___3 = 9,
	TEGRA_MUX_DAP2___3 = 10,
	TEGRA_MUX_DEV3___3 = 11,
	TEGRA_MUX_DISPLAYA___4 = 12,
	TEGRA_MUX_DISPLAYA_ALT___2 = 13,
	TEGRA_MUX_DISPLAYB___4 = 14,
	TEGRA_MUX_DP = 15,
	TEGRA_MUX_DSI_B = 16,
	TEGRA_MUX_DTV___3 = 17,
	TEGRA_MUX_EXTPERIPH1___3 = 18,
	TEGRA_MUX_EXTPERIPH2___3 = 19,
	TEGRA_MUX_EXTPERIPH3___3 = 20,
	TEGRA_MUX_GMI___4 = 21,
	TEGRA_MUX_GMI_ALT___3 = 22,
	TEGRA_MUX_HDA___3 = 23,
	TEGRA_MUX_HSI___3 = 24,
	TEGRA_MUX_I2C1___4 = 25,
	TEGRA_MUX_I2C2___4 = 26,
	TEGRA_MUX_I2C3___4 = 27,
	TEGRA_MUX_I2C4___3 = 28,
	TEGRA_MUX_I2CPWR___3 = 29,
	TEGRA_MUX_I2S0___3 = 30,
	TEGRA_MUX_I2S1___3 = 31,
	TEGRA_MUX_I2S2___3 = 32,
	TEGRA_MUX_I2S3___3 = 33,
	TEGRA_MUX_I2S4___3 = 34,
	TEGRA_MUX_IRDA___3 = 35,
	TEGRA_MUX_KBC___4 = 36,
	TEGRA_MUX_OWR___4 = 37,
	TEGRA_MUX_PE = 38,
	TEGRA_MUX_PE0 = 39,
	TEGRA_MUX_PE1 = 40,
	TEGRA_MUX_PMI___2 = 41,
	TEGRA_MUX_PWM0___3 = 42,
	TEGRA_MUX_PWM1___3 = 43,
	TEGRA_MUX_PWM2___3 = 44,
	TEGRA_MUX_PWM3___3 = 45,
	TEGRA_MUX_PWRON___2 = 46,
	TEGRA_MUX_RESET_OUT_N___2 = 47,
	TEGRA_MUX_RSVD1___4 = 48,
	TEGRA_MUX_RSVD2___4 = 49,
	TEGRA_MUX_RSVD3___4 = 50,
	TEGRA_MUX_RSVD4___4 = 51,
	TEGRA_MUX_RTCK___4 = 52,
	TEGRA_MUX_SATA___2 = 53,
	TEGRA_MUX_SDMMC1___3 = 54,
	TEGRA_MUX_SDMMC2___3 = 55,
	TEGRA_MUX_SDMMC3___3 = 56,
	TEGRA_MUX_SDMMC4___3 = 57,
	TEGRA_MUX_SOC___2 = 58,
	TEGRA_MUX_SPDIF___4 = 59,
	TEGRA_MUX_SPI1___4 = 60,
	TEGRA_MUX_SPI2___4 = 61,
	TEGRA_MUX_SPI3___4 = 62,
	TEGRA_MUX_SPI4___4 = 63,
	TEGRA_MUX_SPI5___3 = 64,
	TEGRA_MUX_SPI6___3 = 65,
	TEGRA_MUX_SYS = 66,
	TEGRA_MUX_TMDS = 67,
	TEGRA_MUX_TRACE___4 = 68,
	TEGRA_MUX_UARTA___4 = 69,
	TEGRA_MUX_UARTB___4 = 70,
	TEGRA_MUX_UARTC___4 = 71,
	TEGRA_MUX_UARTD___4 = 72,
	TEGRA_MUX_ULPI___4 = 73,
	TEGRA_MUX_USB___2 = 74,
	TEGRA_MUX_VGP1___3 = 75,
	TEGRA_MUX_VGP2___3 = 76,
	TEGRA_MUX_VGP3___3 = 77,
	TEGRA_MUX_VGP4___3 = 78,
	TEGRA_MUX_VGP5___3 = 79,
	TEGRA_MUX_VGP6___3 = 80,
	TEGRA_MUX_VI___4 = 81,
	TEGRA_MUX_VI_ALT1___3 = 82,
	TEGRA_MUX_VI_ALT3___3 = 83,
	TEGRA_MUX_VIMCLK2 = 84,
	TEGRA_MUX_VIMCLK2_ALT = 85,
};

struct tegra_xusb_padctl_function {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct tegra_xusb_padctl_lane;

struct tegra_xusb_padctl_soc___2 {
	const struct pinctrl_pin_desc *pins;
	unsigned int num_pins;
	const struct tegra_xusb_padctl_function *functions;
	unsigned int num_functions;
	const struct tegra_xusb_padctl_lane *lanes;
	unsigned int num_lanes;
};

struct tegra_xusb_padctl_lane {
	const char *name;
	unsigned int offset;
	unsigned int shift;
	unsigned int mask;
	unsigned int iddq;
	const unsigned int *funcs;
	unsigned int num_funcs;
};

struct tegra_xusb_padctl___2 {
	struct device *dev;
	void *regs;
	struct mutex lock;
	struct reset_control *rst;
	const struct tegra_xusb_padctl_soc___2 *soc;
	struct pinctrl_dev *pinctrl;
	struct pinctrl_desc desc;
	struct phy_provider *provider;
	struct phy *phys[2];
	unsigned int enable;
};

enum tegra_xusb_padctl_param {
	TEGRA_XUSB_PADCTL_IDDQ = 0,
};

struct tegra_xusb_padctl_property {
	const char *name;
	enum tegra_xusb_padctl_param param;
};

enum tegra124_function {
	TEGRA124_FUNC_SNPS = 0,
	TEGRA124_FUNC_XUSB = 1,
	TEGRA124_FUNC_UART = 2,
	TEGRA124_FUNC_PCIE = 3,
	TEGRA124_FUNC_USB3 = 4,
	TEGRA124_FUNC_SATA = 5,
	TEGRA124_FUNC_RSVD = 6,
};

enum st_retime_style {
	st_retime_style_none = 0,
	st_retime_style_packed = 1,
	st_retime_style_dedicated = 2,
};

struct st_retime_dedicated {
	struct regmap_field *rt[8];
};

struct st_retime_packed {
	struct regmap_field *clk1notclk0;
	struct regmap_field *delay_0;
	struct regmap_field *delay_1;
	struct regmap_field *invertclk;
	struct regmap_field *retime;
	struct regmap_field *clknotdata;
	struct regmap_field *double_edge;
};

struct st_pio_control {
	u32 rt_pin_mask;
	struct regmap_field *alt;
	struct regmap_field *oe;
	struct regmap_field *pu;
	struct regmap_field *od;
	union {
		struct st_retime_packed rt_p;
		struct st_retime_dedicated rt_d;
	} rt;
};

struct st_pctl_data {
	const enum st_retime_style rt_style;
	const unsigned int *input_delays;
	const int ninput_delays;
	const unsigned int *output_delays;
	const int noutput_delays;
	const int alt;
	const int oe;
	const int pu;
	const int od;
	const int rt;
};

struct st_pinconf {
	int pin;
	const char *name;
	long unsigned int config;
	int altfunc;
};

struct st_pmx_func {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct st_pctl_group {
	const char *name;
	unsigned int *pins;
	unsigned int npins;
	struct st_pinconf *pin_conf;
};

struct st_gpio_bank {
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range range;
	void *base;
	struct st_pio_control pc;
	long unsigned int irq_edge_conf;
	spinlock_t lock;
};

struct st_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct st_gpio_bank *banks;
	int nbanks;
	struct st_pmx_func *functions;
	int nfunctions;
	struct st_pctl_group *groups;
	int ngroups;
	struct regmap *regmap;
	const struct st_pctl_data *data;
	void *irqmux_base;
};

enum stmfx_functions {
	STMFX_FUNC_GPIO = 1,
	STMFX_FUNC_ALTGPIO_LOW = 2,
	STMFX_FUNC_ALTGPIO_HIGH = 4,
	STMFX_FUNC_TS = 8,
	STMFX_FUNC_IDD = 16,
};

struct stmfx {
	struct device *dev;
	struct regmap *map;
	struct regulator *vdd;
	int irq;
	struct irq_domain *irq_domain;
	struct mutex lock;
	u8 irq_src;
	u8 bkp_sysctrl;
	u8 bkp_irqoutpin;
};

struct stmfx_pinctrl {
	struct device *dev;
	struct stmfx *stmfx;
	struct pinctrl_dev *pctl_dev;
	struct pinctrl_desc pctl_desc;
	struct gpio_chip gpio_chip;
	struct irq_chip irq_chip;
	struct mutex lock;
	long unsigned int gpio_valid_mask;
	u8 irq_gpi_src[3];
	u8 irq_gpi_type[3];
	u8 irq_gpi_evt[3];
	u8 irq_toggle_edge[3];
	u8 bkp_gpio_state[3];
	u8 bkp_gpio_dir[3];
	u8 bkp_gpio_type[3];
	u8 bkp_gpio_pupd[3];
};

struct zynq_pctrl_group;

struct zynq_pinmux_function;

struct zynq_pinctrl {
	struct pinctrl_dev *pctrl;
	struct regmap *syscon;
	u32 pctrl_offset;
	const struct zynq_pctrl_group *groups;
	unsigned int ngroups;
	const struct zynq_pinmux_function *funcs;
	unsigned int nfuncs;
};

struct zynq_pctrl_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int npins;
};

struct zynq_pinmux_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
	unsigned int mux_val;
	u32 mux;
	u32 mux_mask;
	u8 mux_shift;
};

enum zynq_pinmux_functions {
	ZYNQ_PMUX_can0 = 0,
	ZYNQ_PMUX_can1 = 1,
	ZYNQ_PMUX_ethernet0 = 2,
	ZYNQ_PMUX_ethernet1 = 3,
	ZYNQ_PMUX_gpio0 = 4,
	ZYNQ_PMUX_i2c0 = 5,
	ZYNQ_PMUX_i2c1 = 6,
	ZYNQ_PMUX_mdio0 = 7,
	ZYNQ_PMUX_mdio1 = 8,
	ZYNQ_PMUX_qspi0 = 9,
	ZYNQ_PMUX_qspi1 = 10,
	ZYNQ_PMUX_qspi_fbclk = 11,
	ZYNQ_PMUX_qspi_cs1 = 12,
	ZYNQ_PMUX_spi0 = 13,
	ZYNQ_PMUX_spi1 = 14,
	ZYNQ_PMUX_spi0_ss = 15,
	ZYNQ_PMUX_spi1_ss = 16,
	ZYNQ_PMUX_sdio0 = 17,
	ZYNQ_PMUX_sdio0_pc = 18,
	ZYNQ_PMUX_sdio0_cd = 19,
	ZYNQ_PMUX_sdio0_wp = 20,
	ZYNQ_PMUX_sdio1 = 21,
	ZYNQ_PMUX_sdio1_pc = 22,
	ZYNQ_PMUX_sdio1_cd = 23,
	ZYNQ_PMUX_sdio1_wp = 24,
	ZYNQ_PMUX_smc0_nor = 25,
	ZYNQ_PMUX_smc0_nor_cs1 = 26,
	ZYNQ_PMUX_smc0_nor_addr25 = 27,
	ZYNQ_PMUX_smc0_nand = 28,
	ZYNQ_PMUX_ttc0 = 29,
	ZYNQ_PMUX_ttc1 = 30,
	ZYNQ_PMUX_uart0 = 31,
	ZYNQ_PMUX_uart1 = 32,
	ZYNQ_PMUX_usb0 = 33,
	ZYNQ_PMUX_usb1 = 34,
	ZYNQ_PMUX_swdt0 = 35,
	ZYNQ_PMUX_MAX_FUNC = 36,
};

enum zynq_io_standards {
	zynq_iostd_min = 0,
	zynq_iostd_lvcmos18 = 1,
	zynq_iostd_lvcmos25 = 2,
	zynq_iostd_lvcmos33 = 3,
	zynq_iostd_hstl = 4,
	zynq_iostd_max = 5,
};

struct aspeed_sig_desc {
	unsigned int ip;
	unsigned int reg;
	u32 mask;
	u32 enable;
	u32 disable;
};

struct aspeed_sig_expr {
	const char *signal;
	const char *function;
	int ndescs;
	const struct aspeed_sig_desc *descs;
};

struct aspeed_pin_desc {
	const char *name;
	const struct aspeed_sig_expr ***prios;
};

struct aspeed_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int npins;
};

struct aspeed_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct aspeed_pinmux_data;

struct aspeed_pinmux_ops {
	int (*eval)(struct aspeed_pinmux_data *, const struct aspeed_sig_expr *, _Bool);
	int (*set)(struct aspeed_pinmux_data *, const struct aspeed_sig_expr *, _Bool);
};

struct aspeed_pinmux_data {
	struct device *dev;
	struct regmap *maps[3];
	const struct aspeed_pinmux_ops *ops;
	const struct aspeed_pin_group *groups;
	const unsigned int ngroups;
	const struct aspeed_pin_function *functions;
	const unsigned int nfunctions;
};

struct aspeed_pin_config {
	enum pin_config_param param;
	unsigned int pins[2];
	unsigned int reg;
	u32 mask;
};

struct aspeed_pin_config_map {
	enum pin_config_param param;
	s32 arg;
	u32 val;
	u32 mask;
};

struct aspeed_pinctrl_data {
	struct regmap *scu;
	const struct pinctrl_pin_desc *pins;
	const unsigned int npins;
	const struct aspeed_pin_config *configs;
	const unsigned int nconfigs;
	struct aspeed_pinmux_data pinmux;
	const struct aspeed_pin_config_map *confmaps;
	const unsigned int nconfmaps;
};

enum aspeed_pin_config_map_type {
	MAP_TYPE_ARG = 0,
	MAP_TYPE_VAL = 1,
};

enum bcm281xx_pin_type {
	BCM281XX_PIN_TYPE_UNKNOWN = 0,
	BCM281XX_PIN_TYPE_STD = 1,
	BCM281XX_PIN_TYPE_I2C = 2,
	BCM281XX_PIN_TYPE_HDMI = 3,
};

struct bcm281xx_pin_function {
	const char *name;
	const char * const *groups;
	const unsigned int ngroups;
};

struct bcm281xx_pinctrl_data {
	void *reg_base;
	const struct pinctrl_pin_desc *pins;
	const unsigned int npins;
	const struct bcm281xx_pin_function *functions;
	const unsigned int nfunctions;
	struct regmap *regmap;
};

struct bcm2835_pinctrl {
	struct device *dev;
	void *base;
	int *wake_irq;
	long unsigned int enabled_irq_map[2];
	unsigned int irq_type[58];
	struct pinctrl_dev *pctl_dev;
	struct gpio_chip gpio_chip;
	struct pinctrl_desc pctl_desc;
	struct pinctrl_gpio_range gpio_range;
	raw_spinlock_t irq_lock[2];
};

enum bcm2835_fsel {
	BCM2835_FSEL_COUNT = 8,
	BCM2835_FSEL_MASK = 7,
};

struct bcm_plat_data {
	const struct gpio_chip *gpio_chip;
	const struct pinctrl_desc *pctl_desc;
	const struct pinctrl_gpio_range *gpio_range;
};

enum iproc_pinconf_param {
	IPROC_PINCONF_DRIVE_STRENGTH = 0,
	IPROC_PINCONF_BIAS_DISABLE = 1,
	IPROC_PINCONF_BIAS_PULL_UP = 2,
	IPROC_PINCONF_BIAS_PULL_DOWN = 3,
	IPROC_PINCON_MAX = 4,
};

enum iproc_pinconf_ctrl_type {
	IOCTRL_TYPE_AON = 1,
	IOCTRL_TYPE_CDRU = 2,
	IOCTRL_TYPE_INVALID = 3,
};

struct iproc_gpio {
	struct device *dev;
	void *base;
	void *io_ctrl;
	enum iproc_pinconf_ctrl_type io_ctrl_type;
	raw_spinlock_t lock;
	struct irq_chip irqchip;
	struct gpio_chip gc;
	unsigned int num_banks;
	bool pinmux_is_supported;
	enum pin_config_param *pinconf_disable;
	unsigned int nr_pinconf_disable;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctldesc;
};

struct cygnus_mux {
	unsigned int offset;
	unsigned int shift;
	unsigned int alt;
};

struct cygnus_mux_log {
	struct cygnus_mux mux;
	bool is_configured;
};

struct cygnus_pin_group {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
	struct cygnus_mux mux;
};

struct cygnus_pin_function {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct cygnus_pinctrl {
	struct pinctrl_dev *pctl;
	struct device *dev;
	void *base0;
	void *base1;
	const struct cygnus_pin_group *groups;
	unsigned int num_groups;
	const struct cygnus_pin_function *functions;
	unsigned int num_functions;
	struct cygnus_mux_log *mux_log;
	spinlock_t lock;
};

struct cygnus_gpio_mux {
	int is_supported;
	unsigned int offset;
	unsigned int shift;
};

struct cygnus_pin {
	unsigned int pin;
	char *name;
	struct cygnus_gpio_mux gpio_mux;
};

struct ns_pinctrl_group;

struct ns_pinctrl_function;

struct ns_pinctrl {
	struct device *dev;
	unsigned int chipset_flag;
	struct pinctrl_dev *pctldev;
	struct regmap *regmap;
	u32 offset;
	struct pinctrl_desc pctldesc;
	struct ns_pinctrl_group *groups;
	unsigned int num_groups;
	struct ns_pinctrl_function *functions;
	unsigned int num_functions;
};

struct ns_pinctrl_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int num_pins;
	unsigned int chipsets;
};

struct ns_pinctrl_function {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
	unsigned int chipsets;
};

struct nsp_gpio {
	struct device *dev;
	void *base;
	void *io_ctrl;
	struct irq_chip irqchip;
	struct gpio_chip gc;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctldesc;
	raw_spinlock_t lock;
};

enum base_type {
	REG = 0,
	IO_CTRL = 1,
};

struct nsp_mux {
	unsigned int base;
	unsigned int shift;
	unsigned int mask;
	unsigned int alt;
};

struct nsp_mux_log {
	struct nsp_mux mux;
	bool is_configured;
};

struct nsp_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int num_pins;
	const struct nsp_mux mux;
};

struct nsp_pin_function {
	const char *name;
	const char * const *groups;
	const unsigned int num_groups;
};

struct nsp_pinctrl {
	struct pinctrl_dev *pctl;
	struct device *dev;
	void *base0;
	void *base1;
	void *base2;
	const struct nsp_pin_group *groups;
	unsigned int num_groups;
	const struct nsp_pin_function *functions;
	unsigned int num_functions;
	struct nsp_mux_log *mux_log;
	spinlock_t lock;
};

struct nsp_pin {
	unsigned int pin;
	char *name;
	unsigned int gpio_select;
};

struct berlin_desc_function {
	const char *name;
	u8 muxval;
};

struct berlin_desc_group {
	const char *name;
	u8 offset;
	u8 bit_width;
	u8 lsb;
	struct berlin_desc_function *functions;
};

struct berlin_pinctrl_desc {
	const struct berlin_desc_group *groups;
	unsigned int ngroups;
};

struct berlin_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct berlin_pinctrl {
	struct regmap *regmap;
	struct device *dev;
	const struct berlin_pinctrl_desc *desc;
	struct berlin_pinctrl_function *functions;
	unsigned int nfunctions;
	struct pinctrl_dev *pctrl_dev;
};

struct imx_pin_mmio {
	unsigned int mux_mode;
	u16 input_reg;
	unsigned int input_val;
	long unsigned int config;
};

struct imx_pin_scu {
	unsigned int mux_mode;
	long unsigned int config;
};

struct imx_pin {
	unsigned int pin;
	union {
		struct imx_pin_mmio mmio;
		struct imx_pin_scu scu;
	} conf;
};

struct imx_pin_reg {
	s16 mux_reg;
	s16 conf_reg;
};

struct imx_cfg_params_decode {
	enum pin_config_param param;
	u32 mask;
	u8 shift;
	bool invert;
};

struct imx_pinctrl_soc_info;

struct imx_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	void *base;
	void *input_sel_base;
	const struct imx_pinctrl_soc_info *info;
	struct imx_pin_reg *pin_regs;
	unsigned int group_index;
	struct mutex mutex;
};

struct imx_pinctrl_soc_info {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	unsigned int flags;
	const char *gpr_compatible;
	unsigned int mux_mask;
	u8 mux_shift;
	bool generic_pinconf;
	const struct pinconf_generic_params *custom_params;
	unsigned int num_custom_params;
	const struct imx_cfg_params_decode *decodes;
	unsigned int num_decodes;
	void (*fixup)(long unsigned int *, unsigned int, u32 *);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	int (*imx_pinconf_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*imx_pinconf_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*imx_pinctrl_parse_pin)(struct imx_pinctrl *, unsigned int *, struct imx_pin *, const __be32 **);
};

enum imx50_pads {
	MX50_PAD_RESERVE0 = 0,
	MX50_PAD_RESERVE1 = 1,
	MX50_PAD_RESERVE2 = 2,
	MX50_PAD_RESERVE3 = 3,
	MX50_PAD_RESERVE4 = 4,
	MX50_PAD_RESERVE5 = 5,
	MX50_PAD_RESERVE6 = 6,
	MX50_PAD_RESERVE7 = 7,
	MX50_PAD_KEY_COL0 = 8,
	MX50_PAD_KEY_ROW0 = 9,
	MX50_PAD_KEY_COL1 = 10,
	MX50_PAD_KEY_ROW1 = 11,
	MX50_PAD_KEY_COL2 = 12,
	MX50_PAD_KEY_ROW2 = 13,
	MX50_PAD_KEY_COL3 = 14,
	MX50_PAD_KEY_ROW3 = 15,
	MX50_PAD_I2C1_SCL = 16,
	MX50_PAD_I2C1_SDA = 17,
	MX50_PAD_I2C2_SCL = 18,
	MX50_PAD_I2C2_SDA = 19,
	MX50_PAD_I2C3_SCL = 20,
	MX50_PAD_I2C3_SDA = 21,
	MX50_PAD_PWM1 = 22,
	MX50_PAD_PWM2 = 23,
	MX50_PAD_0WIRE = 24,
	MX50_PAD_EPITO = 25,
	MX50_PAD_WDOG = 26,
	MX50_PAD_SSI_TXFS = 27,
	MX50_PAD_SSI_TXC = 28,
	MX50_PAD_SSI_TXD = 29,
	MX50_PAD_SSI_RXD = 30,
	MX50_PAD_SSI_RXF = 31,
	MX50_PAD_SSI_RXC = 32,
	MX50_PAD_UART1_TXD = 33,
	MX50_PAD_UART1_RXD = 34,
	MX50_PAD_UART1_CTS = 35,
	MX50_PAD_UART1_RTS = 36,
	MX50_PAD_UART2_TXD = 37,
	MX50_PAD_UART2_RXD = 38,
	MX50_PAD_UART2_CTS = 39,
	MX50_PAD_UART2_RTS = 40,
	MX50_PAD_UART3_TXD = 41,
	MX50_PAD_UART3_RXD = 42,
	MX50_PAD_UART4_TXD = 43,
	MX50_PAD_UART4_RXD = 44,
	MX50_PAD_CSPI_CLK = 45,
	MX50_PAD_CSPI_MOSI = 46,
	MX50_PAD_CSPI_MISO = 47,
	MX50_PAD_CSPI_SS0 = 48,
	MX50_PAD_ECSPI1_CLK = 49,
	MX50_PAD_ECSPI1_MOSI = 50,
	MX50_PAD_ECSPI1_MISO = 51,
	MX50_PAD_ECSPI1_SS0 = 52,
	MX50_PAD_ECSPI2_CLK = 53,
	MX50_PAD_ECSPI2_MOSI = 54,
	MX50_PAD_ECSPI2_MISO = 55,
	MX50_PAD_ECSPI2_SS0 = 56,
	MX50_PAD_SD1_CLK = 57,
	MX50_PAD_SD1_CMD = 58,
	MX50_PAD_SD1_D0 = 59,
	MX50_PAD_SD1_D1 = 60,
	MX50_PAD_SD1_D2 = 61,
	MX50_PAD_SD1_D3 = 62,
	MX50_PAD_SD2_CLK = 63,
	MX50_PAD_SD2_CMD = 64,
	MX50_PAD_SD2_D0 = 65,
	MX50_PAD_SD2_D1 = 66,
	MX50_PAD_SD2_D2 = 67,
	MX50_PAD_SD2_D3 = 68,
	MX50_PAD_SD2_D4 = 69,
	MX50_PAD_SD2_D5 = 70,
	MX50_PAD_SD2_D6 = 71,
	MX50_PAD_SD2_D7 = 72,
	MX50_PAD_SD2_WP = 73,
	MX50_PAD_SD2_CD = 74,
	MX50_PAD_DISP_D0 = 75,
	MX50_PAD_DISP_D1 = 76,
	MX50_PAD_DISP_D2 = 77,
	MX50_PAD_DISP_D3 = 78,
	MX50_PAD_DISP_D4 = 79,
	MX50_PAD_DISP_D5 = 80,
	MX50_PAD_DISP_D6 = 81,
	MX50_PAD_DISP_D7 = 82,
	MX50_PAD_DISP_WR = 83,
	MX50_PAD_DISP_RD = 84,
	MX50_PAD_DISP_RS = 85,
	MX50_PAD_DISP_CS = 86,
	MX50_PAD_DISP_BUSY = 87,
	MX50_PAD_DISP_RESET = 88,
	MX50_PAD_SD3_CLK = 89,
	MX50_PAD_SD3_CMD = 90,
	MX50_PAD_SD3_D0 = 91,
	MX50_PAD_SD3_D1 = 92,
	MX50_PAD_SD3_D2 = 93,
	MX50_PAD_SD3_D3 = 94,
	MX50_PAD_SD3_D4 = 95,
	MX50_PAD_SD3_D5 = 96,
	MX50_PAD_SD3_D6 = 97,
	MX50_PAD_SD3_D7 = 98,
	MX50_PAD_SD3_WP = 99,
	MX50_PAD_DISP_D8 = 100,
	MX50_PAD_DISP_D9 = 101,
	MX50_PAD_DISP_D10 = 102,
	MX50_PAD_DISP_D11 = 103,
	MX50_PAD_DISP_D12 = 104,
	MX50_PAD_DISP_D13 = 105,
	MX50_PAD_DISP_D14 = 106,
	MX50_PAD_DISP_D15 = 107,
	MX50_PAD_EPDC_D0 = 108,
	MX50_PAD_EPDC_D1 = 109,
	MX50_PAD_EPDC_D2 = 110,
	MX50_PAD_EPDC_D3 = 111,
	MX50_PAD_EPDC_D4 = 112,
	MX50_PAD_EPDC_D5 = 113,
	MX50_PAD_EPDC_D6 = 114,
	MX50_PAD_EPDC_D7 = 115,
	MX50_PAD_EPDC_D8 = 116,
	MX50_PAD_EPDC_D9 = 117,
	MX50_PAD_EPDC_D10 = 118,
	MX50_PAD_EPDC_D11 = 119,
	MX50_PAD_EPDC_D12 = 120,
	MX50_PAD_EPDC_D13 = 121,
	MX50_PAD_EPDC_D14 = 122,
	MX50_PAD_EPDC_D15 = 123,
	MX50_PAD_EPDC_GDCLK = 124,
	MX50_PAD_EPDC_GDSP = 125,
	MX50_PAD_EPDC_GDOE = 126,
	MX50_PAD_EPDC_GDRL = 127,
	MX50_PAD_EPDC_SDCLK = 128,
	MX50_PAD_EPDC_SDOEZ = 129,
	MX50_PAD_EPDC_SDOED = 130,
	MX50_PAD_EPDC_SDOE = 131,
	MX50_PAD_EPDC_SDLE = 132,
	MX50_PAD_EPDC_SDCLKN = 133,
	MX50_PAD_EPDC_SDSHR = 134,
	MX50_PAD_EPDC_PWRCOM = 135,
	MX50_PAD_EPDC_PWRSTAT = 136,
	MX50_PAD_EPDC_PWRCTRL0 = 137,
	MX50_PAD_EPDC_PWRCTRL1 = 138,
	MX50_PAD_EPDC_PWRCTRL2 = 139,
	MX50_PAD_EPDC_PWRCTRL3 = 140,
	MX50_PAD_EPDC_VCOM0 = 141,
	MX50_PAD_EPDC_VCOM1 = 142,
	MX50_PAD_EPDC_BDR0 = 143,
	MX50_PAD_EPDC_BDR1 = 144,
	MX50_PAD_EPDC_SDCE0 = 145,
	MX50_PAD_EPDC_SDCE1 = 146,
	MX50_PAD_EPDC_SDCE2 = 147,
	MX50_PAD_EPDC_SDCE3 = 148,
	MX50_PAD_EPDC_SDCE4 = 149,
	MX50_PAD_EPDC_SDCE5 = 150,
	MX50_PAD_EIM_DA0 = 151,
	MX50_PAD_EIM_DA1 = 152,
	MX50_PAD_EIM_DA2 = 153,
	MX50_PAD_EIM_DA3 = 154,
	MX50_PAD_EIM_DA4 = 155,
	MX50_PAD_EIM_DA5 = 156,
	MX50_PAD_EIM_DA6 = 157,
	MX50_PAD_EIM_DA7 = 158,
	MX50_PAD_EIM_DA8 = 159,
	MX50_PAD_EIM_DA9 = 160,
	MX50_PAD_EIM_DA10 = 161,
	MX50_PAD_EIM_DA11 = 162,
	MX50_PAD_EIM_DA12 = 163,
	MX50_PAD_EIM_DA13 = 164,
	MX50_PAD_EIM_DA14 = 165,
	MX50_PAD_EIM_DA15 = 166,
	MX50_PAD_EIM_CS2 = 167,
	MX50_PAD_EIM_CS1 = 168,
	MX50_PAD_EIM_CS0 = 169,
	MX50_PAD_EIM_EB0 = 170,
	MX50_PAD_EIM_EB1 = 171,
	MX50_PAD_EIM_WAIT = 172,
	MX50_PAD_EIM_BCLK = 173,
	MX50_PAD_EIM_RDY = 174,
	MX50_PAD_EIM_OE = 175,
	MX50_PAD_EIM_RW = 176,
	MX50_PAD_EIM_LBA = 177,
	MX50_PAD_EIM_CRE = 178,
};

enum imx51_pads {
	MX51_PAD_RESERVE0 = 0,
	MX51_PAD_RESERVE1 = 1,
	MX51_PAD_RESERVE2 = 2,
	MX51_PAD_RESERVE3 = 3,
	MX51_PAD_RESERVE4 = 4,
	MX51_PAD_RESERVE5 = 5,
	MX51_PAD_RESERVE6 = 6,
	MX51_PAD_EIM_DA0 = 7,
	MX51_PAD_EIM_DA1 = 8,
	MX51_PAD_EIM_DA2 = 9,
	MX51_PAD_EIM_DA3 = 10,
	MX51_PAD_EIM_DA4 = 11,
	MX51_PAD_EIM_DA5 = 12,
	MX51_PAD_EIM_DA6 = 13,
	MX51_PAD_EIM_DA7 = 14,
	MX51_PAD_EIM_DA8 = 15,
	MX51_PAD_EIM_DA9 = 16,
	MX51_PAD_EIM_DA10 = 17,
	MX51_PAD_EIM_DA11 = 18,
	MX51_PAD_EIM_DA12 = 19,
	MX51_PAD_EIM_DA13 = 20,
	MX51_PAD_EIM_DA14 = 21,
	MX51_PAD_EIM_DA15 = 22,
	MX51_PAD_EIM_D16 = 23,
	MX51_PAD_EIM_D17 = 24,
	MX51_PAD_EIM_D18 = 25,
	MX51_PAD_EIM_D19 = 26,
	MX51_PAD_EIM_D20 = 27,
	MX51_PAD_EIM_D21 = 28,
	MX51_PAD_EIM_D22 = 29,
	MX51_PAD_EIM_D23 = 30,
	MX51_PAD_EIM_D24 = 31,
	MX51_PAD_EIM_D25 = 32,
	MX51_PAD_EIM_D26 = 33,
	MX51_PAD_EIM_D27 = 34,
	MX51_PAD_EIM_D28 = 35,
	MX51_PAD_EIM_D29 = 36,
	MX51_PAD_EIM_D30 = 37,
	MX51_PAD_EIM_D31 = 38,
	MX51_PAD_EIM_A16 = 39,
	MX51_PAD_EIM_A17 = 40,
	MX51_PAD_EIM_A18 = 41,
	MX51_PAD_EIM_A19 = 42,
	MX51_PAD_EIM_A20 = 43,
	MX51_PAD_EIM_A21 = 44,
	MX51_PAD_EIM_A22 = 45,
	MX51_PAD_EIM_A23 = 46,
	MX51_PAD_EIM_A24 = 47,
	MX51_PAD_EIM_A25 = 48,
	MX51_PAD_EIM_A26 = 49,
	MX51_PAD_EIM_A27 = 50,
	MX51_PAD_EIM_EB0 = 51,
	MX51_PAD_EIM_EB1 = 52,
	MX51_PAD_EIM_EB2 = 53,
	MX51_PAD_EIM_EB3 = 54,
	MX51_PAD_EIM_OE = 55,
	MX51_PAD_EIM_CS0 = 56,
	MX51_PAD_EIM_CS1 = 57,
	MX51_PAD_EIM_CS2 = 58,
	MX51_PAD_EIM_CS3 = 59,
	MX51_PAD_EIM_CS4 = 60,
	MX51_PAD_EIM_CS5 = 61,
	MX51_PAD_EIM_DTACK = 62,
	MX51_PAD_EIM_LBA = 63,
	MX51_PAD_EIM_CRE = 64,
	MX51_PAD_DRAM_CS1 = 65,
	MX51_PAD_NANDF_WE_B = 66,
	MX51_PAD_NANDF_RE_B = 67,
	MX51_PAD_NANDF_ALE = 68,
	MX51_PAD_NANDF_CLE = 69,
	MX51_PAD_NANDF_WP_B = 70,
	MX51_PAD_NANDF_RB0 = 71,
	MX51_PAD_NANDF_RB1 = 72,
	MX51_PAD_NANDF_RB2 = 73,
	MX51_PAD_NANDF_RB3 = 74,
	MX51_PAD_GPIO_NAND = 75,
	MX51_PAD_NANDF_CS0 = 76,
	MX51_PAD_NANDF_CS1 = 77,
	MX51_PAD_NANDF_CS2 = 78,
	MX51_PAD_NANDF_CS3 = 79,
	MX51_PAD_NANDF_CS4 = 80,
	MX51_PAD_NANDF_CS5 = 81,
	MX51_PAD_NANDF_CS6 = 82,
	MX51_PAD_NANDF_CS7 = 83,
	MX51_PAD_NANDF_RDY_INT = 84,
	MX51_PAD_NANDF_D15 = 85,
	MX51_PAD_NANDF_D14 = 86,
	MX51_PAD_NANDF_D13 = 87,
	MX51_PAD_NANDF_D12 = 88,
	MX51_PAD_NANDF_D11 = 89,
	MX51_PAD_NANDF_D10 = 90,
	MX51_PAD_NANDF_D9 = 91,
	MX51_PAD_NANDF_D8 = 92,
	MX51_PAD_NANDF_D7 = 93,
	MX51_PAD_NANDF_D6 = 94,
	MX51_PAD_NANDF_D5 = 95,
	MX51_PAD_NANDF_D4 = 96,
	MX51_PAD_NANDF_D3 = 97,
	MX51_PAD_NANDF_D2 = 98,
	MX51_PAD_NANDF_D1 = 99,
	MX51_PAD_NANDF_D0 = 100,
	MX51_PAD_CSI1_D8 = 101,
	MX51_PAD_CSI1_D9 = 102,
	MX51_PAD_CSI1_D10 = 103,
	MX51_PAD_CSI1_D11 = 104,
	MX51_PAD_CSI1_D12 = 105,
	MX51_PAD_CSI1_D13 = 106,
	MX51_PAD_CSI1_D14 = 107,
	MX51_PAD_CSI1_D15 = 108,
	MX51_PAD_CSI1_D16 = 109,
	MX51_PAD_CSI1_D17 = 110,
	MX51_PAD_CSI1_D18 = 111,
	MX51_PAD_CSI1_D19 = 112,
	MX51_PAD_CSI1_VSYNC = 113,
	MX51_PAD_CSI1_HSYNC = 114,
	MX51_PAD_CSI2_D12 = 115,
	MX51_PAD_CSI2_D13 = 116,
	MX51_PAD_CSI2_D14 = 117,
	MX51_PAD_CSI2_D15 = 118,
	MX51_PAD_CSI2_D16 = 119,
	MX51_PAD_CSI2_D17 = 120,
	MX51_PAD_CSI2_D18 = 121,
	MX51_PAD_CSI2_D19 = 122,
	MX51_PAD_CSI2_VSYNC = 123,
	MX51_PAD_CSI2_HSYNC = 124,
	MX51_PAD_CSI2_PIXCLK = 125,
	MX51_PAD_I2C1_CLK = 126,
	MX51_PAD_I2C1_DAT = 127,
	MX51_PAD_AUD3_BB_TXD = 128,
	MX51_PAD_AUD3_BB_RXD = 129,
	MX51_PAD_AUD3_BB_CK = 130,
	MX51_PAD_AUD3_BB_FS = 131,
	MX51_PAD_CSPI1_MOSI = 132,
	MX51_PAD_CSPI1_MISO = 133,
	MX51_PAD_CSPI1_SS0 = 134,
	MX51_PAD_CSPI1_SS1 = 135,
	MX51_PAD_CSPI1_RDY = 136,
	MX51_PAD_CSPI1_SCLK = 137,
	MX51_PAD_UART1_RXD = 138,
	MX51_PAD_UART1_TXD = 139,
	MX51_PAD_UART1_RTS = 140,
	MX51_PAD_UART1_CTS = 141,
	MX51_PAD_UART2_RXD = 142,
	MX51_PAD_UART2_TXD = 143,
	MX51_PAD_UART3_RXD = 144,
	MX51_PAD_UART3_TXD = 145,
	MX51_PAD_OWIRE_LINE = 146,
	MX51_PAD_KEY_ROW0 = 147,
	MX51_PAD_KEY_ROW1 = 148,
	MX51_PAD_KEY_ROW2 = 149,
	MX51_PAD_KEY_ROW3 = 150,
	MX51_PAD_KEY_COL0 = 151,
	MX51_PAD_KEY_COL1 = 152,
	MX51_PAD_KEY_COL2 = 153,
	MX51_PAD_KEY_COL3 = 154,
	MX51_PAD_KEY_COL4 = 155,
	MX51_PAD_KEY_COL5 = 156,
	MX51_PAD_RESERVE7 = 157,
	MX51_PAD_USBH1_CLK = 158,
	MX51_PAD_USBH1_DIR = 159,
	MX51_PAD_USBH1_STP = 160,
	MX51_PAD_USBH1_NXT = 161,
	MX51_PAD_USBH1_DATA0 = 162,
	MX51_PAD_USBH1_DATA1 = 163,
	MX51_PAD_USBH1_DATA2 = 164,
	MX51_PAD_USBH1_DATA3 = 165,
	MX51_PAD_USBH1_DATA4 = 166,
	MX51_PAD_USBH1_DATA5 = 167,
	MX51_PAD_USBH1_DATA6 = 168,
	MX51_PAD_USBH1_DATA7 = 169,
	MX51_PAD_DI1_PIN11 = 170,
	MX51_PAD_DI1_PIN12 = 171,
	MX51_PAD_DI1_PIN13 = 172,
	MX51_PAD_DI1_D0_CS = 173,
	MX51_PAD_DI1_D1_CS = 174,
	MX51_PAD_DISPB2_SER_DIN = 175,
	MX51_PAD_DISPB2_SER_DIO = 176,
	MX51_PAD_DISPB2_SER_CLK = 177,
	MX51_PAD_DISPB2_SER_RS = 178,
	MX51_PAD_DISP1_DAT0 = 179,
	MX51_PAD_DISP1_DAT1 = 180,
	MX51_PAD_DISP1_DAT2 = 181,
	MX51_PAD_DISP1_DAT3 = 182,
	MX51_PAD_DISP1_DAT4 = 183,
	MX51_PAD_DISP1_DAT5 = 184,
	MX51_PAD_DISP1_DAT6 = 185,
	MX51_PAD_DISP1_DAT7 = 186,
	MX51_PAD_DISP1_DAT8 = 187,
	MX51_PAD_DISP1_DAT9 = 188,
	MX51_PAD_DISP1_DAT10 = 189,
	MX51_PAD_DISP1_DAT11 = 190,
	MX51_PAD_DISP1_DAT12 = 191,
	MX51_PAD_DISP1_DAT13 = 192,
	MX51_PAD_DISP1_DAT14 = 193,
	MX51_PAD_DISP1_DAT15 = 194,
	MX51_PAD_DISP1_DAT16 = 195,
	MX51_PAD_DISP1_DAT17 = 196,
	MX51_PAD_DISP1_DAT18 = 197,
	MX51_PAD_DISP1_DAT19 = 198,
	MX51_PAD_DISP1_DAT20 = 199,
	MX51_PAD_DISP1_DAT21 = 200,
	MX51_PAD_DISP1_DAT22 = 201,
	MX51_PAD_DISP1_DAT23 = 202,
	MX51_PAD_DI1_PIN3 = 203,
	MX51_PAD_DI1_PIN2 = 204,
	MX51_PAD_RESERVE8 = 205,
	MX51_PAD_DI_GP2 = 206,
	MX51_PAD_DI_GP3 = 207,
	MX51_PAD_DI2_PIN4 = 208,
	MX51_PAD_DI2_PIN2 = 209,
	MX51_PAD_DI2_PIN3 = 210,
	MX51_PAD_DI2_DISP_CLK = 211,
	MX51_PAD_DI_GP4 = 212,
	MX51_PAD_DISP2_DAT0 = 213,
	MX51_PAD_DISP2_DAT1 = 214,
	MX51_PAD_DISP2_DAT2 = 215,
	MX51_PAD_DISP2_DAT3 = 216,
	MX51_PAD_DISP2_DAT4 = 217,
	MX51_PAD_DISP2_DAT5 = 218,
	MX51_PAD_DISP2_DAT6 = 219,
	MX51_PAD_DISP2_DAT7 = 220,
	MX51_PAD_DISP2_DAT8 = 221,
	MX51_PAD_DISP2_DAT9 = 222,
	MX51_PAD_DISP2_DAT10 = 223,
	MX51_PAD_DISP2_DAT11 = 224,
	MX51_PAD_DISP2_DAT12 = 225,
	MX51_PAD_DISP2_DAT13 = 226,
	MX51_PAD_DISP2_DAT14 = 227,
	MX51_PAD_DISP2_DAT15 = 228,
	MX51_PAD_SD1_CMD = 229,
	MX51_PAD_SD1_CLK = 230,
	MX51_PAD_SD1_DATA0 = 231,
	MX51_PAD_SD1_DATA1 = 232,
	MX51_PAD_SD1_DATA2 = 233,
	MX51_PAD_SD1_DATA3 = 234,
	MX51_PAD_GPIO1_0 = 235,
	MX51_PAD_GPIO1_1 = 236,
	MX51_PAD_SD2_CMD = 237,
	MX51_PAD_SD2_CLK = 238,
	MX51_PAD_SD2_DATA0 = 239,
	MX51_PAD_SD2_DATA1 = 240,
	MX51_PAD_SD2_DATA2 = 241,
	MX51_PAD_SD2_DATA3 = 242,
	MX51_PAD_GPIO1_2 = 243,
	MX51_PAD_GPIO1_3 = 244,
	MX51_PAD_PMIC_INT_REQ = 245,
	MX51_PAD_GPIO1_4 = 246,
	MX51_PAD_GPIO1_5 = 247,
	MX51_PAD_GPIO1_6 = 248,
	MX51_PAD_GPIO1_7 = 249,
	MX51_PAD_GPIO1_8 = 250,
	MX51_PAD_GPIO1_9 = 251,
	MX51_PAD_RESERVE9 = 252,
	MX51_PAD_RESERVE10 = 253,
	MX51_PAD_RESERVE11 = 254,
	MX51_PAD_RESERVE12 = 255,
	MX51_PAD_RESERVE13 = 256,
	MX51_PAD_RESERVE14 = 257,
	MX51_PAD_RESERVE15 = 258,
	MX51_PAD_RESERVE16 = 259,
	MX51_PAD_RESERVE17 = 260,
	MX51_PAD_RESERVE18 = 261,
	MX51_PAD_RESERVE19 = 262,
	MX51_PAD_RESERVE20 = 263,
	MX51_PAD_RESERVE21 = 264,
	MX51_PAD_RESERVE22 = 265,
	MX51_PAD_RESERVE23 = 266,
	MX51_PAD_RESERVE24 = 267,
	MX51_PAD_RESERVE25 = 268,
	MX51_PAD_RESERVE26 = 269,
	MX51_PAD_RESERVE27 = 270,
	MX51_PAD_RESERVE28 = 271,
	MX51_PAD_RESERVE29 = 272,
	MX51_PAD_RESERVE30 = 273,
	MX51_PAD_RESERVE31 = 274,
	MX51_PAD_RESERVE32 = 275,
	MX51_PAD_RESERVE33 = 276,
	MX51_PAD_RESERVE34 = 277,
	MX51_PAD_RESERVE35 = 278,
	MX51_PAD_RESERVE36 = 279,
	MX51_PAD_RESERVE37 = 280,
	MX51_PAD_RESERVE38 = 281,
	MX51_PAD_RESERVE39 = 282,
	MX51_PAD_RESERVE40 = 283,
	MX51_PAD_RESERVE41 = 284,
	MX51_PAD_RESERVE42 = 285,
	MX51_PAD_RESERVE43 = 286,
	MX51_PAD_RESERVE44 = 287,
	MX51_PAD_RESERVE45 = 288,
	MX51_PAD_RESERVE46 = 289,
	MX51_PAD_RESERVE47 = 290,
	MX51_PAD_RESERVE48 = 291,
	MX51_PAD_RESERVE49 = 292,
	MX51_PAD_RESERVE50 = 293,
	MX51_PAD_RESERVE51 = 294,
	MX51_PAD_RESERVE52 = 295,
	MX51_PAD_RESERVE53 = 296,
	MX51_PAD_RESERVE54 = 297,
	MX51_PAD_RESERVE55 = 298,
	MX51_PAD_RESERVE56 = 299,
	MX51_PAD_RESERVE57 = 300,
	MX51_PAD_RESERVE58 = 301,
	MX51_PAD_RESERVE59 = 302,
	MX51_PAD_RESERVE60 = 303,
	MX51_PAD_RESERVE61 = 304,
	MX51_PAD_RESERVE62 = 305,
	MX51_PAD_RESERVE63 = 306,
	MX51_PAD_RESERVE64 = 307,
	MX51_PAD_RESERVE65 = 308,
	MX51_PAD_RESERVE66 = 309,
	MX51_PAD_RESERVE67 = 310,
	MX51_PAD_RESERVE68 = 311,
	MX51_PAD_RESERVE69 = 312,
	MX51_PAD_RESERVE70 = 313,
	MX51_PAD_RESERVE71 = 314,
	MX51_PAD_RESERVE72 = 315,
	MX51_PAD_RESERVE73 = 316,
	MX51_PAD_RESERVE74 = 317,
	MX51_PAD_RESERVE75 = 318,
	MX51_PAD_RESERVE76 = 319,
	MX51_PAD_RESERVE77 = 320,
	MX51_PAD_RESERVE78 = 321,
	MX51_PAD_RESERVE79 = 322,
	MX51_PAD_RESERVE80 = 323,
	MX51_PAD_RESERVE81 = 324,
	MX51_PAD_RESERVE82 = 325,
	MX51_PAD_RESERVE83 = 326,
	MX51_PAD_RESERVE84 = 327,
	MX51_PAD_RESERVE85 = 328,
	MX51_PAD_RESERVE86 = 329,
	MX51_PAD_RESERVE87 = 330,
	MX51_PAD_RESERVE88 = 331,
	MX51_PAD_RESERVE89 = 332,
	MX51_PAD_RESERVE90 = 333,
	MX51_PAD_RESERVE91 = 334,
	MX51_PAD_RESERVE92 = 335,
	MX51_PAD_RESERVE93 = 336,
	MX51_PAD_RESERVE94 = 337,
	MX51_PAD_RESERVE95 = 338,
	MX51_PAD_RESERVE96 = 339,
	MX51_PAD_RESERVE97 = 340,
	MX51_PAD_RESERVE98 = 341,
	MX51_PAD_RESERVE99 = 342,
	MX51_PAD_RESERVE100 = 343,
	MX51_PAD_RESERVE101 = 344,
	MX51_PAD_RESERVE102 = 345,
	MX51_PAD_RESERVE103 = 346,
	MX51_PAD_RESERVE104 = 347,
	MX51_PAD_RESERVE105 = 348,
	MX51_PAD_RESERVE106 = 349,
	MX51_PAD_RESERVE107 = 350,
	MX51_PAD_RESERVE108 = 351,
	MX51_PAD_RESERVE109 = 352,
	MX51_PAD_RESERVE110 = 353,
	MX51_PAD_RESERVE111 = 354,
	MX51_PAD_RESERVE112 = 355,
	MX51_PAD_RESERVE113 = 356,
	MX51_PAD_RESERVE114 = 357,
	MX51_PAD_RESERVE115 = 358,
	MX51_PAD_RESERVE116 = 359,
	MX51_PAD_RESERVE117 = 360,
	MX51_PAD_RESERVE118 = 361,
	MX51_PAD_RESERVE119 = 362,
	MX51_PAD_RESERVE120 = 363,
	MX51_PAD_RESERVE121 = 364,
	MX51_PAD_CSI1_PIXCLK = 365,
	MX51_PAD_CSI1_MCLK = 366,
};

enum imx53_pads {
	MX53_PAD_RESERVE0 = 0,
	MX53_PAD_RESERVE1 = 1,
	MX53_PAD_RESERVE2 = 2,
	MX53_PAD_RESERVE3 = 3,
	MX53_PAD_RESERVE4 = 4,
	MX53_PAD_RESERVE5 = 5,
	MX53_PAD_RESERVE6 = 6,
	MX53_PAD_RESERVE7 = 7,
	MX53_PAD_GPIO_19 = 8,
	MX53_PAD_KEY_COL0 = 9,
	MX53_PAD_KEY_ROW0 = 10,
	MX53_PAD_KEY_COL1 = 11,
	MX53_PAD_KEY_ROW1 = 12,
	MX53_PAD_KEY_COL2 = 13,
	MX53_PAD_KEY_ROW2 = 14,
	MX53_PAD_KEY_COL3 = 15,
	MX53_PAD_KEY_ROW3 = 16,
	MX53_PAD_KEY_COL4 = 17,
	MX53_PAD_KEY_ROW4 = 18,
	MX53_PAD_DI0_DISP_CLK = 19,
	MX53_PAD_DI0_PIN15 = 20,
	MX53_PAD_DI0_PIN2 = 21,
	MX53_PAD_DI0_PIN3 = 22,
	MX53_PAD_DI0_PIN4 = 23,
	MX53_PAD_DISP0_DAT0 = 24,
	MX53_PAD_DISP0_DAT1 = 25,
	MX53_PAD_DISP0_DAT2 = 26,
	MX53_PAD_DISP0_DAT3 = 27,
	MX53_PAD_DISP0_DAT4 = 28,
	MX53_PAD_DISP0_DAT5 = 29,
	MX53_PAD_DISP0_DAT6 = 30,
	MX53_PAD_DISP0_DAT7 = 31,
	MX53_PAD_DISP0_DAT8 = 32,
	MX53_PAD_DISP0_DAT9 = 33,
	MX53_PAD_DISP0_DAT10 = 34,
	MX53_PAD_DISP0_DAT11 = 35,
	MX53_PAD_DISP0_DAT12 = 36,
	MX53_PAD_DISP0_DAT13 = 37,
	MX53_PAD_DISP0_DAT14 = 38,
	MX53_PAD_DISP0_DAT15 = 39,
	MX53_PAD_DISP0_DAT16 = 40,
	MX53_PAD_DISP0_DAT17 = 41,
	MX53_PAD_DISP0_DAT18 = 42,
	MX53_PAD_DISP0_DAT19 = 43,
	MX53_PAD_DISP0_DAT20 = 44,
	MX53_PAD_DISP0_DAT21 = 45,
	MX53_PAD_DISP0_DAT22 = 46,
	MX53_PAD_DISP0_DAT23 = 47,
	MX53_PAD_CSI0_PIXCLK = 48,
	MX53_PAD_CSI0_MCLK = 49,
	MX53_PAD_CSI0_DATA_EN = 50,
	MX53_PAD_CSI0_VSYNC = 51,
	MX53_PAD_CSI0_DAT4 = 52,
	MX53_PAD_CSI0_DAT5 = 53,
	MX53_PAD_CSI0_DAT6 = 54,
	MX53_PAD_CSI0_DAT7 = 55,
	MX53_PAD_CSI0_DAT8 = 56,
	MX53_PAD_CSI0_DAT9 = 57,
	MX53_PAD_CSI0_DAT10 = 58,
	MX53_PAD_CSI0_DAT11 = 59,
	MX53_PAD_CSI0_DAT12 = 60,
	MX53_PAD_CSI0_DAT13 = 61,
	MX53_PAD_CSI0_DAT14 = 62,
	MX53_PAD_CSI0_DAT15 = 63,
	MX53_PAD_CSI0_DAT16 = 64,
	MX53_PAD_CSI0_DAT17 = 65,
	MX53_PAD_CSI0_DAT18 = 66,
	MX53_PAD_CSI0_DAT19 = 67,
	MX53_PAD_EIM_A25 = 68,
	MX53_PAD_EIM_EB2 = 69,
	MX53_PAD_EIM_D16 = 70,
	MX53_PAD_EIM_D17 = 71,
	MX53_PAD_EIM_D18 = 72,
	MX53_PAD_EIM_D19 = 73,
	MX53_PAD_EIM_D20 = 74,
	MX53_PAD_EIM_D21 = 75,
	MX53_PAD_EIM_D22 = 76,
	MX53_PAD_EIM_D23 = 77,
	MX53_PAD_EIM_EB3 = 78,
	MX53_PAD_EIM_D24 = 79,
	MX53_PAD_EIM_D25 = 80,
	MX53_PAD_EIM_D26 = 81,
	MX53_PAD_EIM_D27 = 82,
	MX53_PAD_EIM_D28 = 83,
	MX53_PAD_EIM_D29 = 84,
	MX53_PAD_EIM_D30 = 85,
	MX53_PAD_EIM_D31 = 86,
	MX53_PAD_EIM_A24 = 87,
	MX53_PAD_EIM_A23 = 88,
	MX53_PAD_EIM_A22 = 89,
	MX53_PAD_EIM_A21 = 90,
	MX53_PAD_EIM_A20 = 91,
	MX53_PAD_EIM_A19 = 92,
	MX53_PAD_EIM_A18 = 93,
	MX53_PAD_EIM_A17 = 94,
	MX53_PAD_EIM_A16 = 95,
	MX53_PAD_EIM_CS0 = 96,
	MX53_PAD_EIM_CS1 = 97,
	MX53_PAD_EIM_OE = 98,
	MX53_PAD_EIM_RW = 99,
	MX53_PAD_EIM_LBA = 100,
	MX53_PAD_EIM_EB0 = 101,
	MX53_PAD_EIM_EB1 = 102,
	MX53_PAD_EIM_DA0 = 103,
	MX53_PAD_EIM_DA1 = 104,
	MX53_PAD_EIM_DA2 = 105,
	MX53_PAD_EIM_DA3 = 106,
	MX53_PAD_EIM_DA4 = 107,
	MX53_PAD_EIM_DA5 = 108,
	MX53_PAD_EIM_DA6 = 109,
	MX53_PAD_EIM_DA7 = 110,
	MX53_PAD_EIM_DA8 = 111,
	MX53_PAD_EIM_DA9 = 112,
	MX53_PAD_EIM_DA10 = 113,
	MX53_PAD_EIM_DA11 = 114,
	MX53_PAD_EIM_DA12 = 115,
	MX53_PAD_EIM_DA13 = 116,
	MX53_PAD_EIM_DA14 = 117,
	MX53_PAD_EIM_DA15 = 118,
	MX53_PAD_NANDF_WE_B = 119,
	MX53_PAD_NANDF_RE_B = 120,
	MX53_PAD_EIM_WAIT = 121,
	MX53_PAD_RESERVE8 = 122,
	MX53_PAD_LVDS1_TX3_P = 123,
	MX53_PAD_LVDS1_TX2_P = 124,
	MX53_PAD_LVDS1_CLK_P = 125,
	MX53_PAD_LVDS1_TX1_P = 126,
	MX53_PAD_LVDS1_TX0_P = 127,
	MX53_PAD_LVDS0_TX3_P = 128,
	MX53_PAD_LVDS0_CLK_P = 129,
	MX53_PAD_LVDS0_TX2_P = 130,
	MX53_PAD_LVDS0_TX1_P = 131,
	MX53_PAD_LVDS0_TX0_P = 132,
	MX53_PAD_GPIO_10 = 133,
	MX53_PAD_GPIO_11 = 134,
	MX53_PAD_GPIO_12 = 135,
	MX53_PAD_GPIO_13 = 136,
	MX53_PAD_GPIO_14 = 137,
	MX53_PAD_NANDF_CLE = 138,
	MX53_PAD_NANDF_ALE = 139,
	MX53_PAD_NANDF_WP_B = 140,
	MX53_PAD_NANDF_RB0 = 141,
	MX53_PAD_NANDF_CS0 = 142,
	MX53_PAD_NANDF_CS1 = 143,
	MX53_PAD_NANDF_CS2 = 144,
	MX53_PAD_NANDF_CS3 = 145,
	MX53_PAD_FEC_MDIO = 146,
	MX53_PAD_FEC_REF_CLK = 147,
	MX53_PAD_FEC_RX_ER = 148,
	MX53_PAD_FEC_CRS_DV = 149,
	MX53_PAD_FEC_RXD1 = 150,
	MX53_PAD_FEC_RXD0 = 151,
	MX53_PAD_FEC_TX_EN = 152,
	MX53_PAD_FEC_TXD1 = 153,
	MX53_PAD_FEC_TXD0 = 154,
	MX53_PAD_FEC_MDC = 155,
	MX53_PAD_PATA_DIOW = 156,
	MX53_PAD_PATA_DMACK = 157,
	MX53_PAD_PATA_DMARQ = 158,
	MX53_PAD_PATA_BUFFER_EN = 159,
	MX53_PAD_PATA_INTRQ = 160,
	MX53_PAD_PATA_DIOR = 161,
	MX53_PAD_PATA_RESET_B = 162,
	MX53_PAD_PATA_IORDY = 163,
	MX53_PAD_PATA_DA_0 = 164,
	MX53_PAD_PATA_DA_1 = 165,
	MX53_PAD_PATA_DA_2 = 166,
	MX53_PAD_PATA_CS_0 = 167,
	MX53_PAD_PATA_CS_1 = 168,
	MX53_PAD_PATA_DATA0 = 169,
	MX53_PAD_PATA_DATA1 = 170,
	MX53_PAD_PATA_DATA2 = 171,
	MX53_PAD_PATA_DATA3 = 172,
	MX53_PAD_PATA_DATA4 = 173,
	MX53_PAD_PATA_DATA5 = 174,
	MX53_PAD_PATA_DATA6 = 175,
	MX53_PAD_PATA_DATA7 = 176,
	MX53_PAD_PATA_DATA8 = 177,
	MX53_PAD_PATA_DATA9 = 178,
	MX53_PAD_PATA_DATA10 = 179,
	MX53_PAD_PATA_DATA11 = 180,
	MX53_PAD_PATA_DATA12 = 181,
	MX53_PAD_PATA_DATA13 = 182,
	MX53_PAD_PATA_DATA14 = 183,
	MX53_PAD_PATA_DATA15 = 184,
	MX53_PAD_SD1_DATA0 = 185,
	MX53_PAD_SD1_DATA1 = 186,
	MX53_PAD_SD1_CMD = 187,
	MX53_PAD_SD1_DATA2 = 188,
	MX53_PAD_SD1_CLK = 189,
	MX53_PAD_SD1_DATA3 = 190,
	MX53_PAD_SD2_CLK = 191,
	MX53_PAD_SD2_CMD = 192,
	MX53_PAD_SD2_DATA3 = 193,
	MX53_PAD_SD2_DATA2 = 194,
	MX53_PAD_SD2_DATA1 = 195,
	MX53_PAD_SD2_DATA0 = 196,
	MX53_PAD_GPIO_0 = 197,
	MX53_PAD_GPIO_1 = 198,
	MX53_PAD_GPIO_9 = 199,
	MX53_PAD_GPIO_3 = 200,
	MX53_PAD_GPIO_6 = 201,
	MX53_PAD_GPIO_2 = 202,
	MX53_PAD_GPIO_4 = 203,
	MX53_PAD_GPIO_5 = 204,
	MX53_PAD_GPIO_7 = 205,
	MX53_PAD_GPIO_8 = 206,
	MX53_PAD_GPIO_16 = 207,
	MX53_PAD_GPIO_17 = 208,
	MX53_PAD_GPIO_18 = 209,
};

enum imx6q_pads {
	MX6Q_PAD_RESERVE0 = 0,
	MX6Q_PAD_RESERVE1 = 1,
	MX6Q_PAD_RESERVE2 = 2,
	MX6Q_PAD_RESERVE3 = 3,
	MX6Q_PAD_RESERVE4 = 4,
	MX6Q_PAD_RESERVE5 = 5,
	MX6Q_PAD_RESERVE6 = 6,
	MX6Q_PAD_RESERVE7 = 7,
	MX6Q_PAD_RESERVE8 = 8,
	MX6Q_PAD_RESERVE9 = 9,
	MX6Q_PAD_RESERVE10 = 10,
	MX6Q_PAD_RESERVE11 = 11,
	MX6Q_PAD_RESERVE12 = 12,
	MX6Q_PAD_RESERVE13 = 13,
	MX6Q_PAD_RESERVE14 = 14,
	MX6Q_PAD_RESERVE15 = 15,
	MX6Q_PAD_RESERVE16 = 16,
	MX6Q_PAD_RESERVE17 = 17,
	MX6Q_PAD_RESERVE18 = 18,
	MX6Q_PAD_SD2_DAT1 = 19,
	MX6Q_PAD_SD2_DAT2 = 20,
	MX6Q_PAD_SD2_DAT0 = 21,
	MX6Q_PAD_RGMII_TXC = 22,
	MX6Q_PAD_RGMII_TD0 = 23,
	MX6Q_PAD_RGMII_TD1 = 24,
	MX6Q_PAD_RGMII_TD2 = 25,
	MX6Q_PAD_RGMII_TD3 = 26,
	MX6Q_PAD_RGMII_RX_CTL = 27,
	MX6Q_PAD_RGMII_RD0 = 28,
	MX6Q_PAD_RGMII_TX_CTL = 29,
	MX6Q_PAD_RGMII_RD1 = 30,
	MX6Q_PAD_RGMII_RD2 = 31,
	MX6Q_PAD_RGMII_RD3 = 32,
	MX6Q_PAD_RGMII_RXC = 33,
	MX6Q_PAD_EIM_A25 = 34,
	MX6Q_PAD_EIM_EB2 = 35,
	MX6Q_PAD_EIM_D16 = 36,
	MX6Q_PAD_EIM_D17 = 37,
	MX6Q_PAD_EIM_D18 = 38,
	MX6Q_PAD_EIM_D19 = 39,
	MX6Q_PAD_EIM_D20 = 40,
	MX6Q_PAD_EIM_D21 = 41,
	MX6Q_PAD_EIM_D22 = 42,
	MX6Q_PAD_EIM_D23 = 43,
	MX6Q_PAD_EIM_EB3 = 44,
	MX6Q_PAD_EIM_D24 = 45,
	MX6Q_PAD_EIM_D25 = 46,
	MX6Q_PAD_EIM_D26 = 47,
	MX6Q_PAD_EIM_D27 = 48,
	MX6Q_PAD_EIM_D28 = 49,
	MX6Q_PAD_EIM_D29 = 50,
	MX6Q_PAD_EIM_D30 = 51,
	MX6Q_PAD_EIM_D31 = 52,
	MX6Q_PAD_EIM_A24 = 53,
	MX6Q_PAD_EIM_A23 = 54,
	MX6Q_PAD_EIM_A22 = 55,
	MX6Q_PAD_EIM_A21 = 56,
	MX6Q_PAD_EIM_A20 = 57,
	MX6Q_PAD_EIM_A19 = 58,
	MX6Q_PAD_EIM_A18 = 59,
	MX6Q_PAD_EIM_A17 = 60,
	MX6Q_PAD_EIM_A16 = 61,
	MX6Q_PAD_EIM_CS0 = 62,
	MX6Q_PAD_EIM_CS1 = 63,
	MX6Q_PAD_EIM_OE = 64,
	MX6Q_PAD_EIM_RW = 65,
	MX6Q_PAD_EIM_LBA = 66,
	MX6Q_PAD_EIM_EB0 = 67,
	MX6Q_PAD_EIM_EB1 = 68,
	MX6Q_PAD_EIM_DA0 = 69,
	MX6Q_PAD_EIM_DA1 = 70,
	MX6Q_PAD_EIM_DA2 = 71,
	MX6Q_PAD_EIM_DA3 = 72,
	MX6Q_PAD_EIM_DA4 = 73,
	MX6Q_PAD_EIM_DA5 = 74,
	MX6Q_PAD_EIM_DA6 = 75,
	MX6Q_PAD_EIM_DA7 = 76,
	MX6Q_PAD_EIM_DA8 = 77,
	MX6Q_PAD_EIM_DA9 = 78,
	MX6Q_PAD_EIM_DA10 = 79,
	MX6Q_PAD_EIM_DA11 = 80,
	MX6Q_PAD_EIM_DA12 = 81,
	MX6Q_PAD_EIM_DA13 = 82,
	MX6Q_PAD_EIM_DA14 = 83,
	MX6Q_PAD_EIM_DA15 = 84,
	MX6Q_PAD_EIM_WAIT = 85,
	MX6Q_PAD_EIM_BCLK = 86,
	MX6Q_PAD_DI0_DISP_CLK = 87,
	MX6Q_PAD_DI0_PIN15 = 88,
	MX6Q_PAD_DI0_PIN2 = 89,
	MX6Q_PAD_DI0_PIN3 = 90,
	MX6Q_PAD_DI0_PIN4 = 91,
	MX6Q_PAD_DISP0_DAT0 = 92,
	MX6Q_PAD_DISP0_DAT1 = 93,
	MX6Q_PAD_DISP0_DAT2 = 94,
	MX6Q_PAD_DISP0_DAT3 = 95,
	MX6Q_PAD_DISP0_DAT4 = 96,
	MX6Q_PAD_DISP0_DAT5 = 97,
	MX6Q_PAD_DISP0_DAT6 = 98,
	MX6Q_PAD_DISP0_DAT7 = 99,
	MX6Q_PAD_DISP0_DAT8 = 100,
	MX6Q_PAD_DISP0_DAT9 = 101,
	MX6Q_PAD_DISP0_DAT10 = 102,
	MX6Q_PAD_DISP0_DAT11 = 103,
	MX6Q_PAD_DISP0_DAT12 = 104,
	MX6Q_PAD_DISP0_DAT13 = 105,
	MX6Q_PAD_DISP0_DAT14 = 106,
	MX6Q_PAD_DISP0_DAT15 = 107,
	MX6Q_PAD_DISP0_DAT16 = 108,
	MX6Q_PAD_DISP0_DAT17 = 109,
	MX6Q_PAD_DISP0_DAT18 = 110,
	MX6Q_PAD_DISP0_DAT19 = 111,
	MX6Q_PAD_DISP0_DAT20 = 112,
	MX6Q_PAD_DISP0_DAT21 = 113,
	MX6Q_PAD_DISP0_DAT22 = 114,
	MX6Q_PAD_DISP0_DAT23 = 115,
	MX6Q_PAD_ENET_MDIO = 116,
	MX6Q_PAD_ENET_REF_CLK = 117,
	MX6Q_PAD_ENET_RX_ER = 118,
	MX6Q_PAD_ENET_CRS_DV = 119,
	MX6Q_PAD_ENET_RXD1 = 120,
	MX6Q_PAD_ENET_RXD0 = 121,
	MX6Q_PAD_ENET_TX_EN = 122,
	MX6Q_PAD_ENET_TXD1 = 123,
	MX6Q_PAD_ENET_TXD0 = 124,
	MX6Q_PAD_ENET_MDC = 125,
	MX6Q_PAD_KEY_COL0 = 126,
	MX6Q_PAD_KEY_ROW0 = 127,
	MX6Q_PAD_KEY_COL1 = 128,
	MX6Q_PAD_KEY_ROW1 = 129,
	MX6Q_PAD_KEY_COL2 = 130,
	MX6Q_PAD_KEY_ROW2 = 131,
	MX6Q_PAD_KEY_COL3 = 132,
	MX6Q_PAD_KEY_ROW3 = 133,
	MX6Q_PAD_KEY_COL4 = 134,
	MX6Q_PAD_KEY_ROW4 = 135,
	MX6Q_PAD_GPIO_0 = 136,
	MX6Q_PAD_GPIO_1 = 137,
	MX6Q_PAD_GPIO_9 = 138,
	MX6Q_PAD_GPIO_3 = 139,
	MX6Q_PAD_GPIO_6 = 140,
	MX6Q_PAD_GPIO_2 = 141,
	MX6Q_PAD_GPIO_4 = 142,
	MX6Q_PAD_GPIO_5 = 143,
	MX6Q_PAD_GPIO_7 = 144,
	MX6Q_PAD_GPIO_8 = 145,
	MX6Q_PAD_GPIO_16 = 146,
	MX6Q_PAD_GPIO_17 = 147,
	MX6Q_PAD_GPIO_18 = 148,
	MX6Q_PAD_GPIO_19 = 149,
	MX6Q_PAD_CSI0_PIXCLK = 150,
	MX6Q_PAD_CSI0_MCLK = 151,
	MX6Q_PAD_CSI0_DATA_EN = 152,
	MX6Q_PAD_CSI0_VSYNC = 153,
	MX6Q_PAD_CSI0_DAT4 = 154,
	MX6Q_PAD_CSI0_DAT5 = 155,
	MX6Q_PAD_CSI0_DAT6 = 156,
	MX6Q_PAD_CSI0_DAT7 = 157,
	MX6Q_PAD_CSI0_DAT8 = 158,
	MX6Q_PAD_CSI0_DAT9 = 159,
	MX6Q_PAD_CSI0_DAT10 = 160,
	MX6Q_PAD_CSI0_DAT11 = 161,
	MX6Q_PAD_CSI0_DAT12 = 162,
	MX6Q_PAD_CSI0_DAT13 = 163,
	MX6Q_PAD_CSI0_DAT14 = 164,
	MX6Q_PAD_CSI0_DAT15 = 165,
	MX6Q_PAD_CSI0_DAT16 = 166,
	MX6Q_PAD_CSI0_DAT17 = 167,
	MX6Q_PAD_CSI0_DAT18 = 168,
	MX6Q_PAD_CSI0_DAT19 = 169,
	MX6Q_PAD_SD3_DAT7 = 170,
	MX6Q_PAD_SD3_DAT6 = 171,
	MX6Q_PAD_SD3_DAT5 = 172,
	MX6Q_PAD_SD3_DAT4 = 173,
	MX6Q_PAD_SD3_CMD = 174,
	MX6Q_PAD_SD3_CLK = 175,
	MX6Q_PAD_SD3_DAT0 = 176,
	MX6Q_PAD_SD3_DAT1 = 177,
	MX6Q_PAD_SD3_DAT2 = 178,
	MX6Q_PAD_SD3_DAT3 = 179,
	MX6Q_PAD_SD3_RST = 180,
	MX6Q_PAD_NANDF_CLE = 181,
	MX6Q_PAD_NANDF_ALE = 182,
	MX6Q_PAD_NANDF_WP_B = 183,
	MX6Q_PAD_NANDF_RB0 = 184,
	MX6Q_PAD_NANDF_CS0 = 185,
	MX6Q_PAD_NANDF_CS1 = 186,
	MX6Q_PAD_NANDF_CS2 = 187,
	MX6Q_PAD_NANDF_CS3 = 188,
	MX6Q_PAD_SD4_CMD = 189,
	MX6Q_PAD_SD4_CLK = 190,
	MX6Q_PAD_NANDF_D0 = 191,
	MX6Q_PAD_NANDF_D1 = 192,
	MX6Q_PAD_NANDF_D2 = 193,
	MX6Q_PAD_NANDF_D3 = 194,
	MX6Q_PAD_NANDF_D4 = 195,
	MX6Q_PAD_NANDF_D5 = 196,
	MX6Q_PAD_NANDF_D6 = 197,
	MX6Q_PAD_NANDF_D7 = 198,
	MX6Q_PAD_SD4_DAT0 = 199,
	MX6Q_PAD_SD4_DAT1 = 200,
	MX6Q_PAD_SD4_DAT2 = 201,
	MX6Q_PAD_SD4_DAT3 = 202,
	MX6Q_PAD_SD4_DAT4 = 203,
	MX6Q_PAD_SD4_DAT5 = 204,
	MX6Q_PAD_SD4_DAT6 = 205,
	MX6Q_PAD_SD4_DAT7 = 206,
	MX6Q_PAD_SD1_DAT1 = 207,
	MX6Q_PAD_SD1_DAT0 = 208,
	MX6Q_PAD_SD1_DAT3 = 209,
	MX6Q_PAD_SD1_CMD = 210,
	MX6Q_PAD_SD1_DAT2 = 211,
	MX6Q_PAD_SD1_CLK = 212,
	MX6Q_PAD_SD2_CLK = 213,
	MX6Q_PAD_SD2_CMD = 214,
	MX6Q_PAD_SD2_DAT3 = 215,
};

enum imx6dl_pads {
	MX6DL_PAD_RESERVE0 = 0,
	MX6DL_PAD_RESERVE1 = 1,
	MX6DL_PAD_RESERVE2 = 2,
	MX6DL_PAD_RESERVE3 = 3,
	MX6DL_PAD_RESERVE4 = 4,
	MX6DL_PAD_RESERVE5 = 5,
	MX6DL_PAD_RESERVE6 = 6,
	MX6DL_PAD_RESERVE7 = 7,
	MX6DL_PAD_RESERVE8 = 8,
	MX6DL_PAD_RESERVE9 = 9,
	MX6DL_PAD_RESERVE10 = 10,
	MX6DL_PAD_RESERVE11 = 11,
	MX6DL_PAD_RESERVE12 = 12,
	MX6DL_PAD_RESERVE13 = 13,
	MX6DL_PAD_RESERVE14 = 14,
	MX6DL_PAD_RESERVE15 = 15,
	MX6DL_PAD_RESERVE16 = 16,
	MX6DL_PAD_RESERVE17 = 17,
	MX6DL_PAD_RESERVE18 = 18,
	MX6DL_PAD_CSI0_DAT10 = 19,
	MX6DL_PAD_CSI0_DAT11 = 20,
	MX6DL_PAD_CSI0_DAT12 = 21,
	MX6DL_PAD_CSI0_DAT13 = 22,
	MX6DL_PAD_CSI0_DAT14 = 23,
	MX6DL_PAD_CSI0_DAT15 = 24,
	MX6DL_PAD_CSI0_DAT16 = 25,
	MX6DL_PAD_CSI0_DAT17 = 26,
	MX6DL_PAD_CSI0_DAT18 = 27,
	MX6DL_PAD_CSI0_DAT19 = 28,
	MX6DL_PAD_CSI0_DAT4 = 29,
	MX6DL_PAD_CSI0_DAT5 = 30,
	MX6DL_PAD_CSI0_DAT6 = 31,
	MX6DL_PAD_CSI0_DAT7 = 32,
	MX6DL_PAD_CSI0_DAT8 = 33,
	MX6DL_PAD_CSI0_DAT9 = 34,
	MX6DL_PAD_CSI0_DATA_EN = 35,
	MX6DL_PAD_CSI0_MCLK = 36,
	MX6DL_PAD_CSI0_PIXCLK = 37,
	MX6DL_PAD_CSI0_VSYNC = 38,
	MX6DL_PAD_DI0_DISP_CLK = 39,
	MX6DL_PAD_DI0_PIN15 = 40,
	MX6DL_PAD_DI0_PIN2 = 41,
	MX6DL_PAD_DI0_PIN3 = 42,
	MX6DL_PAD_DI0_PIN4 = 43,
	MX6DL_PAD_DISP0_DAT0 = 44,
	MX6DL_PAD_DISP0_DAT1 = 45,
	MX6DL_PAD_DISP0_DAT10 = 46,
	MX6DL_PAD_DISP0_DAT11 = 47,
	MX6DL_PAD_DISP0_DAT12 = 48,
	MX6DL_PAD_DISP0_DAT13 = 49,
	MX6DL_PAD_DISP0_DAT14 = 50,
	MX6DL_PAD_DISP0_DAT15 = 51,
	MX6DL_PAD_DISP0_DAT16 = 52,
	MX6DL_PAD_DISP0_DAT17 = 53,
	MX6DL_PAD_DISP0_DAT18 = 54,
	MX6DL_PAD_DISP0_DAT19 = 55,
	MX6DL_PAD_DISP0_DAT2 = 56,
	MX6DL_PAD_DISP0_DAT20 = 57,
	MX6DL_PAD_DISP0_DAT21 = 58,
	MX6DL_PAD_DISP0_DAT22 = 59,
	MX6DL_PAD_DISP0_DAT23 = 60,
	MX6DL_PAD_DISP0_DAT3 = 61,
	MX6DL_PAD_DISP0_DAT4 = 62,
	MX6DL_PAD_DISP0_DAT5 = 63,
	MX6DL_PAD_DISP0_DAT6 = 64,
	MX6DL_PAD_DISP0_DAT7 = 65,
	MX6DL_PAD_DISP0_DAT8 = 66,
	MX6DL_PAD_DISP0_DAT9 = 67,
	MX6DL_PAD_EIM_A16 = 68,
	MX6DL_PAD_EIM_A17 = 69,
	MX6DL_PAD_EIM_A18 = 70,
	MX6DL_PAD_EIM_A19 = 71,
	MX6DL_PAD_EIM_A20 = 72,
	MX6DL_PAD_EIM_A21 = 73,
	MX6DL_PAD_EIM_A22 = 74,
	MX6DL_PAD_EIM_A23 = 75,
	MX6DL_PAD_EIM_A24 = 76,
	MX6DL_PAD_EIM_A25 = 77,
	MX6DL_PAD_EIM_BCLK = 78,
	MX6DL_PAD_EIM_CS0 = 79,
	MX6DL_PAD_EIM_CS1 = 80,
	MX6DL_PAD_EIM_D16 = 81,
	MX6DL_PAD_EIM_D17 = 82,
	MX6DL_PAD_EIM_D18 = 83,
	MX6DL_PAD_EIM_D19 = 84,
	MX6DL_PAD_EIM_D20 = 85,
	MX6DL_PAD_EIM_D21 = 86,
	MX6DL_PAD_EIM_D22 = 87,
	MX6DL_PAD_EIM_D23 = 88,
	MX6DL_PAD_EIM_D24 = 89,
	MX6DL_PAD_EIM_D25 = 90,
	MX6DL_PAD_EIM_D26 = 91,
	MX6DL_PAD_EIM_D27 = 92,
	MX6DL_PAD_EIM_D28 = 93,
	MX6DL_PAD_EIM_D29 = 94,
	MX6DL_PAD_EIM_D30 = 95,
	MX6DL_PAD_EIM_D31 = 96,
	MX6DL_PAD_EIM_DA0 = 97,
	MX6DL_PAD_EIM_DA1 = 98,
	MX6DL_PAD_EIM_DA10 = 99,
	MX6DL_PAD_EIM_DA11 = 100,
	MX6DL_PAD_EIM_DA12 = 101,
	MX6DL_PAD_EIM_DA13 = 102,
	MX6DL_PAD_EIM_DA14 = 103,
	MX6DL_PAD_EIM_DA15 = 104,
	MX6DL_PAD_EIM_DA2 = 105,
	MX6DL_PAD_EIM_DA3 = 106,
	MX6DL_PAD_EIM_DA4 = 107,
	MX6DL_PAD_EIM_DA5 = 108,
	MX6DL_PAD_EIM_DA6 = 109,
	MX6DL_PAD_EIM_DA7 = 110,
	MX6DL_PAD_EIM_DA8 = 111,
	MX6DL_PAD_EIM_DA9 = 112,
	MX6DL_PAD_EIM_EB0 = 113,
	MX6DL_PAD_EIM_EB1 = 114,
	MX6DL_PAD_EIM_EB2 = 115,
	MX6DL_PAD_EIM_EB3 = 116,
	MX6DL_PAD_EIM_LBA = 117,
	MX6DL_PAD_EIM_OE = 118,
	MX6DL_PAD_EIM_RW = 119,
	MX6DL_PAD_EIM_WAIT = 120,
	MX6DL_PAD_ENET_CRS_DV = 121,
	MX6DL_PAD_ENET_MDC = 122,
	MX6DL_PAD_ENET_MDIO = 123,
	MX6DL_PAD_ENET_REF_CLK = 124,
	MX6DL_PAD_ENET_RX_ER = 125,
	MX6DL_PAD_ENET_RXD0 = 126,
	MX6DL_PAD_ENET_RXD1 = 127,
	MX6DL_PAD_ENET_TX_EN = 128,
	MX6DL_PAD_ENET_TXD0 = 129,
	MX6DL_PAD_ENET_TXD1 = 130,
	MX6DL_PAD_GPIO_0 = 131,
	MX6DL_PAD_GPIO_1 = 132,
	MX6DL_PAD_GPIO_16 = 133,
	MX6DL_PAD_GPIO_17 = 134,
	MX6DL_PAD_GPIO_18 = 135,
	MX6DL_PAD_GPIO_19 = 136,
	MX6DL_PAD_GPIO_2 = 137,
	MX6DL_PAD_GPIO_3 = 138,
	MX6DL_PAD_GPIO_4 = 139,
	MX6DL_PAD_GPIO_5 = 140,
	MX6DL_PAD_GPIO_6 = 141,
	MX6DL_PAD_GPIO_7 = 142,
	MX6DL_PAD_GPIO_8 = 143,
	MX6DL_PAD_GPIO_9 = 144,
	MX6DL_PAD_KEY_COL0 = 145,
	MX6DL_PAD_KEY_COL1 = 146,
	MX6DL_PAD_KEY_COL2 = 147,
	MX6DL_PAD_KEY_COL3 = 148,
	MX6DL_PAD_KEY_COL4 = 149,
	MX6DL_PAD_KEY_ROW0 = 150,
	MX6DL_PAD_KEY_ROW1 = 151,
	MX6DL_PAD_KEY_ROW2 = 152,
	MX6DL_PAD_KEY_ROW3 = 153,
	MX6DL_PAD_KEY_ROW4 = 154,
	MX6DL_PAD_NANDF_ALE = 155,
	MX6DL_PAD_NANDF_CLE = 156,
	MX6DL_PAD_NANDF_CS0 = 157,
	MX6DL_PAD_NANDF_CS1 = 158,
	MX6DL_PAD_NANDF_CS2 = 159,
	MX6DL_PAD_NANDF_CS3 = 160,
	MX6DL_PAD_NANDF_D0 = 161,
	MX6DL_PAD_NANDF_D1 = 162,
	MX6DL_PAD_NANDF_D2 = 163,
	MX6DL_PAD_NANDF_D3 = 164,
	MX6DL_PAD_NANDF_D4 = 165,
	MX6DL_PAD_NANDF_D5 = 166,
	MX6DL_PAD_NANDF_D6 = 167,
	MX6DL_PAD_NANDF_D7 = 168,
	MX6DL_PAD_NANDF_RB0 = 169,
	MX6DL_PAD_NANDF_WP_B = 170,
	MX6DL_PAD_RGMII_RD0 = 171,
	MX6DL_PAD_RGMII_RD1 = 172,
	MX6DL_PAD_RGMII_RD2 = 173,
	MX6DL_PAD_RGMII_RD3 = 174,
	MX6DL_PAD_RGMII_RX_CTL = 175,
	MX6DL_PAD_RGMII_RXC = 176,
	MX6DL_PAD_RGMII_TD0 = 177,
	MX6DL_PAD_RGMII_TD1 = 178,
	MX6DL_PAD_RGMII_TD2 = 179,
	MX6DL_PAD_RGMII_TD3 = 180,
	MX6DL_PAD_RGMII_TX_CTL = 181,
	MX6DL_PAD_RGMII_TXC = 182,
	MX6DL_PAD_SD1_CLK = 183,
	MX6DL_PAD_SD1_CMD = 184,
	MX6DL_PAD_SD1_DAT0 = 185,
	MX6DL_PAD_SD1_DAT1 = 186,
	MX6DL_PAD_SD1_DAT2 = 187,
	MX6DL_PAD_SD1_DAT3 = 188,
	MX6DL_PAD_SD2_CLK = 189,
	MX6DL_PAD_SD2_CMD = 190,
	MX6DL_PAD_SD2_DAT0 = 191,
	MX6DL_PAD_SD2_DAT1 = 192,
	MX6DL_PAD_SD2_DAT2 = 193,
	MX6DL_PAD_SD2_DAT3 = 194,
	MX6DL_PAD_SD3_CLK = 195,
	MX6DL_PAD_SD3_CMD = 196,
	MX6DL_PAD_SD3_DAT0 = 197,
	MX6DL_PAD_SD3_DAT1 = 198,
	MX6DL_PAD_SD3_DAT2 = 199,
	MX6DL_PAD_SD3_DAT3 = 200,
	MX6DL_PAD_SD3_DAT4 = 201,
	MX6DL_PAD_SD3_DAT5 = 202,
	MX6DL_PAD_SD3_DAT6 = 203,
	MX6DL_PAD_SD3_DAT7 = 204,
	MX6DL_PAD_SD3_RST = 205,
	MX6DL_PAD_SD4_CLK = 206,
	MX6DL_PAD_SD4_CMD = 207,
	MX6DL_PAD_SD4_DAT0 = 208,
	MX6DL_PAD_SD4_DAT1 = 209,
	MX6DL_PAD_SD4_DAT2 = 210,
	MX6DL_PAD_SD4_DAT3 = 211,
	MX6DL_PAD_SD4_DAT4 = 212,
	MX6DL_PAD_SD4_DAT5 = 213,
	MX6DL_PAD_SD4_DAT6 = 214,
	MX6DL_PAD_SD4_DAT7 = 215,
};

enum imx6sl_pads {
	MX6SL_PAD_RESERVE0 = 0,
	MX6SL_PAD_RESERVE1 = 1,
	MX6SL_PAD_RESERVE2 = 2,
	MX6SL_PAD_RESERVE3 = 3,
	MX6SL_PAD_RESERVE4 = 4,
	MX6SL_PAD_RESERVE5 = 5,
	MX6SL_PAD_RESERVE6 = 6,
	MX6SL_PAD_RESERVE7 = 7,
	MX6SL_PAD_RESERVE8 = 8,
	MX6SL_PAD_RESERVE9 = 9,
	MX6SL_PAD_RESERVE10 = 10,
	MX6SL_PAD_RESERVE11 = 11,
	MX6SL_PAD_RESERVE12 = 12,
	MX6SL_PAD_RESERVE13 = 13,
	MX6SL_PAD_RESERVE14 = 14,
	MX6SL_PAD_RESERVE15 = 15,
	MX6SL_PAD_RESERVE16 = 16,
	MX6SL_PAD_RESERVE17 = 17,
	MX6SL_PAD_RESERVE18 = 18,
	MX6SL_PAD_AUD_MCLK = 19,
	MX6SL_PAD_AUD_RXC = 20,
	MX6SL_PAD_AUD_RXD = 21,
	MX6SL_PAD_AUD_RXFS = 22,
	MX6SL_PAD_AUD_TXC = 23,
	MX6SL_PAD_AUD_TXD = 24,
	MX6SL_PAD_AUD_TXFS = 25,
	MX6SL_PAD_ECSPI1_MISO = 26,
	MX6SL_PAD_ECSPI1_MOSI = 27,
	MX6SL_PAD_ECSPI1_SCLK = 28,
	MX6SL_PAD_ECSPI1_SS0 = 29,
	MX6SL_PAD_ECSPI2_MISO = 30,
	MX6SL_PAD_ECSPI2_MOSI = 31,
	MX6SL_PAD_ECSPI2_SCLK = 32,
	MX6SL_PAD_ECSPI2_SS0 = 33,
	MX6SL_PAD_EPDC_BDR0 = 34,
	MX6SL_PAD_EPDC_BDR1 = 35,
	MX6SL_PAD_EPDC_D0 = 36,
	MX6SL_PAD_EPDC_D1 = 37,
	MX6SL_PAD_EPDC_D10 = 38,
	MX6SL_PAD_EPDC_D11 = 39,
	MX6SL_PAD_EPDC_D12 = 40,
	MX6SL_PAD_EPDC_D13 = 41,
	MX6SL_PAD_EPDC_D14 = 42,
	MX6SL_PAD_EPDC_D15 = 43,
	MX6SL_PAD_EPDC_D2 = 44,
	MX6SL_PAD_EPDC_D3 = 45,
	MX6SL_PAD_EPDC_D4 = 46,
	MX6SL_PAD_EPDC_D5 = 47,
	MX6SL_PAD_EPDC_D6 = 48,
	MX6SL_PAD_EPDC_D7 = 49,
	MX6SL_PAD_EPDC_D8 = 50,
	MX6SL_PAD_EPDC_D9 = 51,
	MX6SL_PAD_EPDC_GDCLK = 52,
	MX6SL_PAD_EPDC_GDOE = 53,
	MX6SL_PAD_EPDC_GDRL = 54,
	MX6SL_PAD_EPDC_GDSP = 55,
	MX6SL_PAD_EPDC_PWRCOM = 56,
	MX6SL_PAD_EPDC_PWRCTRL0 = 57,
	MX6SL_PAD_EPDC_PWRCTRL1 = 58,
	MX6SL_PAD_EPDC_PWRCTRL2 = 59,
	MX6SL_PAD_EPDC_PWRCTRL3 = 60,
	MX6SL_PAD_EPDC_PWRINT = 61,
	MX6SL_PAD_EPDC_PWRSTAT = 62,
	MX6SL_PAD_EPDC_PWRWAKEUP = 63,
	MX6SL_PAD_EPDC_SDCE0 = 64,
	MX6SL_PAD_EPDC_SDCE1 = 65,
	MX6SL_PAD_EPDC_SDCE2 = 66,
	MX6SL_PAD_EPDC_SDCE3 = 67,
	MX6SL_PAD_EPDC_SDCLK = 68,
	MX6SL_PAD_EPDC_SDLE = 69,
	MX6SL_PAD_EPDC_SDOE = 70,
	MX6SL_PAD_EPDC_SDSHR = 71,
	MX6SL_PAD_EPDC_VCOM0 = 72,
	MX6SL_PAD_EPDC_VCOM1 = 73,
	MX6SL_PAD_FEC_CRS_DV = 74,
	MX6SL_PAD_FEC_MDC = 75,
	MX6SL_PAD_FEC_MDIO = 76,
	MX6SL_PAD_FEC_REF_CLK = 77,
	MX6SL_PAD_FEC_RX_ER = 78,
	MX6SL_PAD_FEC_RXD0 = 79,
	MX6SL_PAD_FEC_RXD1 = 80,
	MX6SL_PAD_FEC_TX_CLK = 81,
	MX6SL_PAD_FEC_TX_EN = 82,
	MX6SL_PAD_FEC_TXD0 = 83,
	MX6SL_PAD_FEC_TXD1 = 84,
	MX6SL_PAD_HSIC_DAT = 85,
	MX6SL_PAD_HSIC_STROBE = 86,
	MX6SL_PAD_I2C1_SCL = 87,
	MX6SL_PAD_I2C1_SDA = 88,
	MX6SL_PAD_I2C2_SCL = 89,
	MX6SL_PAD_I2C2_SDA = 90,
	MX6SL_PAD_KEY_COL0 = 91,
	MX6SL_PAD_KEY_COL1 = 92,
	MX6SL_PAD_KEY_COL2 = 93,
	MX6SL_PAD_KEY_COL3 = 94,
	MX6SL_PAD_KEY_COL4 = 95,
	MX6SL_PAD_KEY_COL5 = 96,
	MX6SL_PAD_KEY_COL6 = 97,
	MX6SL_PAD_KEY_COL7 = 98,
	MX6SL_PAD_KEY_ROW0 = 99,
	MX6SL_PAD_KEY_ROW1 = 100,
	MX6SL_PAD_KEY_ROW2 = 101,
	MX6SL_PAD_KEY_ROW3 = 102,
	MX6SL_PAD_KEY_ROW4 = 103,
	MX6SL_PAD_KEY_ROW5 = 104,
	MX6SL_PAD_KEY_ROW6 = 105,
	MX6SL_PAD_KEY_ROW7 = 106,
	MX6SL_PAD_LCD_CLK = 107,
	MX6SL_PAD_LCD_DAT0 = 108,
	MX6SL_PAD_LCD_DAT1 = 109,
	MX6SL_PAD_LCD_DAT10 = 110,
	MX6SL_PAD_LCD_DAT11 = 111,
	MX6SL_PAD_LCD_DAT12 = 112,
	MX6SL_PAD_LCD_DAT13 = 113,
	MX6SL_PAD_LCD_DAT14 = 114,
	MX6SL_PAD_LCD_DAT15 = 115,
	MX6SL_PAD_LCD_DAT16 = 116,
	MX6SL_PAD_LCD_DAT17 = 117,
	MX6SL_PAD_LCD_DAT18 = 118,
	MX6SL_PAD_LCD_DAT19 = 119,
	MX6SL_PAD_LCD_DAT2 = 120,
	MX6SL_PAD_LCD_DAT20 = 121,
	MX6SL_PAD_LCD_DAT21 = 122,
	MX6SL_PAD_LCD_DAT22 = 123,
	MX6SL_PAD_LCD_DAT23 = 124,
	MX6SL_PAD_LCD_DAT3 = 125,
	MX6SL_PAD_LCD_DAT4 = 126,
	MX6SL_PAD_LCD_DAT5 = 127,
	MX6SL_PAD_LCD_DAT6 = 128,
	MX6SL_PAD_LCD_DAT7 = 129,
	MX6SL_PAD_LCD_DAT8 = 130,
	MX6SL_PAD_LCD_DAT9 = 131,
	MX6SL_PAD_LCD_ENABLE = 132,
	MX6SL_PAD_LCD_HSYNC = 133,
	MX6SL_PAD_LCD_RESET = 134,
	MX6SL_PAD_LCD_VSYNC = 135,
	MX6SL_PAD_PWM1 = 136,
	MX6SL_PAD_REF_CLK_24M = 137,
	MX6SL_PAD_REF_CLK_32K = 138,
	MX6SL_PAD_SD1_CLK = 139,
	MX6SL_PAD_SD1_CMD = 140,
	MX6SL_PAD_SD1_DAT0 = 141,
	MX6SL_PAD_SD1_DAT1 = 142,
	MX6SL_PAD_SD1_DAT2 = 143,
	MX6SL_PAD_SD1_DAT3 = 144,
	MX6SL_PAD_SD1_DAT4 = 145,
	MX6SL_PAD_SD1_DAT5 = 146,
	MX6SL_PAD_SD1_DAT6 = 147,
	MX6SL_PAD_SD1_DAT7 = 148,
	MX6SL_PAD_SD2_CLK = 149,
	MX6SL_PAD_SD2_CMD = 150,
	MX6SL_PAD_SD2_DAT0 = 151,
	MX6SL_PAD_SD2_DAT1 = 152,
	MX6SL_PAD_SD2_DAT2 = 153,
	MX6SL_PAD_SD2_DAT3 = 154,
	MX6SL_PAD_SD2_DAT4 = 155,
	MX6SL_PAD_SD2_DAT5 = 156,
	MX6SL_PAD_SD2_DAT6 = 157,
	MX6SL_PAD_SD2_DAT7 = 158,
	MX6SL_PAD_SD2_RST = 159,
	MX6SL_PAD_SD3_CLK = 160,
	MX6SL_PAD_SD3_CMD = 161,
	MX6SL_PAD_SD3_DAT0 = 162,
	MX6SL_PAD_SD3_DAT1 = 163,
	MX6SL_PAD_SD3_DAT2 = 164,
	MX6SL_PAD_SD3_DAT3 = 165,
	MX6SL_PAD_UART1_RXD = 166,
	MX6SL_PAD_UART1_TXD = 167,
	MX6SL_PAD_WDOG_B = 168,
};

enum imx6sx_pads {
	MX6Sx_PAD_RESERVE0 = 0,
	MX6Sx_PAD_RESERVE1 = 1,
	MX6Sx_PAD_RESERVE2 = 2,
	MX6Sx_PAD_RESERVE3 = 3,
	MX6Sx_PAD_RESERVE4 = 4,
	MX6SX_PAD_GPIO1_IO00 = 5,
	MX6SX_PAD_GPIO1_IO01 = 6,
	MX6SX_PAD_GPIO1_IO02 = 7,
	MX6SX_PAD_GPIO1_IO03 = 8,
	MX6SX_PAD_GPIO1_IO04 = 9,
	MX6SX_PAD_GPIO1_IO05 = 10,
	MX6SX_PAD_GPIO1_IO06 = 11,
	MX6SX_PAD_GPIO1_IO07 = 12,
	MX6SX_PAD_GPIO1_IO08 = 13,
	MX6SX_PAD_GPIO1_IO09 = 14,
	MX6SX_PAD_GPIO1_IO10 = 15,
	MX6SX_PAD_GPIO1_IO11 = 16,
	MX6SX_PAD_GPIO1_IO12 = 17,
	MX6SX_PAD_GPIO1_IO13 = 18,
	MX6SX_PAD_CSI_DATA00 = 19,
	MX6SX_PAD_CSI_DATA01 = 20,
	MX6SX_PAD_CSI_DATA02 = 21,
	MX6SX_PAD_CSI_DATA03 = 22,
	MX6SX_PAD_CSI_DATA04 = 23,
	MX6SX_PAD_CSI_DATA05 = 24,
	MX6SX_PAD_CSI_DATA06 = 25,
	MX6SX_PAD_CSI_DATA07 = 26,
	MX6SX_PAD_CSI_HSYNC = 27,
	MX6SX_PAD_CSI_MCLK = 28,
	MX6SX_PAD_CSI_PIXCLK = 29,
	MX6SX_PAD_CSI_VSYNC = 30,
	MX6SX_PAD_ENET1_COL = 31,
	MX6SX_PAD_ENET1_CRS = 32,
	MX6SX_PAD_ENET1_MDC = 33,
	MX6SX_PAD_ENET1_MDIO = 34,
	MX6SX_PAD_ENET1_RX_CLK = 35,
	MX6SX_PAD_ENET1_TX_CLK = 36,
	MX6SX_PAD_ENET2_COL = 37,
	MX6SX_PAD_ENET2_CRS = 38,
	MX6SX_PAD_ENET2_RX_CLK = 39,
	MX6SX_PAD_ENET2_TX_CLK = 40,
	MX6SX_PAD_KEY_COL0 = 41,
	MX6SX_PAD_KEY_COL1 = 42,
	MX6SX_PAD_KEY_COL2 = 43,
	MX6SX_PAD_KEY_COL3 = 44,
	MX6SX_PAD_KEY_COL4 = 45,
	MX6SX_PAD_KEY_ROW0 = 46,
	MX6SX_PAD_KEY_ROW1 = 47,
	MX6SX_PAD_KEY_ROW2 = 48,
	MX6SX_PAD_KEY_ROW3 = 49,
	MX6SX_PAD_KEY_ROW4 = 50,
	MX6SX_PAD_LCD1_CLK = 51,
	MX6SX_PAD_LCD1_DATA00 = 52,
	MX6SX_PAD_LCD1_DATA01 = 53,
	MX6SX_PAD_LCD1_DATA02 = 54,
	MX6SX_PAD_LCD1_DATA03 = 55,
	MX6SX_PAD_LCD1_DATA04 = 56,
	MX6SX_PAD_LCD1_DATA05 = 57,
	MX6SX_PAD_LCD1_DATA06 = 58,
	MX6SX_PAD_LCD1_DATA07 = 59,
	MX6SX_PAD_LCD1_DATA08 = 60,
	MX6SX_PAD_LCD1_DATA09 = 61,
	MX6SX_PAD_LCD1_DATA10 = 62,
	MX6SX_PAD_LCD1_DATA11 = 63,
	MX6SX_PAD_LCD1_DATA12 = 64,
	MX6SX_PAD_LCD1_DATA13 = 65,
	MX6SX_PAD_LCD1_DATA14 = 66,
	MX6SX_PAD_LCD1_DATA15 = 67,
	MX6SX_PAD_LCD1_DATA16 = 68,
	MX6SX_PAD_LCD1_DATA17 = 69,
	MX6SX_PAD_LCD1_DATA18 = 70,
	MX6SX_PAD_LCD1_DATA19 = 71,
	MX6SX_PAD_LCD1_DATA20 = 72,
	MX6SX_PAD_LCD1_DATA21 = 73,
	MX6SX_PAD_LCD1_DATA22 = 74,
	MX6SX_PAD_LCD1_DATA23 = 75,
	MX6SX_PAD_LCD1_ENABLE = 76,
	MX6SX_PAD_LCD1_HSYNC = 77,
	MX6SX_PAD_LCD1_RESET = 78,
	MX6SX_PAD_LCD1_VSYNC = 79,
	MX6SX_PAD_NAND_ALE = 80,
	MX6SX_PAD_NAND_CE0_B = 81,
	MX6SX_PAD_NAND_CE1_B = 82,
	MX6SX_PAD_NAND_CLE = 83,
	MX6SX_PAD_NAND_DATA00 = 84,
	MX6SX_PAD_NAND_DATA01 = 85,
	MX6SX_PAD_NAND_DATA02 = 86,
	MX6SX_PAD_NAND_DATA03 = 87,
	MX6SX_PAD_NAND_DATA04 = 88,
	MX6SX_PAD_NAND_DATA05 = 89,
	MX6SX_PAD_NAND_DATA06 = 90,
	MX6SX_PAD_NAND_DATA07 = 91,
	MX6SX_PAD_NAND_RE_B = 92,
	MX6SX_PAD_NAND_READY_B = 93,
	MX6SX_PAD_NAND_WE_B = 94,
	MX6SX_PAD_NAND_WP_B = 95,
	MX6SX_PAD_QSPI1A_DATA0 = 96,
	MX6SX_PAD_QSPI1A_DATA1 = 97,
	MX6SX_PAD_QSPI1A_DATA2 = 98,
	MX6SX_PAD_QSPI1A_DATA3 = 99,
	MX6SX_PAD_QSPI1A_DQS = 100,
	MX6SX_PAD_QSPI1A_SCLK = 101,
	MX6SX_PAD_QSPI1A_SS0_B = 102,
	MX6SX_PAD_QSPI1A_SS1_B = 103,
	MX6SX_PAD_QSPI1B_DATA0 = 104,
	MX6SX_PAD_QSPI1B_DATA1 = 105,
	MX6SX_PAD_QSPI1B_DATA2 = 106,
	MX6SX_PAD_QSPI1B_DATA3 = 107,
	MX6SX_PAD_QSPI1B_DQS = 108,
	MX6SX_PAD_QSPI1B_SCLK = 109,
	MX6SX_PAD_QSPI1B_SS0_B = 110,
	MX6SX_PAD_QSPI1B_SS1_B = 111,
	MX6SX_PAD_RGMII1_RD0 = 112,
	MX6SX_PAD_RGMII1_RD1 = 113,
	MX6SX_PAD_RGMII1_RD2 = 114,
	MX6SX_PAD_RGMII1_RD3 = 115,
	MX6SX_PAD_RGMII1_RX_CTL = 116,
	MX6SX_PAD_RGMII1_RXC = 117,
	MX6SX_PAD_RGMII1_TD0 = 118,
	MX6SX_PAD_RGMII1_TD1 = 119,
	MX6SX_PAD_RGMII1_TD2 = 120,
	MX6SX_PAD_RGMII1_TD3 = 121,
	MX6SX_PAD_RGMII1_TX_CTL = 122,
	MX6SX_PAD_RGMII1_TXC = 123,
	MX6SX_PAD_RGMII2_RD0 = 124,
	MX6SX_PAD_RGMII2_RD1 = 125,
	MX6SX_PAD_RGMII2_RD2 = 126,
	MX6SX_PAD_RGMII2_RD3 = 127,
	MX6SX_PAD_RGMII2_RX_CTL = 128,
	MX6SX_PAD_RGMII2_RXC = 129,
	MX6SX_PAD_RGMII2_TD0 = 130,
	MX6SX_PAD_RGMII2_TD1 = 131,
	MX6SX_PAD_RGMII2_TD2 = 132,
	MX6SX_PAD_RGMII2_TD3 = 133,
	MX6SX_PAD_RGMII2_TX_CTL = 134,
	MX6SX_PAD_RGMII2_TXC = 135,
	MX6SX_PAD_SD1_CLK = 136,
	MX6SX_PAD_SD1_CMD = 137,
	MX6SX_PAD_SD1_DATA0 = 138,
	MX6SX_PAD_SD1_DATA1 = 139,
	MX6SX_PAD_SD1_DATA2 = 140,
	MX6SX_PAD_SD1_DATA3 = 141,
	MX6SX_PAD_SD2_CLK = 142,
	MX6SX_PAD_SD2_CMD = 143,
	MX6SX_PAD_SD2_DATA0 = 144,
	MX6SX_PAD_SD2_DATA1 = 145,
	MX6SX_PAD_SD2_DATA2 = 146,
	MX6SX_PAD_SD2_DATA3 = 147,
	MX6SX_PAD_SD3_CLK = 148,
	MX6SX_PAD_SD3_CMD = 149,
	MX6SX_PAD_SD3_DATA0 = 150,
	MX6SX_PAD_SD3_DATA1 = 151,
	MX6SX_PAD_SD3_DATA2 = 152,
	MX6SX_PAD_SD3_DATA3 = 153,
	MX6SX_PAD_SD3_DATA4 = 154,
	MX6SX_PAD_SD3_DATA5 = 155,
	MX6SX_PAD_SD3_DATA6 = 156,
	MX6SX_PAD_SD3_DATA7 = 157,
	MX6SX_PAD_SD4_CLK = 158,
	MX6SX_PAD_SD4_CMD = 159,
	MX6SX_PAD_SD4_DATA0 = 160,
	MX6SX_PAD_SD4_DATA1 = 161,
	MX6SX_PAD_SD4_DATA2 = 162,
	MX6SX_PAD_SD4_DATA3 = 163,
	MX6SX_PAD_SD4_DATA4 = 164,
	MX6SX_PAD_SD4_DATA5 = 165,
	MX6SX_PAD_SD4_DATA6 = 166,
	MX6SX_PAD_SD4_DATA7 = 167,
	MX6SX_PAD_SD4_RESET_B = 168,
	MX6SX_PAD_USB_H_DATA = 169,
	MX6SX_PAD_USB_H_STROBE = 170,
};

enum imx6ul_pads {
	MX6UL_PAD_RESERVE0 = 0,
	MX6UL_PAD_RESERVE1 = 1,
	MX6UL_PAD_RESERVE2 = 2,
	MX6UL_PAD_RESERVE3 = 3,
	MX6UL_PAD_RESERVE4 = 4,
	MX6UL_PAD_RESERVE5 = 5,
	MX6UL_PAD_RESERVE6 = 6,
	MX6UL_PAD_RESERVE7 = 7,
	MX6UL_PAD_RESERVE8 = 8,
	MX6UL_PAD_RESERVE9 = 9,
	MX6UL_PAD_RESERVE10 = 10,
	MX6UL_PAD_SNVS_TAMPER4 = 11,
	MX6UL_PAD_RESERVE12 = 12,
	MX6UL_PAD_RESERVE13 = 13,
	MX6UL_PAD_RESERVE14 = 14,
	MX6UL_PAD_RESERVE15 = 15,
	MX6UL_PAD_RESERVE16 = 16,
	MX6UL_PAD_JTAG_MOD = 17,
	MX6UL_PAD_JTAG_TMS = 18,
	MX6UL_PAD_JTAG_TDO = 19,
	MX6UL_PAD_JTAG_TDI = 20,
	MX6UL_PAD_JTAG_TCK = 21,
	MX6UL_PAD_JTAG_TRST_B = 22,
	MX6UL_PAD_GPIO1_IO00 = 23,
	MX6UL_PAD_GPIO1_IO01 = 24,
	MX6UL_PAD_GPIO1_IO02 = 25,
	MX6UL_PAD_GPIO1_IO03 = 26,
	MX6UL_PAD_GPIO1_IO04 = 27,
	MX6UL_PAD_GPIO1_IO05 = 28,
	MX6UL_PAD_GPIO1_IO06 = 29,
	MX6UL_PAD_GPIO1_IO07 = 30,
	MX6UL_PAD_GPIO1_IO08 = 31,
	MX6UL_PAD_GPIO1_IO09 = 32,
	MX6UL_PAD_UART1_TX_DATA = 33,
	MX6UL_PAD_UART1_RX_DATA = 34,
	MX6UL_PAD_UART1_CTS_B = 35,
	MX6UL_PAD_UART1_RTS_B = 36,
	MX6UL_PAD_UART2_TX_DATA = 37,
	MX6UL_PAD_UART2_RX_DATA = 38,
	MX6UL_PAD_UART2_CTS_B = 39,
	MX6UL_PAD_UART2_RTS_B = 40,
	MX6UL_PAD_UART3_TX_DATA = 41,
	MX6UL_PAD_UART3_RX_DATA = 42,
	MX6UL_PAD_UART3_CTS_B = 43,
	MX6UL_PAD_UART3_RTS_B = 44,
	MX6UL_PAD_UART4_TX_DATA = 45,
	MX6UL_PAD_UART4_RX_DATA = 46,
	MX6UL_PAD_UART5_TX_DATA = 47,
	MX6UL_PAD_UART5_RX_DATA = 48,
	MX6UL_PAD_ENET1_RX_DATA0 = 49,
	MX6UL_PAD_ENET1_RX_DATA1 = 50,
	MX6UL_PAD_ENET1_RX_EN = 51,
	MX6UL_PAD_ENET1_TX_DATA0 = 52,
	MX6UL_PAD_ENET1_TX_DATA1 = 53,
	MX6UL_PAD_ENET1_TX_EN = 54,
	MX6UL_PAD_ENET1_TX_CLK = 55,
	MX6UL_PAD_ENET1_RX_ER = 56,
	MX6UL_PAD_ENET2_RX_DATA0 = 57,
	MX6UL_PAD_ENET2_RX_DATA1 = 58,
	MX6UL_PAD_ENET2_RX_EN = 59,
	MX6UL_PAD_ENET2_TX_DATA0 = 60,
	MX6UL_PAD_ENET2_TX_DATA1 = 61,
	MX6UL_PAD_ENET2_TX_EN = 62,
	MX6UL_PAD_ENET2_TX_CLK = 63,
	MX6UL_PAD_ENET2_RX_ER = 64,
	MX6UL_PAD_LCD_CLK = 65,
	MX6UL_PAD_LCD_ENABLE = 66,
	MX6UL_PAD_LCD_HSYNC = 67,
	MX6UL_PAD_LCD_VSYNC = 68,
	MX6UL_PAD_LCD_RESET = 69,
	MX6UL_PAD_LCD_DATA00 = 70,
	MX6UL_PAD_LCD_DATA01 = 71,
	MX6UL_PAD_LCD_DATA02 = 72,
	MX6UL_PAD_LCD_DATA03 = 73,
	MX6UL_PAD_LCD_DATA04 = 74,
	MX6UL_PAD_LCD_DATA05 = 75,
	MX6UL_PAD_LCD_DATA06 = 76,
	MX6UL_PAD_LCD_DATA07 = 77,
	MX6UL_PAD_LCD_DATA08 = 78,
	MX6UL_PAD_LCD_DATA09 = 79,
	MX6UL_PAD_LCD_DATA10 = 80,
	MX6UL_PAD_LCD_DATA11 = 81,
	MX6UL_PAD_LCD_DATA12 = 82,
	MX6UL_PAD_LCD_DATA13 = 83,
	MX6UL_PAD_LCD_DATA14 = 84,
	MX6UL_PAD_LCD_DATA15 = 85,
	MX6UL_PAD_LCD_DATA16 = 86,
	MX6UL_PAD_LCD_DATA17 = 87,
	MX6UL_PAD_LCD_DATA18 = 88,
	MX6UL_PAD_LCD_DATA19 = 89,
	MX6UL_PAD_LCD_DATA20 = 90,
	MX6UL_PAD_LCD_DATA21 = 91,
	MX6UL_PAD_LCD_DATA22 = 92,
	MX6UL_PAD_LCD_DATA23 = 93,
	MX6UL_PAD_NAND_RE_B = 94,
	MX6UL_PAD_NAND_WE_B = 95,
	MX6UL_PAD_NAND_DATA00 = 96,
	MX6UL_PAD_NAND_DATA01 = 97,
	MX6UL_PAD_NAND_DATA02 = 98,
	MX6UL_PAD_NAND_DATA03 = 99,
	MX6UL_PAD_NAND_DATA04 = 100,
	MX6UL_PAD_NAND_DATA05 = 101,
	MX6UL_PAD_NAND_DATA06 = 102,
	MX6UL_PAD_NAND_DATA07 = 103,
	MX6UL_PAD_NAND_ALE = 104,
	MX6UL_PAD_NAND_WP_B = 105,
	MX6UL_PAD_NAND_READY_B = 106,
	MX6UL_PAD_NAND_CE0_B = 107,
	MX6UL_PAD_NAND_CE1_B = 108,
	MX6UL_PAD_NAND_CLE = 109,
	MX6UL_PAD_NAND_DQS = 110,
	MX6UL_PAD_SD1_CMD = 111,
	MX6UL_PAD_SD1_CLK = 112,
	MX6UL_PAD_SD1_DATA0 = 113,
	MX6UL_PAD_SD1_DATA1 = 114,
	MX6UL_PAD_SD1_DATA2 = 115,
	MX6UL_PAD_SD1_DATA3 = 116,
	MX6UL_PAD_CSI_MCLK = 117,
	MX6UL_PAD_CSI_PIXCLK = 118,
	MX6UL_PAD_CSI_VSYNC = 119,
	MX6UL_PAD_CSI_HSYNC = 120,
	MX6UL_PAD_CSI_DATA00 = 121,
	MX6UL_PAD_CSI_DATA01 = 122,
	MX6UL_PAD_CSI_DATA02 = 123,
	MX6UL_PAD_CSI_DATA03 = 124,
	MX6UL_PAD_CSI_DATA04 = 125,
	MX6UL_PAD_CSI_DATA05 = 126,
	MX6UL_PAD_CSI_DATA06 = 127,
	MX6UL_PAD_CSI_DATA07 = 128,
};

enum imx6ull_lpsr_pads {
	MX6ULL_PAD_BOOT_MODE0 = 0,
	MX6ULL_PAD_BOOT_MODE1 = 1,
	MX6ULL_PAD_SNVS_TAMPER0 = 2,
	MX6ULL_PAD_SNVS_TAMPER1 = 3,
	MX6ULL_PAD_SNVS_TAMPER2 = 4,
	MX6ULL_PAD_SNVS_TAMPER3 = 5,
	MX6ULL_PAD_SNVS_TAMPER4 = 6,
	MX6ULL_PAD_SNVS_TAMPER5 = 7,
	MX6ULL_PAD_SNVS_TAMPER6 = 8,
	MX6ULL_PAD_SNVS_TAMPER7 = 9,
	MX6ULL_PAD_SNVS_TAMPER8 = 10,
	MX6ULL_PAD_SNVS_TAMPER9 = 11,
};

enum imx7d_pads {
	MX7D_PAD_RESERVE0 = 0,
	MX7D_PAD_RESERVE1 = 1,
	MX7D_PAD_RESERVE2 = 2,
	MX7D_PAD_RESERVE3 = 3,
	MX7D_PAD_RESERVE4 = 4,
	MX7D_PAD_GPIO1_IO08 = 5,
	MX7D_PAD_GPIO1_IO09 = 6,
	MX7D_PAD_GPIO1_IO10 = 7,
	MX7D_PAD_GPIO1_IO11 = 8,
	MX7D_PAD_GPIO1_IO12 = 9,
	MX7D_PAD_GPIO1_IO13 = 10,
	MX7D_PAD_GPIO1_IO14 = 11,
	MX7D_PAD_GPIO1_IO15 = 12,
	MX7D_PAD_EPDC_DATA00 = 13,
	MX7D_PAD_EPDC_DATA01 = 14,
	MX7D_PAD_EPDC_DATA02 = 15,
	MX7D_PAD_EPDC_DATA03 = 16,
	MX7D_PAD_EPDC_DATA04 = 17,
	MX7D_PAD_EPDC_DATA05 = 18,
	MX7D_PAD_EPDC_DATA06 = 19,
	MX7D_PAD_EPDC_DATA07 = 20,
	MX7D_PAD_EPDC_DATA08 = 21,
	MX7D_PAD_EPDC_DATA09 = 22,
	MX7D_PAD_EPDC_DATA10 = 23,
	MX7D_PAD_EPDC_DATA11 = 24,
	MX7D_PAD_EPDC_DATA12 = 25,
	MX7D_PAD_EPDC_DATA13 = 26,
	MX7D_PAD_EPDC_DATA14 = 27,
	MX7D_PAD_EPDC_DATA15 = 28,
	MX7D_PAD_EPDC_SDCLK = 29,
	MX7D_PAD_EPDC_SDLE = 30,
	MX7D_PAD_EPDC_SDOE = 31,
	MX7D_PAD_EPDC_SDSHR = 32,
	MX7D_PAD_EPDC_SDCE0 = 33,
	MX7D_PAD_EPDC_SDCE1 = 34,
	MX7D_PAD_EPDC_SDCE2 = 35,
	MX7D_PAD_EPDC_SDCE3 = 36,
	MX7D_PAD_EPDC_GDCLK = 37,
	MX7D_PAD_EPDC_GDOE = 38,
	MX7D_PAD_EPDC_GDRL = 39,
	MX7D_PAD_EPDC_GDSP = 40,
	MX7D_PAD_EPDC_BDR0 = 41,
	MX7D_PAD_EPDC_BDR1 = 42,
	MX7D_PAD_EPDC_PWR_COM = 43,
	MX7D_PAD_EPDC_PWR_STAT = 44,
	MX7D_PAD_LCD_CLK = 45,
	MX7D_PAD_LCD_ENABLE = 46,
	MX7D_PAD_LCD_HSYNC = 47,
	MX7D_PAD_LCD_VSYNC = 48,
	MX7D_PAD_LCD_RESET = 49,
	MX7D_PAD_LCD_DATA00 = 50,
	MX7D_PAD_LCD_DATA01 = 51,
	MX7D_PAD_LCD_DATA02 = 52,
	MX7D_PAD_LCD_DATA03 = 53,
	MX7D_PAD_LCD_DATA04 = 54,
	MX7D_PAD_LCD_DATA05 = 55,
	MX7D_PAD_LCD_DATA06 = 56,
	MX7D_PAD_LCD_DATA07 = 57,
	MX7D_PAD_LCD_DATA08 = 58,
	MX7D_PAD_LCD_DATA09 = 59,
	MX7D_PAD_LCD_DATA10 = 60,
	MX7D_PAD_LCD_DATA11 = 61,
	MX7D_PAD_LCD_DATA12 = 62,
	MX7D_PAD_LCD_DATA13 = 63,
	MX7D_PAD_LCD_DATA14 = 64,
	MX7D_PAD_LCD_DATA15 = 65,
	MX7D_PAD_LCD_DATA16 = 66,
	MX7D_PAD_LCD_DATA17 = 67,
	MX7D_PAD_LCD_DATA18 = 68,
	MX7D_PAD_LCD_DATA19 = 69,
	MX7D_PAD_LCD_DATA20 = 70,
	MX7D_PAD_LCD_DATA21 = 71,
	MX7D_PAD_LCD_DATA22 = 72,
	MX7D_PAD_LCD_DATA23 = 73,
	MX7D_PAD_UART1_RX_DATA = 74,
	MX7D_PAD_UART1_TX_DATA = 75,
	MX7D_PAD_UART2_RX_DATA = 76,
	MX7D_PAD_UART2_TX_DATA = 77,
	MX7D_PAD_UART3_RX_DATA = 78,
	MX7D_PAD_UART3_TX_DATA = 79,
	MX7D_PAD_UART3_RTS_B = 80,
	MX7D_PAD_UART3_CTS_B = 81,
	MX7D_PAD_I2C1_SCL = 82,
	MX7D_PAD_I2C1_SDA = 83,
	MX7D_PAD_I2C2_SCL = 84,
	MX7D_PAD_I2C2_SDA = 85,
	MX7D_PAD_I2C3_SCL = 86,
	MX7D_PAD_I2C3_SDA = 87,
	MX7D_PAD_I2C4_SCL = 88,
	MX7D_PAD_I2C4_SDA = 89,
	MX7D_PAD_ECSPI1_SCLK = 90,
	MX7D_PAD_ECSPI1_MOSI = 91,
	MX7D_PAD_ECSPI1_MISO = 92,
	MX7D_PAD_ECSPI1_SS0 = 93,
	MX7D_PAD_ECSPI2_SCLK = 94,
	MX7D_PAD_ECSPI2_MOSI = 95,
	MX7D_PAD_ECSPI2_MISO = 96,
	MX7D_PAD_ECSPI2_SS0 = 97,
	MX7D_PAD_SD1_CD_B = 98,
	MX7D_PAD_SD1_WP = 99,
	MX7D_PAD_SD1_RESET_B = 100,
	MX7D_PAD_SD1_CLK = 101,
	MX7D_PAD_SD1_CMD = 102,
	MX7D_PAD_SD1_DATA0 = 103,
	MX7D_PAD_SD1_DATA1 = 104,
	MX7D_PAD_SD1_DATA2 = 105,
	MX7D_PAD_SD1_DATA3 = 106,
	MX7D_PAD_SD2_CD_B = 107,
	MX7D_PAD_SD2_WP = 108,
	MX7D_PAD_SD2_RESET_B = 109,
	MX7D_PAD_SD2_CLK = 110,
	MX7D_PAD_SD2_CMD = 111,
	MX7D_PAD_SD2_DATA0 = 112,
	MX7D_PAD_SD2_DATA1 = 113,
	MX7D_PAD_SD2_DATA2 = 114,
	MX7D_PAD_SD2_DATA3 = 115,
	MX7D_PAD_SD3_CLK = 116,
	MX7D_PAD_SD3_CMD = 117,
	MX7D_PAD_SD3_DATA0 = 118,
	MX7D_PAD_SD3_DATA1 = 119,
	MX7D_PAD_SD3_DATA2 = 120,
	MX7D_PAD_SD3_DATA3 = 121,
	MX7D_PAD_SD3_DATA4 = 122,
	MX7D_PAD_SD3_DATA5 = 123,
	MX7D_PAD_SD3_DATA6 = 124,
	MX7D_PAD_SD3_DATA7 = 125,
	MX7D_PAD_SD3_STROBE = 126,
	MX7D_PAD_SD3_RESET_B = 127,
	MX7D_PAD_SAI1_RX_DATA = 128,
	MX7D_PAD_SAI1_TX_BCLK = 129,
	MX7D_PAD_SAI1_TX_SYNC = 130,
	MX7D_PAD_SAI1_TX_DATA = 131,
	MX7D_PAD_SAI1_RX_SYNC = 132,
	MX7D_PAD_SAI1_RX_BCLK = 133,
	MX7D_PAD_SAI1_MCLK = 134,
	MX7D_PAD_SAI2_TX_SYNC = 135,
	MX7D_PAD_SAI2_TX_BCLK = 136,
	MX7D_PAD_SAI2_RX_DATA = 137,
	MX7D_PAD_SAI2_TX_DATA = 138,
	MX7D_PAD_ENET1_RGMII_RD0 = 139,
	MX7D_PAD_ENET1_RGMII_RD1 = 140,
	MX7D_PAD_ENET1_RGMII_RD2 = 141,
	MX7D_PAD_ENET1_RGMII_RD3 = 142,
	MX7D_PAD_ENET1_RGMII_RX_CTL = 143,
	MX7D_PAD_ENET1_RGMII_RXC = 144,
	MX7D_PAD_ENET1_RGMII_TD0 = 145,
	MX7D_PAD_ENET1_RGMII_TD1 = 146,
	MX7D_PAD_ENET1_RGMII_TD2 = 147,
	MX7D_PAD_ENET1_RGMII_TD3 = 148,
	MX7D_PAD_ENET1_RGMII_TX_CTL = 149,
	MX7D_PAD_ENET1_RGMII_TXC = 150,
	MX7D_PAD_ENET1_TX_CLK = 151,
	MX7D_PAD_ENET1_RX_CLK = 152,
	MX7D_PAD_ENET1_CRS = 153,
	MX7D_PAD_ENET1_COL = 154,
};

enum imx7d_lpsr_pads {
	MX7D_PAD_GPIO1_IO00 = 0,
	MX7D_PAD_GPIO1_IO01 = 1,
	MX7D_PAD_GPIO1_IO02 = 2,
	MX7D_PAD_GPIO1_IO03 = 3,
	MX7D_PAD_GPIO1_IO04 = 4,
	MX7D_PAD_GPIO1_IO05 = 5,
	MX7D_PAD_GPIO1_IO06 = 6,
	MX7D_PAD_GPIO1_IO07 = 7,
};

enum vf610_pads {
	VF610_PAD_PTA6 = 0,
	VF610_PAD_PTA8 = 1,
	VF610_PAD_PTA9 = 2,
	VF610_PAD_PTA10 = 3,
	VF610_PAD_PTA11 = 4,
	VF610_PAD_PTA12 = 5,
	VF610_PAD_PTA16 = 6,
	VF610_PAD_PTA17 = 7,
	VF610_PAD_PTA18 = 8,
	VF610_PAD_PTA19 = 9,
	VF610_PAD_PTA20 = 10,
	VF610_PAD_PTA21 = 11,
	VF610_PAD_PTA22 = 12,
	VF610_PAD_PTA23 = 13,
	VF610_PAD_PTA24 = 14,
	VF610_PAD_PTA25 = 15,
	VF610_PAD_PTA26 = 16,
	VF610_PAD_PTA27 = 17,
	VF610_PAD_PTA28 = 18,
	VF610_PAD_PTA29 = 19,
	VF610_PAD_PTA30 = 20,
	VF610_PAD_PTA31 = 21,
	VF610_PAD_PTB0 = 22,
	VF610_PAD_PTB1 = 23,
	VF610_PAD_PTB2 = 24,
	VF610_PAD_PTB3 = 25,
	VF610_PAD_PTB4 = 26,
	VF610_PAD_PTB5 = 27,
	VF610_PAD_PTB6 = 28,
	VF610_PAD_PTB7 = 29,
	VF610_PAD_PTB8 = 30,
	VF610_PAD_PTB9 = 31,
	VF610_PAD_PTB10 = 32,
	VF610_PAD_PTB11 = 33,
	VF610_PAD_PTB12 = 34,
	VF610_PAD_PTB13 = 35,
	VF610_PAD_PTB14 = 36,
	VF610_PAD_PTB15 = 37,
	VF610_PAD_PTB16 = 38,
	VF610_PAD_PTB17 = 39,
	VF610_PAD_PTB18 = 40,
	VF610_PAD_PTB19 = 41,
	VF610_PAD_PTB20 = 42,
	VF610_PAD_PTB21 = 43,
	VF610_PAD_PTB22 = 44,
	VF610_PAD_PTC0 = 45,
	VF610_PAD_PTC1 = 46,
	VF610_PAD_PTC2 = 47,
	VF610_PAD_PTC3 = 48,
	VF610_PAD_PTC4 = 49,
	VF610_PAD_PTC5 = 50,
	VF610_PAD_PTC6 = 51,
	VF610_PAD_PTC7 = 52,
	VF610_PAD_PTC8 = 53,
	VF610_PAD_PTC9 = 54,
	VF610_PAD_PTC10 = 55,
	VF610_PAD_PTC11 = 56,
	VF610_PAD_PTC12 = 57,
	VF610_PAD_PTC13 = 58,
	VF610_PAD_PTC14 = 59,
	VF610_PAD_PTC15 = 60,
	VF610_PAD_PTC16 = 61,
	VF610_PAD_PTC17 = 62,
	VF610_PAD_PTD31 = 63,
	VF610_PAD_PTD30 = 64,
	VF610_PAD_PTD29 = 65,
	VF610_PAD_PTD28 = 66,
	VF610_PAD_PTD27 = 67,
	VF610_PAD_PTD26 = 68,
	VF610_PAD_PTD25 = 69,
	VF610_PAD_PTD24 = 70,
	VF610_PAD_PTD23 = 71,
	VF610_PAD_PTD22 = 72,
	VF610_PAD_PTD21 = 73,
	VF610_PAD_PTD20 = 74,
	VF610_PAD_PTD19 = 75,
	VF610_PAD_PTD18 = 76,
	VF610_PAD_PTD17 = 77,
	VF610_PAD_PTD16 = 78,
	VF610_PAD_PTD0 = 79,
	VF610_PAD_PTD1 = 80,
	VF610_PAD_PTD2 = 81,
	VF610_PAD_PTD3 = 82,
	VF610_PAD_PTD4 = 83,
	VF610_PAD_PTD5 = 84,
	VF610_PAD_PTD6 = 85,
	VF610_PAD_PTD7 = 86,
	VF610_PAD_PTD8 = 87,
	VF610_PAD_PTD9 = 88,
	VF610_PAD_PTD10 = 89,
	VF610_PAD_PTD11 = 90,
	VF610_PAD_PTD12 = 91,
	VF610_PAD_PTD13 = 92,
	VF610_PAD_PTB23 = 93,
	VF610_PAD_PTB24 = 94,
	VF610_PAD_PTB25 = 95,
	VF610_PAD_PTB26 = 96,
	VF610_PAD_PTB27 = 97,
	VF610_PAD_PTB28 = 98,
	VF610_PAD_PTC26 = 99,
	VF610_PAD_PTC27 = 100,
	VF610_PAD_PTC28 = 101,
	VF610_PAD_PTC29 = 102,
	VF610_PAD_PTC30 = 103,
	VF610_PAD_PTC31 = 104,
	VF610_PAD_PTE0 = 105,
	VF610_PAD_PTE1 = 106,
	VF610_PAD_PTE2 = 107,
	VF610_PAD_PTE3 = 108,
	VF610_PAD_PTE4 = 109,
	VF610_PAD_PTE5 = 110,
	VF610_PAD_PTE6 = 111,
	VF610_PAD_PTE7 = 112,
	VF610_PAD_PTE8 = 113,
	VF610_PAD_PTE9 = 114,
	VF610_PAD_PTE10 = 115,
	VF610_PAD_PTE11 = 116,
	VF610_PAD_PTE12 = 117,
	VF610_PAD_PTE13 = 118,
	VF610_PAD_PTE14 = 119,
	VF610_PAD_PTE15 = 120,
	VF610_PAD_PTE16 = 121,
	VF610_PAD_PTE17 = 122,
	VF610_PAD_PTE18 = 123,
	VF610_PAD_PTE19 = 124,
	VF610_PAD_PTE20 = 125,
	VF610_PAD_PTE21 = 126,
	VF610_PAD_PTE22 = 127,
	VF610_PAD_PTE23 = 128,
	VF610_PAD_PTE24 = 129,
	VF610_PAD_PTE25 = 130,
	VF610_PAD_PTE26 = 131,
	VF610_PAD_PTE27 = 132,
	VF610_PAD_PTE28 = 133,
	VF610_PAD_PTA7 = 134,
};

struct mvebu_mpp_ctrl_data {
	union {
		void *base;
		struct {
			struct regmap *map;
			u32 offset;
		} regmap;
	};
};

struct mvebu_mpp_ctrl {
	const char *name;
	u8 pid;
	u8 npins;
	unsigned int *pins;
	int (*mpp_get)(struct mvebu_mpp_ctrl_data *, unsigned int, long unsigned int *);
	int (*mpp_set)(struct mvebu_mpp_ctrl_data *, unsigned int, long unsigned int);
	int (*mpp_gpio_req)(struct mvebu_mpp_ctrl_data *, unsigned int);
	int (*mpp_gpio_dir)(struct mvebu_mpp_ctrl_data *, unsigned int, bool);
};

struct mvebu_mpp_ctrl_setting {
	u8 val;
	const char *name;
	const char *subname;
	u8 variant;
	u8 flags;
};

struct mvebu_mpp_mode {
	u8 pid;
	struct mvebu_mpp_ctrl_setting *settings;
};

struct mvebu_pinctrl_soc_info {
	u8 variant;
	const struct mvebu_mpp_ctrl *controls;
	struct mvebu_mpp_ctrl_data *control_data;
	int ncontrols;
	struct mvebu_mpp_mode *modes;
	int nmodes;
	struct pinctrl_gpio_range *gpioranges;
	int ngpioranges;
};

struct mvebu_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int num_groups;
};

struct mvebu_pinctrl_group {
	const char *name;
	const struct mvebu_mpp_ctrl *ctrl;
	struct mvebu_mpp_ctrl_data *data;
	struct mvebu_mpp_ctrl_setting *settings;
	unsigned int num_settings;
	unsigned int gid;
	unsigned int *pins;
	unsigned int npins;
};

struct mvebu_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctldev;
	struct pinctrl_desc desc;
	struct mvebu_pinctrl_group *groups;
	unsigned int num_groups;
	struct mvebu_pinctrl_function *functions;
	unsigned int num_functions;
	u8 variant;
};

enum {
	V_88F6810 = 1,
	V_88F6820 = 2,
	V_88F6828 = 4,
	V_88F6810_PLUS = 7,
	V_88F6820_PLUS = 6,
};

enum {
	V_88F6920 = 1,
	V_88F6925 = 2,
	V_88F6928 = 4,
	V_88F6920_PLUS = 7,
	V_88F6925_PLUS = 6,
};

enum armada_xp_variant {
	V_MV78230 = 1,
	V_MV78260 = 2,
	V_MV78460 = 4,
	V_MV78230_PLUS = 7,
	V_MV78260_PLUS = 6,
	V_98DX3236 = 8,
	V_98DX3336 = 16,
	V_98DX4251 = 32,
	V_98DX3236_PLUS = 56,
};

enum ab8500_version {
	AB8500_VERSION_AB8500 = 0,
	AB8500_VERSION_AB8505 = 1,
	AB8500_VERSION_AB9540 = 2,
	AB8500_VERSION_AB8540 = 4,
	AB8500_VERSION_UNDEFINED = 5,
};

struct ab8500 {
	struct device *dev;
	struct mutex lock;
	struct mutex irq_lock;
	atomic_t transfer_ongoing;
	int irq;
	struct irq_domain *domain;
	enum ab8500_version version;
	u8 chip_id;
	int (*write)(struct ab8500 *, u16, u8);
	int (*write_masked)(struct ab8500 *, u16, u8, u8);
	int (*read)(struct ab8500 *, u16);
	long unsigned int tx_buf[4];
	long unsigned int rx_buf[4];
	u8 *mask;
	u8 *oldmask;
	int mask_size;
	const int *irq_reg_offset;
	int it_latchhier_num;
};

enum abx500_pin_func {
	ABX500_DEFAULT = 0,
	ABX500_ALT_A = 1,
	ABX500_ALT_B = 2,
	ABX500_ALT_C = 3,
};

enum abx500_gpio_pull_updown {
	ABX500_GPIO_PULL_DOWN = 0,
	ABX500_GPIO_PULL_NONE = 1,
	ABX500_GPIO_PULL_UP = 3,
};

struct abx500_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct abx500_pingroup {
	const char *name;
	const unsigned int *pins;
	const unsigned int npins;
	int altsetting;
};

struct alternate_functions {
	unsigned int pin_number;
	s8 gpiosel_bit;
	s8 alt_bit1;
	s8 alt_bit2;
	u8 alta_val;
	u8 altb_val;
	u8 altc_val;
};

struct abx500_gpio_irq_cluster {
	int start;
	int end;
	int to_irq;
};

struct abx500_pinrange {
	unsigned int offset;
	unsigned int npins;
	int altfunc;
};

struct abx500_pinctrl_soc_data {
	const struct abx500_pinrange *gpio_ranges;
	unsigned int gpio_num_ranges;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct abx500_function *functions;
	unsigned int nfunctions;
	const struct abx500_pingroup *groups;
	unsigned int ngroups;
	struct alternate_functions *alternate_functions;
	struct abx500_gpio_irq_cluster *gpio_irq_cluster;
	unsigned int ngpio_irq_cluster;
	int irq_gpio_rising_offset;
	int irq_gpio_falling_offset;
	int irq_gpio_factor;
};

struct abx500_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctldev;
	struct abx500_pinctrl_soc_data *soc;
	struct gpio_chip chip;
	struct ab8500 *parent;
	struct abx500_gpio_irq_cluster *irq_cluster;
	int irq_cluster_size;
};

enum prcm_gpiocr_altcx_index {
	PRCM_IDX_GPIOCR_ALTC1 = 0,
	PRCM_IDX_GPIOCR_ALTC2 = 1,
	PRCM_IDX_GPIOCR_ALTC3 = 2,
	PRCM_IDX_GPIOCR_ALTC4 = 3,
	PRCM_IDX_GPIOCR_ALTC_MAX = 4,
};

struct prcm_gpiocr_altcx {
	bool used: 1;
	u8 reg_index: 2;
	u8 control_bit: 5;
};

struct prcm_gpiocr_altcx_pin_desc {
	short unsigned int pin;
	struct prcm_gpiocr_altcx altcx[4];
};

struct nmk_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct nmk_pingroup {
	const char *name;
	const unsigned int *pins;
	const unsigned int npins;
	int altsetting;
};

struct nmk_pinctrl_soc_data {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct nmk_function *functions;
	unsigned int nfunctions;
	const struct nmk_pingroup *groups;
	unsigned int ngroups;
	const struct prcm_gpiocr_altcx_pin_desc *altcx_pins;
	unsigned int npins_altcx;
	const u16 *prcm_gpiocr_registers;
};

typedef long unsigned int pin_cfg_t;

enum nmk_gpio_pull {
	NMK_GPIO_PULL_NONE = 0,
	NMK_GPIO_PULL_UP = 1,
	NMK_GPIO_PULL_DOWN = 2,
};

enum nmk_gpio_slpm {
	NMK_GPIO_SLPM_INPUT = 0,
	NMK_GPIO_SLPM_WAKEUP_ENABLE = 0,
	NMK_GPIO_SLPM_NOCHANGE = 1,
	NMK_GPIO_SLPM_WAKEUP_DISABLE = 1,
};

struct nmk_gpio_chip {
	struct gpio_chip chip;
	struct irq_chip irqchip;
	void *addr;
	struct clk *clk;
	unsigned int bank;
	void (*set_ioforce)(bool);
	spinlock_t lock;
	bool sleepmode;
	u32 edge_rising;
	u32 edge_falling;
	u32 real_wake;
	u32 rwimsc;
	u32 fwimsc;
	u32 rimsc;
	u32 fimsc;
	u32 pull_up;
	u32 lowemi;
};

struct nmk_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	const struct nmk_pinctrl_soc_data *soc;
	void *prcm_base;
};

enum nmk_gpio_irq_type {
	NORMAL = 0,
	WAKE = 1,
};

struct nmk_cfg_param {
	const char *property;
	long unsigned int config;
	const long unsigned int *choice;
	int size;
};

enum prcm_gpiocr_reg_index {
	PRCM_IDX_GPIOCR1 = 0,
	PRCM_IDX_GPIOCR2 = 1,
	PRCM_IDX_GPIOCR3 = 2,
};

struct msm_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct msm_pingroup {
	const char *name;
	const unsigned int *pins;
	unsigned int npins;
	unsigned int *funcs;
	unsigned int nfuncs;
	u32 ctl_reg;
	u32 io_reg;
	u32 intr_cfg_reg;
	u32 intr_status_reg;
	u32 intr_target_reg;
	unsigned int tile: 2;
	unsigned int mux_bit: 5;
	unsigned int pull_bit: 5;
	unsigned int drv_bit: 5;
	unsigned int od_bit: 5;
	unsigned int oe_bit: 5;
	unsigned int in_bit: 5;
	unsigned int out_bit: 5;
	unsigned int intr_enable_bit: 5;
	unsigned int intr_status_bit: 5;
	unsigned int intr_ack_high: 1;
	unsigned int intr_target_bit: 5;
	unsigned int intr_target_kpss_val: 5;
	unsigned int intr_raw_status_bit: 5;
	char: 1;
	unsigned int intr_polarity_bit: 5;
	unsigned int intr_detection_bit: 5;
	unsigned int intr_detection_width: 5;
};

struct msm_gpio_wakeirq_map {
	unsigned int gpio;
	unsigned int wakeirq;
};

struct msm_pinctrl_soc_data {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct msm_function *functions;
	unsigned int nfunctions;
	const struct msm_pingroup *groups;
	unsigned int ngroups;
	unsigned int ngpios;
	bool pull_no_keeper;
	const char * const *tiles;
	unsigned int ntiles;
	const int *reserved_gpios;
	const struct msm_gpio_wakeirq_map *wakeirq_map;
	unsigned int nwakeirq_map;
	bool wakeirq_dual_edge_errata;
	unsigned int gpio_func;
};

struct msm_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctrl;
	struct gpio_chip chip;
	struct pinctrl_desc desc;
	struct notifier_block restart_nb;
	struct irq_chip irq_chip;
	int irq;
	bool intr_target_use_scm;
	raw_spinlock_t lock;
	long unsigned int dual_edge_irqs[10];
	long unsigned int enabled_irqs[10];
	long unsigned int skip_wake_irqs[10];
	long unsigned int disabled_for_mux[10];
	const struct msm_pinctrl_soc_data *soc;
	void *regs[4];
	u32 phys_base[4];
};

enum apq8064_functions {
	APQ_MUX_cam_mclk = 0,
	APQ_MUX_codec_mic_i2s = 1,
	APQ_MUX_codec_spkr_i2s = 2,
	APQ_MUX_gp_clk_0a = 3,
	APQ_MUX_gp_clk_0b = 4,
	APQ_MUX_gp_clk_1a = 5,
	APQ_MUX_gp_clk_1b = 6,
	APQ_MUX_gp_clk_2a = 7,
	APQ_MUX_gp_clk_2b = 8,
	APQ_MUX_gpio = 9,
	APQ_MUX_gsbi1 = 10,
	APQ_MUX_gsbi2 = 11,
	APQ_MUX_gsbi3 = 12,
	APQ_MUX_gsbi4 = 13,
	APQ_MUX_gsbi4_cam_i2c = 14,
	APQ_MUX_gsbi5 = 15,
	APQ_MUX_gsbi5_spi_cs1 = 16,
	APQ_MUX_gsbi5_spi_cs2 = 17,
	APQ_MUX_gsbi5_spi_cs3 = 18,
	APQ_MUX_gsbi6 = 19,
	APQ_MUX_gsbi6_spi_cs1 = 20,
	APQ_MUX_gsbi6_spi_cs2 = 21,
	APQ_MUX_gsbi6_spi_cs3 = 22,
	APQ_MUX_gsbi7 = 23,
	APQ_MUX_gsbi7_spi_cs1 = 24,
	APQ_MUX_gsbi7_spi_cs2 = 25,
	APQ_MUX_gsbi7_spi_cs3 = 26,
	APQ_MUX_gsbi_cam_i2c = 27,
	APQ_MUX_hdmi = 28,
	APQ_MUX_mi2s = 29,
	APQ_MUX_riva_bt = 30,
	APQ_MUX_riva_fm = 31,
	APQ_MUX_riva_wlan = 32,
	APQ_MUX_sdc2 = 33,
	APQ_MUX_sdc4 = 34,
	APQ_MUX_slimbus = 35,
	APQ_MUX_spkr_i2s = 36,
	APQ_MUX_tsif1 = 37,
	APQ_MUX_tsif2 = 38,
	APQ_MUX_usb2_hsic = 39,
	APQ_MUX_ps_hold = 40,
	APQ_MUX_NA = 41,
};

enum apq8084_functions {
	APQ_MUX_adsp_ext = 0,
	APQ_MUX_audio_ref = 1,
	APQ_MUX_blsp_i2c1 = 2,
	APQ_MUX_blsp_i2c2 = 3,
	APQ_MUX_blsp_i2c3 = 4,
	APQ_MUX_blsp_i2c4 = 5,
	APQ_MUX_blsp_i2c5 = 6,
	APQ_MUX_blsp_i2c6 = 7,
	APQ_MUX_blsp_i2c7 = 8,
	APQ_MUX_blsp_i2c8 = 9,
	APQ_MUX_blsp_i2c9 = 10,
	APQ_MUX_blsp_i2c10 = 11,
	APQ_MUX_blsp_i2c11 = 12,
	APQ_MUX_blsp_i2c12 = 13,
	APQ_MUX_blsp_spi1 = 14,
	APQ_MUX_blsp_spi1_cs1 = 15,
	APQ_MUX_blsp_spi1_cs2 = 16,
	APQ_MUX_blsp_spi1_cs3 = 17,
	APQ_MUX_blsp_spi2 = 18,
	APQ_MUX_blsp_spi3 = 19,
	APQ_MUX_blsp_spi3_cs1 = 20,
	APQ_MUX_blsp_spi3_cs2 = 21,
	APQ_MUX_blsp_spi3_cs3 = 22,
	APQ_MUX_blsp_spi4 = 23,
	APQ_MUX_blsp_spi5 = 24,
	APQ_MUX_blsp_spi6 = 25,
	APQ_MUX_blsp_spi7 = 26,
	APQ_MUX_blsp_spi8 = 27,
	APQ_MUX_blsp_spi9 = 28,
	APQ_MUX_blsp_spi10 = 29,
	APQ_MUX_blsp_spi10_cs1 = 30,
	APQ_MUX_blsp_spi10_cs2 = 31,
	APQ_MUX_blsp_spi10_cs3 = 32,
	APQ_MUX_blsp_spi11 = 33,
	APQ_MUX_blsp_spi12 = 34,
	APQ_MUX_blsp_uart1 = 35,
	APQ_MUX_blsp_uart2 = 36,
	APQ_MUX_blsp_uart3 = 37,
	APQ_MUX_blsp_uart4 = 38,
	APQ_MUX_blsp_uart5 = 39,
	APQ_MUX_blsp_uart6 = 40,
	APQ_MUX_blsp_uart7 = 41,
	APQ_MUX_blsp_uart8 = 42,
	APQ_MUX_blsp_uart9 = 43,
	APQ_MUX_blsp_uart10 = 44,
	APQ_MUX_blsp_uart11 = 45,
	APQ_MUX_blsp_uart12 = 46,
	APQ_MUX_blsp_uim1 = 47,
	APQ_MUX_blsp_uim2 = 48,
	APQ_MUX_blsp_uim3 = 49,
	APQ_MUX_blsp_uim4 = 50,
	APQ_MUX_blsp_uim5 = 51,
	APQ_MUX_blsp_uim6 = 52,
	APQ_MUX_blsp_uim7 = 53,
	APQ_MUX_blsp_uim8 = 54,
	APQ_MUX_blsp_uim9 = 55,
	APQ_MUX_blsp_uim10 = 56,
	APQ_MUX_blsp_uim11 = 57,
	APQ_MUX_blsp_uim12 = 58,
	APQ_MUX_cam_mclk0 = 59,
	APQ_MUX_cam_mclk1 = 60,
	APQ_MUX_cam_mclk2 = 61,
	APQ_MUX_cam_mclk3 = 62,
	APQ_MUX_cci_async = 63,
	APQ_MUX_cci_async_in0 = 64,
	APQ_MUX_cci_i2c0 = 65,
	APQ_MUX_cci_i2c1 = 66,
	APQ_MUX_cci_timer0 = 67,
	APQ_MUX_cci_timer1 = 68,
	APQ_MUX_cci_timer2 = 69,
	APQ_MUX_cci_timer3 = 70,
	APQ_MUX_cci_timer4 = 71,
	APQ_MUX_edp_hpd = 72,
	APQ_MUX_gcc_gp1 = 73,
	APQ_MUX_gcc_gp2 = 74,
	APQ_MUX_gcc_gp3 = 75,
	APQ_MUX_gcc_obt = 76,
	APQ_MUX_gcc_vtt = 77,
	APQ_MUX_gp_mn = 78,
	APQ_MUX_gp_pdm0 = 79,
	APQ_MUX_gp_pdm1 = 80,
	APQ_MUX_gp_pdm2 = 81,
	APQ_MUX_gp0_clk = 82,
	APQ_MUX_gp1_clk = 83,
	APQ_MUX_gpio___2 = 84,
	APQ_MUX_hdmi_cec = 85,
	APQ_MUX_hdmi_ddc = 86,
	APQ_MUX_hdmi_dtest = 87,
	APQ_MUX_hdmi_hpd = 88,
	APQ_MUX_hdmi_rcv = 89,
	APQ_MUX_hsic = 90,
	APQ_MUX_ldo_en = 91,
	APQ_MUX_ldo_update = 92,
	APQ_MUX_mdp_vsync = 93,
	APQ_MUX_pci_e0 = 94,
	APQ_MUX_pci_e0_n = 95,
	APQ_MUX_pci_e0_rst = 96,
	APQ_MUX_pci_e1 = 97,
	APQ_MUX_pci_e1_rst = 98,
	APQ_MUX_pci_e1_rst_n = 99,
	APQ_MUX_pci_e1_clkreq_n = 100,
	APQ_MUX_pri_mi2s = 101,
	APQ_MUX_qua_mi2s = 102,
	APQ_MUX_sata_act = 103,
	APQ_MUX_sata_devsleep = 104,
	APQ_MUX_sata_devsleep_n = 105,
	APQ_MUX_sd_write = 106,
	APQ_MUX_sdc_emmc_mode = 107,
	APQ_MUX_sdc3 = 108,
	APQ_MUX_sdc4___2 = 109,
	APQ_MUX_sec_mi2s = 110,
	APQ_MUX_slimbus___2 = 111,
	APQ_MUX_spdif_tx = 112,
	APQ_MUX_spkr_i2s___2 = 113,
	APQ_MUX_spkr_i2s_ws = 114,
	APQ_MUX_spss_geni = 115,
	APQ_MUX_ter_mi2s = 116,
	APQ_MUX_tsif1___2 = 117,
	APQ_MUX_tsif2___2 = 118,
	APQ_MUX_uim = 119,
	APQ_MUX_uim_batt_alarm = 120,
	APQ_MUX_NA___2 = 121,
};

enum ipq8064_functions {
	IPQ_MUX_gpio = 0,
	IPQ_MUX_mdio = 1,
	IPQ_MUX_mi2s = 2,
	IPQ_MUX_pdm = 3,
	IPQ_MUX_ssbi = 4,
	IPQ_MUX_spmi = 5,
	IPQ_MUX_audio_pcm = 6,
	IPQ_MUX_gsbi1 = 7,
	IPQ_MUX_gsbi2 = 8,
	IPQ_MUX_gsbi4 = 9,
	IPQ_MUX_gsbi5 = 10,
	IPQ_MUX_gsbi5_spi_cs1 = 11,
	IPQ_MUX_gsbi5_spi_cs2 = 12,
	IPQ_MUX_gsbi5_spi_cs3 = 13,
	IPQ_MUX_gsbi6 = 14,
	IPQ_MUX_gsbi7 = 15,
	IPQ_MUX_nss_spi = 16,
	IPQ_MUX_sdc1 = 17,
	IPQ_MUX_spdif = 18,
	IPQ_MUX_nand = 19,
	IPQ_MUX_tsif1 = 20,
	IPQ_MUX_tsif2 = 21,
	IPQ_MUX_usb_fs_n = 22,
	IPQ_MUX_usb_fs = 23,
	IPQ_MUX_usb2_hsic = 24,
	IPQ_MUX_rgmii2 = 25,
	IPQ_MUX_sata = 26,
	IPQ_MUX_pcie1_rst = 27,
	IPQ_MUX_pcie1_prsnt = 28,
	IPQ_MUX_pcie1_pwrflt = 29,
	IPQ_MUX_pcie1_pwren_n = 30,
	IPQ_MUX_pcie1_pwren = 31,
	IPQ_MUX_pcie1_clk_req = 32,
	IPQ_MUX_pcie2_rst = 33,
	IPQ_MUX_pcie2_prsnt = 34,
	IPQ_MUX_pcie2_pwrflt = 35,
	IPQ_MUX_pcie2_pwren_n = 36,
	IPQ_MUX_pcie2_pwren = 37,
	IPQ_MUX_pcie2_clk_req = 38,
	IPQ_MUX_pcie3_rst = 39,
	IPQ_MUX_pcie3_prsnt = 40,
	IPQ_MUX_pcie3_pwrflt = 41,
	IPQ_MUX_pcie3_pwren_n = 42,
	IPQ_MUX_pcie3_pwren = 43,
	IPQ_MUX_pcie3_clk_req = 44,
	IPQ_MUX_ps_hold = 45,
	IPQ_MUX_NA = 46,
};

enum msm8660_functions {
	MSM_MUX_gpio = 0,
	MSM_MUX_cam_mclk = 1,
	MSM_MUX_dsub = 2,
	MSM_MUX_ext_gps = 3,
	MSM_MUX_gp_clk_0a = 4,
	MSM_MUX_gp_clk_0b = 5,
	MSM_MUX_gp_clk_1a = 6,
	MSM_MUX_gp_clk_1b = 7,
	MSM_MUX_gp_clk_2a = 8,
	MSM_MUX_gp_clk_2b = 9,
	MSM_MUX_gp_mn = 10,
	MSM_MUX_gsbi1 = 11,
	MSM_MUX_gsbi1_spi_cs1_n = 12,
	MSM_MUX_gsbi1_spi_cs2a_n = 13,
	MSM_MUX_gsbi1_spi_cs2b_n = 14,
	MSM_MUX_gsbi1_spi_cs3_n = 15,
	MSM_MUX_gsbi2 = 16,
	MSM_MUX_gsbi2_spi_cs1_n = 17,
	MSM_MUX_gsbi2_spi_cs2_n = 18,
	MSM_MUX_gsbi2_spi_cs3_n = 19,
	MSM_MUX_gsbi3 = 20,
	MSM_MUX_gsbi3_spi_cs1_n = 21,
	MSM_MUX_gsbi3_spi_cs2_n = 22,
	MSM_MUX_gsbi3_spi_cs3_n = 23,
	MSM_MUX_gsbi4 = 24,
	MSM_MUX_gsbi5 = 25,
	MSM_MUX_gsbi6 = 26,
	MSM_MUX_gsbi7 = 27,
	MSM_MUX_gsbi8 = 28,
	MSM_MUX_gsbi9 = 29,
	MSM_MUX_gsbi10 = 30,
	MSM_MUX_gsbi11 = 31,
	MSM_MUX_gsbi12 = 32,
	MSM_MUX_hdmi = 33,
	MSM_MUX_i2s = 34,
	MSM_MUX_lcdc = 35,
	MSM_MUX_mdp_vsync = 36,
	MSM_MUX_mi2s = 37,
	MSM_MUX_pcm = 38,
	MSM_MUX_ps_hold = 39,
	MSM_MUX_sdc1 = 40,
	MSM_MUX_sdc2 = 41,
	MSM_MUX_sdc5 = 42,
	MSM_MUX_tsif1 = 43,
	MSM_MUX_tsif2 = 44,
	MSM_MUX_usb_fs1 = 45,
	MSM_MUX_usb_fs1_oe_n = 46,
	MSM_MUX_usb_fs2 = 47,
	MSM_MUX_usb_fs2_oe_n = 48,
	MSM_MUX_vfe = 49,
	MSM_MUX_vsens_alarm = 50,
	MSM_MUX_ebi2cs = 51,
	MSM_MUX_ebi2 = 52,
	MSM_MUX__ = 53,
};

enum msm8960_functions {
	MSM_MUX_audio_pcm = 0,
	MSM_MUX_bt = 1,
	MSM_MUX_cam_mclk0 = 2,
	MSM_MUX_cam_mclk1 = 3,
	MSM_MUX_cam_mclk2 = 4,
	MSM_MUX_codec_mic_i2s = 5,
	MSM_MUX_codec_spkr_i2s = 6,
	MSM_MUX_ext_gps___2 = 7,
	MSM_MUX_fm = 8,
	MSM_MUX_gps_blanking = 9,
	MSM_MUX_gps_pps_in = 10,
	MSM_MUX_gps_pps_out = 11,
	MSM_MUX_gp_clk_0a___2 = 12,
	MSM_MUX_gp_clk_0b___2 = 13,
	MSM_MUX_gp_clk_1a___2 = 14,
	MSM_MUX_gp_clk_1b___2 = 15,
	MSM_MUX_gp_clk_2a___2 = 16,
	MSM_MUX_gp_clk_2b___2 = 17,
	MSM_MUX_gp_mn___2 = 18,
	MSM_MUX_gp_pdm_0a = 19,
	MSM_MUX_gp_pdm_0b = 20,
	MSM_MUX_gp_pdm_1a = 21,
	MSM_MUX_gp_pdm_1b = 22,
	MSM_MUX_gp_pdm_2a = 23,
	MSM_MUX_gp_pdm_2b = 24,
	MSM_MUX_gpio___2 = 25,
	MSM_MUX_gsbi1___2 = 26,
	MSM_MUX_gsbi1_spi_cs1_n___2 = 27,
	MSM_MUX_gsbi1_spi_cs2a_n___2 = 28,
	MSM_MUX_gsbi1_spi_cs2b_n___2 = 29,
	MSM_MUX_gsbi1_spi_cs3_n___2 = 30,
	MSM_MUX_gsbi2___2 = 31,
	MSM_MUX_gsbi2_spi_cs1_n___2 = 32,
	MSM_MUX_gsbi2_spi_cs2_n___2 = 33,
	MSM_MUX_gsbi2_spi_cs3_n___2 = 34,
	MSM_MUX_gsbi3___2 = 35,
	MSM_MUX_gsbi4___2 = 36,
	MSM_MUX_gsbi4_3d_cam_i2c_l = 37,
	MSM_MUX_gsbi4_3d_cam_i2c_r = 38,
	MSM_MUX_gsbi5___2 = 39,
	MSM_MUX_gsbi5_3d_cam_i2c_l = 40,
	MSM_MUX_gsbi5_3d_cam_i2c_r = 41,
	MSM_MUX_gsbi6___2 = 42,
	MSM_MUX_gsbi7___2 = 43,
	MSM_MUX_gsbi8___2 = 44,
	MSM_MUX_gsbi9___2 = 45,
	MSM_MUX_gsbi10___2 = 46,
	MSM_MUX_gsbi11___2 = 47,
	MSM_MUX_gsbi11_spi_cs1a_n = 48,
	MSM_MUX_gsbi11_spi_cs1b_n = 49,
	MSM_MUX_gsbi11_spi_cs2a_n = 50,
	MSM_MUX_gsbi11_spi_cs2b_n = 51,
	MSM_MUX_gsbi11_spi_cs3_n = 52,
	MSM_MUX_gsbi12___2 = 53,
	MSM_MUX_hdmi_cec = 54,
	MSM_MUX_hdmi_ddc_clock = 55,
	MSM_MUX_hdmi_ddc_data = 56,
	MSM_MUX_hdmi_hot_plug_detect = 57,
	MSM_MUX_hsic = 58,
	MSM_MUX_mdp_vsync___2 = 59,
	MSM_MUX_mi2s___2 = 60,
	MSM_MUX_mic_i2s = 61,
	MSM_MUX_pmb_clk = 62,
	MSM_MUX_pmb_ext_ctrl = 63,
	MSM_MUX_ps_hold___2 = 64,
	MSM_MUX_rpm_wdog = 65,
	MSM_MUX_sdc2___2 = 66,
	MSM_MUX_sdc4 = 67,
	MSM_MUX_sdc5___2 = 68,
	MSM_MUX_slimbus1 = 69,
	MSM_MUX_slimbus2 = 70,
	MSM_MUX_spkr_i2s = 71,
	MSM_MUX_ssbi1 = 72,
	MSM_MUX_ssbi2 = 73,
	MSM_MUX_ssbi_ext_gps = 74,
	MSM_MUX_ssbi_pmic2 = 75,
	MSM_MUX_ssbi_qpa1 = 76,
	MSM_MUX_ssbi_ts = 77,
	MSM_MUX_tsif1___2 = 78,
	MSM_MUX_tsif2___2 = 79,
	MSM_MUX_ts_eoc = 80,
	MSM_MUX_usb_fs1___2 = 81,
	MSM_MUX_usb_fs1_oe = 82,
	MSM_MUX_usb_fs1_oe_n___2 = 83,
	MSM_MUX_usb_fs2___2 = 84,
	MSM_MUX_usb_fs2_oe = 85,
	MSM_MUX_usb_fs2_oe_n___2 = 86,
	MSM_MUX_vfe_camif_timer1_a = 87,
	MSM_MUX_vfe_camif_timer1_b = 88,
	MSM_MUX_vfe_camif_timer2 = 89,
	MSM_MUX_vfe_camif_timer3_a = 90,
	MSM_MUX_vfe_camif_timer3_b = 91,
	MSM_MUX_vfe_camif_timer4_a = 92,
	MSM_MUX_vfe_camif_timer4_b = 93,
	MSM_MUX_vfe_camif_timer4_c = 94,
	MSM_MUX_vfe_camif_timer5_a = 95,
	MSM_MUX_vfe_camif_timer5_b = 96,
	MSM_MUX_vfe_camif_timer6_a = 97,
	MSM_MUX_vfe_camif_timer6_b = 98,
	MSM_MUX_vfe_camif_timer6_c = 99,
	MSM_MUX_vfe_camif_timer7_a = 100,
	MSM_MUX_vfe_camif_timer7_b = 101,
	MSM_MUX_vfe_camif_timer7_c = 102,
	MSM_MUX_wlan = 103,
	MSM_MUX_NA = 104,
};

enum msm8x74_functions {
	MSM_MUX_gpio___3 = 0,
	MSM_MUX_cci_i2c0 = 1,
	MSM_MUX_cci_i2c1 = 2,
	MSM_MUX_blsp_i2c1 = 3,
	MSM_MUX_blsp_i2c2 = 4,
	MSM_MUX_blsp_i2c3 = 5,
	MSM_MUX_blsp_i2c4 = 6,
	MSM_MUX_blsp_i2c5 = 7,
	MSM_MUX_blsp_i2c6 = 8,
	MSM_MUX_blsp_i2c7 = 9,
	MSM_MUX_blsp_i2c8 = 10,
	MSM_MUX_blsp_i2c9 = 11,
	MSM_MUX_blsp_i2c10 = 12,
	MSM_MUX_blsp_i2c11 = 13,
	MSM_MUX_blsp_i2c12 = 14,
	MSM_MUX_blsp_spi1 = 15,
	MSM_MUX_blsp_spi1_cs1 = 16,
	MSM_MUX_blsp_spi1_cs2 = 17,
	MSM_MUX_blsp_spi1_cs3 = 18,
	MSM_MUX_blsp_spi2 = 19,
	MSM_MUX_blsp_spi2_cs1 = 20,
	MSM_MUX_blsp_spi2_cs2 = 21,
	MSM_MUX_blsp_spi2_cs3 = 22,
	MSM_MUX_blsp_spi3 = 23,
	MSM_MUX_blsp_spi4 = 24,
	MSM_MUX_blsp_spi5 = 25,
	MSM_MUX_blsp_spi6 = 26,
	MSM_MUX_blsp_spi7 = 27,
	MSM_MUX_blsp_spi8 = 28,
	MSM_MUX_blsp_spi9 = 29,
	MSM_MUX_blsp_spi10 = 30,
	MSM_MUX_blsp_spi10_cs1 = 31,
	MSM_MUX_blsp_spi10_cs2 = 32,
	MSM_MUX_blsp_spi10_cs3 = 33,
	MSM_MUX_blsp_spi11 = 34,
	MSM_MUX_blsp_spi12 = 35,
	MSM_MUX_blsp_uart1 = 36,
	MSM_MUX_blsp_uart2 = 37,
	MSM_MUX_blsp_uart3 = 38,
	MSM_MUX_blsp_uart4 = 39,
	MSM_MUX_blsp_uart5 = 40,
	MSM_MUX_blsp_uart6 = 41,
	MSM_MUX_blsp_uart7 = 42,
	MSM_MUX_blsp_uart8 = 43,
	MSM_MUX_blsp_uart9 = 44,
	MSM_MUX_blsp_uart10 = 45,
	MSM_MUX_blsp_uart11 = 46,
	MSM_MUX_blsp_uart12 = 47,
	MSM_MUX_blsp_uim1 = 48,
	MSM_MUX_blsp_uim2 = 49,
	MSM_MUX_blsp_uim3 = 50,
	MSM_MUX_blsp_uim4 = 51,
	MSM_MUX_blsp_uim5 = 52,
	MSM_MUX_blsp_uim6 = 53,
	MSM_MUX_blsp_uim7 = 54,
	MSM_MUX_blsp_uim8 = 55,
	MSM_MUX_blsp_uim9 = 56,
	MSM_MUX_blsp_uim10 = 57,
	MSM_MUX_blsp_uim11 = 58,
	MSM_MUX_blsp_uim12 = 59,
	MSM_MUX_uim1 = 60,
	MSM_MUX_uim2 = 61,
	MSM_MUX_uim_batt_alarm = 62,
	MSM_MUX_sdc3 = 63,
	MSM_MUX_sdc4___2 = 64,
	MSM_MUX_gcc_gp_clk1 = 65,
	MSM_MUX_gcc_gp_clk2 = 66,
	MSM_MUX_gcc_gp_clk3 = 67,
	MSM_MUX_qua_mi2s = 68,
	MSM_MUX_pri_mi2s = 69,
	MSM_MUX_spkr_mi2s = 70,
	MSM_MUX_ter_mi2s = 71,
	MSM_MUX_sec_mi2s = 72,
	MSM_MUX_hdmi_cec___2 = 73,
	MSM_MUX_hdmi_ddc = 74,
	MSM_MUX_hdmi_hpd = 75,
	MSM_MUX_edp_hpd = 76,
	MSM_MUX_mdp_vsync___3 = 77,
	MSM_MUX_cam_mclk0___2 = 78,
	MSM_MUX_cam_mclk1___2 = 79,
	MSM_MUX_cam_mclk2___2 = 80,
	MSM_MUX_cam_mclk3 = 81,
	MSM_MUX_cci_timer0 = 82,
	MSM_MUX_cci_timer1 = 83,
	MSM_MUX_cci_timer2 = 84,
	MSM_MUX_cci_timer3 = 85,
	MSM_MUX_cci_timer4 = 86,
	MSM_MUX_cci_async_in0 = 87,
	MSM_MUX_cci_async_in1 = 88,
	MSM_MUX_cci_async_in2 = 89,
	MSM_MUX_gp_pdm0 = 90,
	MSM_MUX_gp_pdm1 = 91,
	MSM_MUX_gp_pdm2 = 92,
	MSM_MUX_gp0_clk = 93,
	MSM_MUX_gp1_clk = 94,
	MSM_MUX_gp_mn___3 = 95,
	MSM_MUX_tsif1___3 = 96,
	MSM_MUX_tsif2___3 = 97,
	MSM_MUX_hsic___2 = 98,
	MSM_MUX_grfc = 99,
	MSM_MUX_audio_ref_clk = 100,
	MSM_MUX_bt___2 = 101,
	MSM_MUX_fm___2 = 102,
	MSM_MUX_wlan___2 = 103,
	MSM_MUX_slimbus = 104,
	MSM_MUX_hsic_ctl = 105,
	MSM_MUX_NA___2 = 106,
};

enum msm8916_functions {
	MSM_MUX_adsp_ext = 0,
	MSM_MUX_alsp_int = 1,
	MSM_MUX_atest_bbrx0 = 2,
	MSM_MUX_atest_bbrx1 = 3,
	MSM_MUX_atest_char = 4,
	MSM_MUX_atest_char0 = 5,
	MSM_MUX_atest_char1 = 6,
	MSM_MUX_atest_char2 = 7,
	MSM_MUX_atest_char3 = 8,
	MSM_MUX_atest_combodac = 9,
	MSM_MUX_atest_gpsadc0 = 10,
	MSM_MUX_atest_gpsadc1 = 11,
	MSM_MUX_atest_tsens = 12,
	MSM_MUX_atest_wlan0 = 13,
	MSM_MUX_atest_wlan1 = 14,
	MSM_MUX_backlight_en = 15,
	MSM_MUX_bimc_dte0 = 16,
	MSM_MUX_bimc_dte1 = 17,
	MSM_MUX_blsp_i2c1___2 = 18,
	MSM_MUX_blsp_i2c2___2 = 19,
	MSM_MUX_blsp_i2c3___2 = 20,
	MSM_MUX_blsp_i2c4___2 = 21,
	MSM_MUX_blsp_i2c5___2 = 22,
	MSM_MUX_blsp_i2c6___2 = 23,
	MSM_MUX_blsp_spi1___2 = 24,
	MSM_MUX_blsp_spi1_cs1___2 = 25,
	MSM_MUX_blsp_spi1_cs2___2 = 26,
	MSM_MUX_blsp_spi1_cs3___2 = 27,
	MSM_MUX_blsp_spi2___2 = 28,
	MSM_MUX_blsp_spi2_cs1___2 = 29,
	MSM_MUX_blsp_spi2_cs2___2 = 30,
	MSM_MUX_blsp_spi2_cs3___2 = 31,
	MSM_MUX_blsp_spi3___2 = 32,
	MSM_MUX_blsp_spi3_cs1 = 33,
	MSM_MUX_blsp_spi3_cs2 = 34,
	MSM_MUX_blsp_spi3_cs3 = 35,
	MSM_MUX_blsp_spi4___2 = 36,
	MSM_MUX_blsp_spi5___2 = 37,
	MSM_MUX_blsp_spi6___2 = 38,
	MSM_MUX_blsp_uart1___2 = 39,
	MSM_MUX_blsp_uart2___2 = 40,
	MSM_MUX_blsp_uim1___2 = 41,
	MSM_MUX_blsp_uim2___2 = 42,
	MSM_MUX_cam1_rst = 43,
	MSM_MUX_cam1_standby = 44,
	MSM_MUX_cam_mclk0___3 = 45,
	MSM_MUX_cam_mclk1___3 = 46,
	MSM_MUX_cci_async = 47,
	MSM_MUX_cci_i2c = 48,
	MSM_MUX_cci_timer0___2 = 49,
	MSM_MUX_cci_timer1___2 = 50,
	MSM_MUX_cci_timer2___2 = 51,
	MSM_MUX_cdc_pdm0 = 52,
	MSM_MUX_codec_mad = 53,
	MSM_MUX_dbg_out = 54,
	MSM_MUX_display_5v = 55,
	MSM_MUX_dmic0_clk = 56,
	MSM_MUX_dmic0_data = 57,
	MSM_MUX_dsi_rst = 58,
	MSM_MUX_ebi0_wrcdc = 59,
	MSM_MUX_euro_us = 60,
	MSM_MUX_ext_lpass = 61,
	MSM_MUX_flash_strobe = 62,
	MSM_MUX_gcc_gp1_clk_a = 63,
	MSM_MUX_gcc_gp1_clk_b = 64,
	MSM_MUX_gcc_gp2_clk_a = 65,
	MSM_MUX_gcc_gp2_clk_b = 66,
	MSM_MUX_gcc_gp3_clk_a = 67,
	MSM_MUX_gcc_gp3_clk_b = 68,
	MSM_MUX_gpio___4 = 69,
	MSM_MUX_gsm0_tx0 = 70,
	MSM_MUX_gsm0_tx1 = 71,
	MSM_MUX_gsm1_tx0 = 72,
	MSM_MUX_gsm1_tx1 = 73,
	MSM_MUX_gyro_accl = 74,
	MSM_MUX_kpsns0 = 75,
	MSM_MUX_kpsns1 = 76,
	MSM_MUX_kpsns2 = 77,
	MSM_MUX_ldo_en = 78,
	MSM_MUX_ldo_update = 79,
	MSM_MUX_mag_int = 80,
	MSM_MUX_mdp_vsync___4 = 81,
	MSM_MUX_modem_tsync = 82,
	MSM_MUX_m_voc = 83,
	MSM_MUX_nav_pps = 84,
	MSM_MUX_nav_tsync = 85,
	MSM_MUX_pa_indicator = 86,
	MSM_MUX_pbs0 = 87,
	MSM_MUX_pbs1 = 88,
	MSM_MUX_pbs2 = 89,
	MSM_MUX_pri_mi2s___2 = 90,
	MSM_MUX_pri_mi2s_ws = 91,
	MSM_MUX_prng_rosc = 92,
	MSM_MUX_pwr_crypto_enabled_a = 93,
	MSM_MUX_pwr_crypto_enabled_b = 94,
	MSM_MUX_pwr_modem_enabled_a = 95,
	MSM_MUX_pwr_modem_enabled_b = 96,
	MSM_MUX_pwr_nav_enabled_a = 97,
	MSM_MUX_pwr_nav_enabled_b = 98,
	MSM_MUX_qdss_ctitrig_in_a0 = 99,
	MSM_MUX_qdss_ctitrig_in_a1 = 100,
	MSM_MUX_qdss_ctitrig_in_b0 = 101,
	MSM_MUX_qdss_ctitrig_in_b1 = 102,
	MSM_MUX_qdss_ctitrig_out_a0 = 103,
	MSM_MUX_qdss_ctitrig_out_a1 = 104,
	MSM_MUX_qdss_ctitrig_out_b0 = 105,
	MSM_MUX_qdss_ctitrig_out_b1 = 106,
	MSM_MUX_qdss_traceclk_a = 107,
	MSM_MUX_qdss_traceclk_b = 108,
	MSM_MUX_qdss_tracectl_a = 109,
	MSM_MUX_qdss_tracectl_b = 110,
	MSM_MUX_qdss_tracedata_a = 111,
	MSM_MUX_qdss_tracedata_b = 112,
	MSM_MUX_reset_n = 113,
	MSM_MUX_sd_card = 114,
	MSM_MUX_sd_write = 115,
	MSM_MUX_sec_mi2s___2 = 116,
	MSM_MUX_smb_int = 117,
	MSM_MUX_ssbi_wtr0 = 118,
	MSM_MUX_ssbi_wtr1 = 119,
	MSM_MUX_uim1___2 = 120,
	MSM_MUX_uim2___2 = 121,
	MSM_MUX_uim3 = 122,
	MSM_MUX_uim_batt = 123,
	MSM_MUX_wcss_bt = 124,
	MSM_MUX_wcss_fm = 125,
	MSM_MUX_wcss_wlan = 126,
	MSM_MUX_webcam1_rst = 127,
	MSM_MUX_NA___3 = 128,
};

enum pmic_gpio_func_index {
	PMIC_GPIO_FUNC_INDEX_NORMAL = 0,
	PMIC_GPIO_FUNC_INDEX_PAIRED = 1,
	PMIC_GPIO_FUNC_INDEX_FUNC1 = 2,
	PMIC_GPIO_FUNC_INDEX_FUNC2 = 3,
	PMIC_GPIO_FUNC_INDEX_FUNC3 = 4,
	PMIC_GPIO_FUNC_INDEX_FUNC4 = 5,
	PMIC_GPIO_FUNC_INDEX_DTEST1 = 6,
	PMIC_GPIO_FUNC_INDEX_DTEST2 = 7,
	PMIC_GPIO_FUNC_INDEX_DTEST3 = 8,
	PMIC_GPIO_FUNC_INDEX_DTEST4 = 9,
};

struct pmic_gpio_pad {
	u16 base;
	bool is_enabled;
	bool out_value;
	bool have_buffer;
	bool output_enabled;
	bool input_enabled;
	bool analog_pass;
	bool lv_mv_type;
	unsigned int num_sources;
	unsigned int power_source;
	unsigned int buffer_type;
	unsigned int pullup;
	unsigned int strength;
	unsigned int function;
	unsigned int atest;
	unsigned int dtest_buffer;
};

struct pmic_gpio_state {
	struct device *dev;
	struct regmap *map;
	struct pinctrl_dev *ctrl;
	struct gpio_chip chip;
	struct irq_chip irq;
};

struct pmic_mpp_pad {
	u16 base;
	int irq;
	bool is_enabled;
	bool out_value;
	bool output_enabled;
	bool input_enabled;
	bool paired;
	bool has_pullup;
	unsigned int num_sources;
	unsigned int power_source;
	unsigned int amux_input;
	unsigned int aout_level;
	unsigned int pullup;
	unsigned int function;
	unsigned int drive_strength;
	unsigned int dtest;
};

struct pmic_mpp_state {
	struct device *dev;
	struct regmap *map;
	struct pinctrl_dev *ctrl;
	struct gpio_chip chip;
};

struct pm8xxx_pin_data {
	unsigned int reg;
	u8 power_source;
	u8 mode;
	bool open_drain;
	bool output_value;
	u8 bias;
	u8 pull_up_strength;
	u8 output_strength;
	bool disable;
	u8 function;
	bool inverted;
};

struct pm8xxx_gpio {
	struct device *dev;
	struct regmap *regmap;
	struct pinctrl_dev *pctrl;
	struct gpio_chip chip;
	struct pinctrl_desc desc;
	unsigned int npins;
};

struct pm8xxx_pin_data___2 {
	unsigned int reg;
	int irq;
	u8 mode;
	bool input;
	bool output;
	bool high_z;
	bool paired;
	bool output_value;
	u8 power_source;
	u8 dtest;
	u8 amux;
	u8 aout_level;
	u8 drive_strength;
	unsigned int pullup;
};

struct pm8xxx_mpp {
	struct device *dev;
	struct regmap *regmap;
	struct pinctrl_dev *pctrl;
	struct gpio_chip chip;
	struct pinctrl_desc desc;
	unsigned int npins;
};

enum {
	PINMUX_TYPE_NONE = 0,
	PINMUX_TYPE_FUNCTION = 1,
	PINMUX_TYPE_GPIO = 2,
	PINMUX_TYPE_OUTPUT = 3,
	PINMUX_TYPE_INPUT = 4,
};

struct sh_pfc_pin {
	const char *name;
	unsigned int configs;
	u16 pin;
	u16 enum_id;
};

struct sh_pfc_pin_group {
	const char *name;
	const unsigned int *pins;
	const unsigned int *mux;
	unsigned int nr_pins;
};

struct sh_pfc_function {
	const char *name;
	const char * const *groups;
	unsigned int nr_groups;
};

struct pinmux_cfg_reg {
	u32 reg;
	u8 reg_width;
	u8 field_width;
	const u16 *enum_ids;
	const u8 *var_field_width;
};

struct pinmux_drive_reg_field {
	u16 pin;
	u8 offset;
	u8 size;
};

struct pinmux_drive_reg {
	u32 reg;
	const struct pinmux_drive_reg_field fields[8];
};

struct pinmux_bias_reg {
	u32 puen;
	u32 pud;
	const u16 pins[32];
};

struct pinmux_ioctrl_reg {
	u32 reg;
};

struct pinmux_data_reg {
	u32 reg;
	u8 reg_width;
	const u16 *enum_ids;
};

struct pinmux_irq {
	const short int *gpios;
};

struct pinmux_range {
	u16 begin;
	u16 end;
	u16 force;
};

struct sh_pfc_window {
	phys_addr_t phys;
	void *virt;
	long unsigned int size;
};

struct sh_pfc_soc_info;

struct sh_pfc_pin_range;

struct sh_pfc_chip;

struct sh_pfc {
	struct device *dev;
	const struct sh_pfc_soc_info *info;
	spinlock_t lock;
	unsigned int num_windows;
	struct sh_pfc_window *windows;
	unsigned int num_irqs;
	unsigned int *irqs;
	struct sh_pfc_pin_range *ranges;
	unsigned int nr_ranges;
	unsigned int nr_gpio_pins;
	struct sh_pfc_chip *gpio;
	u32 *saved_regs;
};

struct sh_pfc_soc_operations;

struct sh_pfc_soc_info {
	const char *name;
	const struct sh_pfc_soc_operations *ops;
	struct pinmux_range input;
	struct pinmux_range output;
	const struct pinmux_irq *gpio_irq;
	unsigned int gpio_irq_size;
	struct pinmux_range function;
	const struct sh_pfc_pin *pins;
	unsigned int nr_pins;
	const struct sh_pfc_pin_group *groups;
	unsigned int nr_groups;
	const struct sh_pfc_function *functions;
	unsigned int nr_functions;
	const struct pinmux_cfg_reg *cfg_regs;
	const struct pinmux_drive_reg *drive_regs;
	const struct pinmux_bias_reg *bias_regs;
	const struct pinmux_ioctrl_reg *ioctrl_regs;
	const struct pinmux_data_reg *data_regs;
	const u16 *pinmux_data;
	unsigned int pinmux_data_size;
	u32 unlock_reg;
};

struct sh_pfc_pin_range {
	u16 start;
	u16 end;
};

struct sh_pfc_soc_operations {
	int (*init)(struct sh_pfc *);
	unsigned int (*get_bias)(struct sh_pfc *, unsigned int);
	void (*set_bias)(struct sh_pfc *, unsigned int, unsigned int);
	int (*pin_to_pocctrl)(struct sh_pfc *, unsigned int, u32 *);
};

struct sh_pfc_pin_config {
	u16 gpio_enabled: 1;
	u16 mux_mark: 15;
};

struct sh_pfc_pinctrl {
	struct pinctrl_dev *pctl;
	struct pinctrl_desc pctl_desc;
	struct sh_pfc *pfc;
	struct pinctrl_pin_desc *pins;
	struct sh_pfc_pin_config *configs;
	const char *func_prop_name;
	const char *groups_prop_name;
	const char *pins_prop_name;
};

struct sh_pfc_gpio_data_reg;

struct sh_pfc_gpio_pin;

struct sh_pfc_chip {
	struct sh_pfc *pfc;
	struct gpio_chip gpio_chip;
	struct sh_pfc_window *mem;
	struct sh_pfc_gpio_data_reg *regs;
	struct sh_pfc_gpio_pin *pins;
};

struct sh_pfc_gpio_data_reg {
	const struct pinmux_data_reg *info;
	u32 shadow;
};

struct sh_pfc_gpio_pin {
	u8 dbit;
	u8 dreg;
};

enum {
	PINMUX_RESERVED = 0,
	PINMUX_DATA_BEGIN = 1,
	PORT0_DATA = 2,
	PORT1_DATA = 3,
	PORT2_DATA = 4,
	PORT3_DATA = 5,
	PORT4_DATA = 6,
	PORT5_DATA = 7,
	PORT6_DATA = 8,
	PORT7_DATA = 9,
	PORT8_DATA = 10,
	PORT9_DATA = 11,
	PORT10_DATA = 12,
	PORT11_DATA = 13,
	PORT12_DATA = 14,
	PORT13_DATA = 15,
	PORT14_DATA = 16,
	PORT15_DATA = 17,
	PORT16_DATA = 18,
	PORT17_DATA = 19,
	PORT18_DATA = 20,
	PORT19_DATA = 21,
	PORT20_DATA = 22,
	PORT21_DATA = 23,
	PORT22_DATA = 24,
	PORT23_DATA = 25,
	PORT24_DATA = 26,
	PORT25_DATA = 27,
	PORT26_DATA = 28,
	PORT27_DATA = 29,
	PORT28_DATA = 30,
	PORT29_DATA = 31,
	PORT30_DATA = 32,
	PORT31_DATA = 33,
	PORT32_DATA = 34,
	PORT33_DATA = 35,
	PORT34_DATA = 36,
	PORT35_DATA = 37,
	PORT36_DATA = 38,
	PORT37_DATA = 39,
	PORT38_DATA = 40,
	PORT39_DATA = 41,
	PORT40_DATA = 42,
	PORT41_DATA = 43,
	PORT42_DATA = 44,
	PORT43_DATA = 45,
	PORT44_DATA = 46,
	PORT45_DATA = 47,
	PORT46_DATA = 48,
	PORT47_DATA = 49,
	PORT48_DATA = 50,
	PORT49_DATA = 51,
	PORT50_DATA = 52,
	PORT51_DATA = 53,
	PORT52_DATA = 54,
	PORT53_DATA = 55,
	PORT54_DATA = 56,
	PORT55_DATA = 57,
	PORT56_DATA = 58,
	PORT57_DATA = 59,
	PORT58_DATA = 60,
	PORT59_DATA = 61,
	PORT60_DATA = 62,
	PORT61_DATA = 63,
	PORT62_DATA = 64,
	PORT63_DATA = 65,
	PORT64_DATA = 66,
	PORT65_DATA = 67,
	PORT66_DATA = 68,
	PORT67_DATA = 69,
	PORT68_DATA = 70,
	PORT69_DATA = 71,
	PORT70_DATA = 72,
	PORT71_DATA = 73,
	PORT72_DATA = 74,
	PORT73_DATA = 75,
	PORT74_DATA = 76,
	PORT75_DATA = 77,
	PORT76_DATA = 78,
	PORT77_DATA = 79,
	PORT78_DATA = 80,
	PORT79_DATA = 81,
	PORT80_DATA = 82,
	PORT81_DATA = 83,
	PORT82_DATA = 84,
	PORT83_DATA = 85,
	PORT84_DATA = 86,
	PORT85_DATA = 87,
	PORT86_DATA = 88,
	PORT87_DATA = 89,
	PORT88_DATA = 90,
	PORT89_DATA = 91,
	PORT90_DATA = 92,
	PORT91_DATA = 93,
	PORT92_DATA = 94,
	PORT93_DATA = 95,
	PORT94_DATA = 96,
	PORT95_DATA = 97,
	PORT96_DATA = 98,
	PORT97_DATA = 99,
	PORT98_DATA = 100,
	PORT99_DATA = 101,
	PORT100_DATA = 102,
	PORT101_DATA = 103,
	PORT102_DATA = 104,
	PORT103_DATA = 105,
	PORT104_DATA = 106,
	PORT105_DATA = 107,
	PORT106_DATA = 108,
	PORT107_DATA = 109,
	PORT108_DATA = 110,
	PORT109_DATA = 111,
	PORT110_DATA = 112,
	PORT111_DATA = 113,
	PORT112_DATA = 114,
	PORT113_DATA = 115,
	PORT114_DATA = 116,
	PORT115_DATA = 117,
	PORT116_DATA = 118,
	PORT117_DATA = 119,
	PORT118_DATA = 120,
	PORT119_DATA = 121,
	PORT120_DATA = 122,
	PORT121_DATA = 123,
	PORT122_DATA = 124,
	PORT123_DATA = 125,
	PORT124_DATA = 126,
	PORT125_DATA = 127,
	PORT126_DATA = 128,
	PORT127_DATA = 129,
	PORT128_DATA = 130,
	PORT129_DATA = 131,
	PORT130_DATA = 132,
	PORT131_DATA = 133,
	PORT132_DATA = 134,
	PORT133_DATA = 135,
	PORT134_DATA = 136,
	PORT135_DATA = 137,
	PORT136_DATA = 138,
	PORT137_DATA = 139,
	PORT138_DATA = 140,
	PORT139_DATA = 141,
	PORT140_DATA = 142,
	PORT141_DATA = 143,
	PORT142_DATA = 144,
	PORT143_DATA = 145,
	PORT144_DATA = 146,
	PORT145_DATA = 147,
	PORT146_DATA = 148,
	PORT147_DATA = 149,
	PORT148_DATA = 150,
	PORT149_DATA = 151,
	PORT150_DATA = 152,
	PORT151_DATA = 153,
	PORT152_DATA = 154,
	PORT153_DATA = 155,
	PORT154_DATA = 156,
	PORT155_DATA = 157,
	PORT156_DATA = 158,
	PORT157_DATA = 159,
	PORT158_DATA = 160,
	PINMUX_DATA_END = 161,
	PINMUX_FUNCTION_BEGIN = 162,
	PORT0_FN = 163,
	PORT1_FN = 164,
	PORT2_FN = 165,
	PORT3_FN = 166,
	PORT4_FN = 167,
	PORT5_FN = 168,
	PORT6_FN = 169,
	PORT7_FN = 170,
	PORT8_FN = 171,
	PORT9_FN = 172,
	PORT10_FN = 173,
	PORT11_FN = 174,
	PORT12_FN = 175,
	PORT13_FN = 176,
	PORT14_FN = 177,
	PORT15_FN = 178,
	PORT16_FN = 179,
	PORT17_FN = 180,
	PORT18_FN = 181,
	PORT19_FN = 182,
	PORT20_FN = 183,
	PORT21_FN = 184,
	PORT22_FN = 185,
	PORT23_FN = 186,
	PORT24_FN = 187,
	PORT25_FN = 188,
	PORT26_FN = 189,
	PORT27_FN = 190,
	PORT28_FN = 191,
	PORT29_FN = 192,
	PORT30_FN = 193,
	PORT31_FN = 194,
	PORT32_FN = 195,
	PORT33_FN = 196,
	PORT34_FN = 197,
	PORT35_FN = 198,
	PORT36_FN = 199,
	PORT37_FN = 200,
	PORT38_FN = 201,
	PORT39_FN = 202,
	PORT40_FN = 203,
	PORT41_FN = 204,
	PORT42_FN = 205,
	PORT43_FN = 206,
	PORT44_FN = 207,
	PORT45_FN = 208,
	PORT46_FN = 209,
	PORT47_FN = 210,
	PORT48_FN = 211,
	PORT49_FN = 212,
	PORT50_FN = 213,
	PORT51_FN = 214,
	PORT52_FN = 215,
	PORT53_FN = 216,
	PORT54_FN = 217,
	PORT55_FN = 218,
	PORT56_FN = 219,
	PORT57_FN = 220,
	PORT58_FN = 221,
	PORT59_FN = 222,
	PORT60_FN = 223,
	PORT61_FN = 224,
	PORT62_FN = 225,
	PORT63_FN = 226,
	PORT64_FN = 227,
	PORT65_FN = 228,
	PORT66_FN = 229,
	PORT67_FN = 230,
	PORT68_FN = 231,
	PORT69_FN = 232,
	PORT70_FN = 233,
	PORT71_FN = 234,
	PORT72_FN = 235,
	PORT73_FN = 236,
	PORT74_FN = 237,
	PORT75_FN = 238,
	PORT76_FN = 239,
	PORT77_FN = 240,
	PORT78_FN = 241,
	PORT79_FN = 242,
	PORT80_FN = 243,
	PORT81_FN = 244,
	PORT82_FN = 245,
	PORT83_FN = 246,
	PORT84_FN = 247,
	PORT85_FN = 248,
	PORT86_FN = 249,
	PORT87_FN = 250,
	PORT88_FN = 251,
	PORT89_FN = 252,
	PORT90_FN = 253,
	PORT91_FN = 254,
	PORT92_FN = 255,
	PORT93_FN = 256,
	PORT94_FN = 257,
	PORT95_FN = 258,
	PORT96_FN = 259,
	PORT97_FN = 260,
	PORT98_FN = 261,
	PORT99_FN = 262,
	PORT100_FN = 263,
	PORT101_FN = 264,
	PORT102_FN = 265,
	PORT103_FN = 266,
	PORT104_FN = 267,
	PORT105_FN = 268,
	PORT106_FN = 269,
	PORT107_FN = 270,
	PORT108_FN = 271,
	PORT109_FN = 272,
	PORT110_FN = 273,
	PORT111_FN = 274,
	PORT112_FN = 275,
	PORT113_FN = 276,
	PORT114_FN = 277,
	PORT115_FN = 278,
	PORT116_FN = 279,
	PORT117_FN = 280,
	PORT118_FN = 281,
	PORT119_FN = 282,
	PORT120_FN = 283,
	PORT121_FN = 284,
	PORT122_FN = 285,
	PORT123_FN = 286,
	PORT124_FN = 287,
	PORT125_FN = 288,
	PORT126_FN = 289,
	PORT127_FN = 290,
	PORT128_FN = 291,
	PORT129_FN = 292,
	PORT130_FN = 293,
	PORT131_FN = 294,
	PORT132_FN = 295,
	PORT133_FN = 296,
	PORT134_FN = 297,
	PORT135_FN = 298,
	PORT136_FN = 299,
	PORT137_FN = 300,
	PORT138_FN = 301,
	PORT139_FN = 302,
	PORT140_FN = 303,
	PORT141_FN = 304,
	PORT142_FN = 305,
	PORT143_FN = 306,
	PORT144_FN = 307,
	PORT145_FN = 308,
	PORT146_FN = 309,
	PORT147_FN = 310,
	PORT148_FN = 311,
	PORT149_FN = 312,
	PORT150_FN = 313,
	PORT151_FN = 314,
	PORT152_FN = 315,
	PORT153_FN = 316,
	PORT154_FN = 317,
	PORT155_FN = 318,
	PORT156_FN = 319,
	PORT157_FN = 320,
	PORT158_FN = 321,
	FN_LCD3_1_0_PORT18 = 322,
	FN_LCD3_1_0_PORT20 = 323,
	FN_LCD3_1_0_PORT21 = 324,
	FN_LCD3_1_0_PORT22 = 325,
	FN_LCD3_1_0_PORT23 = 326,
	FN_JT_SEL = 327,
	FN_ERR_RST_REQB = 328,
	FN_REF_CLKO = 329,
	FN_EXT_CLKI = 330,
	FN_LCD3_PXCLKB = 331,
	FN_LCD3_9_8_PORT38 = 332,
	FN_LCD3_9_8_PORT39 = 333,
	FN_LCD3_11_10_PORT40 = 334,
	FN_LCD3_11_10_PORT41 = 335,
	FN_LCD3_11_10_PORT42 = 336,
	FN_LCD3_11_10_PORT43 = 337,
	FN_IIC_1_0_PORT46 = 338,
	FN_IIC_1_0_PORT47 = 339,
	FN_LCD3_R0 = 340,
	FN_LCD3_R1 = 341,
	FN_LCD3_R2 = 342,
	FN_LCD3_R3 = 343,
	FN_LCD3_R4 = 344,
	FN_LCD3_R5 = 345,
	FN_IIC0_SCL = 346,
	FN_IIC0_SDA = 347,
	FN_SD_CKI = 348,
	FN_SDI0_CKO = 349,
	FN_SDI0_CKI = 350,
	FN_SDI0_CMD = 351,
	FN_SDI0_DATA0 = 352,
	FN_SDI0_DATA1 = 353,
	FN_SDI0_DATA2 = 354,
	FN_SDI0_DATA3 = 355,
	FN_SDI0_DATA4 = 356,
	FN_SDI0_DATA5 = 357,
	FN_SDI0_DATA6 = 358,
	FN_SDI0_DATA7 = 359,
	FN_SDI1_CKO = 360,
	FN_SDI1_CKI = 361,
	FN_SDI1_CMD = 362,
	FN_AB_1_0_PORT71 = 363,
	FN_AB_1_0_PORT72 = 364,
	FN_AB_1_0_PORT73 = 365,
	FN_AB_1_0_PORT74 = 366,
	FN_AB_1_0_PORT75 = 367,
	FN_AB_1_0_PORT76 = 368,
	FN_AB_1_0_PORT77 = 369,
	FN_AB_1_0_PORT78 = 370,
	FN_AB_1_0_PORT79 = 371,
	FN_AB_1_0_PORT80 = 372,
	FN_AB_1_0_PORT81 = 373,
	FN_AB_1_0_PORT82 = 374,
	FN_AB_1_0_PORT83 = 375,
	FN_AB_1_0_PORT84 = 376,
	FN_AB_3_2_PORT85 = 377,
	FN_AB_3_2_PORT86 = 378,
	FN_AB_3_2_PORT87 = 379,
	FN_AB_3_2_PORT88 = 380,
	FN_AB_5_4_PORT89 = 381,
	FN_AB_5_4_PORT90 = 382,
	FN_AB_7_6_PORT91 = 383,
	FN_AB_7_6_PORT92 = 384,
	FN_AB_1_0_PORT93 = 385,
	FN_AB_1_0_PORT94 = 386,
	FN_AB_1_0_PORT95 = 387,
	FN_SDI1_DATA0 = 388,
	FN_SDI1_DATA1 = 389,
	FN_SDI1_DATA2 = 390,
	FN_SDI1_DATA3 = 391,
	FN_AB_CLK = 392,
	FN_AB_CSB0 = 393,
	FN_AB_CSB1 = 394,
	FN_AB_13_12_PORT104 = 395,
	FN_AB_13_12_PORT103 = 396,
	FN_AB_11_10_PORT102 = 397,
	FN_AB_11_10_PORT101 = 398,
	FN_AB_11_10_PORT100 = 399,
	FN_AB_9_8_PORT99 = 400,
	FN_AB_9_8_PORT98 = 401,
	FN_AB_9_8_PORT97 = 402,
	FN_USI_1_0_PORT109 = 403,
	FN_USI_1_0_PORT110 = 404,
	FN_USI_1_0_PORT111 = 405,
	FN_USI_1_0_PORT112 = 406,
	FN_USI_3_2_PORT113 = 407,
	FN_USI_3_2_PORT114 = 408,
	FN_USI_5_4_PORT115 = 409,
	FN_USI_5_4_PORT116 = 410,
	FN_USI_5_4_PORT117 = 411,
	FN_USI_5_4_PORT118 = 412,
	FN_USI_7_6_PORT119 = 413,
	FN_USI_9_8_PORT120 = 414,
	FN_USI_9_8_PORT121 = 415,
	FN_AB_A20 = 416,
	FN_USI0_CS1 = 417,
	FN_USI0_CS2 = 418,
	FN_USI1_DI = 419,
	FN_USI1_DO = 420,
	FN_NTSC_CLK = 421,
	FN_NTSC_DATA0 = 422,
	FN_NTSC_DATA1 = 423,
	FN_NTSC_DATA2 = 424,
	FN_NTSC_DATA3 = 425,
	FN_NTSC_DATA4 = 426,
	FN_HSI_1_0_PORT143 = 427,
	FN_HSI_1_0_PORT144 = 428,
	FN_HSI_1_0_PORT145 = 429,
	FN_HSI_1_0_PORT146 = 430,
	FN_HSI_1_0_PORT147 = 431,
	FN_HSI_1_0_PORT148 = 432,
	FN_HSI_1_0_PORT149 = 433,
	FN_HSI_1_0_PORT150 = 434,
	FN_UART_1_0_PORT157 = 435,
	FN_UART_1_0_PORT158 = 436,
	FN_NTSC_DATA5 = 437,
	FN_NTSC_DATA6 = 438,
	FN_NTSC_DATA7 = 439,
	FN_CAM_CLKO = 440,
	FN_CAM_CLKI = 441,
	FN_CAM_VS = 442,
	FN_CAM_HS = 443,
	FN_CAM_YUV0 = 444,
	FN_CAM_YUV1 = 445,
	FN_CAM_YUV2 = 446,
	FN_CAM_YUV3 = 447,
	FN_CAM_YUV4 = 448,
	FN_CAM_YUV5 = 449,
	FN_CAM_YUV6 = 450,
	FN_CAM_YUV7 = 451,
	FN_JT_TDO = 452,
	FN_JT_TDOEN = 453,
	FN_LOWPWR = 454,
	FN_USB_VBUS = 455,
	FN_UART1_RX = 456,
	FN_UART1_TX = 457,
	FN_SEL_LCD3_1_0_00 = 458,
	FN_SEL_LCD3_1_0_01 = 459,
	FN_SEL_LCD3_9_8_00 = 460,
	FN_SEL_LCD3_9_8_10 = 461,
	FN_SEL_LCD3_11_10_00 = 462,
	FN_SEL_LCD3_11_10_01 = 463,
	FN_SEL_LCD3_11_10_10 = 464,
	FN_SEL_IIC_1_0_00 = 465,
	FN_SEL_IIC_1_0_01 = 466,
	FN_SEL_AB_1_0_00 = 467,
	FN_SEL_AB_1_0_10 = 468,
	FN_SEL_AB_3_2_00 = 469,
	FN_SEL_AB_3_2_01 = 470,
	FN_SEL_AB_3_2_10 = 471,
	FN_SEL_AB_3_2_11 = 472,
	FN_SEL_AB_5_4_00 = 473,
	FN_SEL_AB_5_4_01 = 474,
	FN_SEL_AB_5_4_10 = 475,
	FN_SEL_AB_5_4_11 = 476,
	FN_SEL_AB_7_6_00 = 477,
	FN_SEL_AB_7_6_01 = 478,
	FN_SEL_AB_7_6_10 = 479,
	FN_SEL_AB_9_8_00 = 480,
	FN_SEL_AB_9_8_01 = 481,
	FN_SEL_AB_9_8_10 = 482,
	FN_SEL_AB_11_10_00 = 483,
	FN_SEL_AB_11_10_10 = 484,
	FN_SEL_AB_13_12_00 = 485,
	FN_SEL_AB_13_12_10 = 486,
	FN_SEL_USI_1_0_00 = 487,
	FN_SEL_USI_1_0_01 = 488,
	FN_SEL_USI_3_2_00 = 489,
	FN_SEL_USI_3_2_01 = 490,
	FN_SEL_USI_5_4_00 = 491,
	FN_SEL_USI_5_4_01 = 492,
	FN_SEL_USI_7_6_00 = 493,
	FN_SEL_USI_7_6_01 = 494,
	FN_SEL_USI_9_8_00 = 495,
	FN_SEL_USI_9_8_01 = 496,
	FN_SEL_HSI_1_0_00 = 497,
	FN_SEL_HSI_1_0_01 = 498,
	FN_SEL_UART_1_0_00 = 499,
	FN_SEL_UART_1_0_01 = 500,
	PINMUX_FUNCTION_END = 501,
	PINMUX_MARK_BEGIN = 502,
	JT_SEL_MARK = 503,
	ERR_RST_REQB_MARK = 504,
	REF_CLKO_MARK = 505,
	EXT_CLKI_MARK = 506,
	LCD3_PXCLKB_MARK = 507,
	SD_CKI_MARK = 508,
	LCD3_R0_MARK = 509,
	LCD3_R1_MARK = 510,
	LCD3_R2_MARK = 511,
	LCD3_R3_MARK = 512,
	LCD3_R4_MARK = 513,
	LCD3_R5_MARK = 514,
	IIC0_SCL_MARK = 515,
	IIC0_SDA_MARK = 516,
	SDI0_CKO_MARK = 517,
	SDI0_CKI_MARK = 518,
	SDI0_CMD_MARK = 519,
	SDI0_DATA0_MARK = 520,
	SDI0_DATA1_MARK = 521,
	SDI0_DATA2_MARK = 522,
	SDI0_DATA3_MARK = 523,
	SDI0_DATA4_MARK = 524,
	SDI0_DATA5_MARK = 525,
	SDI0_DATA6_MARK = 526,
	SDI0_DATA7_MARK = 527,
	SDI1_CKO_MARK = 528,
	SDI1_CKI_MARK = 529,
	SDI1_CMD_MARK = 530,
	SDI1_DATA0_MARK = 531,
	SDI1_DATA1_MARK = 532,
	SDI1_DATA2_MARK = 533,
	SDI1_DATA3_MARK = 534,
	AB_CLK_MARK = 535,
	AB_CSB0_MARK = 536,
	AB_CSB1_MARK = 537,
	AB_A20_MARK = 538,
	USI0_CS1_MARK = 539,
	USI0_CS2_MARK = 540,
	USI1_DI_MARK = 541,
	USI1_DO_MARK = 542,
	NTSC_CLK_MARK = 543,
	NTSC_DATA0_MARK = 544,
	NTSC_DATA1_MARK = 545,
	NTSC_DATA2_MARK = 546,
	NTSC_DATA3_MARK = 547,
	NTSC_DATA4_MARK = 548,
	NTSC_DATA5_MARK = 549,
	NTSC_DATA6_MARK = 550,
	NTSC_DATA7_MARK = 551,
	CAM_CLKO_MARK = 552,
	CAM_CLKI_MARK = 553,
	CAM_VS_MARK = 554,
	CAM_HS_MARK = 555,
	CAM_YUV0_MARK = 556,
	CAM_YUV1_MARK = 557,
	CAM_YUV2_MARK = 558,
	CAM_YUV3_MARK = 559,
	CAM_YUV4_MARK = 560,
	CAM_YUV5_MARK = 561,
	CAM_YUV6_MARK = 562,
	CAM_YUV7_MARK = 563,
	JT_TDO_MARK = 564,
	JT_TDOEN_MARK = 565,
	USB_VBUS_MARK = 566,
	LOWPWR_MARK = 567,
	UART1_RX_MARK = 568,
	UART1_TX_MARK = 569,
	LCD3_PXCLK_MARK = 570,
	LCD3_CLK_I_MARK = 571,
	LCD3_HS_MARK = 572,
	LCD3_VS_MARK = 573,
	LCD3_DE_MARK = 574,
	LCD3_R6_MARK = 575,
	LCD3_R7_MARK = 576,
	LCD3_G0_MARK = 577,
	LCD3_G1_MARK = 578,
	LCD3_G2_MARK = 579,
	LCD3_G3_MARK = 580,
	LCD3_G4_MARK = 581,
	LCD3_G5_MARK = 582,
	LCD3_G6_MARK = 583,
	LCD3_G7_MARK = 584,
	LCD3_B0_MARK = 585,
	LCD3_B1_MARK = 586,
	LCD3_B2_MARK = 587,
	LCD3_B3_MARK = 588,
	LCD3_B4_MARK = 589,
	LCD3_B5_MARK = 590,
	LCD3_B6_MARK = 591,
	LCD3_B7_MARK = 592,
	YUV3_CLK_O_MARK = 593,
	YUV3_CLK_I_MARK = 594,
	YUV3_HS_MARK = 595,
	YUV3_VS_MARK = 596,
	YUV3_DE_MARK = 597,
	YUV3_D0_MARK = 598,
	YUV3_D1_MARK = 599,
	YUV3_D2_MARK = 600,
	YUV3_D3_MARK = 601,
	YUV3_D4_MARK = 602,
	YUV3_D5_MARK = 603,
	YUV3_D6_MARK = 604,
	YUV3_D7_MARK = 605,
	YUV3_D8_MARK = 606,
	YUV3_D9_MARK = 607,
	YUV3_D10_MARK = 608,
	YUV3_D11_MARK = 609,
	YUV3_D12_MARK = 610,
	YUV3_D13_MARK = 611,
	YUV3_D14_MARK = 612,
	YUV3_D15_MARK = 613,
	TP33_CLK_MARK = 614,
	TP33_CTRL_MARK = 615,
	TP33_DATA0_MARK = 616,
	TP33_DATA1_MARK = 617,
	TP33_DATA2_MARK = 618,
	TP33_DATA3_MARK = 619,
	TP33_DATA4_MARK = 620,
	TP33_DATA5_MARK = 621,
	TP33_DATA6_MARK = 622,
	TP33_DATA7_MARK = 623,
	TP33_DATA8_MARK = 624,
	TP33_DATA9_MARK = 625,
	TP33_DATA10_MARK = 626,
	TP33_DATA11_MARK = 627,
	TP33_DATA12_MARK = 628,
	TP33_DATA13_MARK = 629,
	TP33_DATA14_MARK = 630,
	TP33_DATA15_MARK = 631,
	IIC1_SCL_MARK = 632,
	IIC1_SDA_MARK = 633,
	UART3_RX_MARK = 634,
	UART3_TX_MARK = 635,
	AB_CSB2_MARK = 636,
	AB_CSB3_MARK = 637,
	AB_RDB_MARK = 638,
	AB_WRB_MARK = 639,
	AB_WAIT_MARK = 640,
	AB_ADV_MARK = 641,
	AB_AD0_MARK = 642,
	AB_AD1_MARK = 643,
	AB_AD2_MARK = 644,
	AB_AD3_MARK = 645,
	AB_AD4_MARK = 646,
	AB_AD5_MARK = 647,
	AB_AD6_MARK = 648,
	AB_AD7_MARK = 649,
	AB_AD8_MARK = 650,
	AB_AD9_MARK = 651,
	AB_AD10_MARK = 652,
	AB_AD11_MARK = 653,
	AB_AD12_MARK = 654,
	AB_AD13_MARK = 655,
	AB_AD14_MARK = 656,
	AB_AD15_MARK = 657,
	AB_A17_MARK = 658,
	AB_A18_MARK = 659,
	AB_A19_MARK = 660,
	AB_A21_MARK = 661,
	AB_A22_MARK = 662,
	AB_A23_MARK = 663,
	AB_A24_MARK = 664,
	AB_A25_MARK = 665,
	AB_A26_MARK = 666,
	AB_A27_MARK = 667,
	AB_A28_MARK = 668,
	AB_BEN0_MARK = 669,
	AB_BEN1_MARK = 670,
	DTV_BCLK_A_MARK = 671,
	DTV_PSYNC_A_MARK = 672,
	DTV_VALID_A_MARK = 673,
	DTV_DATA_A_MARK = 674,
	SDI2_CKO_MARK = 675,
	SDI2_CKI_MARK = 676,
	SDI2_CMD_MARK = 677,
	SDI2_DATA0_MARK = 678,
	SDI2_DATA1_MARK = 679,
	SDI2_DATA2_MARK = 680,
	SDI2_DATA3_MARK = 681,
	CF_CSB0_MARK = 682,
	CF_CSB1_MARK = 683,
	CF_IORDB_MARK = 684,
	CF_IOWRB_MARK = 685,
	CF_IORDY_MARK = 686,
	CF_RESET_MARK = 687,
	CF_D00_MARK = 688,
	CF_D01_MARK = 689,
	CF_D02_MARK = 690,
	CF_D03_MARK = 691,
	CF_D04_MARK = 692,
	CF_D05_MARK = 693,
	CF_D06_MARK = 694,
	CF_D07_MARK = 695,
	CF_D08_MARK = 696,
	CF_D09_MARK = 697,
	CF_D10_MARK = 698,
	CF_D11_MARK = 699,
	CF_D12_MARK = 700,
	CF_D13_MARK = 701,
	CF_D14_MARK = 702,
	CF_D15_MARK = 703,
	CF_A00_MARK = 704,
	CF_A01_MARK = 705,
	CF_A02_MARK = 706,
	CF_INTRQ_MARK = 707,
	CF_INPACKB_MARK = 708,
	CF_CDB1_MARK = 709,
	CF_CDB2_MARK = 710,
	USI5_CLK_A_MARK = 711,
	USI5_DI_A_MARK = 712,
	USI5_DO_A_MARK = 713,
	USI5_CS0_A_MARK = 714,
	USI5_CS1_A_MARK = 715,
	USI5_CS2_A_MARK = 716,
	USI0_CS3_MARK = 717,
	USI0_CS4_MARK = 718,
	USI0_CS5_MARK = 719,
	USI0_CS6_MARK = 720,
	USI2_CLK_MARK = 721,
	USI2_DI_MARK = 722,
	USI2_DO_MARK = 723,
	USI2_CS0_MARK = 724,
	USI2_CS1_MARK = 725,
	USI2_CS2_MARK = 726,
	USI3_CLK_MARK = 727,
	USI3_DI_MARK = 728,
	USI3_DO_MARK = 729,
	USI3_CS0_MARK = 730,
	USI4_CLK_MARK = 731,
	USI4_DI_MARK = 732,
	USI4_DO_MARK = 733,
	USI4_CS0_MARK = 734,
	USI4_CS1_MARK = 735,
	PWM0_MARK = 736,
	PWM1_MARK = 737,
	DTV_BCLK_B_MARK = 738,
	DTV_PSYNC_B_MARK = 739,
	DTV_VALID_B_MARK = 740,
	DTV_DATA_B_MARK = 741,
	USI5_CLK_B_MARK = 742,
	USI5_DO_B_MARK = 743,
	USI5_CS0_B_MARK = 744,
	USI5_CS1_B_MARK = 745,
	USI5_CS2_B_MARK = 746,
	USI5_CS3_B_MARK = 747,
	USI5_CS4_B_MARK = 748,
	USI5_DI_B_MARK = 749,
	UART1_CTSB_MARK = 750,
	UART1_RTSB_MARK = 751,
	UART2_RX_MARK = 752,
	UART2_TX_MARK = 753,
	PINMUX_MARK_END = 754,
};

enum {
	PORT_LAST = 158,
	PIN_LCD3_B2 = 159,
	PIN_LCD3_B3 = 160,
	PIN_LCD3_B4 = 161,
	PIN_LCD3_B5 = 162,
	PIN_LCD3_B6 = 163,
	PIN_LCD3_B7 = 164,
	PIN_LCD3_G2 = 165,
	PIN_LCD3_G3 = 166,
	PIN_LCD3_G4 = 167,
	PIN_LCD3_G5 = 168,
	PIN_LCD3_G6 = 169,
	PIN_LCD3_G7 = 170,
};

enum {
	PINMUX_RESERVED___2 = 0,
	PINMUX_DATA_BEGIN___2 = 1,
	PORT0_DATA___2 = 2,
	PORT1_DATA___2 = 3,
	PORT2_DATA___2 = 4,
	PORT3_DATA___2 = 5,
	PORT4_DATA___2 = 6,
	PORT5_DATA___2 = 7,
	PORT6_DATA___2 = 8,
	PORT7_DATA___2 = 9,
	PORT8_DATA___2 = 10,
	PORT9_DATA___2 = 11,
	PORT10_DATA___2 = 12,
	PORT11_DATA___2 = 13,
	PORT12_DATA___2 = 14,
	PORT13_DATA___2 = 15,
	PORT14_DATA___2 = 16,
	PORT15_DATA___2 = 17,
	PORT16_DATA___2 = 18,
	PORT17_DATA___2 = 19,
	PORT18_DATA___2 = 20,
	PORT19_DATA___2 = 21,
	PORT20_DATA___2 = 22,
	PORT21_DATA___2 = 23,
	PORT22_DATA___2 = 24,
	PORT23_DATA___2 = 25,
	PORT24_DATA___2 = 26,
	PORT25_DATA___2 = 27,
	PORT26_DATA___2 = 28,
	PORT27_DATA___2 = 29,
	PORT28_DATA___2 = 30,
	PORT29_DATA___2 = 31,
	PORT30_DATA___2 = 32,
	PORT32_DATA___2 = 33,
	PORT33_DATA___2 = 34,
	PORT34_DATA___2 = 35,
	PORT35_DATA___2 = 36,
	PORT36_DATA___2 = 37,
	PORT37_DATA___2 = 38,
	PORT38_DATA___2 = 39,
	PORT39_DATA___2 = 40,
	PORT40_DATA___2 = 41,
	PORT64_DATA___2 = 42,
	PORT65_DATA___2 = 43,
	PORT66_DATA___2 = 44,
	PORT67_DATA___2 = 45,
	PORT68_DATA___2 = 46,
	PORT69_DATA___2 = 47,
	PORT70_DATA___2 = 48,
	PORT71_DATA___2 = 49,
	PORT72_DATA___2 = 50,
	PORT73_DATA___2 = 51,
	PORT74_DATA___2 = 52,
	PORT75_DATA___2 = 53,
	PORT76_DATA___2 = 54,
	PORT77_DATA___2 = 55,
	PORT78_DATA___2 = 56,
	PORT79_DATA___2 = 57,
	PORT80_DATA___2 = 58,
	PORT81_DATA___2 = 59,
	PORT82_DATA___2 = 60,
	PORT83_DATA___2 = 61,
	PORT84_DATA___2 = 62,
	PORT85_DATA___2 = 63,
	PORT96_DATA___2 = 64,
	PORT97_DATA___2 = 65,
	PORT98_DATA___2 = 66,
	PORT99_DATA___2 = 67,
	PORT100_DATA___2 = 68,
	PORT101_DATA___2 = 69,
	PORT102_DATA___2 = 70,
	PORT103_DATA___2 = 71,
	PORT104_DATA___2 = 72,
	PORT105_DATA___2 = 73,
	PORT106_DATA___2 = 74,
	PORT107_DATA___2 = 75,
	PORT108_DATA___2 = 76,
	PORT109_DATA___2 = 77,
	PORT110_DATA___2 = 78,
	PORT111_DATA___2 = 79,
	PORT112_DATA___2 = 80,
	PORT113_DATA___2 = 81,
	PORT114_DATA___2 = 82,
	PORT115_DATA___2 = 83,
	PORT116_DATA___2 = 84,
	PORT117_DATA___2 = 85,
	PORT118_DATA___2 = 86,
	PORT119_DATA___2 = 87,
	PORT120_DATA___2 = 88,
	PORT121_DATA___2 = 89,
	PORT122_DATA___2 = 90,
	PORT123_DATA___2 = 91,
	PORT124_DATA___2 = 92,
	PORT125_DATA___2 = 93,
	PORT126_DATA___2 = 94,
	PORT128_DATA___2 = 95,
	PORT129_DATA___2 = 96,
	PORT130_DATA___2 = 97,
	PORT131_DATA___2 = 98,
	PORT132_DATA___2 = 99,
	PORT133_DATA___2 = 100,
	PORT134_DATA___2 = 101,
	PORT160_DATA = 102,
	PORT161_DATA = 103,
	PORT162_DATA = 104,
	PORT163_DATA = 105,
	PORT164_DATA = 106,
	PORT165_DATA = 107,
	PORT166_DATA = 108,
	PORT167_DATA = 109,
	PORT168_DATA = 110,
	PORT169_DATA = 111,
	PORT170_DATA = 112,
	PORT171_DATA = 113,
	PORT172_DATA = 114,
	PORT173_DATA = 115,
	PORT174_DATA = 116,
	PORT175_DATA = 117,
	PORT176_DATA = 118,
	PORT177_DATA = 119,
	PORT178_DATA = 120,
	PORT192_DATA = 121,
	PORT193_DATA = 122,
	PORT194_DATA = 123,
	PORT195_DATA = 124,
	PORT196_DATA = 125,
	PORT197_DATA = 126,
	PORT198_DATA = 127,
	PORT199_DATA = 128,
	PORT200_DATA = 129,
	PORT201_DATA = 130,
	PORT202_DATA = 131,
	PORT203_DATA = 132,
	PORT204_DATA = 133,
	PORT205_DATA = 134,
	PORT206_DATA = 135,
	PORT207_DATA = 136,
	PORT208_DATA = 137,
	PORT209_DATA = 138,
	PORT210_DATA = 139,
	PORT211_DATA = 140,
	PORT212_DATA = 141,
	PORT213_DATA = 142,
	PORT214_DATA = 143,
	PORT215_DATA = 144,
	PORT216_DATA = 145,
	PORT217_DATA = 146,
	PORT218_DATA = 147,
	PORT219_DATA = 148,
	PORT220_DATA = 149,
	PORT221_DATA = 150,
	PORT222_DATA = 151,
	PORT224_DATA = 152,
	PORT225_DATA = 153,
	PORT226_DATA = 154,
	PORT227_DATA = 155,
	PORT228_DATA = 156,
	PORT229_DATA = 157,
	PORT230_DATA = 158,
	PORT231_DATA = 159,
	PORT232_DATA = 160,
	PORT233_DATA = 161,
	PORT234_DATA = 162,
	PORT235_DATA = 163,
	PORT236_DATA = 164,
	PORT237_DATA = 165,
	PORT238_DATA = 166,
	PORT239_DATA = 167,
	PORT240_DATA = 168,
	PORT241_DATA = 169,
	PORT242_DATA = 170,
	PORT243_DATA = 171,
	PORT244_DATA = 172,
	PORT245_DATA = 173,
	PORT246_DATA = 174,
	PORT247_DATA = 175,
	PORT248_DATA = 176,
	PORT249_DATA = 177,
	PORT250_DATA = 178,
	PORT256_DATA = 179,
	PORT257_DATA = 180,
	PORT258_DATA = 181,
	PORT259_DATA = 182,
	PORT260_DATA = 183,
	PORT261_DATA = 184,
	PORT262_DATA = 185,
	PORT263_DATA = 186,
	PORT264_DATA = 187,
	PORT265_DATA = 188,
	PORT266_DATA = 189,
	PORT267_DATA = 190,
	PORT268_DATA = 191,
	PORT269_DATA = 192,
	PORT270_DATA = 193,
	PORT271_DATA = 194,
	PORT272_DATA = 195,
	PORT273_DATA = 196,
	PORT274_DATA = 197,
	PORT275_DATA = 198,
	PORT276_DATA = 199,
	PORT277_DATA = 200,
	PORT278_DATA = 201,
	PORT279_DATA = 202,
	PORT280_DATA = 203,
	PORT281_DATA = 204,
	PORT282_DATA = 205,
	PORT283_DATA = 206,
	PORT288_DATA = 207,
	PORT289_DATA = 208,
	PORT290_DATA = 209,
	PORT291_DATA = 210,
	PORT292_DATA = 211,
	PORT293_DATA = 212,
	PORT294_DATA = 213,
	PORT295_DATA = 214,
	PORT296_DATA = 215,
	PORT297_DATA = 216,
	PORT298_DATA = 217,
	PORT299_DATA = 218,
	PORT300_DATA = 219,
	PORT301_DATA = 220,
	PORT302_DATA = 221,
	PORT303_DATA = 222,
	PORT304_DATA = 223,
	PORT305_DATA = 224,
	PORT306_DATA = 225,
	PORT307_DATA = 226,
	PORT308_DATA = 227,
	PORT320_DATA = 228,
	PORT321_DATA = 229,
	PORT322_DATA = 230,
	PORT323_DATA = 231,
	PORT324_DATA = 232,
	PORT325_DATA = 233,
	PORT326_DATA = 234,
	PORT327_DATA = 235,
	PORT328_DATA = 236,
	PORT329_DATA = 237,
	PINMUX_DATA_END___2 = 238,
	PINMUX_INPUT_BEGIN = 239,
	PORT0_IN = 240,
	PORT1_IN = 241,
	PORT2_IN = 242,
	PORT3_IN = 243,
	PORT4_IN = 244,
	PORT5_IN = 245,
	PORT6_IN = 246,
	PORT7_IN = 247,
	PORT8_IN = 248,
	PORT9_IN = 249,
	PORT10_IN = 250,
	PORT11_IN = 251,
	PORT12_IN = 252,
	PORT13_IN = 253,
	PORT14_IN = 254,
	PORT15_IN = 255,
	PORT16_IN = 256,
	PORT17_IN = 257,
	PORT18_IN = 258,
	PORT19_IN = 259,
	PORT20_IN = 260,
	PORT21_IN = 261,
	PORT22_IN = 262,
	PORT23_IN = 263,
	PORT24_IN = 264,
	PORT25_IN = 265,
	PORT26_IN = 266,
	PORT27_IN = 267,
	PORT28_IN = 268,
	PORT29_IN = 269,
	PORT30_IN = 270,
	PORT32_IN = 271,
	PORT33_IN = 272,
	PORT34_IN = 273,
	PORT35_IN = 274,
	PORT36_IN = 275,
	PORT37_IN = 276,
	PORT38_IN = 277,
	PORT39_IN = 278,
	PORT40_IN = 279,
	PORT64_IN = 280,
	PORT65_IN = 281,
	PORT66_IN = 282,
	PORT67_IN = 283,
	PORT68_IN = 284,
	PORT69_IN = 285,
	PORT70_IN = 286,
	PORT71_IN = 287,
	PORT72_IN = 288,
	PORT73_IN = 289,
	PORT74_IN = 290,
	PORT75_IN = 291,
	PORT76_IN = 292,
	PORT77_IN = 293,
	PORT78_IN = 294,
	PORT79_IN = 295,
	PORT80_IN = 296,
	PORT81_IN = 297,
	PORT82_IN = 298,
	PORT83_IN = 299,
	PORT84_IN = 300,
	PORT85_IN = 301,
	PORT96_IN = 302,
	PORT97_IN = 303,
	PORT98_IN = 304,
	PORT99_IN = 305,
	PORT100_IN = 306,
	PORT101_IN = 307,
	PORT102_IN = 308,
	PORT103_IN = 309,
	PORT104_IN = 310,
	PORT105_IN = 311,
	PORT106_IN = 312,
	PORT107_IN = 313,
	PORT108_IN = 314,
	PORT109_IN = 315,
	PORT110_IN = 316,
	PORT111_IN = 317,
	PORT112_IN = 318,
	PORT113_IN = 319,
	PORT114_IN = 320,
	PORT115_IN = 321,
	PORT116_IN = 322,
	PORT117_IN = 323,
	PORT118_IN = 324,
	PORT119_IN = 325,
	PORT120_IN = 326,
	PORT121_IN = 327,
	PORT122_IN = 328,
	PORT123_IN = 329,
	PORT124_IN = 330,
	PORT125_IN = 331,
	PORT126_IN = 332,
	PORT128_IN = 333,
	PORT129_IN = 334,
	PORT130_IN = 335,
	PORT131_IN = 336,
	PORT132_IN = 337,
	PORT133_IN = 338,
	PORT134_IN = 339,
	PORT160_IN = 340,
	PORT161_IN = 341,
	PORT162_IN = 342,
	PORT163_IN = 343,
	PORT164_IN = 344,
	PORT165_IN = 345,
	PORT166_IN = 346,
	PORT167_IN = 347,
	PORT168_IN = 348,
	PORT169_IN = 349,
	PORT170_IN = 350,
	PORT171_IN = 351,
	PORT172_IN = 352,
	PORT173_IN = 353,
	PORT174_IN = 354,
	PORT175_IN = 355,
	PORT176_IN = 356,
	PORT177_IN = 357,
	PORT178_IN = 358,
	PORT192_IN = 359,
	PORT193_IN = 360,
	PORT194_IN = 361,
	PORT195_IN = 362,
	PORT196_IN = 363,
	PORT197_IN = 364,
	PORT198_IN = 365,
	PORT199_IN = 366,
	PORT200_IN = 367,
	PORT201_IN = 368,
	PORT202_IN = 369,
	PORT203_IN = 370,
	PORT204_IN = 371,
	PORT205_IN = 372,
	PORT206_IN = 373,
	PORT207_IN = 374,
	PORT208_IN = 375,
	PORT209_IN = 376,
	PORT210_IN = 377,
	PORT211_IN = 378,
	PORT212_IN = 379,
	PORT213_IN = 380,
	PORT214_IN = 381,
	PORT215_IN = 382,
	PORT216_IN = 383,
	PORT217_IN = 384,
	PORT218_IN = 385,
	PORT219_IN = 386,
	PORT220_IN = 387,
	PORT221_IN = 388,
	PORT222_IN = 389,
	PORT224_IN = 390,
	PORT225_IN = 391,
	PORT226_IN = 392,
	PORT227_IN = 393,
	PORT228_IN = 394,
	PORT229_IN = 395,
	PORT230_IN = 396,
	PORT231_IN = 397,
	PORT232_IN = 398,
	PORT233_IN = 399,
	PORT234_IN = 400,
	PORT235_IN = 401,
	PORT236_IN = 402,
	PORT237_IN = 403,
	PORT238_IN = 404,
	PORT239_IN = 405,
	PORT240_IN = 406,
	PORT241_IN = 407,
	PORT242_IN = 408,
	PORT243_IN = 409,
	PORT244_IN = 410,
	PORT245_IN = 411,
	PORT246_IN = 412,
	PORT247_IN = 413,
	PORT248_IN = 414,
	PORT249_IN = 415,
	PORT250_IN = 416,
	PORT256_IN = 417,
	PORT257_IN = 418,
	PORT258_IN = 419,
	PORT259_IN = 420,
	PORT260_IN = 421,
	PORT261_IN = 422,
	PORT262_IN = 423,
	PORT263_IN = 424,
	PORT264_IN = 425,
	PORT265_IN = 426,
	PORT266_IN = 427,
	PORT267_IN = 428,
	PORT268_IN = 429,
	PORT269_IN = 430,
	PORT270_IN = 431,
	PORT271_IN = 432,
	PORT272_IN = 433,
	PORT273_IN = 434,
	PORT274_IN = 435,
	PORT275_IN = 436,
	PORT276_IN = 437,
	PORT277_IN = 438,
	PORT278_IN = 439,
	PORT279_IN = 440,
	PORT280_IN = 441,
	PORT281_IN = 442,
	PORT282_IN = 443,
	PORT283_IN = 444,
	PORT288_IN = 445,
	PORT289_IN = 446,
	PORT290_IN = 447,
	PORT291_IN = 448,
	PORT292_IN = 449,
	PORT293_IN = 450,
	PORT294_IN = 451,
	PORT295_IN = 452,
	PORT296_IN = 453,
	PORT297_IN = 454,
	PORT298_IN = 455,
	PORT299_IN = 456,
	PORT300_IN = 457,
	PORT301_IN = 458,
	PORT302_IN = 459,
	PORT303_IN = 460,
	PORT304_IN = 461,
	PORT305_IN = 462,
	PORT306_IN = 463,
	PORT307_IN = 464,
	PORT308_IN = 465,
	PORT320_IN = 466,
	PORT321_IN = 467,
	PORT322_IN = 468,
	PORT323_IN = 469,
	PORT324_IN = 470,
	PORT325_IN = 471,
	PORT326_IN = 472,
	PORT327_IN = 473,
	PORT328_IN = 474,
	PORT329_IN = 475,
	PINMUX_INPUT_END = 476,
	PINMUX_OUTPUT_BEGIN = 477,
	PORT0_OUT = 478,
	PORT1_OUT = 479,
	PORT2_OUT = 480,
	PORT3_OUT = 481,
	PORT4_OUT = 482,
	PORT5_OUT = 483,
	PORT6_OUT = 484,
	PORT7_OUT = 485,
	PORT8_OUT = 486,
	PORT9_OUT = 487,
	PORT10_OUT = 488,
	PORT11_OUT = 489,
	PORT12_OUT = 490,
	PORT13_OUT = 491,
	PORT14_OUT = 492,
	PORT15_OUT = 493,
	PORT16_OUT = 494,
	PORT17_OUT = 495,
	PORT18_OUT = 496,
	PORT19_OUT = 497,
	PORT20_OUT = 498,
	PORT21_OUT = 499,
	PORT22_OUT = 500,
	PORT23_OUT = 501,
	PORT24_OUT = 502,
	PORT25_OUT = 503,
	PORT26_OUT = 504,
	PORT27_OUT = 505,
	PORT28_OUT = 506,
	PORT29_OUT = 507,
	PORT30_OUT = 508,
	PORT32_OUT = 509,
	PORT33_OUT = 510,
	PORT34_OUT = 511,
	PORT35_OUT = 512,
	PORT36_OUT = 513,
	PORT37_OUT = 514,
	PORT38_OUT = 515,
	PORT39_OUT = 516,
	PORT40_OUT = 517,
	PORT64_OUT = 518,
	PORT65_OUT = 519,
	PORT66_OUT = 520,
	PORT67_OUT = 521,
	PORT68_OUT = 522,
	PORT69_OUT = 523,
	PORT70_OUT = 524,
	PORT71_OUT = 525,
	PORT72_OUT = 526,
	PORT73_OUT = 527,
	PORT74_OUT = 528,
	PORT75_OUT = 529,
	PORT76_OUT = 530,
	PORT77_OUT = 531,
	PORT78_OUT = 532,
	PORT79_OUT = 533,
	PORT80_OUT = 534,
	PORT81_OUT = 535,
	PORT82_OUT = 536,
	PORT83_OUT = 537,
	PORT84_OUT = 538,
	PORT85_OUT = 539,
	PORT96_OUT = 540,
	PORT97_OUT = 541,
	PORT98_OUT = 542,
	PORT99_OUT = 543,
	PORT100_OUT = 544,
	PORT101_OUT = 545,
	PORT102_OUT = 546,
	PORT103_OUT = 547,
	PORT104_OUT = 548,
	PORT105_OUT = 549,
	PORT106_OUT = 550,
	PORT107_OUT = 551,
	PORT108_OUT = 552,
	PORT109_OUT = 553,
	PORT110_OUT = 554,
	PORT111_OUT = 555,
	PORT112_OUT = 556,
	PORT113_OUT = 557,
	PORT114_OUT = 558,
	PORT115_OUT = 559,
	PORT116_OUT = 560,
	PORT117_OUT = 561,
	PORT118_OUT = 562,
	PORT119_OUT = 563,
	PORT120_OUT = 564,
	PORT121_OUT = 565,
	PORT122_OUT = 566,
	PORT123_OUT = 567,
	PORT124_OUT = 568,
	PORT125_OUT = 569,
	PORT126_OUT = 570,
	PORT128_OUT = 571,
	PORT129_OUT = 572,
	PORT130_OUT = 573,
	PORT131_OUT = 574,
	PORT132_OUT = 575,
	PORT133_OUT = 576,
	PORT134_OUT = 577,
	PORT160_OUT = 578,
	PORT161_OUT = 579,
	PORT162_OUT = 580,
	PORT163_OUT = 581,
	PORT164_OUT = 582,
	PORT165_OUT = 583,
	PORT166_OUT = 584,
	PORT167_OUT = 585,
	PORT168_OUT = 586,
	PORT169_OUT = 587,
	PORT170_OUT = 588,
	PORT171_OUT = 589,
	PORT172_OUT = 590,
	PORT173_OUT = 591,
	PORT174_OUT = 592,
	PORT175_OUT = 593,
	PORT176_OUT = 594,
	PORT177_OUT = 595,
	PORT178_OUT = 596,
	PORT192_OUT = 597,
	PORT193_OUT = 598,
	PORT194_OUT = 599,
	PORT195_OUT = 600,
	PORT196_OUT = 601,
	PORT197_OUT = 602,
	PORT198_OUT = 603,
	PORT199_OUT = 604,
	PORT200_OUT = 605,
	PORT201_OUT = 606,
	PORT202_OUT = 607,
	PORT203_OUT = 608,
	PORT204_OUT = 609,
	PORT205_OUT = 610,
	PORT206_OUT = 611,
	PORT207_OUT = 612,
	PORT208_OUT = 613,
	PORT209_OUT = 614,
	PORT210_OUT = 615,
	PORT211_OUT = 616,
	PORT212_OUT = 617,
	PORT213_OUT = 618,
	PORT214_OUT = 619,
	PORT215_OUT = 620,
	PORT216_OUT = 621,
	PORT217_OUT = 622,
	PORT218_OUT = 623,
	PORT219_OUT = 624,
	PORT220_OUT = 625,
	PORT221_OUT = 626,
	PORT222_OUT = 627,
	PORT224_OUT = 628,
	PORT225_OUT = 629,
	PORT226_OUT = 630,
	PORT227_OUT = 631,
	PORT228_OUT = 632,
	PORT229_OUT = 633,
	PORT230_OUT = 634,
	PORT231_OUT = 635,
	PORT232_OUT = 636,
	PORT233_OUT = 637,
	PORT234_OUT = 638,
	PORT235_OUT = 639,
	PORT236_OUT = 640,
	PORT237_OUT = 641,
	PORT238_OUT = 642,
	PORT239_OUT = 643,
	PORT240_OUT = 644,
	PORT241_OUT = 645,
	PORT242_OUT = 646,
	PORT243_OUT = 647,
	PORT244_OUT = 648,
	PORT245_OUT = 649,
	PORT246_OUT = 650,
	PORT247_OUT = 651,
	PORT248_OUT = 652,
	PORT249_OUT = 653,
	PORT250_OUT = 654,
	PORT256_OUT = 655,
	PORT257_OUT = 656,
	PORT258_OUT = 657,
	PORT259_OUT = 658,
	PORT260_OUT = 659,
	PORT261_OUT = 660,
	PORT262_OUT = 661,
	PORT263_OUT = 662,
	PORT264_OUT = 663,
	PORT265_OUT = 664,
	PORT266_OUT = 665,
	PORT267_OUT = 666,
	PORT268_OUT = 667,
	PORT269_OUT = 668,
	PORT270_OUT = 669,
	PORT271_OUT = 670,
	PORT272_OUT = 671,
	PORT273_OUT = 672,
	PORT274_OUT = 673,
	PORT275_OUT = 674,
	PORT276_OUT = 675,
	PORT277_OUT = 676,
	PORT278_OUT = 677,
	PORT279_OUT = 678,
	PORT280_OUT = 679,
	PORT281_OUT = 680,
	PORT282_OUT = 681,
	PORT283_OUT = 682,
	PORT288_OUT = 683,
	PORT289_OUT = 684,
	PORT290_OUT = 685,
	PORT291_OUT = 686,
	PORT292_OUT = 687,
	PORT293_OUT = 688,
	PORT294_OUT = 689,
	PORT295_OUT = 690,
	PORT296_OUT = 691,
	PORT297_OUT = 692,
	PORT298_OUT = 693,
	PORT299_OUT = 694,
	PORT300_OUT = 695,
	PORT301_OUT = 696,
	PORT302_OUT = 697,
	PORT303_OUT = 698,
	PORT304_OUT = 699,
	PORT305_OUT = 700,
	PORT306_OUT = 701,
	PORT307_OUT = 702,
	PORT308_OUT = 703,
	PORT320_OUT = 704,
	PORT321_OUT = 705,
	PORT322_OUT = 706,
	PORT323_OUT = 707,
	PORT324_OUT = 708,
	PORT325_OUT = 709,
	PORT326_OUT = 710,
	PORT327_OUT = 711,
	PORT328_OUT = 712,
	PORT329_OUT = 713,
	PINMUX_OUTPUT_END = 714,
	PINMUX_FUNCTION_BEGIN___2 = 715,
	PORT0_FN_IN = 716,
	PORT1_FN_IN = 717,
	PORT2_FN_IN = 718,
	PORT3_FN_IN = 719,
	PORT4_FN_IN = 720,
	PORT5_FN_IN = 721,
	PORT6_FN_IN = 722,
	PORT7_FN_IN = 723,
	PORT8_FN_IN = 724,
	PORT9_FN_IN = 725,
	PORT10_FN_IN = 726,
	PORT11_FN_IN = 727,
	PORT12_FN_IN = 728,
	PORT13_FN_IN = 729,
	PORT14_FN_IN = 730,
	PORT15_FN_IN = 731,
	PORT16_FN_IN = 732,
	PORT17_FN_IN = 733,
	PORT18_FN_IN = 734,
	PORT19_FN_IN = 735,
	PORT20_FN_IN = 736,
	PORT21_FN_IN = 737,
	PORT22_FN_IN = 738,
	PORT23_FN_IN = 739,
	PORT24_FN_IN = 740,
	PORT25_FN_IN = 741,
	PORT26_FN_IN = 742,
	PORT27_FN_IN = 743,
	PORT28_FN_IN = 744,
	PORT29_FN_IN = 745,
	PORT30_FN_IN = 746,
	PORT32_FN_IN = 747,
	PORT33_FN_IN = 748,
	PORT34_FN_IN = 749,
	PORT35_FN_IN = 750,
	PORT36_FN_IN = 751,
	PORT37_FN_IN = 752,
	PORT38_FN_IN = 753,
	PORT39_FN_IN = 754,
	PORT40_FN_IN = 755,
	PORT64_FN_IN = 756,
	PORT65_FN_IN = 757,
	PORT66_FN_IN = 758,
	PORT67_FN_IN = 759,
	PORT68_FN_IN = 760,
	PORT69_FN_IN = 761,
	PORT70_FN_IN = 762,
	PORT71_FN_IN = 763,
	PORT72_FN_IN = 764,
	PORT73_FN_IN = 765,
	PORT74_FN_IN = 766,
	PORT75_FN_IN = 767,
	PORT76_FN_IN = 768,
	PORT77_FN_IN = 769,
	PORT78_FN_IN = 770,
	PORT79_FN_IN = 771,
	PORT80_FN_IN = 772,
	PORT81_FN_IN = 773,
	PORT82_FN_IN = 774,
	PORT83_FN_IN = 775,
	PORT84_FN_IN = 776,
	PORT85_FN_IN = 777,
	PORT96_FN_IN = 778,
	PORT97_FN_IN = 779,
	PORT98_FN_IN = 780,
	PORT99_FN_IN = 781,
	PORT100_FN_IN = 782,
	PORT101_FN_IN = 783,
	PORT102_FN_IN = 784,
	PORT103_FN_IN = 785,
	PORT104_FN_IN = 786,
	PORT105_FN_IN = 787,
	PORT106_FN_IN = 788,
	PORT107_FN_IN = 789,
	PORT108_FN_IN = 790,
	PORT109_FN_IN = 791,
	PORT110_FN_IN = 792,
	PORT111_FN_IN = 793,
	PORT112_FN_IN = 794,
	PORT113_FN_IN = 795,
	PORT114_FN_IN = 796,
	PORT115_FN_IN = 797,
	PORT116_FN_IN = 798,
	PORT117_FN_IN = 799,
	PORT118_FN_IN = 800,
	PORT119_FN_IN = 801,
	PORT120_FN_IN = 802,
	PORT121_FN_IN = 803,
	PORT122_FN_IN = 804,
	PORT123_FN_IN = 805,
	PORT124_FN_IN = 806,
	PORT125_FN_IN = 807,
	PORT126_FN_IN = 808,
	PORT128_FN_IN = 809,
	PORT129_FN_IN = 810,
	PORT130_FN_IN = 811,
	PORT131_FN_IN = 812,
	PORT132_FN_IN = 813,
	PORT133_FN_IN = 814,
	PORT134_FN_IN = 815,
	PORT160_FN_IN = 816,
	PORT161_FN_IN = 817,
	PORT162_FN_IN = 818,
	PORT163_FN_IN = 819,
	PORT164_FN_IN = 820,
	PORT165_FN_IN = 821,
	PORT166_FN_IN = 822,
	PORT167_FN_IN = 823,
	PORT168_FN_IN = 824,
	PORT169_FN_IN = 825,
	PORT170_FN_IN = 826,
	PORT171_FN_IN = 827,
	PORT172_FN_IN = 828,
	PORT173_FN_IN = 829,
	PORT174_FN_IN = 830,
	PORT175_FN_IN = 831,
	PORT176_FN_IN = 832,
	PORT177_FN_IN = 833,
	PORT178_FN_IN = 834,
	PORT192_FN_IN = 835,
	PORT193_FN_IN = 836,
	PORT194_FN_IN = 837,
	PORT195_FN_IN = 838,
	PORT196_FN_IN = 839,
	PORT197_FN_IN = 840,
	PORT198_FN_IN = 841,
	PORT199_FN_IN = 842,
	PORT200_FN_IN = 843,
	PORT201_FN_IN = 844,
	PORT202_FN_IN = 845,
	PORT203_FN_IN = 846,
	PORT204_FN_IN = 847,
	PORT205_FN_IN = 848,
	PORT206_FN_IN = 849,
	PORT207_FN_IN = 850,
	PORT208_FN_IN = 851,
	PORT209_FN_IN = 852,
	PORT210_FN_IN = 853,
	PORT211_FN_IN = 854,
	PORT212_FN_IN = 855,
	PORT213_FN_IN = 856,
	PORT214_FN_IN = 857,
	PORT215_FN_IN = 858,
	PORT216_FN_IN = 859,
	PORT217_FN_IN = 860,
	PORT218_FN_IN = 861,
	PORT219_FN_IN = 862,
	PORT220_FN_IN = 863,
	PORT221_FN_IN = 864,
	PORT222_FN_IN = 865,
	PORT224_FN_IN = 866,
	PORT225_FN_IN = 867,
	PORT226_FN_IN = 868,
	PORT227_FN_IN = 869,
	PORT228_FN_IN = 870,
	PORT229_FN_IN = 871,
	PORT230_FN_IN = 872,
	PORT231_FN_IN = 873,
	PORT232_FN_IN = 874,
	PORT233_FN_IN = 875,
	PORT234_FN_IN = 876,
	PORT235_FN_IN = 877,
	PORT236_FN_IN = 878,
	PORT237_FN_IN = 879,
	PORT238_FN_IN = 880,
	PORT239_FN_IN = 881,
	PORT240_FN_IN = 882,
	PORT241_FN_IN = 883,
	PORT242_FN_IN = 884,
	PORT243_FN_IN = 885,
	PORT244_FN_IN = 886,
	PORT245_FN_IN = 887,
	PORT246_FN_IN = 888,
	PORT247_FN_IN = 889,
	PORT248_FN_IN = 890,
	PORT249_FN_IN = 891,
	PORT250_FN_IN = 892,
	PORT256_FN_IN = 893,
	PORT257_FN_IN = 894,
	PORT258_FN_IN = 895,
	PORT259_FN_IN = 896,
	PORT260_FN_IN = 897,
	PORT261_FN_IN = 898,
	PORT262_FN_IN = 899,
	PORT263_FN_IN = 900,
	PORT264_FN_IN = 901,
	PORT265_FN_IN = 902,
	PORT266_FN_IN = 903,
	PORT267_FN_IN = 904,
	PORT268_FN_IN = 905,
	PORT269_FN_IN = 906,
	PORT270_FN_IN = 907,
	PORT271_FN_IN = 908,
	PORT272_FN_IN = 909,
	PORT273_FN_IN = 910,
	PORT274_FN_IN = 911,
	PORT275_FN_IN = 912,
	PORT276_FN_IN = 913,
	PORT277_FN_IN = 914,
	PORT278_FN_IN = 915,
	PORT279_FN_IN = 916,
	PORT280_FN_IN = 917,
	PORT281_FN_IN = 918,
	PORT282_FN_IN = 919,
	PORT283_FN_IN = 920,
	PORT288_FN_IN = 921,
	PORT289_FN_IN = 922,
	PORT290_FN_IN = 923,
	PORT291_FN_IN = 924,
	PORT292_FN_IN = 925,
	PORT293_FN_IN = 926,
	PORT294_FN_IN = 927,
	PORT295_FN_IN = 928,
	PORT296_FN_IN = 929,
	PORT297_FN_IN = 930,
	PORT298_FN_IN = 931,
	PORT299_FN_IN = 932,
	PORT300_FN_IN = 933,
	PORT301_FN_IN = 934,
	PORT302_FN_IN = 935,
	PORT303_FN_IN = 936,
	PORT304_FN_IN = 937,
	PORT305_FN_IN = 938,
	PORT306_FN_IN = 939,
	PORT307_FN_IN = 940,
	PORT308_FN_IN = 941,
	PORT320_FN_IN = 942,
	PORT321_FN_IN = 943,
	PORT322_FN_IN = 944,
	PORT323_FN_IN = 945,
	PORT324_FN_IN = 946,
	PORT325_FN_IN = 947,
	PORT326_FN_IN = 948,
	PORT327_FN_IN = 949,
	PORT328_FN_IN = 950,
	PORT329_FN_IN = 951,
	PORT0_FN_OUT = 952,
	PORT1_FN_OUT = 953,
	PORT2_FN_OUT = 954,
	PORT3_FN_OUT = 955,
	PORT4_FN_OUT = 956,
	PORT5_FN_OUT = 957,
	PORT6_FN_OUT = 958,
	PORT7_FN_OUT = 959,
	PORT8_FN_OUT = 960,
	PORT9_FN_OUT = 961,
	PORT10_FN_OUT = 962,
	PORT11_FN_OUT = 963,
	PORT12_FN_OUT = 964,
	PORT13_FN_OUT = 965,
	PORT14_FN_OUT = 966,
	PORT15_FN_OUT = 967,
	PORT16_FN_OUT = 968,
	PORT17_FN_OUT = 969,
	PORT18_FN_OUT = 970,
	PORT19_FN_OUT = 971,
	PORT20_FN_OUT = 972,
	PORT21_FN_OUT = 973,
	PORT22_FN_OUT = 974,
	PORT23_FN_OUT = 975,
	PORT24_FN_OUT = 976,
	PORT25_FN_OUT = 977,
	PORT26_FN_OUT = 978,
	PORT27_FN_OUT = 979,
	PORT28_FN_OUT = 980,
	PORT29_FN_OUT = 981,
	PORT30_FN_OUT = 982,
	PORT32_FN_OUT = 983,
	PORT33_FN_OUT = 984,
	PORT34_FN_OUT = 985,
	PORT35_FN_OUT = 986,
	PORT36_FN_OUT = 987,
	PORT37_FN_OUT = 988,
	PORT38_FN_OUT = 989,
	PORT39_FN_OUT = 990,
	PORT40_FN_OUT = 991,
	PORT64_FN_OUT = 992,
	PORT65_FN_OUT = 993,
	PORT66_FN_OUT = 994,
	PORT67_FN_OUT = 995,
	PORT68_FN_OUT = 996,
	PORT69_FN_OUT = 997,
	PORT70_FN_OUT = 998,
	PORT71_FN_OUT = 999,
	PORT72_FN_OUT = 1000,
	PORT73_FN_OUT = 1001,
	PORT74_FN_OUT = 1002,
	PORT75_FN_OUT = 1003,
	PORT76_FN_OUT = 1004,
	PORT77_FN_OUT = 1005,
	PORT78_FN_OUT = 1006,
	PORT79_FN_OUT = 1007,
	PORT80_FN_OUT = 1008,
	PORT81_FN_OUT = 1009,
	PORT82_FN_OUT = 1010,
	PORT83_FN_OUT = 1011,
	PORT84_FN_OUT = 1012,
	PORT85_FN_OUT = 1013,
	PORT96_FN_OUT = 1014,
	PORT97_FN_OUT = 1015,
	PORT98_FN_OUT = 1016,
	PORT99_FN_OUT = 1017,
	PORT100_FN_OUT = 1018,
	PORT101_FN_OUT = 1019,
	PORT102_FN_OUT = 1020,
	PORT103_FN_OUT = 1021,
	PORT104_FN_OUT = 1022,
	PORT105_FN_OUT = 1023,
	PORT106_FN_OUT = 1024,
	PORT107_FN_OUT = 1025,
	PORT108_FN_OUT = 1026,
	PORT109_FN_OUT = 1027,
	PORT110_FN_OUT = 1028,
	PORT111_FN_OUT = 1029,
	PORT112_FN_OUT = 1030,
	PORT113_FN_OUT = 1031,
	PORT114_FN_OUT = 1032,
	PORT115_FN_OUT = 1033,
	PORT116_FN_OUT = 1034,
	PORT117_FN_OUT = 1035,
	PORT118_FN_OUT = 1036,
	PORT119_FN_OUT = 1037,
	PORT120_FN_OUT = 1038,
	PORT121_FN_OUT = 1039,
	PORT122_FN_OUT = 1040,
	PORT123_FN_OUT = 1041,
	PORT124_FN_OUT = 1042,
	PORT125_FN_OUT = 1043,
	PORT126_FN_OUT = 1044,
	PORT128_FN_OUT = 1045,
	PORT129_FN_OUT = 1046,
	PORT130_FN_OUT = 1047,
	PORT131_FN_OUT = 1048,
	PORT132_FN_OUT = 1049,
	PORT133_FN_OUT = 1050,
	PORT134_FN_OUT = 1051,
	PORT160_FN_OUT = 1052,
	PORT161_FN_OUT = 1053,
	PORT162_FN_OUT = 1054,
	PORT163_FN_OUT = 1055,
	PORT164_FN_OUT = 1056,
	PORT165_FN_OUT = 1057,
	PORT166_FN_OUT = 1058,
	PORT167_FN_OUT = 1059,
	PORT168_FN_OUT = 1060,
	PORT169_FN_OUT = 1061,
	PORT170_FN_OUT = 1062,
	PORT171_FN_OUT = 1063,
	PORT172_FN_OUT = 1064,
	PORT173_FN_OUT = 1065,
	PORT174_FN_OUT = 1066,
	PORT175_FN_OUT = 1067,
	PORT176_FN_OUT = 1068,
	PORT177_FN_OUT = 1069,
	PORT178_FN_OUT = 1070,
	PORT192_FN_OUT = 1071,
	PORT193_FN_OUT = 1072,
	PORT194_FN_OUT = 1073,
	PORT195_FN_OUT = 1074,
	PORT196_FN_OUT = 1075,
	PORT197_FN_OUT = 1076,
	PORT198_FN_OUT = 1077,
	PORT199_FN_OUT = 1078,
	PORT200_FN_OUT = 1079,
	PORT201_FN_OUT = 1080,
	PORT202_FN_OUT = 1081,
	PORT203_FN_OUT = 1082,
	PORT204_FN_OUT = 1083,
	PORT205_FN_OUT = 1084,
	PORT206_FN_OUT = 1085,
	PORT207_FN_OUT = 1086,
	PORT208_FN_OUT = 1087,
	PORT209_FN_OUT = 1088,
	PORT210_FN_OUT = 1089,
	PORT211_FN_OUT = 1090,
	PORT212_FN_OUT = 1091,
	PORT213_FN_OUT = 1092,
	PORT214_FN_OUT = 1093,
	PORT215_FN_OUT = 1094,
	PORT216_FN_OUT = 1095,
	PORT217_FN_OUT = 1096,
	PORT218_FN_OUT = 1097,
	PORT219_FN_OUT = 1098,
	PORT220_FN_OUT = 1099,
	PORT221_FN_OUT = 1100,
	PORT222_FN_OUT = 1101,
	PORT224_FN_OUT = 1102,
	PORT225_FN_OUT = 1103,
	PORT226_FN_OUT = 1104,
	PORT227_FN_OUT = 1105,
	PORT228_FN_OUT = 1106,
	PORT229_FN_OUT = 1107,
	PORT230_FN_OUT = 1108,
	PORT231_FN_OUT = 1109,
	PORT232_FN_OUT = 1110,
	PORT233_FN_OUT = 1111,
	PORT234_FN_OUT = 1112,
	PORT235_FN_OUT = 1113,
	PORT236_FN_OUT = 1114,
	PORT237_FN_OUT = 1115,
	PORT238_FN_OUT = 1116,
	PORT239_FN_OUT = 1117,
	PORT240_FN_OUT = 1118,
	PORT241_FN_OUT = 1119,
	PORT242_FN_OUT = 1120,
	PORT243_FN_OUT = 1121,
	PORT244_FN_OUT = 1122,
	PORT245_FN_OUT = 1123,
	PORT246_FN_OUT = 1124,
	PORT247_FN_OUT = 1125,
	PORT248_FN_OUT = 1126,
	PORT249_FN_OUT = 1127,
	PORT250_FN_OUT = 1128,
	PORT256_FN_OUT = 1129,
	PORT257_FN_OUT = 1130,
	PORT258_FN_OUT = 1131,
	PORT259_FN_OUT = 1132,
	PORT260_FN_OUT = 1133,
	PORT261_FN_OUT = 1134,
	PORT262_FN_OUT = 1135,
	PORT263_FN_OUT = 1136,
	PORT264_FN_OUT = 1137,
	PORT265_FN_OUT = 1138,
	PORT266_FN_OUT = 1139,
	PORT267_FN_OUT = 1140,
	PORT268_FN_OUT = 1141,
	PORT269_FN_OUT = 1142,
	PORT270_FN_OUT = 1143,
	PORT271_FN_OUT = 1144,
	PORT272_FN_OUT = 1145,
	PORT273_FN_OUT = 1146,
	PORT274_FN_OUT = 1147,
	PORT275_FN_OUT = 1148,
	PORT276_FN_OUT = 1149,
	PORT277_FN_OUT = 1150,
	PORT278_FN_OUT = 1151,
	PORT279_FN_OUT = 1152,
	PORT280_FN_OUT = 1153,
	PORT281_FN_OUT = 1154,
	PORT282_FN_OUT = 1155,
	PORT283_FN_OUT = 1156,
	PORT288_FN_OUT = 1157,
	PORT289_FN_OUT = 1158,
	PORT290_FN_OUT = 1159,
	PORT291_FN_OUT = 1160,
	PORT292_FN_OUT = 1161,
	PORT293_FN_OUT = 1162,
	PORT294_FN_OUT = 1163,
	PORT295_FN_OUT = 1164,
	PORT296_FN_OUT = 1165,
	PORT297_FN_OUT = 1166,
	PORT298_FN_OUT = 1167,
	PORT299_FN_OUT = 1168,
	PORT300_FN_OUT = 1169,
	PORT301_FN_OUT = 1170,
	PORT302_FN_OUT = 1171,
	PORT303_FN_OUT = 1172,
	PORT304_FN_OUT = 1173,
	PORT305_FN_OUT = 1174,
	PORT306_FN_OUT = 1175,
	PORT307_FN_OUT = 1176,
	PORT308_FN_OUT = 1177,
	PORT320_FN_OUT = 1178,
	PORT321_FN_OUT = 1179,
	PORT322_FN_OUT = 1180,
	PORT323_FN_OUT = 1181,
	PORT324_FN_OUT = 1182,
	PORT325_FN_OUT = 1183,
	PORT326_FN_OUT = 1184,
	PORT327_FN_OUT = 1185,
	PORT328_FN_OUT = 1186,
	PORT329_FN_OUT = 1187,
	PORT0_FN0 = 1188,
	PORT1_FN0 = 1189,
	PORT2_FN0 = 1190,
	PORT3_FN0 = 1191,
	PORT4_FN0 = 1192,
	PORT5_FN0 = 1193,
	PORT6_FN0 = 1194,
	PORT7_FN0 = 1195,
	PORT8_FN0 = 1196,
	PORT9_FN0 = 1197,
	PORT10_FN0 = 1198,
	PORT11_FN0 = 1199,
	PORT12_FN0 = 1200,
	PORT13_FN0 = 1201,
	PORT14_FN0 = 1202,
	PORT15_FN0 = 1203,
	PORT16_FN0 = 1204,
	PORT17_FN0 = 1205,
	PORT18_FN0 = 1206,
	PORT19_FN0 = 1207,
	PORT20_FN0 = 1208,
	PORT21_FN0 = 1209,
	PORT22_FN0 = 1210,
	PORT23_FN0 = 1211,
	PORT24_FN0 = 1212,
	PORT25_FN0 = 1213,
	PORT26_FN0 = 1214,
	PORT27_FN0 = 1215,
	PORT28_FN0 = 1216,
	PORT29_FN0 = 1217,
	PORT30_FN0 = 1218,
	PORT32_FN0 = 1219,
	PORT33_FN0 = 1220,
	PORT34_FN0 = 1221,
	PORT35_FN0 = 1222,
	PORT36_FN0 = 1223,
	PORT37_FN0 = 1224,
	PORT38_FN0 = 1225,
	PORT39_FN0 = 1226,
	PORT40_FN0 = 1227,
	PORT64_FN0 = 1228,
	PORT65_FN0 = 1229,
	PORT66_FN0 = 1230,
	PORT67_FN0 = 1231,
	PORT68_FN0 = 1232,
	PORT69_FN0 = 1233,
	PORT70_FN0 = 1234,
	PORT71_FN0 = 1235,
	PORT72_FN0 = 1236,
	PORT73_FN0 = 1237,
	PORT74_FN0 = 1238,
	PORT75_FN0 = 1239,
	PORT76_FN0 = 1240,
	PORT77_FN0 = 1241,
	PORT78_FN0 = 1242,
	PORT79_FN0 = 1243,
	PORT80_FN0 = 1244,
	PORT81_FN0 = 1245,
	PORT82_FN0 = 1246,
	PORT83_FN0 = 1247,
	PORT84_FN0 = 1248,
	PORT85_FN0 = 1249,
	PORT96_FN0 = 1250,
	PORT97_FN0 = 1251,
	PORT98_FN0 = 1252,
	PORT99_FN0 = 1253,
	PORT100_FN0 = 1254,
	PORT101_FN0 = 1255,
	PORT102_FN0 = 1256,
	PORT103_FN0 = 1257,
	PORT104_FN0 = 1258,
	PORT105_FN0 = 1259,
	PORT106_FN0 = 1260,
	PORT107_FN0 = 1261,
	PORT108_FN0 = 1262,
	PORT109_FN0 = 1263,
	PORT110_FN0 = 1264,
	PORT111_FN0 = 1265,
	PORT112_FN0 = 1266,
	PORT113_FN0 = 1267,
	PORT114_FN0 = 1268,
	PORT115_FN0 = 1269,
	PORT116_FN0 = 1270,
	PORT117_FN0 = 1271,
	PORT118_FN0 = 1272,
	PORT119_FN0 = 1273,
	PORT120_FN0 = 1274,
	PORT121_FN0 = 1275,
	PORT122_FN0 = 1276,
	PORT123_FN0 = 1277,
	PORT124_FN0 = 1278,
	PORT125_FN0 = 1279,
	PORT126_FN0 = 1280,
	PORT128_FN0 = 1281,
	PORT129_FN0 = 1282,
	PORT130_FN0 = 1283,
	PORT131_FN0 = 1284,
	PORT132_FN0 = 1285,
	PORT133_FN0 = 1286,
	PORT134_FN0 = 1287,
	PORT160_FN0 = 1288,
	PORT161_FN0 = 1289,
	PORT162_FN0 = 1290,
	PORT163_FN0 = 1291,
	PORT164_FN0 = 1292,
	PORT165_FN0 = 1293,
	PORT166_FN0 = 1294,
	PORT167_FN0 = 1295,
	PORT168_FN0 = 1296,
	PORT169_FN0 = 1297,
	PORT170_FN0 = 1298,
	PORT171_FN0 = 1299,
	PORT172_FN0 = 1300,
	PORT173_FN0 = 1301,
	PORT174_FN0 = 1302,
	PORT175_FN0 = 1303,
	PORT176_FN0 = 1304,
	PORT177_FN0 = 1305,
	PORT178_FN0 = 1306,
	PORT192_FN0 = 1307,
	PORT193_FN0 = 1308,
	PORT194_FN0 = 1309,
	PORT195_FN0 = 1310,
	PORT196_FN0 = 1311,
	PORT197_FN0 = 1312,
	PORT198_FN0 = 1313,
	PORT199_FN0 = 1314,
	PORT200_FN0 = 1315,
	PORT201_FN0 = 1316,
	PORT202_FN0 = 1317,
	PORT203_FN0 = 1318,
	PORT204_FN0 = 1319,
	PORT205_FN0 = 1320,
	PORT206_FN0 = 1321,
	PORT207_FN0 = 1322,
	PORT208_FN0 = 1323,
	PORT209_FN0 = 1324,
	PORT210_FN0 = 1325,
	PORT211_FN0 = 1326,
	PORT212_FN0 = 1327,
	PORT213_FN0 = 1328,
	PORT214_FN0 = 1329,
	PORT215_FN0 = 1330,
	PORT216_FN0 = 1331,
	PORT217_FN0 = 1332,
	PORT218_FN0 = 1333,
	PORT219_FN0 = 1334,
	PORT220_FN0 = 1335,
	PORT221_FN0 = 1336,
	PORT222_FN0 = 1337,
	PORT224_FN0 = 1338,
	PORT225_FN0 = 1339,
	PORT226_FN0 = 1340,
	PORT227_FN0 = 1341,
	PORT228_FN0 = 1342,
	PORT229_FN0 = 1343,
	PORT230_FN0 = 1344,
	PORT231_FN0 = 1345,
	PORT232_FN0 = 1346,
	PORT233_FN0 = 1347,
	PORT234_FN0 = 1348,
	PORT235_FN0 = 1349,
	PORT236_FN0 = 1350,
	PORT237_FN0 = 1351,
	PORT238_FN0 = 1352,
	PORT239_FN0 = 1353,
	PORT240_FN0 = 1354,
	PORT241_FN0 = 1355,
	PORT242_FN0 = 1356,
	PORT243_FN0 = 1357,
	PORT244_FN0 = 1358,
	PORT245_FN0 = 1359,
	PORT246_FN0 = 1360,
	PORT247_FN0 = 1361,
	PORT248_FN0 = 1362,
	PORT249_FN0 = 1363,
	PORT250_FN0 = 1364,
	PORT256_FN0 = 1365,
	PORT257_FN0 = 1366,
	PORT258_FN0 = 1367,
	PORT259_FN0 = 1368,
	PORT260_FN0 = 1369,
	PORT261_FN0 = 1370,
	PORT262_FN0 = 1371,
	PORT263_FN0 = 1372,
	PORT264_FN0 = 1373,
	PORT265_FN0 = 1374,
	PORT266_FN0 = 1375,
	PORT267_FN0 = 1376,
	PORT268_FN0 = 1377,
	PORT269_FN0 = 1378,
	PORT270_FN0 = 1379,
	PORT271_FN0 = 1380,
	PORT272_FN0 = 1381,
	PORT273_FN0 = 1382,
	PORT274_FN0 = 1383,
	PORT275_FN0 = 1384,
	PORT276_FN0 = 1385,
	PORT277_FN0 = 1386,
	PORT278_FN0 = 1387,
	PORT279_FN0 = 1388,
	PORT280_FN0 = 1389,
	PORT281_FN0 = 1390,
	PORT282_FN0 = 1391,
	PORT283_FN0 = 1392,
	PORT288_FN0 = 1393,
	PORT289_FN0 = 1394,
	PORT290_FN0 = 1395,
	PORT291_FN0 = 1396,
	PORT292_FN0 = 1397,
	PORT293_FN0 = 1398,
	PORT294_FN0 = 1399,
	PORT295_FN0 = 1400,
	PORT296_FN0 = 1401,
	PORT297_FN0 = 1402,
	PORT298_FN0 = 1403,
	PORT299_FN0 = 1404,
	PORT300_FN0 = 1405,
	PORT301_FN0 = 1406,
	PORT302_FN0 = 1407,
	PORT303_FN0 = 1408,
	PORT304_FN0 = 1409,
	PORT305_FN0 = 1410,
	PORT306_FN0 = 1411,
	PORT307_FN0 = 1412,
	PORT308_FN0 = 1413,
	PORT320_FN0 = 1414,
	PORT321_FN0 = 1415,
	PORT322_FN0 = 1416,
	PORT323_FN0 = 1417,
	PORT324_FN0 = 1418,
	PORT325_FN0 = 1419,
	PORT326_FN0 = 1420,
	PORT327_FN0 = 1421,
	PORT328_FN0 = 1422,
	PORT329_FN0 = 1423,
	PORT0_FN1 = 1424,
	PORT1_FN1 = 1425,
	PORT2_FN1 = 1426,
	PORT3_FN1 = 1427,
	PORT4_FN1 = 1428,
	PORT5_FN1 = 1429,
	PORT6_FN1 = 1430,
	PORT7_FN1 = 1431,
	PORT8_FN1 = 1432,
	PORT9_FN1 = 1433,
	PORT10_FN1 = 1434,
	PORT11_FN1 = 1435,
	PORT12_FN1 = 1436,
	PORT13_FN1 = 1437,
	PORT14_FN1 = 1438,
	PORT15_FN1 = 1439,
	PORT16_FN1 = 1440,
	PORT17_FN1 = 1441,
	PORT18_FN1 = 1442,
	PORT19_FN1 = 1443,
	PORT20_FN1 = 1444,
	PORT21_FN1 = 1445,
	PORT22_FN1 = 1446,
	PORT23_FN1 = 1447,
	PORT24_FN1 = 1448,
	PORT25_FN1 = 1449,
	PORT26_FN1 = 1450,
	PORT27_FN1 = 1451,
	PORT28_FN1 = 1452,
	PORT29_FN1 = 1453,
	PORT30_FN1 = 1454,
	PORT32_FN1 = 1455,
	PORT33_FN1 = 1456,
	PORT34_FN1 = 1457,
	PORT35_FN1 = 1458,
	PORT36_FN1 = 1459,
	PORT37_FN1 = 1460,
	PORT38_FN1 = 1461,
	PORT39_FN1 = 1462,
	PORT40_FN1 = 1463,
	PORT64_FN1 = 1464,
	PORT65_FN1 = 1465,
	PORT66_FN1 = 1466,
	PORT67_FN1 = 1467,
	PORT68_FN1 = 1468,
	PORT69_FN1 = 1469,
	PORT70_FN1 = 1470,
	PORT71_FN1 = 1471,
	PORT72_FN1 = 1472,
	PORT73_FN1 = 1473,
	PORT74_FN1 = 1474,
	PORT75_FN1 = 1475,
	PORT76_FN1 = 1476,
	PORT77_FN1 = 1477,
	PORT78_FN1 = 1478,
	PORT79_FN1 = 1479,
	PORT80_FN1 = 1480,
	PORT81_FN1 = 1481,
	PORT82_FN1 = 1482,
	PORT83_FN1 = 1483,
	PORT84_FN1 = 1484,
	PORT85_FN1 = 1485,
	PORT96_FN1 = 1486,
	PORT97_FN1 = 1487,
	PORT98_FN1 = 1488,
	PORT99_FN1 = 1489,
	PORT100_FN1 = 1490,
	PORT101_FN1 = 1491,
	PORT102_FN1 = 1492,
	PORT103_FN1 = 1493,
	PORT104_FN1 = 1494,
	PORT105_FN1 = 1495,
	PORT106_FN1 = 1496,
	PORT107_FN1 = 1497,
	PORT108_FN1 = 1498,
	PORT109_FN1 = 1499,
	PORT110_FN1 = 1500,
	PORT111_FN1 = 1501,
	PORT112_FN1 = 1502,
	PORT113_FN1 = 1503,
	PORT114_FN1 = 1504,
	PORT115_FN1 = 1505,
	PORT116_FN1 = 1506,
	PORT117_FN1 = 1507,
	PORT118_FN1 = 1508,
	PORT119_FN1 = 1509,
	PORT120_FN1 = 1510,
	PORT121_FN1 = 1511,
	PORT122_FN1 = 1512,
	PORT123_FN1 = 1513,
	PORT124_FN1 = 1514,
	PORT125_FN1 = 1515,
	PORT126_FN1 = 1516,
	PORT128_FN1 = 1517,
	PORT129_FN1 = 1518,
	PORT130_FN1 = 1519,
	PORT131_FN1 = 1520,
	PORT132_FN1 = 1521,
	PORT133_FN1 = 1522,
	PORT134_FN1 = 1523,
	PORT160_FN1 = 1524,
	PORT161_FN1 = 1525,
	PORT162_FN1 = 1526,
	PORT163_FN1 = 1527,
	PORT164_FN1 = 1528,
	PORT165_FN1 = 1529,
	PORT166_FN1 = 1530,
	PORT167_FN1 = 1531,
	PORT168_FN1 = 1532,
	PORT169_FN1 = 1533,
	PORT170_FN1 = 1534,
	PORT171_FN1 = 1535,
	PORT172_FN1 = 1536,
	PORT173_FN1 = 1537,
	PORT174_FN1 = 1538,
	PORT175_FN1 = 1539,
	PORT176_FN1 = 1540,
	PORT177_FN1 = 1541,
	PORT178_FN1 = 1542,
	PORT192_FN1 = 1543,
	PORT193_FN1 = 1544,
	PORT194_FN1 = 1545,
	PORT195_FN1 = 1546,
	PORT196_FN1 = 1547,
	PORT197_FN1 = 1548,
	PORT198_FN1 = 1549,
	PORT199_FN1 = 1550,
	PORT200_FN1 = 1551,
	PORT201_FN1 = 1552,
	PORT202_FN1 = 1553,
	PORT203_FN1 = 1554,
	PORT204_FN1 = 1555,
	PORT205_FN1 = 1556,
	PORT206_FN1 = 1557,
	PORT207_FN1 = 1558,
	PORT208_FN1 = 1559,
	PORT209_FN1 = 1560,
	PORT210_FN1 = 1561,
	PORT211_FN1 = 1562,
	PORT212_FN1 = 1563,
	PORT213_FN1 = 1564,
	PORT214_FN1 = 1565,
	PORT215_FN1 = 1566,
	PORT216_FN1 = 1567,
	PORT217_FN1 = 1568,
	PORT218_FN1 = 1569,
	PORT219_FN1 = 1570,
	PORT220_FN1 = 1571,
	PORT221_FN1 = 1572,
	PORT222_FN1 = 1573,
	PORT224_FN1 = 1574,
	PORT225_FN1 = 1575,
	PORT226_FN1 = 1576,
	PORT227_FN1 = 1577,
	PORT228_FN1 = 1578,
	PORT229_FN1 = 1579,
	PORT230_FN1 = 1580,
	PORT231_FN1 = 1581,
	PORT232_FN1 = 1582,
	PORT233_FN1 = 1583,
	PORT234_FN1 = 1584,
	PORT235_FN1 = 1585,
	PORT236_FN1 = 1586,
	PORT237_FN1 = 1587,
	PORT238_FN1 = 1588,
	PORT239_FN1 = 1589,
	PORT240_FN1 = 1590,
	PORT241_FN1 = 1591,
	PORT242_FN1 = 1592,
	PORT243_FN1 = 1593,
	PORT244_FN1 = 1594,
	PORT245_FN1 = 1595,
	PORT246_FN1 = 1596,
	PORT247_FN1 = 1597,
	PORT248_FN1 = 1598,
	PORT249_FN1 = 1599,
	PORT250_FN1 = 1600,
	PORT256_FN1 = 1601,
	PORT257_FN1 = 1602,
	PORT258_FN1 = 1603,
	PORT259_FN1 = 1604,
	PORT260_FN1 = 1605,
	PORT261_FN1 = 1606,
	PORT262_FN1 = 1607,
	PORT263_FN1 = 1608,
	PORT264_FN1 = 1609,
	PORT265_FN1 = 1610,
	PORT266_FN1 = 1611,
	PORT267_FN1 = 1612,
	PORT268_FN1 = 1613,
	PORT269_FN1 = 1614,
	PORT270_FN1 = 1615,
	PORT271_FN1 = 1616,
	PORT272_FN1 = 1617,
	PORT273_FN1 = 1618,
	PORT274_FN1 = 1619,
	PORT275_FN1 = 1620,
	PORT276_FN1 = 1621,
	PORT277_FN1 = 1622,
	PORT278_FN1 = 1623,
	PORT279_FN1 = 1624,
	PORT280_FN1 = 1625,
	PORT281_FN1 = 1626,
	PORT282_FN1 = 1627,
	PORT283_FN1 = 1628,
	PORT288_FN1 = 1629,
	PORT289_FN1 = 1630,
	PORT290_FN1 = 1631,
	PORT291_FN1 = 1632,
	PORT292_FN1 = 1633,
	PORT293_FN1 = 1634,
	PORT294_FN1 = 1635,
	PORT295_FN1 = 1636,
	PORT296_FN1 = 1637,
	PORT297_FN1 = 1638,
	PORT298_FN1 = 1639,
	PORT299_FN1 = 1640,
	PORT300_FN1 = 1641,
	PORT301_FN1 = 1642,
	PORT302_FN1 = 1643,
	PORT303_FN1 = 1644,
	PORT304_FN1 = 1645,
	PORT305_FN1 = 1646,
	PORT306_FN1 = 1647,
	PORT307_FN1 = 1648,
	PORT308_FN1 = 1649,
	PORT320_FN1 = 1650,
	PORT321_FN1 = 1651,
	PORT322_FN1 = 1652,
	PORT323_FN1 = 1653,
	PORT324_FN1 = 1654,
	PORT325_FN1 = 1655,
	PORT326_FN1 = 1656,
	PORT327_FN1 = 1657,
	PORT328_FN1 = 1658,
	PORT329_FN1 = 1659,
	PORT0_FN2 = 1660,
	PORT1_FN2 = 1661,
	PORT2_FN2 = 1662,
	PORT3_FN2 = 1663,
	PORT4_FN2 = 1664,
	PORT5_FN2 = 1665,
	PORT6_FN2 = 1666,
	PORT7_FN2 = 1667,
	PORT8_FN2 = 1668,
	PORT9_FN2 = 1669,
	PORT10_FN2 = 1670,
	PORT11_FN2 = 1671,
	PORT12_FN2 = 1672,
	PORT13_FN2 = 1673,
	PORT14_FN2 = 1674,
	PORT15_FN2 = 1675,
	PORT16_FN2 = 1676,
	PORT17_FN2 = 1677,
	PORT18_FN2 = 1678,
	PORT19_FN2 = 1679,
	PORT20_FN2 = 1680,
	PORT21_FN2 = 1681,
	PORT22_FN2 = 1682,
	PORT23_FN2 = 1683,
	PORT24_FN2 = 1684,
	PORT25_FN2 = 1685,
	PORT26_FN2 = 1686,
	PORT27_FN2 = 1687,
	PORT28_FN2 = 1688,
	PORT29_FN2 = 1689,
	PORT30_FN2 = 1690,
	PORT32_FN2 = 1691,
	PORT33_FN2 = 1692,
	PORT34_FN2 = 1693,
	PORT35_FN2 = 1694,
	PORT36_FN2 = 1695,
	PORT37_FN2 = 1696,
	PORT38_FN2 = 1697,
	PORT39_FN2 = 1698,
	PORT40_FN2 = 1699,
	PORT64_FN2 = 1700,
	PORT65_FN2 = 1701,
	PORT66_FN2 = 1702,
	PORT67_FN2 = 1703,
	PORT68_FN2 = 1704,
	PORT69_FN2 = 1705,
	PORT70_FN2 = 1706,
	PORT71_FN2 = 1707,
	PORT72_FN2 = 1708,
	PORT73_FN2 = 1709,
	PORT74_FN2 = 1710,
	PORT75_FN2 = 1711,
	PORT76_FN2 = 1712,
	PORT77_FN2 = 1713,
	PORT78_FN2 = 1714,
	PORT79_FN2 = 1715,
	PORT80_FN2 = 1716,
	PORT81_FN2 = 1717,
	PORT82_FN2 = 1718,
	PORT83_FN2 = 1719,
	PORT84_FN2 = 1720,
	PORT85_FN2 = 1721,
	PORT96_FN2 = 1722,
	PORT97_FN2 = 1723,
	PORT98_FN2 = 1724,
	PORT99_FN2 = 1725,
	PORT100_FN2 = 1726,
	PORT101_FN2 = 1727,
	PORT102_FN2 = 1728,
	PORT103_FN2 = 1729,
	PORT104_FN2 = 1730,
	PORT105_FN2 = 1731,
	PORT106_FN2 = 1732,
	PORT107_FN2 = 1733,
	PORT108_FN2 = 1734,
	PORT109_FN2 = 1735,
	PORT110_FN2 = 1736,
	PORT111_FN2 = 1737,
	PORT112_FN2 = 1738,
	PORT113_FN2 = 1739,
	PORT114_FN2 = 1740,
	PORT115_FN2 = 1741,
	PORT116_FN2 = 1742,
	PORT117_FN2 = 1743,
	PORT118_FN2 = 1744,
	PORT119_FN2 = 1745,
	PORT120_FN2 = 1746,
	PORT121_FN2 = 1747,
	PORT122_FN2 = 1748,
	PORT123_FN2 = 1749,
	PORT124_FN2 = 1750,
	PORT125_FN2 = 1751,
	PORT126_FN2 = 1752,
	PORT128_FN2 = 1753,
	PORT129_FN2 = 1754,
	PORT130_FN2 = 1755,
	PORT131_FN2 = 1756,
	PORT132_FN2 = 1757,
	PORT133_FN2 = 1758,
	PORT134_FN2 = 1759,
	PORT160_FN2 = 1760,
	PORT161_FN2 = 1761,
	PORT162_FN2 = 1762,
	PORT163_FN2 = 1763,
	PORT164_FN2 = 1764,
	PORT165_FN2 = 1765,
	PORT166_FN2 = 1766,
	PORT167_FN2 = 1767,
	PORT168_FN2 = 1768,
	PORT169_FN2 = 1769,
	PORT170_FN2 = 1770,
	PORT171_FN2 = 1771,
	PORT172_FN2 = 1772,
	PORT173_FN2 = 1773,
	PORT174_FN2 = 1774,
	PORT175_FN2 = 1775,
	PORT176_FN2 = 1776,
	PORT177_FN2 = 1777,
	PORT178_FN2 = 1778,
	PORT192_FN2 = 1779,
	PORT193_FN2 = 1780,
	PORT194_FN2 = 1781,
	PORT195_FN2 = 1782,
	PORT196_FN2 = 1783,
	PORT197_FN2 = 1784,
	PORT198_FN2 = 1785,
	PORT199_FN2 = 1786,
	PORT200_FN2 = 1787,
	PORT201_FN2 = 1788,
	PORT202_FN2 = 1789,
	PORT203_FN2 = 1790,
	PORT204_FN2 = 1791,
	PORT205_FN2 = 1792,
	PORT206_FN2 = 1793,
	PORT207_FN2 = 1794,
	PORT208_FN2 = 1795,
	PORT209_FN2 = 1796,
	PORT210_FN2 = 1797,
	PORT211_FN2 = 1798,
	PORT212_FN2 = 1799,
	PORT213_FN2 = 1800,
	PORT214_FN2 = 1801,
	PORT215_FN2 = 1802,
	PORT216_FN2 = 1803,
	PORT217_FN2 = 1804,
	PORT218_FN2 = 1805,
	PORT219_FN2 = 1806,
	PORT220_FN2 = 1807,
	PORT221_FN2 = 1808,
	PORT222_FN2 = 1809,
	PORT224_FN2 = 1810,
	PORT225_FN2 = 1811,
	PORT226_FN2 = 1812,
	PORT227_FN2 = 1813,
	PORT228_FN2 = 1814,
	PORT229_FN2 = 1815,
	PORT230_FN2 = 1816,
	PORT231_FN2 = 1817,
	PORT232_FN2 = 1818,
	PORT233_FN2 = 1819,
	PORT234_FN2 = 1820,
	PORT235_FN2 = 1821,
	PORT236_FN2 = 1822,
	PORT237_FN2 = 1823,
	PORT238_FN2 = 1824,
	PORT239_FN2 = 1825,
	PORT240_FN2 = 1826,
	PORT241_FN2 = 1827,
	PORT242_FN2 = 1828,
	PORT243_FN2 = 1829,
	PORT244_FN2 = 1830,
	PORT245_FN2 = 1831,
	PORT246_FN2 = 1832,
	PORT247_FN2 = 1833,
	PORT248_FN2 = 1834,
	PORT249_FN2 = 1835,
	PORT250_FN2 = 1836,
	PORT256_FN2 = 1837,
	PORT257_FN2 = 1838,
	PORT258_FN2 = 1839,
	PORT259_FN2 = 1840,
	PORT260_FN2 = 1841,
	PORT261_FN2 = 1842,
	PORT262_FN2 = 1843,
	PORT263_FN2 = 1844,
	PORT264_FN2 = 1845,
	PORT265_FN2 = 1846,
	PORT266_FN2 = 1847,
	PORT267_FN2 = 1848,
	PORT268_FN2 = 1849,
	PORT269_FN2 = 1850,
	PORT270_FN2 = 1851,
	PORT271_FN2 = 1852,
	PORT272_FN2 = 1853,
	PORT273_FN2 = 1854,
	PORT274_FN2 = 1855,
	PORT275_FN2 = 1856,
	PORT276_FN2 = 1857,
	PORT277_FN2 = 1858,
	PORT278_FN2 = 1859,
	PORT279_FN2 = 1860,
	PORT280_FN2 = 1861,
	PORT281_FN2 = 1862,
	PORT282_FN2 = 1863,
	PORT283_FN2 = 1864,
	PORT288_FN2 = 1865,
	PORT289_FN2 = 1866,
	PORT290_FN2 = 1867,
	PORT291_FN2 = 1868,
	PORT292_FN2 = 1869,
	PORT293_FN2 = 1870,
	PORT294_FN2 = 1871,
	PORT295_FN2 = 1872,
	PORT296_FN2 = 1873,
	PORT297_FN2 = 1874,
	PORT298_FN2 = 1875,
	PORT299_FN2 = 1876,
	PORT300_FN2 = 1877,
	PORT301_FN2 = 1878,
	PORT302_FN2 = 1879,
	PORT303_FN2 = 1880,
	PORT304_FN2 = 1881,
	PORT305_FN2 = 1882,
	PORT306_FN2 = 1883,
	PORT307_FN2 = 1884,
	PORT308_FN2 = 1885,
	PORT320_FN2 = 1886,
	PORT321_FN2 = 1887,
	PORT322_FN2 = 1888,
	PORT323_FN2 = 1889,
	PORT324_FN2 = 1890,
	PORT325_FN2 = 1891,
	PORT326_FN2 = 1892,
	PORT327_FN2 = 1893,
	PORT328_FN2 = 1894,
	PORT329_FN2 = 1895,
	PORT0_FN3 = 1896,
	PORT1_FN3 = 1897,
	PORT2_FN3 = 1898,
	PORT3_FN3 = 1899,
	PORT4_FN3 = 1900,
	PORT5_FN3 = 1901,
	PORT6_FN3 = 1902,
	PORT7_FN3 = 1903,
	PORT8_FN3 = 1904,
	PORT9_FN3 = 1905,
	PORT10_FN3 = 1906,
	PORT11_FN3 = 1907,
	PORT12_FN3 = 1908,
	PORT13_FN3 = 1909,
	PORT14_FN3 = 1910,
	PORT15_FN3 = 1911,
	PORT16_FN3 = 1912,
	PORT17_FN3 = 1913,
	PORT18_FN3 = 1914,
	PORT19_FN3 = 1915,
	PORT20_FN3 = 1916,
	PORT21_FN3 = 1917,
	PORT22_FN3 = 1918,
	PORT23_FN3 = 1919,
	PORT24_FN3 = 1920,
	PORT25_FN3 = 1921,
	PORT26_FN3 = 1922,
	PORT27_FN3 = 1923,
	PORT28_FN3 = 1924,
	PORT29_FN3 = 1925,
	PORT30_FN3 = 1926,
	PORT32_FN3 = 1927,
	PORT33_FN3 = 1928,
	PORT34_FN3 = 1929,
	PORT35_FN3 = 1930,
	PORT36_FN3 = 1931,
	PORT37_FN3 = 1932,
	PORT38_FN3 = 1933,
	PORT39_FN3 = 1934,
	PORT40_FN3 = 1935,
	PORT64_FN3 = 1936,
	PORT65_FN3 = 1937,
	PORT66_FN3 = 1938,
	PORT67_FN3 = 1939,
	PORT68_FN3 = 1940,
	PORT69_FN3 = 1941,
	PORT70_FN3 = 1942,
	PORT71_FN3 = 1943,
	PORT72_FN3 = 1944,
	PORT73_FN3 = 1945,
	PORT74_FN3 = 1946,
	PORT75_FN3 = 1947,
	PORT76_FN3 = 1948,
	PORT77_FN3 = 1949,
	PORT78_FN3 = 1950,
	PORT79_FN3 = 1951,
	PORT80_FN3 = 1952,
	PORT81_FN3 = 1953,
	PORT82_FN3 = 1954,
	PORT83_FN3 = 1955,
	PORT84_FN3 = 1956,
	PORT85_FN3 = 1957,
	PORT96_FN3 = 1958,
	PORT97_FN3 = 1959,
	PORT98_FN3 = 1960,
	PORT99_FN3 = 1961,
	PORT100_FN3 = 1962,
	PORT101_FN3 = 1963,
	PORT102_FN3 = 1964,
	PORT103_FN3 = 1965,
	PORT104_FN3 = 1966,
	PORT105_FN3 = 1967,
	PORT106_FN3 = 1968,
	PORT107_FN3 = 1969,
	PORT108_FN3 = 1970,
	PORT109_FN3 = 1971,
	PORT110_FN3 = 1972,
	PORT111_FN3 = 1973,
	PORT112_FN3 = 1974,
	PORT113_FN3 = 1975,
	PORT114_FN3 = 1976,
	PORT115_FN3 = 1977,
	PORT116_FN3 = 1978,
	PORT117_FN3 = 1979,
	PORT118_FN3 = 1980,
	PORT119_FN3 = 1981,
	PORT120_FN3 = 1982,
	PORT121_FN3 = 1983,
	PORT122_FN3 = 1984,
	PORT123_FN3 = 1985,
	PORT124_FN3 = 1986,
	PORT125_FN3 = 1987,
	PORT126_FN3 = 1988,
	PORT128_FN3 = 1989,
	PORT129_FN3 = 1990,
	PORT130_FN3 = 1991,
	PORT131_FN3 = 1992,
	PORT132_FN3 = 1993,
	PORT133_FN3 = 1994,
	PORT134_FN3 = 1995,
	PORT160_FN3 = 1996,
	PORT161_FN3 = 1997,
	PORT162_FN3 = 1998,
	PORT163_FN3 = 1999,
	PORT164_FN3 = 2000,
	PORT165_FN3 = 2001,
	PORT166_FN3 = 2002,
	PORT167_FN3 = 2003,
	PORT168_FN3 = 2004,
	PORT169_FN3 = 2005,
	PORT170_FN3 = 2006,
	PORT171_FN3 = 2007,
	PORT172_FN3 = 2008,
	PORT173_FN3 = 2009,
	PORT174_FN3 = 2010,
	PORT175_FN3 = 2011,
	PORT176_FN3 = 2012,
	PORT177_FN3 = 2013,
	PORT178_FN3 = 2014,
	PORT192_FN3 = 2015,
	PORT193_FN3 = 2016,
	PORT194_FN3 = 2017,
	PORT195_FN3 = 2018,
	PORT196_FN3 = 2019,
	PORT197_FN3 = 2020,
	PORT198_FN3 = 2021,
	PORT199_FN3 = 2022,
	PORT200_FN3 = 2023,
	PORT201_FN3 = 2024,
	PORT202_FN3 = 2025,
	PORT203_FN3 = 2026,
	PORT204_FN3 = 2027,
	PORT205_FN3 = 2028,
	PORT206_FN3 = 2029,
	PORT207_FN3 = 2030,
	PORT208_FN3 = 2031,
	PORT209_FN3 = 2032,
	PORT210_FN3 = 2033,
	PORT211_FN3 = 2034,
	PORT212_FN3 = 2035,
	PORT213_FN3 = 2036,
	PORT214_FN3 = 2037,
	PORT215_FN3 = 2038,
	PORT216_FN3 = 2039,
	PORT217_FN3 = 2040,
	PORT218_FN3 = 2041,
	PORT219_FN3 = 2042,
	PORT220_FN3 = 2043,
	PORT221_FN3 = 2044,
	PORT222_FN3 = 2045,
	PORT224_FN3 = 2046,
	PORT225_FN3 = 2047,
	PORT226_FN3 = 2048,
	PORT227_FN3 = 2049,
	PORT228_FN3 = 2050,
	PORT229_FN3 = 2051,
	PORT230_FN3 = 2052,
	PORT231_FN3 = 2053,
	PORT232_FN3 = 2054,
	PORT233_FN3 = 2055,
	PORT234_FN3 = 2056,
	PORT235_FN3 = 2057,
	PORT236_FN3 = 2058,
	PORT237_FN3 = 2059,
	PORT238_FN3 = 2060,
	PORT239_FN3 = 2061,
	PORT240_FN3 = 2062,
	PORT241_FN3 = 2063,
	PORT242_FN3 = 2064,
	PORT243_FN3 = 2065,
	PORT244_FN3 = 2066,
	PORT245_FN3 = 2067,
	PORT246_FN3 = 2068,
	PORT247_FN3 = 2069,
	PORT248_FN3 = 2070,
	PORT249_FN3 = 2071,
	PORT250_FN3 = 2072,
	PORT256_FN3 = 2073,
	PORT257_FN3 = 2074,
	PORT258_FN3 = 2075,
	PORT259_FN3 = 2076,
	PORT260_FN3 = 2077,
	PORT261_FN3 = 2078,
	PORT262_FN3 = 2079,
	PORT263_FN3 = 2080,
	PORT264_FN3 = 2081,
	PORT265_FN3 = 2082,
	PORT266_FN3 = 2083,
	PORT267_FN3 = 2084,
	PORT268_FN3 = 2085,
	PORT269_FN3 = 2086,
	PORT270_FN3 = 2087,
	PORT271_FN3 = 2088,
	PORT272_FN3 = 2089,
	PORT273_FN3 = 2090,
	PORT274_FN3 = 2091,
	PORT275_FN3 = 2092,
	PORT276_FN3 = 2093,
	PORT277_FN3 = 2094,
	PORT278_FN3 = 2095,
	PORT279_FN3 = 2096,
	PORT280_FN3 = 2097,
	PORT281_FN3 = 2098,
	PORT282_FN3 = 2099,
	PORT283_FN3 = 2100,
	PORT288_FN3 = 2101,
	PORT289_FN3 = 2102,
	PORT290_FN3 = 2103,
	PORT291_FN3 = 2104,
	PORT292_FN3 = 2105,
	PORT293_FN3 = 2106,
	PORT294_FN3 = 2107,
	PORT295_FN3 = 2108,
	PORT296_FN3 = 2109,
	PORT297_FN3 = 2110,
	PORT298_FN3 = 2111,
	PORT299_FN3 = 2112,
	PORT300_FN3 = 2113,
	PORT301_FN3 = 2114,
	PORT302_FN3 = 2115,
	PORT303_FN3 = 2116,
	PORT304_FN3 = 2117,
	PORT305_FN3 = 2118,
	PORT306_FN3 = 2119,
	PORT307_FN3 = 2120,
	PORT308_FN3 = 2121,
	PORT320_FN3 = 2122,
	PORT321_FN3 = 2123,
	PORT322_FN3 = 2124,
	PORT323_FN3 = 2125,
	PORT324_FN3 = 2126,
	PORT325_FN3 = 2127,
	PORT326_FN3 = 2128,
	PORT327_FN3 = 2129,
	PORT328_FN3 = 2130,
	PORT329_FN3 = 2131,
	PORT0_FN4 = 2132,
	PORT1_FN4 = 2133,
	PORT2_FN4 = 2134,
	PORT3_FN4 = 2135,
	PORT4_FN4 = 2136,
	PORT5_FN4 = 2137,
	PORT6_FN4 = 2138,
	PORT7_FN4 = 2139,
	PORT8_FN4 = 2140,
	PORT9_FN4 = 2141,
	PORT10_FN4 = 2142,
	PORT11_FN4 = 2143,
	PORT12_FN4 = 2144,
	PORT13_FN4 = 2145,
	PORT14_FN4 = 2146,
	PORT15_FN4 = 2147,
	PORT16_FN4 = 2148,
	PORT17_FN4 = 2149,
	PORT18_FN4 = 2150,
	PORT19_FN4 = 2151,
	PORT20_FN4 = 2152,
	PORT21_FN4 = 2153,
	PORT22_FN4 = 2154,
	PORT23_FN4 = 2155,
	PORT24_FN4 = 2156,
	PORT25_FN4 = 2157,
	PORT26_FN4 = 2158,
	PORT27_FN4 = 2159,
	PORT28_FN4 = 2160,
	PORT29_FN4 = 2161,
	PORT30_FN4 = 2162,
	PORT32_FN4 = 2163,
	PORT33_FN4 = 2164,
	PORT34_FN4 = 2165,
	PORT35_FN4 = 2166,
	PORT36_FN4 = 2167,
	PORT37_FN4 = 2168,
	PORT38_FN4 = 2169,
	PORT39_FN4 = 2170,
	PORT40_FN4 = 2171,
	PORT64_FN4 = 2172,
	PORT65_FN4 = 2173,
	PORT66_FN4 = 2174,
	PORT67_FN4 = 2175,
	PORT68_FN4 = 2176,
	PORT69_FN4 = 2177,
	PORT70_FN4 = 2178,
	PORT71_FN4 = 2179,
	PORT72_FN4 = 2180,
	PORT73_FN4 = 2181,
	PORT74_FN4 = 2182,
	PORT75_FN4 = 2183,
	PORT76_FN4 = 2184,
	PORT77_FN4 = 2185,
	PORT78_FN4 = 2186,
	PORT79_FN4 = 2187,
	PORT80_FN4 = 2188,
	PORT81_FN4 = 2189,
	PORT82_FN4 = 2190,
	PORT83_FN4 = 2191,
	PORT84_FN4 = 2192,
	PORT85_FN4 = 2193,
	PORT96_FN4 = 2194,
	PORT97_FN4 = 2195,
	PORT98_FN4 = 2196,
	PORT99_FN4 = 2197,
	PORT100_FN4 = 2198,
	PORT101_FN4 = 2199,
	PORT102_FN4 = 2200,
	PORT103_FN4 = 2201,
	PORT104_FN4 = 2202,
	PORT105_FN4 = 2203,
	PORT106_FN4 = 2204,
	PORT107_FN4 = 2205,
	PORT108_FN4 = 2206,
	PORT109_FN4 = 2207,
	PORT110_FN4 = 2208,
	PORT111_FN4 = 2209,
	PORT112_FN4 = 2210,
	PORT113_FN4 = 2211,
	PORT114_FN4 = 2212,
	PORT115_FN4 = 2213,
	PORT116_FN4 = 2214,
	PORT117_FN4 = 2215,
	PORT118_FN4 = 2216,
	PORT119_FN4 = 2217,
	PORT120_FN4 = 2218,
	PORT121_FN4 = 2219,
	PORT122_FN4 = 2220,
	PORT123_FN4 = 2221,
	PORT124_FN4 = 2222,
	PORT125_FN4 = 2223,
	PORT126_FN4 = 2224,
	PORT128_FN4 = 2225,
	PORT129_FN4 = 2226,
	PORT130_FN4 = 2227,
	PORT131_FN4 = 2228,
	PORT132_FN4 = 2229,
	PORT133_FN4 = 2230,
	PORT134_FN4 = 2231,
	PORT160_FN4 = 2232,
	PORT161_FN4 = 2233,
	PORT162_FN4 = 2234,
	PORT163_FN4 = 2235,
	PORT164_FN4 = 2236,
	PORT165_FN4 = 2237,
	PORT166_FN4 = 2238,
	PORT167_FN4 = 2239,
	PORT168_FN4 = 2240,
	PORT169_FN4 = 2241,
	PORT170_FN4 = 2242,
	PORT171_FN4 = 2243,
	PORT172_FN4 = 2244,
	PORT173_FN4 = 2245,
	PORT174_FN4 = 2246,
	PORT175_FN4 = 2247,
	PORT176_FN4 = 2248,
	PORT177_FN4 = 2249,
	PORT178_FN4 = 2250,
	PORT192_FN4 = 2251,
	PORT193_FN4 = 2252,
	PORT194_FN4 = 2253,
	PORT195_FN4 = 2254,
	PORT196_FN4 = 2255,
	PORT197_FN4 = 2256,
	PORT198_FN4 = 2257,
	PORT199_FN4 = 2258,
	PORT200_FN4 = 2259,
	PORT201_FN4 = 2260,
	PORT202_FN4 = 2261,
	PORT203_FN4 = 2262,
	PORT204_FN4 = 2263,
	PORT205_FN4 = 2264,
	PORT206_FN4 = 2265,
	PORT207_FN4 = 2266,
	PORT208_FN4 = 2267,
	PORT209_FN4 = 2268,
	PORT210_FN4 = 2269,
	PORT211_FN4 = 2270,
	PORT212_FN4 = 2271,
	PORT213_FN4 = 2272,
	PORT214_FN4 = 2273,
	PORT215_FN4 = 2274,
	PORT216_FN4 = 2275,
	PORT217_FN4 = 2276,
	PORT218_FN4 = 2277,
	PORT219_FN4 = 2278,
	PORT220_FN4 = 2279,
	PORT221_FN4 = 2280,
	PORT222_FN4 = 2281,
	PORT224_FN4 = 2282,
	PORT225_FN4 = 2283,
	PORT226_FN4 = 2284,
	PORT227_FN4 = 2285,
	PORT228_FN4 = 2286,
	PORT229_FN4 = 2287,
	PORT230_FN4 = 2288,
	PORT231_FN4 = 2289,
	PORT232_FN4 = 2290,
	PORT233_FN4 = 2291,
	PORT234_FN4 = 2292,
	PORT235_FN4 = 2293,
	PORT236_FN4 = 2294,
	PORT237_FN4 = 2295,
	PORT238_FN4 = 2296,
	PORT239_FN4 = 2297,
	PORT240_FN4 = 2298,
	PORT241_FN4 = 2299,
	PORT242_FN4 = 2300,
	PORT243_FN4 = 2301,
	PORT244_FN4 = 2302,
	PORT245_FN4 = 2303,
	PORT246_FN4 = 2304,
	PORT247_FN4 = 2305,
	PORT248_FN4 = 2306,
	PORT249_FN4 = 2307,
	PORT250_FN4 = 2308,
	PORT256_FN4 = 2309,
	PORT257_FN4 = 2310,
	PORT258_FN4 = 2311,
	PORT259_FN4 = 2312,
	PORT260_FN4 = 2313,
	PORT261_FN4 = 2314,
	PORT262_FN4 = 2315,
	PORT263_FN4 = 2316,
	PORT264_FN4 = 2317,
	PORT265_FN4 = 2318,
	PORT266_FN4 = 2319,
	PORT267_FN4 = 2320,
	PORT268_FN4 = 2321,
	PORT269_FN4 = 2322,
	PORT270_FN4 = 2323,
	PORT271_FN4 = 2324,
	PORT272_FN4 = 2325,
	PORT273_FN4 = 2326,
	PORT274_FN4 = 2327,
	PORT275_FN4 = 2328,
	PORT276_FN4 = 2329,
	PORT277_FN4 = 2330,
	PORT278_FN4 = 2331,
	PORT279_FN4 = 2332,
	PORT280_FN4 = 2333,
	PORT281_FN4 = 2334,
	PORT282_FN4 = 2335,
	PORT283_FN4 = 2336,
	PORT288_FN4 = 2337,
	PORT289_FN4 = 2338,
	PORT290_FN4 = 2339,
	PORT291_FN4 = 2340,
	PORT292_FN4 = 2341,
	PORT293_FN4 = 2342,
	PORT294_FN4 = 2343,
	PORT295_FN4 = 2344,
	PORT296_FN4 = 2345,
	PORT297_FN4 = 2346,
	PORT298_FN4 = 2347,
	PORT299_FN4 = 2348,
	PORT300_FN4 = 2349,
	PORT301_FN4 = 2350,
	PORT302_FN4 = 2351,
	PORT303_FN4 = 2352,
	PORT304_FN4 = 2353,
	PORT305_FN4 = 2354,
	PORT306_FN4 = 2355,
	PORT307_FN4 = 2356,
	PORT308_FN4 = 2357,
	PORT320_FN4 = 2358,
	PORT321_FN4 = 2359,
	PORT322_FN4 = 2360,
	PORT323_FN4 = 2361,
	PORT324_FN4 = 2362,
	PORT325_FN4 = 2363,
	PORT326_FN4 = 2364,
	PORT327_FN4 = 2365,
	PORT328_FN4 = 2366,
	PORT329_FN4 = 2367,
	PORT0_FN5 = 2368,
	PORT1_FN5 = 2369,
	PORT2_FN5 = 2370,
	PORT3_FN5 = 2371,
	PORT4_FN5 = 2372,
	PORT5_FN5 = 2373,
	PORT6_FN5 = 2374,
	PORT7_FN5 = 2375,
	PORT8_FN5 = 2376,
	PORT9_FN5 = 2377,
	PORT10_FN5 = 2378,
	PORT11_FN5 = 2379,
	PORT12_FN5 = 2380,
	PORT13_FN5 = 2381,
	PORT14_FN5 = 2382,
	PORT15_FN5 = 2383,
	PORT16_FN5 = 2384,
	PORT17_FN5 = 2385,
	PORT18_FN5 = 2386,
	PORT19_FN5 = 2387,
	PORT20_FN5 = 2388,
	PORT21_FN5 = 2389,
	PORT22_FN5 = 2390,
	PORT23_FN5 = 2391,
	PORT24_FN5 = 2392,
	PORT25_FN5 = 2393,
	PORT26_FN5 = 2394,
	PORT27_FN5 = 2395,
	PORT28_FN5 = 2396,
	PORT29_FN5 = 2397,
	PORT30_FN5 = 2398,
	PORT32_FN5 = 2399,
	PORT33_FN5 = 2400,
	PORT34_FN5 = 2401,
	PORT35_FN5 = 2402,
	PORT36_FN5 = 2403,
	PORT37_FN5 = 2404,
	PORT38_FN5 = 2405,
	PORT39_FN5 = 2406,
	PORT40_FN5 = 2407,
	PORT64_FN5 = 2408,
	PORT65_FN5 = 2409,
	PORT66_FN5 = 2410,
	PORT67_FN5 = 2411,
	PORT68_FN5 = 2412,
	PORT69_FN5 = 2413,
	PORT70_FN5 = 2414,
	PORT71_FN5 = 2415,
	PORT72_FN5 = 2416,
	PORT73_FN5 = 2417,
	PORT74_FN5 = 2418,
	PORT75_FN5 = 2419,
	PORT76_FN5 = 2420,
	PORT77_FN5 = 2421,
	PORT78_FN5 = 2422,
	PORT79_FN5 = 2423,
	PORT80_FN5 = 2424,
	PORT81_FN5 = 2425,
	PORT82_FN5 = 2426,
	PORT83_FN5 = 2427,
	PORT84_FN5 = 2428,
	PORT85_FN5 = 2429,
	PORT96_FN5 = 2430,
	PORT97_FN5 = 2431,
	PORT98_FN5 = 2432,
	PORT99_FN5 = 2433,
	PORT100_FN5 = 2434,
	PORT101_FN5 = 2435,
	PORT102_FN5 = 2436,
	PORT103_FN5 = 2437,
	PORT104_FN5 = 2438,
	PORT105_FN5 = 2439,
	PORT106_FN5 = 2440,
	PORT107_FN5 = 2441,
	PORT108_FN5 = 2442,
	PORT109_FN5 = 2443,
	PORT110_FN5 = 2444,
	PORT111_FN5 = 2445,
	PORT112_FN5 = 2446,
	PORT113_FN5 = 2447,
	PORT114_FN5 = 2448,
	PORT115_FN5 = 2449,
	PORT116_FN5 = 2450,
	PORT117_FN5 = 2451,
	PORT118_FN5 = 2452,
	PORT119_FN5 = 2453,
	PORT120_FN5 = 2454,
	PORT121_FN5 = 2455,
	PORT122_FN5 = 2456,
	PORT123_FN5 = 2457,
	PORT124_FN5 = 2458,
	PORT125_FN5 = 2459,
	PORT126_FN5 = 2460,
	PORT128_FN5 = 2461,
	PORT129_FN5 = 2462,
	PORT130_FN5 = 2463,
	PORT131_FN5 = 2464,
	PORT132_FN5 = 2465,
	PORT133_FN5 = 2466,
	PORT134_FN5 = 2467,
	PORT160_FN5 = 2468,
	PORT161_FN5 = 2469,
	PORT162_FN5 = 2470,
	PORT163_FN5 = 2471,
	PORT164_FN5 = 2472,
	PORT165_FN5 = 2473,
	PORT166_FN5 = 2474,
	PORT167_FN5 = 2475,
	PORT168_FN5 = 2476,
	PORT169_FN5 = 2477,
	PORT170_FN5 = 2478,
	PORT171_FN5 = 2479,
	PORT172_FN5 = 2480,
	PORT173_FN5 = 2481,
	PORT174_FN5 = 2482,
	PORT175_FN5 = 2483,
	PORT176_FN5 = 2484,
	PORT177_FN5 = 2485,
	PORT178_FN5 = 2486,
	PORT192_FN5 = 2487,
	PORT193_FN5 = 2488,
	PORT194_FN5 = 2489,
	PORT195_FN5 = 2490,
	PORT196_FN5 = 2491,
	PORT197_FN5 = 2492,
	PORT198_FN5 = 2493,
	PORT199_FN5 = 2494,
	PORT200_FN5 = 2495,
	PORT201_FN5 = 2496,
	PORT202_FN5 = 2497,
	PORT203_FN5 = 2498,
	PORT204_FN5 = 2499,
	PORT205_FN5 = 2500,
	PORT206_FN5 = 2501,
	PORT207_FN5 = 2502,
	PORT208_FN5 = 2503,
	PORT209_FN5 = 2504,
	PORT210_FN5 = 2505,
	PORT211_FN5 = 2506,
	PORT212_FN5 = 2507,
	PORT213_FN5 = 2508,
	PORT214_FN5 = 2509,
	PORT215_FN5 = 2510,
	PORT216_FN5 = 2511,
	PORT217_FN5 = 2512,
	PORT218_FN5 = 2513,
	PORT219_FN5 = 2514,
	PORT220_FN5 = 2515,
	PORT221_FN5 = 2516,
	PORT222_FN5 = 2517,
	PORT224_FN5 = 2518,
	PORT225_FN5 = 2519,
	PORT226_FN5 = 2520,
	PORT227_FN5 = 2521,
	PORT228_FN5 = 2522,
	PORT229_FN5 = 2523,
	PORT230_FN5 = 2524,
	PORT231_FN5 = 2525,
	PORT232_FN5 = 2526,
	PORT233_FN5 = 2527,
	PORT234_FN5 = 2528,
	PORT235_FN5 = 2529,
	PORT236_FN5 = 2530,
	PORT237_FN5 = 2531,
	PORT238_FN5 = 2532,
	PORT239_FN5 = 2533,
	PORT240_FN5 = 2534,
	PORT241_FN5 = 2535,
	PORT242_FN5 = 2536,
	PORT243_FN5 = 2537,
	PORT244_FN5 = 2538,
	PORT245_FN5 = 2539,
	PORT246_FN5 = 2540,
	PORT247_FN5 = 2541,
	PORT248_FN5 = 2542,
	PORT249_FN5 = 2543,
	PORT250_FN5 = 2544,
	PORT256_FN5 = 2545,
	PORT257_FN5 = 2546,
	PORT258_FN5 = 2547,
	PORT259_FN5 = 2548,
	PORT260_FN5 = 2549,
	PORT261_FN5 = 2550,
	PORT262_FN5 = 2551,
	PORT263_FN5 = 2552,
	PORT264_FN5 = 2553,
	PORT265_FN5 = 2554,
	PORT266_FN5 = 2555,
	PORT267_FN5 = 2556,
	PORT268_FN5 = 2557,
	PORT269_FN5 = 2558,
	PORT270_FN5 = 2559,
	PORT271_FN5 = 2560,
	PORT272_FN5 = 2561,
	PORT273_FN5 = 2562,
	PORT274_FN5 = 2563,
	PORT275_FN5 = 2564,
	PORT276_FN5 = 2565,
	PORT277_FN5 = 2566,
	PORT278_FN5 = 2567,
	PORT279_FN5 = 2568,
	PORT280_FN5 = 2569,
	PORT281_FN5 = 2570,
	PORT282_FN5 = 2571,
	PORT283_FN5 = 2572,
	PORT288_FN5 = 2573,
	PORT289_FN5 = 2574,
	PORT290_FN5 = 2575,
	PORT291_FN5 = 2576,
	PORT292_FN5 = 2577,
	PORT293_FN5 = 2578,
	PORT294_FN5 = 2579,
	PORT295_FN5 = 2580,
	PORT296_FN5 = 2581,
	PORT297_FN5 = 2582,
	PORT298_FN5 = 2583,
	PORT299_FN5 = 2584,
	PORT300_FN5 = 2585,
	PORT301_FN5 = 2586,
	PORT302_FN5 = 2587,
	PORT303_FN5 = 2588,
	PORT304_FN5 = 2589,
	PORT305_FN5 = 2590,
	PORT306_FN5 = 2591,
	PORT307_FN5 = 2592,
	PORT308_FN5 = 2593,
	PORT320_FN5 = 2594,
	PORT321_FN5 = 2595,
	PORT322_FN5 = 2596,
	PORT323_FN5 = 2597,
	PORT324_FN5 = 2598,
	PORT325_FN5 = 2599,
	PORT326_FN5 = 2600,
	PORT327_FN5 = 2601,
	PORT328_FN5 = 2602,
	PORT329_FN5 = 2603,
	PORT0_FN6 = 2604,
	PORT1_FN6 = 2605,
	PORT2_FN6 = 2606,
	PORT3_FN6 = 2607,
	PORT4_FN6 = 2608,
	PORT5_FN6 = 2609,
	PORT6_FN6 = 2610,
	PORT7_FN6 = 2611,
	PORT8_FN6 = 2612,
	PORT9_FN6 = 2613,
	PORT10_FN6 = 2614,
	PORT11_FN6 = 2615,
	PORT12_FN6 = 2616,
	PORT13_FN6 = 2617,
	PORT14_FN6 = 2618,
	PORT15_FN6 = 2619,
	PORT16_FN6 = 2620,
	PORT17_FN6 = 2621,
	PORT18_FN6 = 2622,
	PORT19_FN6 = 2623,
	PORT20_FN6 = 2624,
	PORT21_FN6 = 2625,
	PORT22_FN6 = 2626,
	PORT23_FN6 = 2627,
	PORT24_FN6 = 2628,
	PORT25_FN6 = 2629,
	PORT26_FN6 = 2630,
	PORT27_FN6 = 2631,
	PORT28_FN6 = 2632,
	PORT29_FN6 = 2633,
	PORT30_FN6 = 2634,
	PORT32_FN6 = 2635,
	PORT33_FN6 = 2636,
	PORT34_FN6 = 2637,
	PORT35_FN6 = 2638,
	PORT36_FN6 = 2639,
	PORT37_FN6 = 2640,
	PORT38_FN6 = 2641,
	PORT39_FN6 = 2642,
	PORT40_FN6 = 2643,
	PORT64_FN6 = 2644,
	PORT65_FN6 = 2645,
	PORT66_FN6 = 2646,
	PORT67_FN6 = 2647,
	PORT68_FN6 = 2648,
	PORT69_FN6 = 2649,
	PORT70_FN6 = 2650,
	PORT71_FN6 = 2651,
	PORT72_FN6 = 2652,
	PORT73_FN6 = 2653,
	PORT74_FN6 = 2654,
	PORT75_FN6 = 2655,
	PORT76_FN6 = 2656,
	PORT77_FN6 = 2657,
	PORT78_FN6 = 2658,
	PORT79_FN6 = 2659,
	PORT80_FN6 = 2660,
	PORT81_FN6 = 2661,
	PORT82_FN6 = 2662,
	PORT83_FN6 = 2663,
	PORT84_FN6 = 2664,
	PORT85_FN6 = 2665,
	PORT96_FN6 = 2666,
	PORT97_FN6 = 2667,
	PORT98_FN6 = 2668,
	PORT99_FN6 = 2669,
	PORT100_FN6 = 2670,
	PORT101_FN6 = 2671,
	PORT102_FN6 = 2672,
	PORT103_FN6 = 2673,
	PORT104_FN6 = 2674,
	PORT105_FN6 = 2675,
	PORT106_FN6 = 2676,
	PORT107_FN6 = 2677,
	PORT108_FN6 = 2678,
	PORT109_FN6 = 2679,
	PORT110_FN6 = 2680,
	PORT111_FN6 = 2681,
	PORT112_FN6 = 2682,
	PORT113_FN6 = 2683,
	PORT114_FN6 = 2684,
	PORT115_FN6 = 2685,
	PORT116_FN6 = 2686,
	PORT117_FN6 = 2687,
	PORT118_FN6 = 2688,
	PORT119_FN6 = 2689,
	PORT120_FN6 = 2690,
	PORT121_FN6 = 2691,
	PORT122_FN6 = 2692,
	PORT123_FN6 = 2693,
	PORT124_FN6 = 2694,
	PORT125_FN6 = 2695,
	PORT126_FN6 = 2696,
	PORT128_FN6 = 2697,
	PORT129_FN6 = 2698,
	PORT130_FN6 = 2699,
	PORT131_FN6 = 2700,
	PORT132_FN6 = 2701,
	PORT133_FN6 = 2702,
	PORT134_FN6 = 2703,
	PORT160_FN6 = 2704,
	PORT161_FN6 = 2705,
	PORT162_FN6 = 2706,
	PORT163_FN6 = 2707,
	PORT164_FN6 = 2708,
	PORT165_FN6 = 2709,
	PORT166_FN6 = 2710,
	PORT167_FN6 = 2711,
	PORT168_FN6 = 2712,
	PORT169_FN6 = 2713,
	PORT170_FN6 = 2714,
	PORT171_FN6 = 2715,
	PORT172_FN6 = 2716,
	PORT173_FN6 = 2717,
	PORT174_FN6 = 2718,
	PORT175_FN6 = 2719,
	PORT176_FN6 = 2720,
	PORT177_FN6 = 2721,
	PORT178_FN6 = 2722,
	PORT192_FN6 = 2723,
	PORT193_FN6 = 2724,
	PORT194_FN6 = 2725,
	PORT195_FN6 = 2726,
	PORT196_FN6 = 2727,
	PORT197_FN6 = 2728,
	PORT198_FN6 = 2729,
	PORT199_FN6 = 2730,
	PORT200_FN6 = 2731,
	PORT201_FN6 = 2732,
	PORT202_FN6 = 2733,
	PORT203_FN6 = 2734,
	PORT204_FN6 = 2735,
	PORT205_FN6 = 2736,
	PORT206_FN6 = 2737,
	PORT207_FN6 = 2738,
	PORT208_FN6 = 2739,
	PORT209_FN6 = 2740,
	PORT210_FN6 = 2741,
	PORT211_FN6 = 2742,
	PORT212_FN6 = 2743,
	PORT213_FN6 = 2744,
	PORT214_FN6 = 2745,
	PORT215_FN6 = 2746,
	PORT216_FN6 = 2747,
	PORT217_FN6 = 2748,
	PORT218_FN6 = 2749,
	PORT219_FN6 = 2750,
	PORT220_FN6 = 2751,
	PORT221_FN6 = 2752,
	PORT222_FN6 = 2753,
	PORT224_FN6 = 2754,
	PORT225_FN6 = 2755,
	PORT226_FN6 = 2756,
	PORT227_FN6 = 2757,
	PORT228_FN6 = 2758,
	PORT229_FN6 = 2759,
	PORT230_FN6 = 2760,
	PORT231_FN6 = 2761,
	PORT232_FN6 = 2762,
	PORT233_FN6 = 2763,
	PORT234_FN6 = 2764,
	PORT235_FN6 = 2765,
	PORT236_FN6 = 2766,
	PORT237_FN6 = 2767,
	PORT238_FN6 = 2768,
	PORT239_FN6 = 2769,
	PORT240_FN6 = 2770,
	PORT241_FN6 = 2771,
	PORT242_FN6 = 2772,
	PORT243_FN6 = 2773,
	PORT244_FN6 = 2774,
	PORT245_FN6 = 2775,
	PORT246_FN6 = 2776,
	PORT247_FN6 = 2777,
	PORT248_FN6 = 2778,
	PORT249_FN6 = 2779,
	PORT250_FN6 = 2780,
	PORT256_FN6 = 2781,
	PORT257_FN6 = 2782,
	PORT258_FN6 = 2783,
	PORT259_FN6 = 2784,
	PORT260_FN6 = 2785,
	PORT261_FN6 = 2786,
	PORT262_FN6 = 2787,
	PORT263_FN6 = 2788,
	PORT264_FN6 = 2789,
	PORT265_FN6 = 2790,
	PORT266_FN6 = 2791,
	PORT267_FN6 = 2792,
	PORT268_FN6 = 2793,
	PORT269_FN6 = 2794,
	PORT270_FN6 = 2795,
	PORT271_FN6 = 2796,
	PORT272_FN6 = 2797,
	PORT273_FN6 = 2798,
	PORT274_FN6 = 2799,
	PORT275_FN6 = 2800,
	PORT276_FN6 = 2801,
	PORT277_FN6 = 2802,
	PORT278_FN6 = 2803,
	PORT279_FN6 = 2804,
	PORT280_FN6 = 2805,
	PORT281_FN6 = 2806,
	PORT282_FN6 = 2807,
	PORT283_FN6 = 2808,
	PORT288_FN6 = 2809,
	PORT289_FN6 = 2810,
	PORT290_FN6 = 2811,
	PORT291_FN6 = 2812,
	PORT292_FN6 = 2813,
	PORT293_FN6 = 2814,
	PORT294_FN6 = 2815,
	PORT295_FN6 = 2816,
	PORT296_FN6 = 2817,
	PORT297_FN6 = 2818,
	PORT298_FN6 = 2819,
	PORT299_FN6 = 2820,
	PORT300_FN6 = 2821,
	PORT301_FN6 = 2822,
	PORT302_FN6 = 2823,
	PORT303_FN6 = 2824,
	PORT304_FN6 = 2825,
	PORT305_FN6 = 2826,
	PORT306_FN6 = 2827,
	PORT307_FN6 = 2828,
	PORT308_FN6 = 2829,
	PORT320_FN6 = 2830,
	PORT321_FN6 = 2831,
	PORT322_FN6 = 2832,
	PORT323_FN6 = 2833,
	PORT324_FN6 = 2834,
	PORT325_FN6 = 2835,
	PORT326_FN6 = 2836,
	PORT327_FN6 = 2837,
	PORT328_FN6 = 2838,
	PORT329_FN6 = 2839,
	PORT0_FN7 = 2840,
	PORT1_FN7 = 2841,
	PORT2_FN7 = 2842,
	PORT3_FN7 = 2843,
	PORT4_FN7 = 2844,
	PORT5_FN7 = 2845,
	PORT6_FN7 = 2846,
	PORT7_FN7 = 2847,
	PORT8_FN7 = 2848,
	PORT9_FN7 = 2849,
	PORT10_FN7 = 2850,
	PORT11_FN7 = 2851,
	PORT12_FN7 = 2852,
	PORT13_FN7 = 2853,
	PORT14_FN7 = 2854,
	PORT15_FN7 = 2855,
	PORT16_FN7 = 2856,
	PORT17_FN7 = 2857,
	PORT18_FN7 = 2858,
	PORT19_FN7 = 2859,
	PORT20_FN7 = 2860,
	PORT21_FN7 = 2861,
	PORT22_FN7 = 2862,
	PORT23_FN7 = 2863,
	PORT24_FN7 = 2864,
	PORT25_FN7 = 2865,
	PORT26_FN7 = 2866,
	PORT27_FN7 = 2867,
	PORT28_FN7 = 2868,
	PORT29_FN7 = 2869,
	PORT30_FN7 = 2870,
	PORT32_FN7 = 2871,
	PORT33_FN7 = 2872,
	PORT34_FN7 = 2873,
	PORT35_FN7 = 2874,
	PORT36_FN7 = 2875,
	PORT37_FN7 = 2876,
	PORT38_FN7 = 2877,
	PORT39_FN7 = 2878,
	PORT40_FN7 = 2879,
	PORT64_FN7 = 2880,
	PORT65_FN7 = 2881,
	PORT66_FN7 = 2882,
	PORT67_FN7 = 2883,
	PORT68_FN7 = 2884,
	PORT69_FN7 = 2885,
	PORT70_FN7 = 2886,
	PORT71_FN7 = 2887,
	PORT72_FN7 = 2888,
	PORT73_FN7 = 2889,
	PORT74_FN7 = 2890,
	PORT75_FN7 = 2891,
	PORT76_FN7 = 2892,
	PORT77_FN7 = 2893,
	PORT78_FN7 = 2894,
	PORT79_FN7 = 2895,
	PORT80_FN7 = 2896,
	PORT81_FN7 = 2897,
	PORT82_FN7 = 2898,
	PORT83_FN7 = 2899,
	PORT84_FN7 = 2900,
	PORT85_FN7 = 2901,
	PORT96_FN7 = 2902,
	PORT97_FN7 = 2903,
	PORT98_FN7 = 2904,
	PORT99_FN7 = 2905,
	PORT100_FN7 = 2906,
	PORT101_FN7 = 2907,
	PORT102_FN7 = 2908,
	PORT103_FN7 = 2909,
	PORT104_FN7 = 2910,
	PORT105_FN7 = 2911,
	PORT106_FN7 = 2912,
	PORT107_FN7 = 2913,
	PORT108_FN7 = 2914,
	PORT109_FN7 = 2915,
	PORT110_FN7 = 2916,
	PORT111_FN7 = 2917,
	PORT112_FN7 = 2918,
	PORT113_FN7 = 2919,
	PORT114_FN7 = 2920,
	PORT115_FN7 = 2921,
	PORT116_FN7 = 2922,
	PORT117_FN7 = 2923,
	PORT118_FN7 = 2924,
	PORT119_FN7 = 2925,
	PORT120_FN7 = 2926,
	PORT121_FN7 = 2927,
	PORT122_FN7 = 2928,
	PORT123_FN7 = 2929,
	PORT124_FN7 = 2930,
	PORT125_FN7 = 2931,
	PORT126_FN7 = 2932,
	PORT128_FN7 = 2933,
	PORT129_FN7 = 2934,
	PORT130_FN7 = 2935,
	PORT131_FN7 = 2936,
	PORT132_FN7 = 2937,
	PORT133_FN7 = 2938,
	PORT134_FN7 = 2939,
	PORT160_FN7 = 2940,
	PORT161_FN7 = 2941,
	PORT162_FN7 = 2942,
	PORT163_FN7 = 2943,
	PORT164_FN7 = 2944,
	PORT165_FN7 = 2945,
	PORT166_FN7 = 2946,
	PORT167_FN7 = 2947,
	PORT168_FN7 = 2948,
	PORT169_FN7 = 2949,
	PORT170_FN7 = 2950,
	PORT171_FN7 = 2951,
	PORT172_FN7 = 2952,
	PORT173_FN7 = 2953,
	PORT174_FN7 = 2954,
	PORT175_FN7 = 2955,
	PORT176_FN7 = 2956,
	PORT177_FN7 = 2957,
	PORT178_FN7 = 2958,
	PORT192_FN7 = 2959,
	PORT193_FN7 = 2960,
	PORT194_FN7 = 2961,
	PORT195_FN7 = 2962,
	PORT196_FN7 = 2963,
	PORT197_FN7 = 2964,
	PORT198_FN7 = 2965,
	PORT199_FN7 = 2966,
	PORT200_FN7 = 2967,
	PORT201_FN7 = 2968,
	PORT202_FN7 = 2969,
	PORT203_FN7 = 2970,
	PORT204_FN7 = 2971,
	PORT205_FN7 = 2972,
	PORT206_FN7 = 2973,
	PORT207_FN7 = 2974,
	PORT208_FN7 = 2975,
	PORT209_FN7 = 2976,
	PORT210_FN7 = 2977,
	PORT211_FN7 = 2978,
	PORT212_FN7 = 2979,
	PORT213_FN7 = 2980,
	PORT214_FN7 = 2981,
	PORT215_FN7 = 2982,
	PORT216_FN7 = 2983,
	PORT217_FN7 = 2984,
	PORT218_FN7 = 2985,
	PORT219_FN7 = 2986,
	PORT220_FN7 = 2987,
	PORT221_FN7 = 2988,
	PORT222_FN7 = 2989,
	PORT224_FN7 = 2990,
	PORT225_FN7 = 2991,
	PORT226_FN7 = 2992,
	PORT227_FN7 = 2993,
	PORT228_FN7 = 2994,
	PORT229_FN7 = 2995,
	PORT230_FN7 = 2996,
	PORT231_FN7 = 2997,
	PORT232_FN7 = 2998,
	PORT233_FN7 = 2999,
	PORT234_FN7 = 3000,
	PORT235_FN7 = 3001,
	PORT236_FN7 = 3002,
	PORT237_FN7 = 3003,
	PORT238_FN7 = 3004,
	PORT239_FN7 = 3005,
	PORT240_FN7 = 3006,
	PORT241_FN7 = 3007,
	PORT242_FN7 = 3008,
	PORT243_FN7 = 3009,
	PORT244_FN7 = 3010,
	PORT245_FN7 = 3011,
	PORT246_FN7 = 3012,
	PORT247_FN7 = 3013,
	PORT248_FN7 = 3014,
	PORT249_FN7 = 3015,
	PORT250_FN7 = 3016,
	PORT256_FN7 = 3017,
	PORT257_FN7 = 3018,
	PORT258_FN7 = 3019,
	PORT259_FN7 = 3020,
	PORT260_FN7 = 3021,
	PORT261_FN7 = 3022,
	PORT262_FN7 = 3023,
	PORT263_FN7 = 3024,
	PORT264_FN7 = 3025,
	PORT265_FN7 = 3026,
	PORT266_FN7 = 3027,
	PORT267_FN7 = 3028,
	PORT268_FN7 = 3029,
	PORT269_FN7 = 3030,
	PORT270_FN7 = 3031,
	PORT271_FN7 = 3032,
	PORT272_FN7 = 3033,
	PORT273_FN7 = 3034,
	PORT274_FN7 = 3035,
	PORT275_FN7 = 3036,
	PORT276_FN7 = 3037,
	PORT277_FN7 = 3038,
	PORT278_FN7 = 3039,
	PORT279_FN7 = 3040,
	PORT280_FN7 = 3041,
	PORT281_FN7 = 3042,
	PORT282_FN7 = 3043,
	PORT283_FN7 = 3044,
	PORT288_FN7 = 3045,
	PORT289_FN7 = 3046,
	PORT290_FN7 = 3047,
	PORT291_FN7 = 3048,
	PORT292_FN7 = 3049,
	PORT293_FN7 = 3050,
	PORT294_FN7 = 3051,
	PORT295_FN7 = 3052,
	PORT296_FN7 = 3053,
	PORT297_FN7 = 3054,
	PORT298_FN7 = 3055,
	PORT299_FN7 = 3056,
	PORT300_FN7 = 3057,
	PORT301_FN7 = 3058,
	PORT302_FN7 = 3059,
	PORT303_FN7 = 3060,
	PORT304_FN7 = 3061,
	PORT305_FN7 = 3062,
	PORT306_FN7 = 3063,
	PORT307_FN7 = 3064,
	PORT308_FN7 = 3065,
	PORT320_FN7 = 3066,
	PORT321_FN7 = 3067,
	PORT322_FN7 = 3068,
	PORT323_FN7 = 3069,
	PORT324_FN7 = 3070,
	PORT325_FN7 = 3071,
	PORT326_FN7 = 3072,
	PORT327_FN7 = 3073,
	PORT328_FN7 = 3074,
	PORT329_FN7 = 3075,
	MSEL1CR_31_0 = 3076,
	MSEL1CR_31_1 = 3077,
	MSEL1CR_27_0 = 3078,
	MSEL1CR_27_1 = 3079,
	MSEL1CR_25_0 = 3080,
	MSEL1CR_25_1 = 3081,
	MSEL1CR_24_0 = 3082,
	MSEL1CR_24_1 = 3083,
	MSEL1CR_22_0 = 3084,
	MSEL1CR_22_1 = 3085,
	MSEL1CR_21_0 = 3086,
	MSEL1CR_21_1 = 3087,
	MSEL1CR_20_0 = 3088,
	MSEL1CR_20_1 = 3089,
	MSEL1CR_19_0 = 3090,
	MSEL1CR_19_1 = 3091,
	MSEL1CR_18_0 = 3092,
	MSEL1CR_18_1 = 3093,
	MSEL1CR_17_0 = 3094,
	MSEL1CR_17_1 = 3095,
	MSEL1CR_16_0 = 3096,
	MSEL1CR_16_1 = 3097,
	MSEL1CR_15_0 = 3098,
	MSEL1CR_15_1 = 3099,
	MSEL1CR_14_0 = 3100,
	MSEL1CR_14_1 = 3101,
	MSEL1CR_13_0 = 3102,
	MSEL1CR_13_1 = 3103,
	MSEL1CR_12_0 = 3104,
	MSEL1CR_12_1 = 3105,
	MSEL1CR_11_0 = 3106,
	MSEL1CR_11_1 = 3107,
	MSEL1CR_10_0 = 3108,
	MSEL1CR_10_1 = 3109,
	MSEL1CR_09_0 = 3110,
	MSEL1CR_09_1 = 3111,
	MSEL1CR_08_0 = 3112,
	MSEL1CR_08_1 = 3113,
	MSEL1CR_07_0 = 3114,
	MSEL1CR_07_1 = 3115,
	MSEL1CR_06_0 = 3116,
	MSEL1CR_06_1 = 3117,
	MSEL1CR_05_0 = 3118,
	MSEL1CR_05_1 = 3119,
	MSEL1CR_04_0 = 3120,
	MSEL1CR_04_1 = 3121,
	MSEL1CR_03_0 = 3122,
	MSEL1CR_03_1 = 3123,
	MSEL1CR_02_0 = 3124,
	MSEL1CR_02_1 = 3125,
	MSEL1CR_01_0 = 3126,
	MSEL1CR_01_1 = 3127,
	MSEL1CR_00_0 = 3128,
	MSEL1CR_00_1 = 3129,
	MSEL3CR_31_0 = 3130,
	MSEL3CR_31_1 = 3131,
	MSEL3CR_28_0 = 3132,
	MSEL3CR_28_1 = 3133,
	MSEL3CR_27_0 = 3134,
	MSEL3CR_27_1 = 3135,
	MSEL3CR_26_0 = 3136,
	MSEL3CR_26_1 = 3137,
	MSEL3CR_23_0 = 3138,
	MSEL3CR_23_1 = 3139,
	MSEL3CR_22_0 = 3140,
	MSEL3CR_22_1 = 3141,
	MSEL3CR_21_0 = 3142,
	MSEL3CR_21_1 = 3143,
	MSEL3CR_20_0 = 3144,
	MSEL3CR_20_1 = 3145,
	MSEL3CR_19_0 = 3146,
	MSEL3CR_19_1 = 3147,
	MSEL3CR_18_0 = 3148,
	MSEL3CR_18_1 = 3149,
	MSEL3CR_17_0 = 3150,
	MSEL3CR_17_1 = 3151,
	MSEL3CR_16_0 = 3152,
	MSEL3CR_16_1 = 3153,
	MSEL3CR_15_0 = 3154,
	MSEL3CR_15_1 = 3155,
	MSEL3CR_12_0 = 3156,
	MSEL3CR_12_1 = 3157,
	MSEL3CR_11_0 = 3158,
	MSEL3CR_11_1 = 3159,
	MSEL3CR_10_0 = 3160,
	MSEL3CR_10_1 = 3161,
	MSEL3CR_09_0 = 3162,
	MSEL3CR_09_1 = 3163,
	MSEL3CR_06_0 = 3164,
	MSEL3CR_06_1 = 3165,
	MSEL3CR_03_0 = 3166,
	MSEL3CR_03_1 = 3167,
	MSEL3CR_01_0 = 3168,
	MSEL3CR_01_1 = 3169,
	MSEL3CR_00_0 = 3170,
	MSEL3CR_00_1 = 3171,
	MSEL4CR_30_0 = 3172,
	MSEL4CR_30_1 = 3173,
	MSEL4CR_29_0 = 3174,
	MSEL4CR_29_1 = 3175,
	MSEL4CR_28_0 = 3176,
	MSEL4CR_28_1 = 3177,
	MSEL4CR_27_0 = 3178,
	MSEL4CR_27_1 = 3179,
	MSEL4CR_26_0 = 3180,
	MSEL4CR_26_1 = 3181,
	MSEL4CR_25_0 = 3182,
	MSEL4CR_25_1 = 3183,
	MSEL4CR_24_0 = 3184,
	MSEL4CR_24_1 = 3185,
	MSEL4CR_23_0 = 3186,
	MSEL4CR_23_1 = 3187,
	MSEL4CR_22_0 = 3188,
	MSEL4CR_22_1 = 3189,
	MSEL4CR_21_0 = 3190,
	MSEL4CR_21_1 = 3191,
	MSEL4CR_20_0 = 3192,
	MSEL4CR_20_1 = 3193,
	MSEL4CR_19_0 = 3194,
	MSEL4CR_19_1 = 3195,
	MSEL4CR_18_0 = 3196,
	MSEL4CR_18_1 = 3197,
	MSEL4CR_17_0 = 3198,
	MSEL4CR_17_1 = 3199,
	MSEL4CR_16_0 = 3200,
	MSEL4CR_16_1 = 3201,
	MSEL4CR_15_0 = 3202,
	MSEL4CR_15_1 = 3203,
	MSEL4CR_14_0 = 3204,
	MSEL4CR_14_1 = 3205,
	MSEL4CR_13_0 = 3206,
	MSEL4CR_13_1 = 3207,
	MSEL4CR_12_0 = 3208,
	MSEL4CR_12_1 = 3209,
	MSEL4CR_11_0 = 3210,
	MSEL4CR_11_1 = 3211,
	MSEL4CR_10_0 = 3212,
	MSEL4CR_10_1 = 3213,
	MSEL4CR_09_0 = 3214,
	MSEL4CR_09_1 = 3215,
	MSEL4CR_07_0 = 3216,
	MSEL4CR_07_1 = 3217,
	MSEL4CR_04_0 = 3218,
	MSEL4CR_04_1 = 3219,
	MSEL4CR_01_0 = 3220,
	MSEL4CR_01_1 = 3221,
	MSEL5CR_31_0 = 3222,
	MSEL5CR_31_1 = 3223,
	MSEL5CR_30_0 = 3224,
	MSEL5CR_30_1 = 3225,
	MSEL5CR_29_0 = 3226,
	MSEL5CR_29_1 = 3227,
	MSEL5CR_28_0 = 3228,
	MSEL5CR_28_1 = 3229,
	MSEL5CR_27_0 = 3230,
	MSEL5CR_27_1 = 3231,
	MSEL5CR_26_0 = 3232,
	MSEL5CR_26_1 = 3233,
	MSEL5CR_25_0 = 3234,
	MSEL5CR_25_1 = 3235,
	MSEL5CR_24_0 = 3236,
	MSEL5CR_24_1 = 3237,
	MSEL5CR_23_0 = 3238,
	MSEL5CR_23_1 = 3239,
	MSEL5CR_22_0 = 3240,
	MSEL5CR_22_1 = 3241,
	MSEL5CR_21_0 = 3242,
	MSEL5CR_21_1 = 3243,
	MSEL5CR_20_0 = 3244,
	MSEL5CR_20_1 = 3245,
	MSEL5CR_19_0 = 3246,
	MSEL5CR_19_1 = 3247,
	MSEL5CR_18_0 = 3248,
	MSEL5CR_18_1 = 3249,
	MSEL5CR_17_0 = 3250,
	MSEL5CR_17_1 = 3251,
	MSEL5CR_16_0 = 3252,
	MSEL5CR_16_1 = 3253,
	MSEL5CR_15_0 = 3254,
	MSEL5CR_15_1 = 3255,
	MSEL5CR_14_0 = 3256,
	MSEL5CR_14_1 = 3257,
	MSEL5CR_13_0 = 3258,
	MSEL5CR_13_1 = 3259,
	MSEL5CR_12_0 = 3260,
	MSEL5CR_12_1 = 3261,
	MSEL5CR_11_0 = 3262,
	MSEL5CR_11_1 = 3263,
	MSEL5CR_10_0 = 3264,
	MSEL5CR_10_1 = 3265,
	MSEL5CR_09_0 = 3266,
	MSEL5CR_09_1 = 3267,
	MSEL5CR_08_0 = 3268,
	MSEL5CR_08_1 = 3269,
	MSEL5CR_07_0 = 3270,
	MSEL5CR_07_1 = 3271,
	MSEL5CR_06_0 = 3272,
	MSEL5CR_06_1 = 3273,
	MSEL8CR_16_0 = 3274,
	MSEL8CR_16_1 = 3275,
	MSEL8CR_01_0 = 3276,
	MSEL8CR_01_1 = 3277,
	MSEL8CR_00_0 = 3278,
	MSEL8CR_00_1 = 3279,
	PINMUX_FUNCTION_END___2 = 3280,
	PINMUX_MARK_BEGIN___2 = 3281,
	LCDD0_MARK = 3282,
	PDM2_CLK_0_MARK = 3283,
	DU0_DR0_MARK = 3284,
	IRQ0_MARK = 3285,
	LCDD1_MARK = 3286,
	PDM2_DATA_1_MARK = 3287,
	DU0_DR19_MARK = 3288,
	IRQ1_MARK = 3289,
	LCDD2_MARK = 3290,
	PDM3_CLK_2_MARK = 3291,
	DU0_DR2_MARK = 3292,
	IRQ2_MARK = 3293,
	LCDD3_MARK = 3294,
	PDM3_DATA_3_MARK = 3295,
	DU0_DR3_MARK = 3296,
	IRQ3_MARK = 3297,
	LCDD4_MARK = 3298,
	PDM4_CLK_4_MARK = 3299,
	DU0_DR4_MARK = 3300,
	IRQ4_MARK = 3301,
	LCDD5_MARK = 3302,
	PDM4_DATA_5_MARK = 3303,
	DU0_DR5_MARK = 3304,
	IRQ5_MARK = 3305,
	LCDD6_MARK = 3306,
	PDM0_OUTCLK_6_MARK = 3307,
	DU0_DR6_MARK = 3308,
	IRQ6_MARK = 3309,
	LCDD7_MARK = 3310,
	PDM0_OUTDATA_7_MARK = 3311,
	DU0_DR7_MARK = 3312,
	IRQ7_MARK = 3313,
	LCDD8_MARK = 3314,
	PDM1_OUTCLK_8_MARK = 3315,
	DU0_DG0_MARK = 3316,
	IRQ8_MARK = 3317,
	LCDD9_MARK = 3318,
	PDM1_OUTDATA_9_MARK = 3319,
	DU0_DG1_MARK = 3320,
	IRQ9_MARK = 3321,
	LCDD10_MARK = 3322,
	FSICCK_MARK = 3323,
	DU0_DG2_MARK = 3324,
	IRQ10_MARK = 3325,
	LCDD11_MARK = 3326,
	FSICISLD_MARK = 3327,
	DU0_DG3_MARK = 3328,
	IRQ11_MARK = 3329,
	LCDD12_MARK = 3330,
	FSICOMC_MARK = 3331,
	DU0_DG4_MARK = 3332,
	IRQ12_MARK = 3333,
	LCDD13_MARK = 3334,
	FSICOLR_MARK = 3335,
	FSICILR_MARK = 3336,
	DU0_DG5_MARK = 3337,
	IRQ13_MARK = 3338,
	LCDD14_MARK = 3339,
	FSICOBT_MARK = 3340,
	FSICIBT_MARK = 3341,
	DU0_DG6_MARK = 3342,
	IRQ14_MARK = 3343,
	LCDD15_MARK = 3344,
	FSICOSLD_MARK = 3345,
	DU0_DG7_MARK = 3346,
	IRQ15_MARK = 3347,
	LCDD16_MARK = 3348,
	TPU1TO1_MARK = 3349,
	DU0_DB0_MARK = 3350,
	LCDD17_MARK = 3351,
	SF_IRQ_00_MARK = 3352,
	DU0_DB1_MARK = 3353,
	LCDD18_MARK = 3354,
	SF_IRQ_01_MARK = 3355,
	DU0_DB2_MARK = 3356,
	LCDD19_MARK = 3357,
	SCIFB3_RTS_19_MARK = 3358,
	DU0_DB3_MARK = 3359,
	LCDD20_MARK = 3360,
	SCIFB3_CTS_20_MARK = 3361,
	DU0_DB4_MARK = 3362,
	LCDD21_MARK = 3363,
	SCIFB3_TXD_21_MARK = 3364,
	DU0_DB5_MARK = 3365,
	LCDD22_MARK = 3366,
	SCIFB3_RXD_22_MARK = 3367,
	DU0_DB6_MARK = 3368,
	LCDD23_MARK = 3369,
	SCIFB3_SCK_23_MARK = 3370,
	DU0_DB7_MARK = 3371,
	LCDHSYN_MARK = 3372,
	LCDCS_MARK = 3373,
	SCIFB1_RTS_24_MARK = 3374,
	DU0_EXHSYNC_N_CSYNC_N_HSYNC_N_MARK = 3375,
	LCDVSYN_MARK = 3376,
	SCIFB1_CTS_25_MARK = 3377,
	DU0_EXVSYNC_N_VSYNC_N_CSYNC_N_MARK = 3378,
	LCDDCK_MARK = 3379,
	LCDWR_MARK = 3380,
	SCIFB1_TXD_26_MARK = 3381,
	DU0_DOTCLKIN_MARK = 3382,
	LCDDISP_MARK = 3383,
	LCDRS_MARK = 3384,
	SCIFB1_RXD_27_MARK = 3385,
	DU0_DOTCLKOUT_MARK = 3386,
	LCDRD_N_MARK = 3387,
	SCIFB1_SCK_28_MARK = 3388,
	DU0_DOTCLKOUTB_MARK = 3389,
	LCDLCLK_MARK = 3390,
	SF_IRQ_02_MARK = 3391,
	DU0_DISP_CSYNC_N_DE_MARK = 3392,
	LCDDON_MARK = 3393,
	SF_IRQ_03_MARK = 3394,
	DU0_ODDF_N_CLAMP_MARK = 3395,
	SCIFA0_RTS_MARK = 3396,
	SIM0_DET_MARK = 3397,
	CSCIF0_RTS_MARK = 3398,
	SCIFA0_CTS_MARK = 3399,
	SIM1_DET_MARK = 3400,
	CSCIF0_CTS_MARK = 3401,
	SCIFA0_SCK_MARK = 3402,
	SIM0_PWRON_MARK = 3403,
	CSCIF0_SCK_MARK = 3404,
	SCIFA1_RTS_MARK = 3405,
	CSCIF1_RTS_MARK = 3406,
	SCIFA1_CTS_MARK = 3407,
	CSCIF1_CTS_MARK = 3408,
	SCIFA1_SCK_MARK = 3409,
	CSCIF1_SCK_MARK = 3410,
	SCIFB0_RTS_MARK = 3411,
	TPU0TO1_MARK = 3412,
	SCIFB3_RTS_38_MARK = 3413,
	CHSCIF0_HRTS_MARK = 3414,
	SCIFB0_CTS_MARK = 3415,
	TPU0TO2_MARK = 3416,
	SCIFB3_CTS_39_MARK = 3417,
	CHSCIF0_HCTS_MARK = 3418,
	SCIFB0_SCK_MARK = 3419,
	TPU0TO3_MARK = 3420,
	SCIFB3_SCK_40_MARK = 3421,
	CHSCIF0_HSCK_MARK = 3422,
	PDM0_DATA_MARK = 3423,
	PDM1_DATA_MARK = 3424,
	HSI_RX_WAKE_MARK = 3425,
	SCIFB2_CTS_66_MARK = 3426,
	MSIOF3_SYNC_MARK = 3427,
	GenIO4_MARK = 3428,
	IRQ40_MARK = 3429,
	HSI_RX_READY_MARK = 3430,
	SCIFB1_TXD_67_MARK = 3431,
	GIO_OUT3_67_MARK = 3432,
	CHSCIF1_HTX_MARK = 3433,
	HSI_RX_FLAG_MARK = 3434,
	SCIFB2_TXD_68_MARK = 3435,
	MSIOF3_TXD_MARK = 3436,
	GIO_OUT4_68_MARK = 3437,
	HSI_RX_DATA_MARK = 3438,
	SCIFB2_RXD_69_MARK = 3439,
	MSIOF3_RXD_MARK = 3440,
	GIO_OUT5_69_MARK = 3441,
	HSI_TX_FLAG_MARK = 3442,
	SCIFB1_RTS_70_MARK = 3443,
	GIO_OUT1_70_MARK = 3444,
	HSIC_TSTCLK0_MARK = 3445,
	CHSCIF1_HRTS_MARK = 3446,
	HSI_TX_DATA_MARK = 3447,
	SCIFB1_CTS_71_MARK = 3448,
	GIO_OUT2_71_MARK = 3449,
	HSIC_TSTCLK1_MARK = 3450,
	CHSCIF1_HCTS_MARK = 3451,
	HSI_TX_WAKE_MARK = 3452,
	SCIFB1_RXD_72_MARK = 3453,
	GenIO8_MARK = 3454,
	CHSCIF1_HRX_MARK = 3455,
	HSI_TX_READY_MARK = 3456,
	SCIFB2_RTS_73_MARK = 3457,
	MSIOF3_SCK_MARK = 3458,
	GIO_OUT0_73_MARK = 3459,
	IRDA_OUT_MARK = 3460,
	IRDA_IN_MARK = 3461,
	IRDA_FIRSEL_MARK = 3462,
	TPU0TO0_MARK = 3463,
	DIGRFEN_MARK = 3464,
	GPS_TIMESTAMP_MARK = 3465,
	TXP_MARK = 3466,
	TXP2_MARK = 3467,
	COEX_0_MARK = 3468,
	COEX_1_MARK = 3469,
	IRQ19_MARK = 3470,
	IRQ18_MARK = 3471,
	KEYIN0_MARK = 3472,
	KEYIN1_MARK = 3473,
	KEYIN2_MARK = 3474,
	KEYIN3_MARK = 3475,
	KEYIN4_MARK = 3476,
	KEYIN5_MARK = 3477,
	KEYIN6_MARK = 3478,
	IRQ41_MARK = 3479,
	KEYIN7_MARK = 3480,
	IRQ42_MARK = 3481,
	KEYOUT0_MARK = 3482,
	KEYOUT1_MARK = 3483,
	KEYOUT2_MARK = 3484,
	KEYOUT3_MARK = 3485,
	KEYOUT4_MARK = 3486,
	KEYOUT5_MARK = 3487,
	IRQ43_MARK = 3488,
	KEYOUT6_MARK = 3489,
	IRQ44_MARK = 3490,
	KEYOUT7_MARK = 3491,
	RFANAEN_MARK = 3492,
	IRQ45_MARK = 3493,
	KEYIN8_MARK = 3494,
	KEYOUT8_MARK = 3495,
	SF_IRQ_04_MARK = 3496,
	IRQ46_MARK = 3497,
	KEYIN9_MARK = 3498,
	KEYOUT9_MARK = 3499,
	SF_IRQ_05_MARK = 3500,
	IRQ47_MARK = 3501,
	KEYIN10_MARK = 3502,
	KEYOUT10_MARK = 3503,
	SF_IRQ_06_MARK = 3504,
	IRQ48_MARK = 3505,
	KEYIN11_MARK = 3506,
	KEYOUT11_MARK = 3507,
	SF_IRQ_07_MARK = 3508,
	IRQ49_MARK = 3509,
	SCIFA0_TXD_MARK = 3510,
	CSCIF0_TX_MARK = 3511,
	SCIFA0_RXD_MARK = 3512,
	CSCIF0_RX_MARK = 3513,
	SCIFA1_TXD_MARK = 3514,
	CSCIF1_TX_MARK = 3515,
	SCIFA1_RXD_MARK = 3516,
	CSCIF1_RX_MARK = 3517,
	SF_PORT_1_120_MARK = 3518,
	SCIFB3_RXD_120_MARK = 3519,
	DU0_CDE_MARK = 3520,
	SF_PORT_0_121_MARK = 3521,
	SCIFB3_TXD_121_MARK = 3522,
	SCIFB0_TXD_MARK = 3523,
	CHSCIF0_HTX_MARK = 3524,
	SCIFB0_RXD_MARK = 3525,
	CHSCIF0_HRX_MARK = 3526,
	ISP_STROBE_124_MARK = 3527,
	STP_ISD_0_MARK = 3528,
	PDM4_CLK_125_MARK = 3529,
	MSIOF2_TXD_MARK = 3530,
	SIM0_VOLTSEL0_MARK = 3531,
	TS_SDEN_MARK = 3532,
	MSIOF7_SYNC_MARK = 3533,
	STP_ISEN_1_MARK = 3534,
	STP_ISEN_0_MARK = 3535,
	PDM1_OUTDATA_128_MARK = 3536,
	MSIOF2_SYNC_MARK = 3537,
	SIM1_VOLTSEL1_MARK = 3538,
	TS_SPSYNC_MARK = 3539,
	MSIOF7_RXD_MARK = 3540,
	STP_ISSYNC_1_MARK = 3541,
	STP_ISSYNC_0_MARK = 3542,
	PDM4_DATA_130_MARK = 3543,
	MSIOF2_RXD_MARK = 3544,
	SIM0_VOLTSEL1_MARK = 3545,
	STP_OPWM_0_MARK = 3546,
	SIM1_PWRON_MARK = 3547,
	TS_SCK_MARK = 3548,
	MSIOF7_SCK_MARK = 3549,
	STP_ISCLK_1_MARK = 3550,
	STP_ISCLK_0_MARK = 3551,
	PDM1_OUTCLK_133_MARK = 3552,
	MSIOF2_SCK_MARK = 3553,
	SIM1_VOLTSEL0_MARK = 3554,
	TS_SDAT_MARK = 3555,
	MSIOF7_TXD_MARK = 3556,
	STP_ISD_1_MARK = 3557,
	IRQ20_MARK = 3558,
	IRQ21_MARK = 3559,
	IRQ22_MARK = 3560,
	IRQ23_MARK = 3561,
	MMCD0_0_MARK = 3562,
	MMCD0_1_MARK = 3563,
	MMCD0_2_MARK = 3564,
	MMCD0_3_MARK = 3565,
	MMCD0_4_MARK = 3566,
	MMCD0_5_MARK = 3567,
	MMCD0_6_MARK = 3568,
	MMCD0_7_MARK = 3569,
	MMCCMD0_MARK = 3570,
	MMCCLK0_MARK = 3571,
	MMCRST_MARK = 3572,
	IRQ24_MARK = 3573,
	IRQ25_MARK = 3574,
	IRQ26_MARK = 3575,
	IRQ27_MARK = 3576,
	A10_MARK = 3577,
	MMCD1_7_MARK = 3578,
	IRQ31_MARK = 3579,
	A9_MARK = 3580,
	MMCD1_6_MARK = 3581,
	IRQ32_MARK = 3582,
	A8_MARK = 3583,
	MMCD1_5_MARK = 3584,
	IRQ33_MARK = 3585,
	A7_MARK = 3586,
	MMCD1_4_MARK = 3587,
	IRQ34_MARK = 3588,
	A6_MARK = 3589,
	MMCD1_3_MARK = 3590,
	IRQ35_MARK = 3591,
	A5_MARK = 3592,
	MMCD1_2_MARK = 3593,
	IRQ36_MARK = 3594,
	A4_MARK = 3595,
	MMCD1_1_MARK = 3596,
	IRQ37_MARK = 3597,
	A3_MARK = 3598,
	MMCD1_0_MARK = 3599,
	IRQ38_MARK = 3600,
	A2_MARK = 3601,
	MMCCMD1_MARK = 3602,
	IRQ39_MARK = 3603,
	A1_MARK = 3604,
	A0_MARK = 3605,
	BS_MARK = 3606,
	CKO_MARK = 3607,
	MMCCLK1_MARK = 3608,
	CS0_N_MARK = 3609,
	SIM0_GPO1_MARK = 3610,
	CS2_N_MARK = 3611,
	SIM0_GPO2_MARK = 3612,
	CS4_N_MARK = 3613,
	VIO_VD_MARK = 3614,
	SIM1_GPO0_MARK = 3615,
	D15_MARK = 3616,
	GIO_OUT15_MARK = 3617,
	D14_MARK = 3618,
	GIO_OUT14_MARK = 3619,
	D13_MARK = 3620,
	GIO_OUT13_MARK = 3621,
	D12_MARK = 3622,
	GIO_OUT12_MARK = 3623,
	D11_MARK = 3624,
	WGM_TXP2_MARK = 3625,
	D10_MARK = 3626,
	WGM_GPS_TIMEM_ASK_RFCLK_MARK = 3627,
	D9_MARK = 3628,
	VIO_D9_MARK = 3629,
	GIO_OUT9_MARK = 3630,
	D8_MARK = 3631,
	VIO_D8_MARK = 3632,
	GIO_OUT8_MARK = 3633,
	D7_MARK = 3634,
	VIO_D7_MARK = 3635,
	GIO_OUT7_MARK = 3636,
	D6_MARK = 3637,
	VIO_D6_MARK = 3638,
	GIO_OUT6_MARK = 3639,
	D5_MARK = 3640,
	VIO_D5_MARK = 3641,
	GIO_OUT5_217_MARK = 3642,
	D4_MARK = 3643,
	VIO_D4_MARK = 3644,
	GIO_OUT4_218_MARK = 3645,
	D3_MARK = 3646,
	VIO_D3_MARK = 3647,
	GIO_OUT3_219_MARK = 3648,
	D2_MARK = 3649,
	VIO_D2_MARK = 3650,
	GIO_OUT2_220_MARK = 3651,
	D1_MARK = 3652,
	VIO_D1_MARK = 3653,
	GIO_OUT1_221_MARK = 3654,
	D0_MARK = 3655,
	VIO_D0_MARK = 3656,
	GIO_OUT0_222_MARK = 3657,
	RDWR_224_MARK = 3658,
	VIO_HD_MARK = 3659,
	SIM1_GPO2_MARK = 3660,
	RD_N_MARK = 3661,
	WAIT_N_MARK = 3662,
	VIO_CLK_MARK = 3663,
	SIM1_GPO1_MARK = 3664,
	WE0_N_MARK = 3665,
	RDWR_227_MARK = 3666,
	WE1_N_MARK = 3667,
	SIM0_GPO0_MARK = 3668,
	PWMO_MARK = 3669,
	VIO_CKO1_229_MARK = 3670,
	SLIM_CLK_MARK = 3671,
	VIO_CKO4_230_MARK = 3672,
	SLIM_DATA_MARK = 3673,
	VIO_CKO5_231_MARK = 3674,
	VIO_CKO2_232_MARK = 3675,
	SF_PORT_0_232_MARK = 3676,
	VIO_CKO3_233_MARK = 3677,
	SF_PORT_1_233_MARK = 3678,
	FSIACK_MARK = 3679,
	PDM3_CLK_234_MARK = 3680,
	ISP_IRIS1_234_MARK = 3681,
	FSIAISLD_MARK = 3682,
	PDM3_DATA_235_MARK = 3683,
	FSIAOMC_MARK = 3684,
	PDM0_OUTCLK_236_MARK = 3685,
	ISP_IRIS0_236_MARK = 3686,
	FSIAOLR_MARK = 3687,
	FSIAILR_MARK = 3688,
	FSIAOBT_MARK = 3689,
	FSIAIBT_MARK = 3690,
	FSIAOSLD_MARK = 3691,
	PDM0_OUTDATA_239_MARK = 3692,
	FSIBISLD_MARK = 3693,
	FSIBOLR_MARK = 3694,
	FSIBILR_MARK = 3695,
	FSIBOMC_MARK = 3696,
	ISP_SHUTTER1_242_MARK = 3697,
	FSIBOBT_MARK = 3698,
	FSIBIBT_MARK = 3699,
	FSIBOSLD_MARK = 3700,
	FSIASPDIF_MARK = 3701,
	FSIBCK_MARK = 3702,
	ISP_SHUTTER0_245_MARK = 3703,
	ISP_IRIS1_246_MARK = 3704,
	ISP_IRIS0_247_MARK = 3705,
	ISP_SHUTTER1_248_MARK = 3706,
	ISP_SHUTTER0_249_MARK = 3707,
	ISP_STROBE_250_MARK = 3708,
	MSIOF0_SYNC_MARK = 3709,
	MSIOF0_RXD_MARK = 3710,
	MSIOF0_SCK_MARK = 3711,
	MSIOF0_SS2_MARK = 3712,
	VIO_CKO3_259_MARK = 3713,
	MSIOF0_TXD_MARK = 3714,
	SCIFB1_SCK_261_MARK = 3715,
	CHSCIF1_HSCK_MARK = 3716,
	SCIFB2_SCK_262_MARK = 3717,
	MSIOF1_SS2_MARK = 3718,
	MSIOF5_SS2_MARK = 3719,
	MSIOF1_TXD_MARK = 3720,
	MSIOF5_TXD_MARK = 3721,
	MSIOF1_RXD_MARK = 3722,
	MSIOF5_RXD_MARK = 3723,
	MSIOF1_SS1_MARK = 3724,
	MSIOF5_SS1_MARK = 3725,
	MSIOF0_SS1_MARK = 3726,
	MSIOF1_SCK_MARK = 3727,
	MSIOF5_SCK_MARK = 3728,
	MSIOF1_SYNC_MARK = 3729,
	MSIOF5_SYNC_MARK = 3730,
	MSIOF2_SS1_MARK = 3731,
	VIO_CKO5_270_MARK = 3732,
	MSIOF2_SS2_MARK = 3733,
	VIO_CKO2_271_MARK = 3734,
	MSIOF3_SS2_MARK = 3735,
	VIO_CKO1_272_MARK = 3736,
	MSIOF3_SS1_MARK = 3737,
	VIO_CKO4_273_MARK = 3738,
	MSIOF4_SS2_MARK = 3739,
	TPU1TO0_MARK = 3740,
	IC_DP_MARK = 3741,
	SIM0_RST_MARK = 3742,
	IC_DM_MARK = 3743,
	SIM0_BSICOMP_MARK = 3744,
	SIM0_CLK_MARK = 3745,
	SIM0_IO_MARK = 3746,
	SIM1_IO_MARK = 3747,
	PDM2_DATA_281_MARK = 3748,
	SIM1_CLK_MARK = 3749,
	PDM2_CLK_282_MARK = 3750,
	SIM1_RST_MARK = 3751,
	SDHID1_0_MARK = 3752,
	STMDATA0_2_MARK = 3753,
	SDHID1_1_MARK = 3754,
	STMDATA1_2_MARK = 3755,
	IRQ51_MARK = 3756,
	SDHID1_2_MARK = 3757,
	STMDATA2_2_MARK = 3758,
	SDHID1_3_MARK = 3759,
	STMDATA3_2_MARK = 3760,
	SDHICLK1_MARK = 3761,
	STMCLK_2_MARK = 3762,
	SDHICMD1_MARK = 3763,
	STMSIDI_2_MARK = 3764,
	SDHID2_0_MARK = 3765,
	MSIOF4_TXD_MARK = 3766,
	SCIFB2_TXD_295_MARK = 3767,
	MSIOF6_TXD_MARK = 3768,
	SDHID2_1_MARK = 3769,
	MSIOF6_SS2_MARK = 3770,
	IRQ52_MARK = 3771,
	SDHID2_2_MARK = 3772,
	MSIOF4_RXD_MARK = 3773,
	SCIFB2_RXD_297_MARK = 3774,
	MSIOF6_RXD_MARK = 3775,
	SDHID2_3_MARK = 3776,
	MSIOF4_SYNC_MARK = 3777,
	SCIFB2_CTS_298_MARK = 3778,
	MSIOF6_SYNC_MARK = 3779,
	SDHICLK2_MARK = 3780,
	MSIOF4_SCK_MARK = 3781,
	SCIFB2_SCK_299_MARK = 3782,
	MSIOF6_SCK_MARK = 3783,
	SDHICMD2_MARK = 3784,
	MSIOF4_SS1_MARK = 3785,
	SCIFB2_RTS_300_MARK = 3786,
	MSIOF6_SS1_MARK = 3787,
	SDHICD0_MARK = 3788,
	IRQ50_MARK = 3789,
	SDHID0_0_MARK = 3790,
	STMDATA0_1_MARK = 3791,
	SDHID0_1_MARK = 3792,
	STMDATA1_1_MARK = 3793,
	SDHID0_2_MARK = 3794,
	STMDATA2_1_MARK = 3795,
	SDHID0_3_MARK = 3796,
	STMDATA3_1_MARK = 3797,
	SDHICMD0_MARK = 3798,
	STMSIDI_1_MARK = 3799,
	SDHIWP0_MARK = 3800,
	SDHICLK0_MARK = 3801,
	STMCLK_1_MARK = 3802,
	IRQ16_MARK = 3803,
	IRQ17_MARK = 3804,
	IRQ28_MARK = 3805,
	IRQ29_MARK = 3806,
	IRQ30_MARK = 3807,
	IRQ53_MARK = 3808,
	IRQ54_MARK = 3809,
	IRQ55_MARK = 3810,
	IRQ56_MARK = 3811,
	IRQ57_MARK = 3812,
	PINMUX_MARK_END___2 = 3813,
};

enum {
	PINMUX_RESERVED___3 = 0,
	PINMUX_DATA_BEGIN___3 = 1,
	PORT0_DATA___3 = 2,
	PORT1_DATA___3 = 3,
	PORT2_DATA___3 = 4,
	PORT3_DATA___3 = 5,
	PORT4_DATA___3 = 6,
	PORT5_DATA___3 = 7,
	PORT6_DATA___3 = 8,
	PORT7_DATA___3 = 9,
	PORT8_DATA___3 = 10,
	PORT9_DATA___3 = 11,
	PORT10_DATA___3 = 12,
	PORT11_DATA___3 = 13,
	PORT12_DATA___3 = 14,
	PORT13_DATA___3 = 15,
	PORT14_DATA___3 = 16,
	PORT15_DATA___3 = 17,
	PORT16_DATA___3 = 18,
	PORT17_DATA___3 = 19,
	PORT18_DATA___3 = 20,
	PORT19_DATA___3 = 21,
	PORT20_DATA___3 = 22,
	PORT21_DATA___3 = 23,
	PORT22_DATA___3 = 24,
	PORT23_DATA___3 = 25,
	PORT24_DATA___3 = 26,
	PORT25_DATA___3 = 27,
	PORT26_DATA___3 = 28,
	PORT27_DATA___3 = 29,
	PORT28_DATA___3 = 30,
	PORT29_DATA___3 = 31,
	PORT30_DATA___3 = 32,
	PORT31_DATA___2 = 33,
	PORT32_DATA___3 = 34,
	PORT33_DATA___3 = 35,
	PORT34_DATA___3 = 36,
	PORT35_DATA___3 = 37,
	PORT36_DATA___3 = 38,
	PORT37_DATA___3 = 39,
	PORT38_DATA___3 = 40,
	PORT39_DATA___3 = 41,
	PORT40_DATA___3 = 42,
	PORT41_DATA___2 = 43,
	PORT42_DATA___2 = 44,
	PORT43_DATA___2 = 45,
	PORT44_DATA___2 = 46,
	PORT45_DATA___2 = 47,
	PORT46_DATA___2 = 48,
	PORT47_DATA___2 = 49,
	PORT48_DATA___2 = 50,
	PORT49_DATA___2 = 51,
	PORT50_DATA___2 = 52,
	PORT51_DATA___2 = 53,
	PORT52_DATA___2 = 54,
	PORT53_DATA___2 = 55,
	PORT54_DATA___2 = 56,
	PORT55_DATA___2 = 57,
	PORT56_DATA___2 = 58,
	PORT57_DATA___2 = 59,
	PORT58_DATA___2 = 60,
	PORT59_DATA___2 = 61,
	PORT60_DATA___2 = 62,
	PORT61_DATA___2 = 63,
	PORT62_DATA___2 = 64,
	PORT63_DATA___2 = 65,
	PORT64_DATA___3 = 66,
	PORT65_DATA___3 = 67,
	PORT66_DATA___3 = 68,
	PORT67_DATA___3 = 69,
	PORT68_DATA___3 = 70,
	PORT69_DATA___3 = 71,
	PORT70_DATA___3 = 72,
	PORT71_DATA___3 = 73,
	PORT72_DATA___3 = 74,
	PORT73_DATA___3 = 75,
	PORT74_DATA___3 = 76,
	PORT75_DATA___3 = 77,
	PORT76_DATA___3 = 78,
	PORT77_DATA___3 = 79,
	PORT78_DATA___3 = 80,
	PORT79_DATA___3 = 81,
	PORT80_DATA___3 = 82,
	PORT81_DATA___3 = 83,
	PORT82_DATA___3 = 84,
	PORT83_DATA___3 = 85,
	PORT84_DATA___3 = 86,
	PORT85_DATA___3 = 87,
	PORT86_DATA___2 = 88,
	PORT87_DATA___2 = 89,
	PORT88_DATA___2 = 90,
	PORT89_DATA___2 = 91,
	PORT90_DATA___2 = 92,
	PORT91_DATA___2 = 93,
	PORT92_DATA___2 = 94,
	PORT93_DATA___2 = 95,
	PORT94_DATA___2 = 96,
	PORT95_DATA___2 = 97,
	PORT96_DATA___3 = 98,
	PORT97_DATA___3 = 99,
	PORT98_DATA___3 = 100,
	PORT99_DATA___3 = 101,
	PORT100_DATA___3 = 102,
	PORT101_DATA___3 = 103,
	PORT102_DATA___3 = 104,
	PORT103_DATA___3 = 105,
	PORT104_DATA___3 = 106,
	PORT105_DATA___3 = 107,
	PORT106_DATA___3 = 108,
	PORT107_DATA___3 = 109,
	PORT108_DATA___3 = 110,
	PORT109_DATA___3 = 111,
	PORT110_DATA___3 = 112,
	PORT111_DATA___3 = 113,
	PORT112_DATA___3 = 114,
	PORT113_DATA___3 = 115,
	PORT114_DATA___3 = 116,
	PORT115_DATA___3 = 117,
	PORT116_DATA___3 = 118,
	PORT117_DATA___3 = 119,
	PORT118_DATA___3 = 120,
	PORT119_DATA___3 = 121,
	PORT120_DATA___3 = 122,
	PORT121_DATA___3 = 123,
	PORT122_DATA___3 = 124,
	PORT123_DATA___3 = 125,
	PORT124_DATA___3 = 126,
	PORT125_DATA___3 = 127,
	PORT126_DATA___3 = 128,
	PORT127_DATA___2 = 129,
	PORT128_DATA___3 = 130,
	PORT129_DATA___3 = 131,
	PORT130_DATA___3 = 132,
	PORT131_DATA___3 = 133,
	PORT132_DATA___3 = 134,
	PORT133_DATA___3 = 135,
	PORT134_DATA___3 = 136,
	PORT135_DATA___2 = 137,
	PORT136_DATA___2 = 138,
	PORT137_DATA___2 = 139,
	PORT138_DATA___2 = 140,
	PORT139_DATA___2 = 141,
	PORT140_DATA___2 = 142,
	PORT141_DATA___2 = 143,
	PORT142_DATA___2 = 144,
	PORT143_DATA___2 = 145,
	PORT144_DATA___2 = 146,
	PORT145_DATA___2 = 147,
	PORT146_DATA___2 = 148,
	PORT147_DATA___2 = 149,
	PORT148_DATA___2 = 150,
	PORT149_DATA___2 = 151,
	PORT150_DATA___2 = 152,
	PORT151_DATA___2 = 153,
	PORT152_DATA___2 = 154,
	PORT153_DATA___2 = 155,
	PORT154_DATA___2 = 156,
	PORT155_DATA___2 = 157,
	PORT156_DATA___2 = 158,
	PORT157_DATA___2 = 159,
	PORT158_DATA___2 = 160,
	PORT159_DATA = 161,
	PORT160_DATA___2 = 162,
	PORT161_DATA___2 = 163,
	PORT162_DATA___2 = 164,
	PORT163_DATA___2 = 165,
	PORT164_DATA___2 = 166,
	PORT165_DATA___2 = 167,
	PORT166_DATA___2 = 168,
	PORT167_DATA___2 = 169,
	PORT168_DATA___2 = 170,
	PORT169_DATA___2 = 171,
	PORT170_DATA___2 = 172,
	PORT171_DATA___2 = 173,
	PORT172_DATA___2 = 174,
	PORT173_DATA___2 = 175,
	PORT174_DATA___2 = 176,
	PORT175_DATA___2 = 177,
	PORT176_DATA___2 = 178,
	PORT177_DATA___2 = 179,
	PORT178_DATA___2 = 180,
	PORT179_DATA = 181,
	PORT180_DATA = 182,
	PORT181_DATA = 183,
	PORT182_DATA = 184,
	PORT183_DATA = 185,
	PORT184_DATA = 186,
	PORT185_DATA = 187,
	PORT186_DATA = 188,
	PORT187_DATA = 189,
	PORT188_DATA = 190,
	PORT189_DATA = 191,
	PORT190_DATA = 192,
	PORT191_DATA = 193,
	PORT192_DATA___2 = 194,
	PORT193_DATA___2 = 195,
	PORT194_DATA___2 = 196,
	PORT195_DATA___2 = 197,
	PORT196_DATA___2 = 198,
	PORT197_DATA___2 = 199,
	PORT198_DATA___2 = 200,
	PORT199_DATA___2 = 201,
	PORT200_DATA___2 = 202,
	PORT201_DATA___2 = 203,
	PORT202_DATA___2 = 204,
	PORT203_DATA___2 = 205,
	PORT204_DATA___2 = 206,
	PORT205_DATA___2 = 207,
	PORT206_DATA___2 = 208,
	PORT207_DATA___2 = 209,
	PORT208_DATA___2 = 210,
	PORT209_DATA___2 = 211,
	PORT210_DATA___2 = 212,
	PORT211_DATA___2 = 213,
	PINMUX_DATA_END___3 = 214,
	PINMUX_INPUT_BEGIN___2 = 215,
	PORT0_IN___2 = 216,
	PORT1_IN___2 = 217,
	PORT2_IN___2 = 218,
	PORT3_IN___2 = 219,
	PORT4_IN___2 = 220,
	PORT5_IN___2 = 221,
	PORT6_IN___2 = 222,
	PORT7_IN___2 = 223,
	PORT8_IN___2 = 224,
	PORT9_IN___2 = 225,
	PORT10_IN___2 = 226,
	PORT11_IN___2 = 227,
	PORT12_IN___2 = 228,
	PORT13_IN___2 = 229,
	PORT14_IN___2 = 230,
	PORT15_IN___2 = 231,
	PORT16_IN___2 = 232,
	PORT17_IN___2 = 233,
	PORT18_IN___2 = 234,
	PORT19_IN___2 = 235,
	PORT20_IN___2 = 236,
	PORT21_IN___2 = 237,
	PORT22_IN___2 = 238,
	PORT23_IN___2 = 239,
	PORT24_IN___2 = 240,
	PORT25_IN___2 = 241,
	PORT26_IN___2 = 242,
	PORT27_IN___2 = 243,
	PORT28_IN___2 = 244,
	PORT29_IN___2 = 245,
	PORT30_IN___2 = 246,
	PORT31_IN = 247,
	PORT32_IN___2 = 248,
	PORT33_IN___2 = 249,
	PORT34_IN___2 = 250,
	PORT35_IN___2 = 251,
	PORT36_IN___2 = 252,
	PORT37_IN___2 = 253,
	PORT38_IN___2 = 254,
	PORT39_IN___2 = 255,
	PORT40_IN___2 = 256,
	PORT41_IN = 257,
	PORT42_IN = 258,
	PORT43_IN = 259,
	PORT44_IN = 260,
	PORT45_IN = 261,
	PORT46_IN = 262,
	PORT47_IN = 263,
	PORT48_IN = 264,
	PORT49_IN = 265,
	PORT50_IN = 266,
	PORT51_IN = 267,
	PORT52_IN = 268,
	PORT53_IN = 269,
	PORT54_IN = 270,
	PORT55_IN = 271,
	PORT56_IN = 272,
	PORT57_IN = 273,
	PORT58_IN = 274,
	PORT59_IN = 275,
	PORT60_IN = 276,
	PORT61_IN = 277,
	PORT62_IN = 278,
	PORT63_IN = 279,
	PORT64_IN___2 = 280,
	PORT65_IN___2 = 281,
	PORT66_IN___2 = 282,
	PORT67_IN___2 = 283,
	PORT68_IN___2 = 284,
	PORT69_IN___2 = 285,
	PORT70_IN___2 = 286,
	PORT71_IN___2 = 287,
	PORT72_IN___2 = 288,
	PORT73_IN___2 = 289,
	PORT74_IN___2 = 290,
	PORT75_IN___2 = 291,
	PORT76_IN___2 = 292,
	PORT77_IN___2 = 293,
	PORT78_IN___2 = 294,
	PORT79_IN___2 = 295,
	PORT80_IN___2 = 296,
	PORT81_IN___2 = 297,
	PORT82_IN___2 = 298,
	PORT83_IN___2 = 299,
	PORT84_IN___2 = 300,
	PORT85_IN___2 = 301,
	PORT86_IN = 302,
	PORT87_IN = 303,
	PORT88_IN = 304,
	PORT89_IN = 305,
	PORT90_IN = 306,
	PORT91_IN = 307,
	PORT92_IN = 308,
	PORT93_IN = 309,
	PORT94_IN = 310,
	PORT95_IN = 311,
	PORT96_IN___2 = 312,
	PORT97_IN___2 = 313,
	PORT98_IN___2 = 314,
	PORT99_IN___2 = 315,
	PORT100_IN___2 = 316,
	PORT101_IN___2 = 317,
	PORT102_IN___2 = 318,
	PORT103_IN___2 = 319,
	PORT104_IN___2 = 320,
	PORT105_IN___2 = 321,
	PORT106_IN___2 = 322,
	PORT107_IN___2 = 323,
	PORT108_IN___2 = 324,
	PORT109_IN___2 = 325,
	PORT110_IN___2 = 326,
	PORT111_IN___2 = 327,
	PORT112_IN___2 = 328,
	PORT113_IN___2 = 329,
	PORT114_IN___2 = 330,
	PORT115_IN___2 = 331,
	PORT116_IN___2 = 332,
	PORT117_IN___2 = 333,
	PORT118_IN___2 = 334,
	PORT119_IN___2 = 335,
	PORT120_IN___2 = 336,
	PORT121_IN___2 = 337,
	PORT122_IN___2 = 338,
	PORT123_IN___2 = 339,
	PORT124_IN___2 = 340,
	PORT125_IN___2 = 341,
	PORT126_IN___2 = 342,
	PORT127_IN = 343,
	PORT128_IN___2 = 344,
	PORT129_IN___2 = 345,
	PORT130_IN___2 = 346,
	PORT131_IN___2 = 347,
	PORT132_IN___2 = 348,
	PORT133_IN___2 = 349,
	PORT134_IN___2 = 350,
	PORT135_IN = 351,
	PORT136_IN = 352,
	PORT137_IN = 353,
	PORT138_IN = 354,
	PORT139_IN = 355,
	PORT140_IN = 356,
	PORT141_IN = 357,
	PORT142_IN = 358,
	PORT143_IN = 359,
	PORT144_IN = 360,
	PORT145_IN = 361,
	PORT146_IN = 362,
	PORT147_IN = 363,
	PORT148_IN = 364,
	PORT149_IN = 365,
	PORT150_IN = 366,
	PORT151_IN = 367,
	PORT152_IN = 368,
	PORT153_IN = 369,
	PORT154_IN = 370,
	PORT155_IN = 371,
	PORT156_IN = 372,
	PORT157_IN = 373,
	PORT158_IN = 374,
	PORT159_IN = 375,
	PORT160_IN___2 = 376,
	PORT161_IN___2 = 377,
	PORT162_IN___2 = 378,
	PORT163_IN___2 = 379,
	PORT164_IN___2 = 380,
	PORT165_IN___2 = 381,
	PORT166_IN___2 = 382,
	PORT167_IN___2 = 383,
	PORT168_IN___2 = 384,
	PORT169_IN___2 = 385,
	PORT170_IN___2 = 386,
	PORT171_IN___2 = 387,
	PORT172_IN___2 = 388,
	PORT173_IN___2 = 389,
	PORT174_IN___2 = 390,
	PORT175_IN___2 = 391,
	PORT176_IN___2 = 392,
	PORT177_IN___2 = 393,
	PORT178_IN___2 = 394,
	PORT179_IN = 395,
	PORT180_IN = 396,
	PORT181_IN = 397,
	PORT182_IN = 398,
	PORT183_IN = 399,
	PORT184_IN = 400,
	PORT185_IN = 401,
	PORT186_IN = 402,
	PORT187_IN = 403,
	PORT188_IN = 404,
	PORT189_IN = 405,
	PORT190_IN = 406,
	PORT191_IN = 407,
	PORT192_IN___2 = 408,
	PORT193_IN___2 = 409,
	PORT194_IN___2 = 410,
	PORT195_IN___2 = 411,
	PORT196_IN___2 = 412,
	PORT197_IN___2 = 413,
	PORT198_IN___2 = 414,
	PORT199_IN___2 = 415,
	PORT200_IN___2 = 416,
	PORT201_IN___2 = 417,
	PORT202_IN___2 = 418,
	PORT203_IN___2 = 419,
	PORT204_IN___2 = 420,
	PORT205_IN___2 = 421,
	PORT206_IN___2 = 422,
	PORT207_IN___2 = 423,
	PORT208_IN___2 = 424,
	PORT209_IN___2 = 425,
	PORT210_IN___2 = 426,
	PORT211_IN___2 = 427,
	PINMUX_INPUT_END___2 = 428,
	PINMUX_OUTPUT_BEGIN___2 = 429,
	PORT0_OUT___2 = 430,
	PORT1_OUT___2 = 431,
	PORT2_OUT___2 = 432,
	PORT3_OUT___2 = 433,
	PORT4_OUT___2 = 434,
	PORT5_OUT___2 = 435,
	PORT6_OUT___2 = 436,
	PORT7_OUT___2 = 437,
	PORT8_OUT___2 = 438,
	PORT9_OUT___2 = 439,
	PORT10_OUT___2 = 440,
	PORT11_OUT___2 = 441,
	PORT12_OUT___2 = 442,
	PORT13_OUT___2 = 443,
	PORT14_OUT___2 = 444,
	PORT15_OUT___2 = 445,
	PORT16_OUT___2 = 446,
	PORT17_OUT___2 = 447,
	PORT18_OUT___2 = 448,
	PORT19_OUT___2 = 449,
	PORT20_OUT___2 = 450,
	PORT21_OUT___2 = 451,
	PORT22_OUT___2 = 452,
	PORT23_OUT___2 = 453,
	PORT24_OUT___2 = 454,
	PORT25_OUT___2 = 455,
	PORT26_OUT___2 = 456,
	PORT27_OUT___2 = 457,
	PORT28_OUT___2 = 458,
	PORT29_OUT___2 = 459,
	PORT30_OUT___2 = 460,
	PORT31_OUT = 461,
	PORT32_OUT___2 = 462,
	PORT33_OUT___2 = 463,
	PORT34_OUT___2 = 464,
	PORT35_OUT___2 = 465,
	PORT36_OUT___2 = 466,
	PORT37_OUT___2 = 467,
	PORT38_OUT___2 = 468,
	PORT39_OUT___2 = 469,
	PORT40_OUT___2 = 470,
	PORT41_OUT = 471,
	PORT42_OUT = 472,
	PORT43_OUT = 473,
	PORT44_OUT = 474,
	PORT45_OUT = 475,
	PORT46_OUT = 476,
	PORT47_OUT = 477,
	PORT48_OUT = 478,
	PORT49_OUT = 479,
	PORT50_OUT = 480,
	PORT51_OUT = 481,
	PORT52_OUT = 482,
	PORT53_OUT = 483,
	PORT54_OUT = 484,
	PORT55_OUT = 485,
	PORT56_OUT = 486,
	PORT57_OUT = 487,
	PORT58_OUT = 488,
	PORT59_OUT = 489,
	PORT60_OUT = 490,
	PORT61_OUT = 491,
	PORT62_OUT = 492,
	PORT63_OUT = 493,
	PORT64_OUT___2 = 494,
	PORT65_OUT___2 = 495,
	PORT66_OUT___2 = 496,
	PORT67_OUT___2 = 497,
	PORT68_OUT___2 = 498,
	PORT69_OUT___2 = 499,
	PORT70_OUT___2 = 500,
	PORT71_OUT___2 = 501,
	PORT72_OUT___2 = 502,
	PORT73_OUT___2 = 503,
	PORT74_OUT___2 = 504,
	PORT75_OUT___2 = 505,
	PORT76_OUT___2 = 506,
	PORT77_OUT___2 = 507,
	PORT78_OUT___2 = 508,
	PORT79_OUT___2 = 509,
	PORT80_OUT___2 = 510,
	PORT81_OUT___2 = 511,
	PORT82_OUT___2 = 512,
	PORT83_OUT___2 = 513,
	PORT84_OUT___2 = 514,
	PORT85_OUT___2 = 515,
	PORT86_OUT = 516,
	PORT87_OUT = 517,
	PORT88_OUT = 518,
	PORT89_OUT = 519,
	PORT90_OUT = 520,
	PORT91_OUT = 521,
	PORT92_OUT = 522,
	PORT93_OUT = 523,
	PORT94_OUT = 524,
	PORT95_OUT = 525,
	PORT96_OUT___2 = 526,
	PORT97_OUT___2 = 527,
	PORT98_OUT___2 = 528,
	PORT99_OUT___2 = 529,
	PORT100_OUT___2 = 530,
	PORT101_OUT___2 = 531,
	PORT102_OUT___2 = 532,
	PORT103_OUT___2 = 533,
	PORT104_OUT___2 = 534,
	PORT105_OUT___2 = 535,
	PORT106_OUT___2 = 536,
	PORT107_OUT___2 = 537,
	PORT108_OUT___2 = 538,
	PORT109_OUT___2 = 539,
	PORT110_OUT___2 = 540,
	PORT111_OUT___2 = 541,
	PORT112_OUT___2 = 542,
	PORT113_OUT___2 = 543,
	PORT114_OUT___2 = 544,
	PORT115_OUT___2 = 545,
	PORT116_OUT___2 = 546,
	PORT117_OUT___2 = 547,
	PORT118_OUT___2 = 548,
	PORT119_OUT___2 = 549,
	PORT120_OUT___2 = 550,
	PORT121_OUT___2 = 551,
	PORT122_OUT___2 = 552,
	PORT123_OUT___2 = 553,
	PORT124_OUT___2 = 554,
	PORT125_OUT___2 = 555,
	PORT126_OUT___2 = 556,
	PORT127_OUT = 557,
	PORT128_OUT___2 = 558,
	PORT129_OUT___2 = 559,
	PORT130_OUT___2 = 560,
	PORT131_OUT___2 = 561,
	PORT132_OUT___2 = 562,
	PORT133_OUT___2 = 563,
	PORT134_OUT___2 = 564,
	PORT135_OUT = 565,
	PORT136_OUT = 566,
	PORT137_OUT = 567,
	PORT138_OUT = 568,
	PORT139_OUT = 569,
	PORT140_OUT = 570,
	PORT141_OUT = 571,
	PORT142_OUT = 572,
	PORT143_OUT = 573,
	PORT144_OUT = 574,
	PORT145_OUT = 575,
	PORT146_OUT = 576,
	PORT147_OUT = 577,
	PORT148_OUT = 578,
	PORT149_OUT = 579,
	PORT150_OUT = 580,
	PORT151_OUT = 581,
	PORT152_OUT = 582,
	PORT153_OUT = 583,
	PORT154_OUT = 584,
	PORT155_OUT = 585,
	PORT156_OUT = 586,
	PORT157_OUT = 587,
	PORT158_OUT = 588,
	PORT159_OUT = 589,
	PORT160_OUT___2 = 590,
	PORT161_OUT___2 = 591,
	PORT162_OUT___2 = 592,
	PORT163_OUT___2 = 593,
	PORT164_OUT___2 = 594,
	PORT165_OUT___2 = 595,
	PORT166_OUT___2 = 596,
	PORT167_OUT___2 = 597,
	PORT168_OUT___2 = 598,
	PORT169_OUT___2 = 599,
	PORT170_OUT___2 = 600,
	PORT171_OUT___2 = 601,
	PORT172_OUT___2 = 602,
	PORT173_OUT___2 = 603,
	PORT174_OUT___2 = 604,
	PORT175_OUT___2 = 605,
	PORT176_OUT___2 = 606,
	PORT177_OUT___2 = 607,
	PORT178_OUT___2 = 608,
	PORT179_OUT = 609,
	PORT180_OUT = 610,
	PORT181_OUT = 611,
	PORT182_OUT = 612,
	PORT183_OUT = 613,
	PORT184_OUT = 614,
	PORT185_OUT = 615,
	PORT186_OUT = 616,
	PORT187_OUT = 617,
	PORT188_OUT = 618,
	PORT189_OUT = 619,
	PORT190_OUT = 620,
	PORT191_OUT = 621,
	PORT192_OUT___2 = 622,
	PORT193_OUT___2 = 623,
	PORT194_OUT___2 = 624,
	PORT195_OUT___2 = 625,
	PORT196_OUT___2 = 626,
	PORT197_OUT___2 = 627,
	PORT198_OUT___2 = 628,
	PORT199_OUT___2 = 629,
	PORT200_OUT___2 = 630,
	PORT201_OUT___2 = 631,
	PORT202_OUT___2 = 632,
	PORT203_OUT___2 = 633,
	PORT204_OUT___2 = 634,
	PORT205_OUT___2 = 635,
	PORT206_OUT___2 = 636,
	PORT207_OUT___2 = 637,
	PORT208_OUT___2 = 638,
	PORT209_OUT___2 = 639,
	PORT210_OUT___2 = 640,
	PORT211_OUT___2 = 641,
	PINMUX_OUTPUT_END___2 = 642,
	PINMUX_FUNCTION_BEGIN___3 = 643,
	PORT0_FN_IN___2 = 644,
	PORT1_FN_IN___2 = 645,
	PORT2_FN_IN___2 = 646,
	PORT3_FN_IN___2 = 647,
	PORT4_FN_IN___2 = 648,
	PORT5_FN_IN___2 = 649,
	PORT6_FN_IN___2 = 650,
	PORT7_FN_IN___2 = 651,
	PORT8_FN_IN___2 = 652,
	PORT9_FN_IN___2 = 653,
	PORT10_FN_IN___2 = 654,
	PORT11_FN_IN___2 = 655,
	PORT12_FN_IN___2 = 656,
	PORT13_FN_IN___2 = 657,
	PORT14_FN_IN___2 = 658,
	PORT15_FN_IN___2 = 659,
	PORT16_FN_IN___2 = 660,
	PORT17_FN_IN___2 = 661,
	PORT18_FN_IN___2 = 662,
	PORT19_FN_IN___2 = 663,
	PORT20_FN_IN___2 = 664,
	PORT21_FN_IN___2 = 665,
	PORT22_FN_IN___2 = 666,
	PORT23_FN_IN___2 = 667,
	PORT24_FN_IN___2 = 668,
	PORT25_FN_IN___2 = 669,
	PORT26_FN_IN___2 = 670,
	PORT27_FN_IN___2 = 671,
	PORT28_FN_IN___2 = 672,
	PORT29_FN_IN___2 = 673,
	PORT30_FN_IN___2 = 674,
	PORT31_FN_IN = 675,
	PORT32_FN_IN___2 = 676,
	PORT33_FN_IN___2 = 677,
	PORT34_FN_IN___2 = 678,
	PORT35_FN_IN___2 = 679,
	PORT36_FN_IN___2 = 680,
	PORT37_FN_IN___2 = 681,
	PORT38_FN_IN___2 = 682,
	PORT39_FN_IN___2 = 683,
	PORT40_FN_IN___2 = 684,
	PORT41_FN_IN = 685,
	PORT42_FN_IN = 686,
	PORT43_FN_IN = 687,
	PORT44_FN_IN = 688,
	PORT45_FN_IN = 689,
	PORT46_FN_IN = 690,
	PORT47_FN_IN = 691,
	PORT48_FN_IN = 692,
	PORT49_FN_IN = 693,
	PORT50_FN_IN = 694,
	PORT51_FN_IN = 695,
	PORT52_FN_IN = 696,
	PORT53_FN_IN = 697,
	PORT54_FN_IN = 698,
	PORT55_FN_IN = 699,
	PORT56_FN_IN = 700,
	PORT57_FN_IN = 701,
	PORT58_FN_IN = 702,
	PORT59_FN_IN = 703,
	PORT60_FN_IN = 704,
	PORT61_FN_IN = 705,
	PORT62_FN_IN = 706,
	PORT63_FN_IN = 707,
	PORT64_FN_IN___2 = 708,
	PORT65_FN_IN___2 = 709,
	PORT66_FN_IN___2 = 710,
	PORT67_FN_IN___2 = 711,
	PORT68_FN_IN___2 = 712,
	PORT69_FN_IN___2 = 713,
	PORT70_FN_IN___2 = 714,
	PORT71_FN_IN___2 = 715,
	PORT72_FN_IN___2 = 716,
	PORT73_FN_IN___2 = 717,
	PORT74_FN_IN___2 = 718,
	PORT75_FN_IN___2 = 719,
	PORT76_FN_IN___2 = 720,
	PORT77_FN_IN___2 = 721,
	PORT78_FN_IN___2 = 722,
	PORT79_FN_IN___2 = 723,
	PORT80_FN_IN___2 = 724,
	PORT81_FN_IN___2 = 725,
	PORT82_FN_IN___2 = 726,
	PORT83_FN_IN___2 = 727,
	PORT84_FN_IN___2 = 728,
	PORT85_FN_IN___2 = 729,
	PORT86_FN_IN = 730,
	PORT87_FN_IN = 731,
	PORT88_FN_IN = 732,
	PORT89_FN_IN = 733,
	PORT90_FN_IN = 734,
	PORT91_FN_IN = 735,
	PORT92_FN_IN = 736,
	PORT93_FN_IN = 737,
	PORT94_FN_IN = 738,
	PORT95_FN_IN = 739,
	PORT96_FN_IN___2 = 740,
	PORT97_FN_IN___2 = 741,
	PORT98_FN_IN___2 = 742,
	PORT99_FN_IN___2 = 743,
	PORT100_FN_IN___2 = 744,
	PORT101_FN_IN___2 = 745,
	PORT102_FN_IN___2 = 746,
	PORT103_FN_IN___2 = 747,
	PORT104_FN_IN___2 = 748,
	PORT105_FN_IN___2 = 749,
	PORT106_FN_IN___2 = 750,
	PORT107_FN_IN___2 = 751,
	PORT108_FN_IN___2 = 752,
	PORT109_FN_IN___2 = 753,
	PORT110_FN_IN___2 = 754,
	PORT111_FN_IN___2 = 755,
	PORT112_FN_IN___2 = 756,
	PORT113_FN_IN___2 = 757,
	PORT114_FN_IN___2 = 758,
	PORT115_FN_IN___2 = 759,
	PORT116_FN_IN___2 = 760,
	PORT117_FN_IN___2 = 761,
	PORT118_FN_IN___2 = 762,
	PORT119_FN_IN___2 = 763,
	PORT120_FN_IN___2 = 764,
	PORT121_FN_IN___2 = 765,
	PORT122_FN_IN___2 = 766,
	PORT123_FN_IN___2 = 767,
	PORT124_FN_IN___2 = 768,
	PORT125_FN_IN___2 = 769,
	PORT126_FN_IN___2 = 770,
	PORT127_FN_IN = 771,
	PORT128_FN_IN___2 = 772,
	PORT129_FN_IN___2 = 773,
	PORT130_FN_IN___2 = 774,
	PORT131_FN_IN___2 = 775,
	PORT132_FN_IN___2 = 776,
	PORT133_FN_IN___2 = 777,
	PORT134_FN_IN___2 = 778,
	PORT135_FN_IN = 779,
	PORT136_FN_IN = 780,
	PORT137_FN_IN = 781,
	PORT138_FN_IN = 782,
	PORT139_FN_IN = 783,
	PORT140_FN_IN = 784,
	PORT141_FN_IN = 785,
	PORT142_FN_IN = 786,
	PORT143_FN_IN = 787,
	PORT144_FN_IN = 788,
	PORT145_FN_IN = 789,
	PORT146_FN_IN = 790,
	PORT147_FN_IN = 791,
	PORT148_FN_IN = 792,
	PORT149_FN_IN = 793,
	PORT150_FN_IN = 794,
	PORT151_FN_IN = 795,
	PORT152_FN_IN = 796,
	PORT153_FN_IN = 797,
	PORT154_FN_IN = 798,
	PORT155_FN_IN = 799,
	PORT156_FN_IN = 800,
	PORT157_FN_IN = 801,
	PORT158_FN_IN = 802,
	PORT159_FN_IN = 803,
	PORT160_FN_IN___2 = 804,
	PORT161_FN_IN___2 = 805,
	PORT162_FN_IN___2 = 806,
	PORT163_FN_IN___2 = 807,
	PORT164_FN_IN___2 = 808,
	PORT165_FN_IN___2 = 809,
	PORT166_FN_IN___2 = 810,
	PORT167_FN_IN___2 = 811,
	PORT168_FN_IN___2 = 812,
	PORT169_FN_IN___2 = 813,
	PORT170_FN_IN___2 = 814,
	PORT171_FN_IN___2 = 815,
	PORT172_FN_IN___2 = 816,
	PORT173_FN_IN___2 = 817,
	PORT174_FN_IN___2 = 818,
	PORT175_FN_IN___2 = 819,
	PORT176_FN_IN___2 = 820,
	PORT177_FN_IN___2 = 821,
	PORT178_FN_IN___2 = 822,
	PORT179_FN_IN = 823,
	PORT180_FN_IN = 824,
	PORT181_FN_IN = 825,
	PORT182_FN_IN = 826,
	PORT183_FN_IN = 827,
	PORT184_FN_IN = 828,
	PORT185_FN_IN = 829,
	PORT186_FN_IN = 830,
	PORT187_FN_IN = 831,
	PORT188_FN_IN = 832,
	PORT189_FN_IN = 833,
	PORT190_FN_IN = 834,
	PORT191_FN_IN = 835,
	PORT192_FN_IN___2 = 836,
	PORT193_FN_IN___2 = 837,
	PORT194_FN_IN___2 = 838,
	PORT195_FN_IN___2 = 839,
	PORT196_FN_IN___2 = 840,
	PORT197_FN_IN___2 = 841,
	PORT198_FN_IN___2 = 842,
	PORT199_FN_IN___2 = 843,
	PORT200_FN_IN___2 = 844,
	PORT201_FN_IN___2 = 845,
	PORT202_FN_IN___2 = 846,
	PORT203_FN_IN___2 = 847,
	PORT204_FN_IN___2 = 848,
	PORT205_FN_IN___2 = 849,
	PORT206_FN_IN___2 = 850,
	PORT207_FN_IN___2 = 851,
	PORT208_FN_IN___2 = 852,
	PORT209_FN_IN___2 = 853,
	PORT210_FN_IN___2 = 854,
	PORT211_FN_IN___2 = 855,
	PORT0_FN_OUT___2 = 856,
	PORT1_FN_OUT___2 = 857,
	PORT2_FN_OUT___2 = 858,
	PORT3_FN_OUT___2 = 859,
	PORT4_FN_OUT___2 = 860,
	PORT5_FN_OUT___2 = 861,
	PORT6_FN_OUT___2 = 862,
	PORT7_FN_OUT___2 = 863,
	PORT8_FN_OUT___2 = 864,
	PORT9_FN_OUT___2 = 865,
	PORT10_FN_OUT___2 = 866,
	PORT11_FN_OUT___2 = 867,
	PORT12_FN_OUT___2 = 868,
	PORT13_FN_OUT___2 = 869,
	PORT14_FN_OUT___2 = 870,
	PORT15_FN_OUT___2 = 871,
	PORT16_FN_OUT___2 = 872,
	PORT17_FN_OUT___2 = 873,
	PORT18_FN_OUT___2 = 874,
	PORT19_FN_OUT___2 = 875,
	PORT20_FN_OUT___2 = 876,
	PORT21_FN_OUT___2 = 877,
	PORT22_FN_OUT___2 = 878,
	PORT23_FN_OUT___2 = 879,
	PORT24_FN_OUT___2 = 880,
	PORT25_FN_OUT___2 = 881,
	PORT26_FN_OUT___2 = 882,
	PORT27_FN_OUT___2 = 883,
	PORT28_FN_OUT___2 = 884,
	PORT29_FN_OUT___2 = 885,
	PORT30_FN_OUT___2 = 886,
	PORT31_FN_OUT = 887,
	PORT32_FN_OUT___2 = 888,
	PORT33_FN_OUT___2 = 889,
	PORT34_FN_OUT___2 = 890,
	PORT35_FN_OUT___2 = 891,
	PORT36_FN_OUT___2 = 892,
	PORT37_FN_OUT___2 = 893,
	PORT38_FN_OUT___2 = 894,
	PORT39_FN_OUT___2 = 895,
	PORT40_FN_OUT___2 = 896,
	PORT41_FN_OUT = 897,
	PORT42_FN_OUT = 898,
	PORT43_FN_OUT = 899,
	PORT44_FN_OUT = 900,
	PORT45_FN_OUT = 901,
	PORT46_FN_OUT = 902,
	PORT47_FN_OUT = 903,
	PORT48_FN_OUT = 904,
	PORT49_FN_OUT = 905,
	PORT50_FN_OUT = 906,
	PORT51_FN_OUT = 907,
	PORT52_FN_OUT = 908,
	PORT53_FN_OUT = 909,
	PORT54_FN_OUT = 910,
	PORT55_FN_OUT = 911,
	PORT56_FN_OUT = 912,
	PORT57_FN_OUT = 913,
	PORT58_FN_OUT = 914,
	PORT59_FN_OUT = 915,
	PORT60_FN_OUT = 916,
	PORT61_FN_OUT = 917,
	PORT62_FN_OUT = 918,
	PORT63_FN_OUT = 919,
	PORT64_FN_OUT___2 = 920,
	PORT65_FN_OUT___2 = 921,
	PORT66_FN_OUT___2 = 922,
	PORT67_FN_OUT___2 = 923,
	PORT68_FN_OUT___2 = 924,
	PORT69_FN_OUT___2 = 925,
	PORT70_FN_OUT___2 = 926,
	PORT71_FN_OUT___2 = 927,
	PORT72_FN_OUT___2 = 928,
	PORT73_FN_OUT___2 = 929,
	PORT74_FN_OUT___2 = 930,
	PORT75_FN_OUT___2 = 931,
	PORT76_FN_OUT___2 = 932,
	PORT77_FN_OUT___2 = 933,
	PORT78_FN_OUT___2 = 934,
	PORT79_FN_OUT___2 = 935,
	PORT80_FN_OUT___2 = 936,
	PORT81_FN_OUT___2 = 937,
	PORT82_FN_OUT___2 = 938,
	PORT83_FN_OUT___2 = 939,
	PORT84_FN_OUT___2 = 940,
	PORT85_FN_OUT___2 = 941,
	PORT86_FN_OUT = 942,
	PORT87_FN_OUT = 943,
	PORT88_FN_OUT = 944,
	PORT89_FN_OUT = 945,
	PORT90_FN_OUT = 946,
	PORT91_FN_OUT = 947,
	PORT92_FN_OUT = 948,
	PORT93_FN_OUT = 949,
	PORT94_FN_OUT = 950,
	PORT95_FN_OUT = 951,
	PORT96_FN_OUT___2 = 952,
	PORT97_FN_OUT___2 = 953,
	PORT98_FN_OUT___2 = 954,
	PORT99_FN_OUT___2 = 955,
	PORT100_FN_OUT___2 = 956,
	PORT101_FN_OUT___2 = 957,
	PORT102_FN_OUT___2 = 958,
	PORT103_FN_OUT___2 = 959,
	PORT104_FN_OUT___2 = 960,
	PORT105_FN_OUT___2 = 961,
	PORT106_FN_OUT___2 = 962,
	PORT107_FN_OUT___2 = 963,
	PORT108_FN_OUT___2 = 964,
	PORT109_FN_OUT___2 = 965,
	PORT110_FN_OUT___2 = 966,
	PORT111_FN_OUT___2 = 967,
	PORT112_FN_OUT___2 = 968,
	PORT113_FN_OUT___2 = 969,
	PORT114_FN_OUT___2 = 970,
	PORT115_FN_OUT___2 = 971,
	PORT116_FN_OUT___2 = 972,
	PORT117_FN_OUT___2 = 973,
	PORT118_FN_OUT___2 = 974,
	PORT119_FN_OUT___2 = 975,
	PORT120_FN_OUT___2 = 976,
	PORT121_FN_OUT___2 = 977,
	PORT122_FN_OUT___2 = 978,
	PORT123_FN_OUT___2 = 979,
	PORT124_FN_OUT___2 = 980,
	PORT125_FN_OUT___2 = 981,
	PORT126_FN_OUT___2 = 982,
	PORT127_FN_OUT = 983,
	PORT128_FN_OUT___2 = 984,
	PORT129_FN_OUT___2 = 985,
	PORT130_FN_OUT___2 = 986,
	PORT131_FN_OUT___2 = 987,
	PORT132_FN_OUT___2 = 988,
	PORT133_FN_OUT___2 = 989,
	PORT134_FN_OUT___2 = 990,
	PORT135_FN_OUT = 991,
	PORT136_FN_OUT = 992,
	PORT137_FN_OUT = 993,
	PORT138_FN_OUT = 994,
	PORT139_FN_OUT = 995,
	PORT140_FN_OUT = 996,
	PORT141_FN_OUT = 997,
	PORT142_FN_OUT = 998,
	PORT143_FN_OUT = 999,
	PORT144_FN_OUT = 1000,
	PORT145_FN_OUT = 1001,
	PORT146_FN_OUT = 1002,
	PORT147_FN_OUT = 1003,
	PORT148_FN_OUT = 1004,
	PORT149_FN_OUT = 1005,
	PORT150_FN_OUT = 1006,
	PORT151_FN_OUT = 1007,
	PORT152_FN_OUT = 1008,
	PORT153_FN_OUT = 1009,
	PORT154_FN_OUT = 1010,
	PORT155_FN_OUT = 1011,
	PORT156_FN_OUT = 1012,
	PORT157_FN_OUT = 1013,
	PORT158_FN_OUT = 1014,
	PORT159_FN_OUT = 1015,
	PORT160_FN_OUT___2 = 1016,
	PORT161_FN_OUT___2 = 1017,
	PORT162_FN_OUT___2 = 1018,
	PORT163_FN_OUT___2 = 1019,
	PORT164_FN_OUT___2 = 1020,
	PORT165_FN_OUT___2 = 1021,
	PORT166_FN_OUT___2 = 1022,
	PORT167_FN_OUT___2 = 1023,
	PORT168_FN_OUT___2 = 1024,
	PORT169_FN_OUT___2 = 1025,
	PORT170_FN_OUT___2 = 1026,
	PORT171_FN_OUT___2 = 1027,
	PORT172_FN_OUT___2 = 1028,
	PORT173_FN_OUT___2 = 1029,
	PORT174_FN_OUT___2 = 1030,
	PORT175_FN_OUT___2 = 1031,
	PORT176_FN_OUT___2 = 1032,
	PORT177_FN_OUT___2 = 1033,
	PORT178_FN_OUT___2 = 1034,
	PORT179_FN_OUT = 1035,
	PORT180_FN_OUT = 1036,
	PORT181_FN_OUT = 1037,
	PORT182_FN_OUT = 1038,
	PORT183_FN_OUT = 1039,
	PORT184_FN_OUT = 1040,
	PORT185_FN_OUT = 1041,
	PORT186_FN_OUT = 1042,
	PORT187_FN_OUT = 1043,
	PORT188_FN_OUT = 1044,
	PORT189_FN_OUT = 1045,
	PORT190_FN_OUT = 1046,
	PORT191_FN_OUT = 1047,
	PORT192_FN_OUT___2 = 1048,
	PORT193_FN_OUT___2 = 1049,
	PORT194_FN_OUT___2 = 1050,
	PORT195_FN_OUT___2 = 1051,
	PORT196_FN_OUT___2 = 1052,
	PORT197_FN_OUT___2 = 1053,
	PORT198_FN_OUT___2 = 1054,
	PORT199_FN_OUT___2 = 1055,
	PORT200_FN_OUT___2 = 1056,
	PORT201_FN_OUT___2 = 1057,
	PORT202_FN_OUT___2 = 1058,
	PORT203_FN_OUT___2 = 1059,
	PORT204_FN_OUT___2 = 1060,
	PORT205_FN_OUT___2 = 1061,
	PORT206_FN_OUT___2 = 1062,
	PORT207_FN_OUT___2 = 1063,
	PORT208_FN_OUT___2 = 1064,
	PORT209_FN_OUT___2 = 1065,
	PORT210_FN_OUT___2 = 1066,
	PORT211_FN_OUT___2 = 1067,
	PORT0_FN0___2 = 1068,
	PORT1_FN0___2 = 1069,
	PORT2_FN0___2 = 1070,
	PORT3_FN0___2 = 1071,
	PORT4_FN0___2 = 1072,
	PORT5_FN0___2 = 1073,
	PORT6_FN0___2 = 1074,
	PORT7_FN0___2 = 1075,
	PORT8_FN0___2 = 1076,
	PORT9_FN0___2 = 1077,
	PORT10_FN0___2 = 1078,
	PORT11_FN0___2 = 1079,
	PORT12_FN0___2 = 1080,
	PORT13_FN0___2 = 1081,
	PORT14_FN0___2 = 1082,
	PORT15_FN0___2 = 1083,
	PORT16_FN0___2 = 1084,
	PORT17_FN0___2 = 1085,
	PORT18_FN0___2 = 1086,
	PORT19_FN0___2 = 1087,
	PORT20_FN0___2 = 1088,
	PORT21_FN0___2 = 1089,
	PORT22_FN0___2 = 1090,
	PORT23_FN0___2 = 1091,
	PORT24_FN0___2 = 1092,
	PORT25_FN0___2 = 1093,
	PORT26_FN0___2 = 1094,
	PORT27_FN0___2 = 1095,
	PORT28_FN0___2 = 1096,
	PORT29_FN0___2 = 1097,
	PORT30_FN0___2 = 1098,
	PORT31_FN0 = 1099,
	PORT32_FN0___2 = 1100,
	PORT33_FN0___2 = 1101,
	PORT34_FN0___2 = 1102,
	PORT35_FN0___2 = 1103,
	PORT36_FN0___2 = 1104,
	PORT37_FN0___2 = 1105,
	PORT38_FN0___2 = 1106,
	PORT39_FN0___2 = 1107,
	PORT40_FN0___2 = 1108,
	PORT41_FN0 = 1109,
	PORT42_FN0 = 1110,
	PORT43_FN0 = 1111,
	PORT44_FN0 = 1112,
	PORT45_FN0 = 1113,
	PORT46_FN0 = 1114,
	PORT47_FN0 = 1115,
	PORT48_FN0 = 1116,
	PORT49_FN0 = 1117,
	PORT50_FN0 = 1118,
	PORT51_FN0 = 1119,
	PORT52_FN0 = 1120,
	PORT53_FN0 = 1121,
	PORT54_FN0 = 1122,
	PORT55_FN0 = 1123,
	PORT56_FN0 = 1124,
	PORT57_FN0 = 1125,
	PORT58_FN0 = 1126,
	PORT59_FN0 = 1127,
	PORT60_FN0 = 1128,
	PORT61_FN0 = 1129,
	PORT62_FN0 = 1130,
	PORT63_FN0 = 1131,
	PORT64_FN0___2 = 1132,
	PORT65_FN0___2 = 1133,
	PORT66_FN0___2 = 1134,
	PORT67_FN0___2 = 1135,
	PORT68_FN0___2 = 1136,
	PORT69_FN0___2 = 1137,
	PORT70_FN0___2 = 1138,
	PORT71_FN0___2 = 1139,
	PORT72_FN0___2 = 1140,
	PORT73_FN0___2 = 1141,
	PORT74_FN0___2 = 1142,
	PORT75_FN0___2 = 1143,
	PORT76_FN0___2 = 1144,
	PORT77_FN0___2 = 1145,
	PORT78_FN0___2 = 1146,
	PORT79_FN0___2 = 1147,
	PORT80_FN0___2 = 1148,
	PORT81_FN0___2 = 1149,
	PORT82_FN0___2 = 1150,
	PORT83_FN0___2 = 1151,
	PORT84_FN0___2 = 1152,
	PORT85_FN0___2 = 1153,
	PORT86_FN0 = 1154,
	PORT87_FN0 = 1155,
	PORT88_FN0 = 1156,
	PORT89_FN0 = 1157,
	PORT90_FN0 = 1158,
	PORT91_FN0 = 1159,
	PORT92_FN0 = 1160,
	PORT93_FN0 = 1161,
	PORT94_FN0 = 1162,
	PORT95_FN0 = 1163,
	PORT96_FN0___2 = 1164,
	PORT97_FN0___2 = 1165,
	PORT98_FN0___2 = 1166,
	PORT99_FN0___2 = 1167,
	PORT100_FN0___2 = 1168,
	PORT101_FN0___2 = 1169,
	PORT102_FN0___2 = 1170,
	PORT103_FN0___2 = 1171,
	PORT104_FN0___2 = 1172,
	PORT105_FN0___2 = 1173,
	PORT106_FN0___2 = 1174,
	PORT107_FN0___2 = 1175,
	PORT108_FN0___2 = 1176,
	PORT109_FN0___2 = 1177,
	PORT110_FN0___2 = 1178,
	PORT111_FN0___2 = 1179,
	PORT112_FN0___2 = 1180,
	PORT113_FN0___2 = 1181,
	PORT114_FN0___2 = 1182,
	PORT115_FN0___2 = 1183,
	PORT116_FN0___2 = 1184,
	PORT117_FN0___2 = 1185,
	PORT118_FN0___2 = 1186,
	PORT119_FN0___2 = 1187,
	PORT120_FN0___2 = 1188,
	PORT121_FN0___2 = 1189,
	PORT122_FN0___2 = 1190,
	PORT123_FN0___2 = 1191,
	PORT124_FN0___2 = 1192,
	PORT125_FN0___2 = 1193,
	PORT126_FN0___2 = 1194,
	PORT127_FN0 = 1195,
	PORT128_FN0___2 = 1196,
	PORT129_FN0___2 = 1197,
	PORT130_FN0___2 = 1198,
	PORT131_FN0___2 = 1199,
	PORT132_FN0___2 = 1200,
	PORT133_FN0___2 = 1201,
	PORT134_FN0___2 = 1202,
	PORT135_FN0 = 1203,
	PORT136_FN0 = 1204,
	PORT137_FN0 = 1205,
	PORT138_FN0 = 1206,
	PORT139_FN0 = 1207,
	PORT140_FN0 = 1208,
	PORT141_FN0 = 1209,
	PORT142_FN0 = 1210,
	PORT143_FN0 = 1211,
	PORT144_FN0 = 1212,
	PORT145_FN0 = 1213,
	PORT146_FN0 = 1214,
	PORT147_FN0 = 1215,
	PORT148_FN0 = 1216,
	PORT149_FN0 = 1217,
	PORT150_FN0 = 1218,
	PORT151_FN0 = 1219,
	PORT152_FN0 = 1220,
	PORT153_FN0 = 1221,
	PORT154_FN0 = 1222,
	PORT155_FN0 = 1223,
	PORT156_FN0 = 1224,
	PORT157_FN0 = 1225,
	PORT158_FN0 = 1226,
	PORT159_FN0 = 1227,
	PORT160_FN0___2 = 1228,
	PORT161_FN0___2 = 1229,
	PORT162_FN0___2 = 1230,
	PORT163_FN0___2 = 1231,
	PORT164_FN0___2 = 1232,
	PORT165_FN0___2 = 1233,
	PORT166_FN0___2 = 1234,
	PORT167_FN0___2 = 1235,
	PORT168_FN0___2 = 1236,
	PORT169_FN0___2 = 1237,
	PORT170_FN0___2 = 1238,
	PORT171_FN0___2 = 1239,
	PORT172_FN0___2 = 1240,
	PORT173_FN0___2 = 1241,
	PORT174_FN0___2 = 1242,
	PORT175_FN0___2 = 1243,
	PORT176_FN0___2 = 1244,
	PORT177_FN0___2 = 1245,
	PORT178_FN0___2 = 1246,
	PORT179_FN0 = 1247,
	PORT180_FN0 = 1248,
	PORT181_FN0 = 1249,
	PORT182_FN0 = 1250,
	PORT183_FN0 = 1251,
	PORT184_FN0 = 1252,
	PORT185_FN0 = 1253,
	PORT186_FN0 = 1254,
	PORT187_FN0 = 1255,
	PORT188_FN0 = 1256,
	PORT189_FN0 = 1257,
	PORT190_FN0 = 1258,
	PORT191_FN0 = 1259,
	PORT192_FN0___2 = 1260,
	PORT193_FN0___2 = 1261,
	PORT194_FN0___2 = 1262,
	PORT195_FN0___2 = 1263,
	PORT196_FN0___2 = 1264,
	PORT197_FN0___2 = 1265,
	PORT198_FN0___2 = 1266,
	PORT199_FN0___2 = 1267,
	PORT200_FN0___2 = 1268,
	PORT201_FN0___2 = 1269,
	PORT202_FN0___2 = 1270,
	PORT203_FN0___2 = 1271,
	PORT204_FN0___2 = 1272,
	PORT205_FN0___2 = 1273,
	PORT206_FN0___2 = 1274,
	PORT207_FN0___2 = 1275,
	PORT208_FN0___2 = 1276,
	PORT209_FN0___2 = 1277,
	PORT210_FN0___2 = 1278,
	PORT211_FN0___2 = 1279,
	PORT0_FN1___2 = 1280,
	PORT1_FN1___2 = 1281,
	PORT2_FN1___2 = 1282,
	PORT3_FN1___2 = 1283,
	PORT4_FN1___2 = 1284,
	PORT5_FN1___2 = 1285,
	PORT6_FN1___2 = 1286,
	PORT7_FN1___2 = 1287,
	PORT8_FN1___2 = 1288,
	PORT9_FN1___2 = 1289,
	PORT10_FN1___2 = 1290,
	PORT11_FN1___2 = 1291,
	PORT12_FN1___2 = 1292,
	PORT13_FN1___2 = 1293,
	PORT14_FN1___2 = 1294,
	PORT15_FN1___2 = 1295,
	PORT16_FN1___2 = 1296,
	PORT17_FN1___2 = 1297,
	PORT18_FN1___2 = 1298,
	PORT19_FN1___2 = 1299,
	PORT20_FN1___2 = 1300,
	PORT21_FN1___2 = 1301,
	PORT22_FN1___2 = 1302,
	PORT23_FN1___2 = 1303,
	PORT24_FN1___2 = 1304,
	PORT25_FN1___2 = 1305,
	PORT26_FN1___2 = 1306,
	PORT27_FN1___2 = 1307,
	PORT28_FN1___2 = 1308,
	PORT29_FN1___2 = 1309,
	PORT30_FN1___2 = 1310,
	PORT31_FN1 = 1311,
	PORT32_FN1___2 = 1312,
	PORT33_FN1___2 = 1313,
	PORT34_FN1___2 = 1314,
	PORT35_FN1___2 = 1315,
	PORT36_FN1___2 = 1316,
	PORT37_FN1___2 = 1317,
	PORT38_FN1___2 = 1318,
	PORT39_FN1___2 = 1319,
	PORT40_FN1___2 = 1320,
	PORT41_FN1 = 1321,
	PORT42_FN1 = 1322,
	PORT43_FN1 = 1323,
	PORT44_FN1 = 1324,
	PORT45_FN1 = 1325,
	PORT46_FN1 = 1326,
	PORT47_FN1 = 1327,
	PORT48_FN1 = 1328,
	PORT49_FN1 = 1329,
	PORT50_FN1 = 1330,
	PORT51_FN1 = 1331,
	PORT52_FN1 = 1332,
	PORT53_FN1 = 1333,
	PORT54_FN1 = 1334,
	PORT55_FN1 = 1335,
	PORT56_FN1 = 1336,
	PORT57_FN1 = 1337,
	PORT58_FN1 = 1338,
	PORT59_FN1 = 1339,
	PORT60_FN1 = 1340,
	PORT61_FN1 = 1341,
	PORT62_FN1 = 1342,
	PORT63_FN1 = 1343,
	PORT64_FN1___2 = 1344,
	PORT65_FN1___2 = 1345,
	PORT66_FN1___2 = 1346,
	PORT67_FN1___2 = 1347,
	PORT68_FN1___2 = 1348,
	PORT69_FN1___2 = 1349,
	PORT70_FN1___2 = 1350,
	PORT71_FN1___2 = 1351,
	PORT72_FN1___2 = 1352,
	PORT73_FN1___2 = 1353,
	PORT74_FN1___2 = 1354,
	PORT75_FN1___2 = 1355,
	PORT76_FN1___2 = 1356,
	PORT77_FN1___2 = 1357,
	PORT78_FN1___2 = 1358,
	PORT79_FN1___2 = 1359,
	PORT80_FN1___2 = 1360,
	PORT81_FN1___2 = 1361,
	PORT82_FN1___2 = 1362,
	PORT83_FN1___2 = 1363,
	PORT84_FN1___2 = 1364,
	PORT85_FN1___2 = 1365,
	PORT86_FN1 = 1366,
	PORT87_FN1 = 1367,
	PORT88_FN1 = 1368,
	PORT89_FN1 = 1369,
	PORT90_FN1 = 1370,
	PORT91_FN1 = 1371,
	PORT92_FN1 = 1372,
	PORT93_FN1 = 1373,
	PORT94_FN1 = 1374,
	PORT95_FN1 = 1375,
	PORT96_FN1___2 = 1376,
	PORT97_FN1___2 = 1377,
	PORT98_FN1___2 = 1378,
	PORT99_FN1___2 = 1379,
	PORT100_FN1___2 = 1380,
	PORT101_FN1___2 = 1381,
	PORT102_FN1___2 = 1382,
	PORT103_FN1___2 = 1383,
	PORT104_FN1___2 = 1384,
	PORT105_FN1___2 = 1385,
	PORT106_FN1___2 = 1386,
	PORT107_FN1___2 = 1387,
	PORT108_FN1___2 = 1388,
	PORT109_FN1___2 = 1389,
	PORT110_FN1___2 = 1390,
	PORT111_FN1___2 = 1391,
	PORT112_FN1___2 = 1392,
	PORT113_FN1___2 = 1393,
	PORT114_FN1___2 = 1394,
	PORT115_FN1___2 = 1395,
	PORT116_FN1___2 = 1396,
	PORT117_FN1___2 = 1397,
	PORT118_FN1___2 = 1398,
	PORT119_FN1___2 = 1399,
	PORT120_FN1___2 = 1400,
	PORT121_FN1___2 = 1401,
	PORT122_FN1___2 = 1402,
	PORT123_FN1___2 = 1403,
	PORT124_FN1___2 = 1404,
	PORT125_FN1___2 = 1405,
	PORT126_FN1___2 = 1406,
	PORT127_FN1 = 1407,
	PORT128_FN1___2 = 1408,
	PORT129_FN1___2 = 1409,
	PORT130_FN1___2 = 1410,
	PORT131_FN1___2 = 1411,
	PORT132_FN1___2 = 1412,
	PORT133_FN1___2 = 1413,
	PORT134_FN1___2 = 1414,
	PORT135_FN1 = 1415,
	PORT136_FN1 = 1416,
	PORT137_FN1 = 1417,
	PORT138_FN1 = 1418,
	PORT139_FN1 = 1419,
	PORT140_FN1 = 1420,
	PORT141_FN1 = 1421,
	PORT142_FN1 = 1422,
	PORT143_FN1 = 1423,
	PORT144_FN1 = 1424,
	PORT145_FN1 = 1425,
	PORT146_FN1 = 1426,
	PORT147_FN1 = 1427,
	PORT148_FN1 = 1428,
	PORT149_FN1 = 1429,
	PORT150_FN1 = 1430,
	PORT151_FN1 = 1431,
	PORT152_FN1 = 1432,
	PORT153_FN1 = 1433,
	PORT154_FN1 = 1434,
	PORT155_FN1 = 1435,
	PORT156_FN1 = 1436,
	PORT157_FN1 = 1437,
	PORT158_FN1 = 1438,
	PORT159_FN1 = 1439,
	PORT160_FN1___2 = 1440,
	PORT161_FN1___2 = 1441,
	PORT162_FN1___2 = 1442,
	PORT163_FN1___2 = 1443,
	PORT164_FN1___2 = 1444,
	PORT165_FN1___2 = 1445,
	PORT166_FN1___2 = 1446,
	PORT167_FN1___2 = 1447,
	PORT168_FN1___2 = 1448,
	PORT169_FN1___2 = 1449,
	PORT170_FN1___2 = 1450,
	PORT171_FN1___2 = 1451,
	PORT172_FN1___2 = 1452,
	PORT173_FN1___2 = 1453,
	PORT174_FN1___2 = 1454,
	PORT175_FN1___2 = 1455,
	PORT176_FN1___2 = 1456,
	PORT177_FN1___2 = 1457,
	PORT178_FN1___2 = 1458,
	PORT179_FN1 = 1459,
	PORT180_FN1 = 1460,
	PORT181_FN1 = 1461,
	PORT182_FN1 = 1462,
	PORT183_FN1 = 1463,
	PORT184_FN1 = 1464,
	PORT185_FN1 = 1465,
	PORT186_FN1 = 1466,
	PORT187_FN1 = 1467,
	PORT188_FN1 = 1468,
	PORT189_FN1 = 1469,
	PORT190_FN1 = 1470,
	PORT191_FN1 = 1471,
	PORT192_FN1___2 = 1472,
	PORT193_FN1___2 = 1473,
	PORT194_FN1___2 = 1474,
	PORT195_FN1___2 = 1475,
	PORT196_FN1___2 = 1476,
	PORT197_FN1___2 = 1477,
	PORT198_FN1___2 = 1478,
	PORT199_FN1___2 = 1479,
	PORT200_FN1___2 = 1480,
	PORT201_FN1___2 = 1481,
	PORT202_FN1___2 = 1482,
	PORT203_FN1___2 = 1483,
	PORT204_FN1___2 = 1484,
	PORT205_FN1___2 = 1485,
	PORT206_FN1___2 = 1486,
	PORT207_FN1___2 = 1487,
	PORT208_FN1___2 = 1488,
	PORT209_FN1___2 = 1489,
	PORT210_FN1___2 = 1490,
	PORT211_FN1___2 = 1491,
	PORT0_FN2___2 = 1492,
	PORT1_FN2___2 = 1493,
	PORT2_FN2___2 = 1494,
	PORT3_FN2___2 = 1495,
	PORT4_FN2___2 = 1496,
	PORT5_FN2___2 = 1497,
	PORT6_FN2___2 = 1498,
	PORT7_FN2___2 = 1499,
	PORT8_FN2___2 = 1500,
	PORT9_FN2___2 = 1501,
	PORT10_FN2___2 = 1502,
	PORT11_FN2___2 = 1503,
	PORT12_FN2___2 = 1504,
	PORT13_FN2___2 = 1505,
	PORT14_FN2___2 = 1506,
	PORT15_FN2___2 = 1507,
	PORT16_FN2___2 = 1508,
	PORT17_FN2___2 = 1509,
	PORT18_FN2___2 = 1510,
	PORT19_FN2___2 = 1511,
	PORT20_FN2___2 = 1512,
	PORT21_FN2___2 = 1513,
	PORT22_FN2___2 = 1514,
	PORT23_FN2___2 = 1515,
	PORT24_FN2___2 = 1516,
	PORT25_FN2___2 = 1517,
	PORT26_FN2___2 = 1518,
	PORT27_FN2___2 = 1519,
	PORT28_FN2___2 = 1520,
	PORT29_FN2___2 = 1521,
	PORT30_FN2___2 = 1522,
	PORT31_FN2 = 1523,
	PORT32_FN2___2 = 1524,
	PORT33_FN2___2 = 1525,
	PORT34_FN2___2 = 1526,
	PORT35_FN2___2 = 1527,
	PORT36_FN2___2 = 1528,
	PORT37_FN2___2 = 1529,
	PORT38_FN2___2 = 1530,
	PORT39_FN2___2 = 1531,
	PORT40_FN2___2 = 1532,
	PORT41_FN2 = 1533,
	PORT42_FN2 = 1534,
	PORT43_FN2 = 1535,
	PORT44_FN2 = 1536,
	PORT45_FN2 = 1537,
	PORT46_FN2 = 1538,
	PORT47_FN2 = 1539,
	PORT48_FN2 = 1540,
	PORT49_FN2 = 1541,
	PORT50_FN2 = 1542,
	PORT51_FN2 = 1543,
	PORT52_FN2 = 1544,
	PORT53_FN2 = 1545,
	PORT54_FN2 = 1546,
	PORT55_FN2 = 1547,
	PORT56_FN2 = 1548,
	PORT57_FN2 = 1549,
	PORT58_FN2 = 1550,
	PORT59_FN2 = 1551,
	PORT60_FN2 = 1552,
	PORT61_FN2 = 1553,
	PORT62_FN2 = 1554,
	PORT63_FN2 = 1555,
	PORT64_FN2___2 = 1556,
	PORT65_FN2___2 = 1557,
	PORT66_FN2___2 = 1558,
	PORT67_FN2___2 = 1559,
	PORT68_FN2___2 = 1560,
	PORT69_FN2___2 = 1561,
	PORT70_FN2___2 = 1562,
	PORT71_FN2___2 = 1563,
	PORT72_FN2___2 = 1564,
	PORT73_FN2___2 = 1565,
	PORT74_FN2___2 = 1566,
	PORT75_FN2___2 = 1567,
	PORT76_FN2___2 = 1568,
	PORT77_FN2___2 = 1569,
	PORT78_FN2___2 = 1570,
	PORT79_FN2___2 = 1571,
	PORT80_FN2___2 = 1572,
	PORT81_FN2___2 = 1573,
	PORT82_FN2___2 = 1574,
	PORT83_FN2___2 = 1575,
	PORT84_FN2___2 = 1576,
	PORT85_FN2___2 = 1577,
	PORT86_FN2 = 1578,
	PORT87_FN2 = 1579,
	PORT88_FN2 = 1580,
	PORT89_FN2 = 1581,
	PORT90_FN2 = 1582,
	PORT91_FN2 = 1583,
	PORT92_FN2 = 1584,
	PORT93_FN2 = 1585,
	PORT94_FN2 = 1586,
	PORT95_FN2 = 1587,
	PORT96_FN2___2 = 1588,
	PORT97_FN2___2 = 1589,
	PORT98_FN2___2 = 1590,
	PORT99_FN2___2 = 1591,
	PORT100_FN2___2 = 1592,
	PORT101_FN2___2 = 1593,
	PORT102_FN2___2 = 1594,
	PORT103_FN2___2 = 1595,
	PORT104_FN2___2 = 1596,
	PORT105_FN2___2 = 1597,
	PORT106_FN2___2 = 1598,
	PORT107_FN2___2 = 1599,
	PORT108_FN2___2 = 1600,
	PORT109_FN2___2 = 1601,
	PORT110_FN2___2 = 1602,
	PORT111_FN2___2 = 1603,
	PORT112_FN2___2 = 1604,
	PORT113_FN2___2 = 1605,
	PORT114_FN2___2 = 1606,
	PORT115_FN2___2 = 1607,
	PORT116_FN2___2 = 1608,
	PORT117_FN2___2 = 1609,
	PORT118_FN2___2 = 1610,
	PORT119_FN2___2 = 1611,
	PORT120_FN2___2 = 1612,
	PORT121_FN2___2 = 1613,
	PORT122_FN2___2 = 1614,
	PORT123_FN2___2 = 1615,
	PORT124_FN2___2 = 1616,
	PORT125_FN2___2 = 1617,
	PORT126_FN2___2 = 1618,
	PORT127_FN2 = 1619,
	PORT128_FN2___2 = 1620,
	PORT129_FN2___2 = 1621,
	PORT130_FN2___2 = 1622,
	PORT131_FN2___2 = 1623,
	PORT132_FN2___2 = 1624,
	PORT133_FN2___2 = 1625,
	PORT134_FN2___2 = 1626,
	PORT135_FN2 = 1627,
	PORT136_FN2 = 1628,
	PORT137_FN2 = 1629,
	PORT138_FN2 = 1630,
	PORT139_FN2 = 1631,
	PORT140_FN2 = 1632,
	PORT141_FN2 = 1633,
	PORT142_FN2 = 1634,
	PORT143_FN2 = 1635,
	PORT144_FN2 = 1636,
	PORT145_FN2 = 1637,
	PORT146_FN2 = 1638,
	PORT147_FN2 = 1639,
	PORT148_FN2 = 1640,
	PORT149_FN2 = 1641,
	PORT150_FN2 = 1642,
	PORT151_FN2 = 1643,
	PORT152_FN2 = 1644,
	PORT153_FN2 = 1645,
	PORT154_FN2 = 1646,
	PORT155_FN2 = 1647,
	PORT156_FN2 = 1648,
	PORT157_FN2 = 1649,
	PORT158_FN2 = 1650,
	PORT159_FN2 = 1651,
	PORT160_FN2___2 = 1652,
	PORT161_FN2___2 = 1653,
	PORT162_FN2___2 = 1654,
	PORT163_FN2___2 = 1655,
	PORT164_FN2___2 = 1656,
	PORT165_FN2___2 = 1657,
	PORT166_FN2___2 = 1658,
	PORT167_FN2___2 = 1659,
	PORT168_FN2___2 = 1660,
	PORT169_FN2___2 = 1661,
	PORT170_FN2___2 = 1662,
	PORT171_FN2___2 = 1663,
	PORT172_FN2___2 = 1664,
	PORT173_FN2___2 = 1665,
	PORT174_FN2___2 = 1666,
	PORT175_FN2___2 = 1667,
	PORT176_FN2___2 = 1668,
	PORT177_FN2___2 = 1669,
	PORT178_FN2___2 = 1670,
	PORT179_FN2 = 1671,
	PORT180_FN2 = 1672,
	PORT181_FN2 = 1673,
	PORT182_FN2 = 1674,
	PORT183_FN2 = 1675,
	PORT184_FN2 = 1676,
	PORT185_FN2 = 1677,
	PORT186_FN2 = 1678,
	PORT187_FN2 = 1679,
	PORT188_FN2 = 1680,
	PORT189_FN2 = 1681,
	PORT190_FN2 = 1682,
	PORT191_FN2 = 1683,
	PORT192_FN2___2 = 1684,
	PORT193_FN2___2 = 1685,
	PORT194_FN2___2 = 1686,
	PORT195_FN2___2 = 1687,
	PORT196_FN2___2 = 1688,
	PORT197_FN2___2 = 1689,
	PORT198_FN2___2 = 1690,
	PORT199_FN2___2 = 1691,
	PORT200_FN2___2 = 1692,
	PORT201_FN2___2 = 1693,
	PORT202_FN2___2 = 1694,
	PORT203_FN2___2 = 1695,
	PORT204_FN2___2 = 1696,
	PORT205_FN2___2 = 1697,
	PORT206_FN2___2 = 1698,
	PORT207_FN2___2 = 1699,
	PORT208_FN2___2 = 1700,
	PORT209_FN2___2 = 1701,
	PORT210_FN2___2 = 1702,
	PORT211_FN2___2 = 1703,
	PORT0_FN3___2 = 1704,
	PORT1_FN3___2 = 1705,
	PORT2_FN3___2 = 1706,
	PORT3_FN3___2 = 1707,
	PORT4_FN3___2 = 1708,
	PORT5_FN3___2 = 1709,
	PORT6_FN3___2 = 1710,
	PORT7_FN3___2 = 1711,
	PORT8_FN3___2 = 1712,
	PORT9_FN3___2 = 1713,
	PORT10_FN3___2 = 1714,
	PORT11_FN3___2 = 1715,
	PORT12_FN3___2 = 1716,
	PORT13_FN3___2 = 1717,
	PORT14_FN3___2 = 1718,
	PORT15_FN3___2 = 1719,
	PORT16_FN3___2 = 1720,
	PORT17_FN3___2 = 1721,
	PORT18_FN3___2 = 1722,
	PORT19_FN3___2 = 1723,
	PORT20_FN3___2 = 1724,
	PORT21_FN3___2 = 1725,
	PORT22_FN3___2 = 1726,
	PORT23_FN3___2 = 1727,
	PORT24_FN3___2 = 1728,
	PORT25_FN3___2 = 1729,
	PORT26_FN3___2 = 1730,
	PORT27_FN3___2 = 1731,
	PORT28_FN3___2 = 1732,
	PORT29_FN3___2 = 1733,
	PORT30_FN3___2 = 1734,
	PORT31_FN3 = 1735,
	PORT32_FN3___2 = 1736,
	PORT33_FN3___2 = 1737,
	PORT34_FN3___2 = 1738,
	PORT35_FN3___2 = 1739,
	PORT36_FN3___2 = 1740,
	PORT37_FN3___2 = 1741,
	PORT38_FN3___2 = 1742,
	PORT39_FN3___2 = 1743,
	PORT40_FN3___2 = 1744,
	PORT41_FN3 = 1745,
	PORT42_FN3 = 1746,
	PORT43_FN3 = 1747,
	PORT44_FN3 = 1748,
	PORT45_FN3 = 1749,
	PORT46_FN3 = 1750,
	PORT47_FN3 = 1751,
	PORT48_FN3 = 1752,
	PORT49_FN3 = 1753,
	PORT50_FN3 = 1754,
	PORT51_FN3 = 1755,
	PORT52_FN3 = 1756,
	PORT53_FN3 = 1757,
	PORT54_FN3 = 1758,
	PORT55_FN3 = 1759,
	PORT56_FN3 = 1760,
	PORT57_FN3 = 1761,
	PORT58_FN3 = 1762,
	PORT59_FN3 = 1763,
	PORT60_FN3 = 1764,
	PORT61_FN3 = 1765,
	PORT62_FN3 = 1766,
	PORT63_FN3 = 1767,
	PORT64_FN3___2 = 1768,
	PORT65_FN3___2 = 1769,
	PORT66_FN3___2 = 1770,
	PORT67_FN3___2 = 1771,
	PORT68_FN3___2 = 1772,
	PORT69_FN3___2 = 1773,
	PORT70_FN3___2 = 1774,
	PORT71_FN3___2 = 1775,
	PORT72_FN3___2 = 1776,
	PORT73_FN3___2 = 1777,
	PORT74_FN3___2 = 1778,
	PORT75_FN3___2 = 1779,
	PORT76_FN3___2 = 1780,
	PORT77_FN3___2 = 1781,
	PORT78_FN3___2 = 1782,
	PORT79_FN3___2 = 1783,
	PORT80_FN3___2 = 1784,
	PORT81_FN3___2 = 1785,
	PORT82_FN3___2 = 1786,
	PORT83_FN3___2 = 1787,
	PORT84_FN3___2 = 1788,
	PORT85_FN3___2 = 1789,
	PORT86_FN3 = 1790,
	PORT87_FN3 = 1791,
	PORT88_FN3 = 1792,
	PORT89_FN3 = 1793,
	PORT90_FN3 = 1794,
	PORT91_FN3 = 1795,
	PORT92_FN3 = 1796,
	PORT93_FN3 = 1797,
	PORT94_FN3 = 1798,
	PORT95_FN3 = 1799,
	PORT96_FN3___2 = 1800,
	PORT97_FN3___2 = 1801,
	PORT98_FN3___2 = 1802,
	PORT99_FN3___2 = 1803,
	PORT100_FN3___2 = 1804,
	PORT101_FN3___2 = 1805,
	PORT102_FN3___2 = 1806,
	PORT103_FN3___2 = 1807,
	PORT104_FN3___2 = 1808,
	PORT105_FN3___2 = 1809,
	PORT106_FN3___2 = 1810,
	PORT107_FN3___2 = 1811,
	PORT108_FN3___2 = 1812,
	PORT109_FN3___2 = 1813,
	PORT110_FN3___2 = 1814,
	PORT111_FN3___2 = 1815,
	PORT112_FN3___2 = 1816,
	PORT113_FN3___2 = 1817,
	PORT114_FN3___2 = 1818,
	PORT115_FN3___2 = 1819,
	PORT116_FN3___2 = 1820,
	PORT117_FN3___2 = 1821,
	PORT118_FN3___2 = 1822,
	PORT119_FN3___2 = 1823,
	PORT120_FN3___2 = 1824,
	PORT121_FN3___2 = 1825,
	PORT122_FN3___2 = 1826,
	PORT123_FN3___2 = 1827,
	PORT124_FN3___2 = 1828,
	PORT125_FN3___2 = 1829,
	PORT126_FN3___2 = 1830,
	PORT127_FN3 = 1831,
	PORT128_FN3___2 = 1832,
	PORT129_FN3___2 = 1833,
	PORT130_FN3___2 = 1834,
	PORT131_FN3___2 = 1835,
	PORT132_FN3___2 = 1836,
	PORT133_FN3___2 = 1837,
	PORT134_FN3___2 = 1838,
	PORT135_FN3 = 1839,
	PORT136_FN3 = 1840,
	PORT137_FN3 = 1841,
	PORT138_FN3 = 1842,
	PORT139_FN3 = 1843,
	PORT140_FN3 = 1844,
	PORT141_FN3 = 1845,
	PORT142_FN3 = 1846,
	PORT143_FN3 = 1847,
	PORT144_FN3 = 1848,
	PORT145_FN3 = 1849,
	PORT146_FN3 = 1850,
	PORT147_FN3 = 1851,
	PORT148_FN3 = 1852,
	PORT149_FN3 = 1853,
	PORT150_FN3 = 1854,
	PORT151_FN3 = 1855,
	PORT152_FN3 = 1856,
	PORT153_FN3 = 1857,
	PORT154_FN3 = 1858,
	PORT155_FN3 = 1859,
	PORT156_FN3 = 1860,
	PORT157_FN3 = 1861,
	PORT158_FN3 = 1862,
	PORT159_FN3 = 1863,
	PORT160_FN3___2 = 1864,
	PORT161_FN3___2 = 1865,
	PORT162_FN3___2 = 1866,
	PORT163_FN3___2 = 1867,
	PORT164_FN3___2 = 1868,
	PORT165_FN3___2 = 1869,
	PORT166_FN3___2 = 1870,
	PORT167_FN3___2 = 1871,
	PORT168_FN3___2 = 1872,
	PORT169_FN3___2 = 1873,
	PORT170_FN3___2 = 1874,
	PORT171_FN3___2 = 1875,
	PORT172_FN3___2 = 1876,
	PORT173_FN3___2 = 1877,
	PORT174_FN3___2 = 1878,
	PORT175_FN3___2 = 1879,
	PORT176_FN3___2 = 1880,
	PORT177_FN3___2 = 1881,
	PORT178_FN3___2 = 1882,
	PORT179_FN3 = 1883,
	PORT180_FN3 = 1884,
	PORT181_FN3 = 1885,
	PORT182_FN3 = 1886,
	PORT183_FN3 = 1887,
	PORT184_FN3 = 1888,
	PORT185_FN3 = 1889,
	PORT186_FN3 = 1890,
	PORT187_FN3 = 1891,
	PORT188_FN3 = 1892,
	PORT189_FN3 = 1893,
	PORT190_FN3 = 1894,
	PORT191_FN3 = 1895,
	PORT192_FN3___2 = 1896,
	PORT193_FN3___2 = 1897,
	PORT194_FN3___2 = 1898,
	PORT195_FN3___2 = 1899,
	PORT196_FN3___2 = 1900,
	PORT197_FN3___2 = 1901,
	PORT198_FN3___2 = 1902,
	PORT199_FN3___2 = 1903,
	PORT200_FN3___2 = 1904,
	PORT201_FN3___2 = 1905,
	PORT202_FN3___2 = 1906,
	PORT203_FN3___2 = 1907,
	PORT204_FN3___2 = 1908,
	PORT205_FN3___2 = 1909,
	PORT206_FN3___2 = 1910,
	PORT207_FN3___2 = 1911,
	PORT208_FN3___2 = 1912,
	PORT209_FN3___2 = 1913,
	PORT210_FN3___2 = 1914,
	PORT211_FN3___2 = 1915,
	PORT0_FN4___2 = 1916,
	PORT1_FN4___2 = 1917,
	PORT2_FN4___2 = 1918,
	PORT3_FN4___2 = 1919,
	PORT4_FN4___2 = 1920,
	PORT5_FN4___2 = 1921,
	PORT6_FN4___2 = 1922,
	PORT7_FN4___2 = 1923,
	PORT8_FN4___2 = 1924,
	PORT9_FN4___2 = 1925,
	PORT10_FN4___2 = 1926,
	PORT11_FN4___2 = 1927,
	PORT12_FN4___2 = 1928,
	PORT13_FN4___2 = 1929,
	PORT14_FN4___2 = 1930,
	PORT15_FN4___2 = 1931,
	PORT16_FN4___2 = 1932,
	PORT17_FN4___2 = 1933,
	PORT18_FN4___2 = 1934,
	PORT19_FN4___2 = 1935,
	PORT20_FN4___2 = 1936,
	PORT21_FN4___2 = 1937,
	PORT22_FN4___2 = 1938,
	PORT23_FN4___2 = 1939,
	PORT24_FN4___2 = 1940,
	PORT25_FN4___2 = 1941,
	PORT26_FN4___2 = 1942,
	PORT27_FN4___2 = 1943,
	PORT28_FN4___2 = 1944,
	PORT29_FN4___2 = 1945,
	PORT30_FN4___2 = 1946,
	PORT31_FN4 = 1947,
	PORT32_FN4___2 = 1948,
	PORT33_FN4___2 = 1949,
	PORT34_FN4___2 = 1950,
	PORT35_FN4___2 = 1951,
	PORT36_FN4___2 = 1952,
	PORT37_FN4___2 = 1953,
	PORT38_FN4___2 = 1954,
	PORT39_FN4___2 = 1955,
	PORT40_FN4___2 = 1956,
	PORT41_FN4 = 1957,
	PORT42_FN4 = 1958,
	PORT43_FN4 = 1959,
	PORT44_FN4 = 1960,
	PORT45_FN4 = 1961,
	PORT46_FN4 = 1962,
	PORT47_FN4 = 1963,
	PORT48_FN4 = 1964,
	PORT49_FN4 = 1965,
	PORT50_FN4 = 1966,
	PORT51_FN4 = 1967,
	PORT52_FN4 = 1968,
	PORT53_FN4 = 1969,
	PORT54_FN4 = 1970,
	PORT55_FN4 = 1971,
	PORT56_FN4 = 1972,
	PORT57_FN4 = 1973,
	PORT58_FN4 = 1974,
	PORT59_FN4 = 1975,
	PORT60_FN4 = 1976,
	PORT61_FN4 = 1977,
	PORT62_FN4 = 1978,
	PORT63_FN4 = 1979,
	PORT64_FN4___2 = 1980,
	PORT65_FN4___2 = 1981,
	PORT66_FN4___2 = 1982,
	PORT67_FN4___2 = 1983,
	PORT68_FN4___2 = 1984,
	PORT69_FN4___2 = 1985,
	PORT70_FN4___2 = 1986,
	PORT71_FN4___2 = 1987,
	PORT72_FN4___2 = 1988,
	PORT73_FN4___2 = 1989,
	PORT74_FN4___2 = 1990,
	PORT75_FN4___2 = 1991,
	PORT76_FN4___2 = 1992,
	PORT77_FN4___2 = 1993,
	PORT78_FN4___2 = 1994,
	PORT79_FN4___2 = 1995,
	PORT80_FN4___2 = 1996,
	PORT81_FN4___2 = 1997,
	PORT82_FN4___2 = 1998,
	PORT83_FN4___2 = 1999,
	PORT84_FN4___2 = 2000,
	PORT85_FN4___2 = 2001,
	PORT86_FN4 = 2002,
	PORT87_FN4 = 2003,
	PORT88_FN4 = 2004,
	PORT89_FN4 = 2005,
	PORT90_FN4 = 2006,
	PORT91_FN4 = 2007,
	PORT92_FN4 = 2008,
	PORT93_FN4 = 2009,
	PORT94_FN4 = 2010,
	PORT95_FN4 = 2011,
	PORT96_FN4___2 = 2012,
	PORT97_FN4___2 = 2013,
	PORT98_FN4___2 = 2014,
	PORT99_FN4___2 = 2015,
	PORT100_FN4___2 = 2016,
	PORT101_FN4___2 = 2017,
	PORT102_FN4___2 = 2018,
	PORT103_FN4___2 = 2019,
	PORT104_FN4___2 = 2020,
	PORT105_FN4___2 = 2021,
	PORT106_FN4___2 = 2022,
	PORT107_FN4___2 = 2023,
	PORT108_FN4___2 = 2024,
	PORT109_FN4___2 = 2025,
	PORT110_FN4___2 = 2026,
	PORT111_FN4___2 = 2027,
	PORT112_FN4___2 = 2028,
	PORT113_FN4___2 = 2029,
	PORT114_FN4___2 = 2030,
	PORT115_FN4___2 = 2031,
	PORT116_FN4___2 = 2032,
	PORT117_FN4___2 = 2033,
	PORT118_FN4___2 = 2034,
	PORT119_FN4___2 = 2035,
	PORT120_FN4___2 = 2036,
	PORT121_FN4___2 = 2037,
	PORT122_FN4___2 = 2038,
	PORT123_FN4___2 = 2039,
	PORT124_FN4___2 = 2040,
	PORT125_FN4___2 = 2041,
	PORT126_FN4___2 = 2042,
	PORT127_FN4 = 2043,
	PORT128_FN4___2 = 2044,
	PORT129_FN4___2 = 2045,
	PORT130_FN4___2 = 2046,
	PORT131_FN4___2 = 2047,
	PORT132_FN4___2 = 2048,
	PORT133_FN4___2 = 2049,
	PORT134_FN4___2 = 2050,
	PORT135_FN4 = 2051,
	PORT136_FN4 = 2052,
	PORT137_FN4 = 2053,
	PORT138_FN4 = 2054,
	PORT139_FN4 = 2055,
	PORT140_FN4 = 2056,
	PORT141_FN4 = 2057,
	PORT142_FN4 = 2058,
	PORT143_FN4 = 2059,
	PORT144_FN4 = 2060,
	PORT145_FN4 = 2061,
	PORT146_FN4 = 2062,
	PORT147_FN4 = 2063,
	PORT148_FN4 = 2064,
	PORT149_FN4 = 2065,
	PORT150_FN4 = 2066,
	PORT151_FN4 = 2067,
	PORT152_FN4 = 2068,
	PORT153_FN4 = 2069,
	PORT154_FN4 = 2070,
	PORT155_FN4 = 2071,
	PORT156_FN4 = 2072,
	PORT157_FN4 = 2073,
	PORT158_FN4 = 2074,
	PORT159_FN4 = 2075,
	PORT160_FN4___2 = 2076,
	PORT161_FN4___2 = 2077,
	PORT162_FN4___2 = 2078,
	PORT163_FN4___2 = 2079,
	PORT164_FN4___2 = 2080,
	PORT165_FN4___2 = 2081,
	PORT166_FN4___2 = 2082,
	PORT167_FN4___2 = 2083,
	PORT168_FN4___2 = 2084,
	PORT169_FN4___2 = 2085,
	PORT170_FN4___2 = 2086,
	PORT171_FN4___2 = 2087,
	PORT172_FN4___2 = 2088,
	PORT173_FN4___2 = 2089,
	PORT174_FN4___2 = 2090,
	PORT175_FN4___2 = 2091,
	PORT176_FN4___2 = 2092,
	PORT177_FN4___2 = 2093,
	PORT178_FN4___2 = 2094,
	PORT179_FN4 = 2095,
	PORT180_FN4 = 2096,
	PORT181_FN4 = 2097,
	PORT182_FN4 = 2098,
	PORT183_FN4 = 2099,
	PORT184_FN4 = 2100,
	PORT185_FN4 = 2101,
	PORT186_FN4 = 2102,
	PORT187_FN4 = 2103,
	PORT188_FN4 = 2104,
	PORT189_FN4 = 2105,
	PORT190_FN4 = 2106,
	PORT191_FN4 = 2107,
	PORT192_FN4___2 = 2108,
	PORT193_FN4___2 = 2109,
	PORT194_FN4___2 = 2110,
	PORT195_FN4___2 = 2111,
	PORT196_FN4___2 = 2112,
	PORT197_FN4___2 = 2113,
	PORT198_FN4___2 = 2114,
	PORT199_FN4___2 = 2115,
	PORT200_FN4___2 = 2116,
	PORT201_FN4___2 = 2117,
	PORT202_FN4___2 = 2118,
	PORT203_FN4___2 = 2119,
	PORT204_FN4___2 = 2120,
	PORT205_FN4___2 = 2121,
	PORT206_FN4___2 = 2122,
	PORT207_FN4___2 = 2123,
	PORT208_FN4___2 = 2124,
	PORT209_FN4___2 = 2125,
	PORT210_FN4___2 = 2126,
	PORT211_FN4___2 = 2127,
	PORT0_FN5___2 = 2128,
	PORT1_FN5___2 = 2129,
	PORT2_FN5___2 = 2130,
	PORT3_FN5___2 = 2131,
	PORT4_FN5___2 = 2132,
	PORT5_FN5___2 = 2133,
	PORT6_FN5___2 = 2134,
	PORT7_FN5___2 = 2135,
	PORT8_FN5___2 = 2136,
	PORT9_FN5___2 = 2137,
	PORT10_FN5___2 = 2138,
	PORT11_FN5___2 = 2139,
	PORT12_FN5___2 = 2140,
	PORT13_FN5___2 = 2141,
	PORT14_FN5___2 = 2142,
	PORT15_FN5___2 = 2143,
	PORT16_FN5___2 = 2144,
	PORT17_FN5___2 = 2145,
	PORT18_FN5___2 = 2146,
	PORT19_FN5___2 = 2147,
	PORT20_FN5___2 = 2148,
	PORT21_FN5___2 = 2149,
	PORT22_FN5___2 = 2150,
	PORT23_FN5___2 = 2151,
	PORT24_FN5___2 = 2152,
	PORT25_FN5___2 = 2153,
	PORT26_FN5___2 = 2154,
	PORT27_FN5___2 = 2155,
	PORT28_FN5___2 = 2156,
	PORT29_FN5___2 = 2157,
	PORT30_FN5___2 = 2158,
	PORT31_FN5 = 2159,
	PORT32_FN5___2 = 2160,
	PORT33_FN5___2 = 2161,
	PORT34_FN5___2 = 2162,
	PORT35_FN5___2 = 2163,
	PORT36_FN5___2 = 2164,
	PORT37_FN5___2 = 2165,
	PORT38_FN5___2 = 2166,
	PORT39_FN5___2 = 2167,
	PORT40_FN5___2 = 2168,
	PORT41_FN5 = 2169,
	PORT42_FN5 = 2170,
	PORT43_FN5 = 2171,
	PORT44_FN5 = 2172,
	PORT45_FN5 = 2173,
	PORT46_FN5 = 2174,
	PORT47_FN5 = 2175,
	PORT48_FN5 = 2176,
	PORT49_FN5 = 2177,
	PORT50_FN5 = 2178,
	PORT51_FN5 = 2179,
	PORT52_FN5 = 2180,
	PORT53_FN5 = 2181,
	PORT54_FN5 = 2182,
	PORT55_FN5 = 2183,
	PORT56_FN5 = 2184,
	PORT57_FN5 = 2185,
	PORT58_FN5 = 2186,
	PORT59_FN5 = 2187,
	PORT60_FN5 = 2188,
	PORT61_FN5 = 2189,
	PORT62_FN5 = 2190,
	PORT63_FN5 = 2191,
	PORT64_FN5___2 = 2192,
	PORT65_FN5___2 = 2193,
	PORT66_FN5___2 = 2194,
	PORT67_FN5___2 = 2195,
	PORT68_FN5___2 = 2196,
	PORT69_FN5___2 = 2197,
	PORT70_FN5___2 = 2198,
	PORT71_FN5___2 = 2199,
	PORT72_FN5___2 = 2200,
	PORT73_FN5___2 = 2201,
	PORT74_FN5___2 = 2202,
	PORT75_FN5___2 = 2203,
	PORT76_FN5___2 = 2204,
	PORT77_FN5___2 = 2205,
	PORT78_FN5___2 = 2206,
	PORT79_FN5___2 = 2207,
	PORT80_FN5___2 = 2208,
	PORT81_FN5___2 = 2209,
	PORT82_FN5___2 = 2210,
	PORT83_FN5___2 = 2211,
	PORT84_FN5___2 = 2212,
	PORT85_FN5___2 = 2213,
	PORT86_FN5 = 2214,
	PORT87_FN5 = 2215,
	PORT88_FN5 = 2216,
	PORT89_FN5 = 2217,
	PORT90_FN5 = 2218,
	PORT91_FN5 = 2219,
	PORT92_FN5 = 2220,
	PORT93_FN5 = 2221,
	PORT94_FN5 = 2222,
	PORT95_FN5 = 2223,
	PORT96_FN5___2 = 2224,
	PORT97_FN5___2 = 2225,
	PORT98_FN5___2 = 2226,
	PORT99_FN5___2 = 2227,
	PORT100_FN5___2 = 2228,
	PORT101_FN5___2 = 2229,
	PORT102_FN5___2 = 2230,
	PORT103_FN5___2 = 2231,
	PORT104_FN5___2 = 2232,
	PORT105_FN5___2 = 2233,
	PORT106_FN5___2 = 2234,
	PORT107_FN5___2 = 2235,
	PORT108_FN5___2 = 2236,
	PORT109_FN5___2 = 2237,
	PORT110_FN5___2 = 2238,
	PORT111_FN5___2 = 2239,
	PORT112_FN5___2 = 2240,
	PORT113_FN5___2 = 2241,
	PORT114_FN5___2 = 2242,
	PORT115_FN5___2 = 2243,
	PORT116_FN5___2 = 2244,
	PORT117_FN5___2 = 2245,
	PORT118_FN5___2 = 2246,
	PORT119_FN5___2 = 2247,
	PORT120_FN5___2 = 2248,
	PORT121_FN5___2 = 2249,
	PORT122_FN5___2 = 2250,
	PORT123_FN5___2 = 2251,
	PORT124_FN5___2 = 2252,
	PORT125_FN5___2 = 2253,
	PORT126_FN5___2 = 2254,
	PORT127_FN5 = 2255,
	PORT128_FN5___2 = 2256,
	PORT129_FN5___2 = 2257,
	PORT130_FN5___2 = 2258,
	PORT131_FN5___2 = 2259,
	PORT132_FN5___2 = 2260,
	PORT133_FN5___2 = 2261,
	PORT134_FN5___2 = 2262,
	PORT135_FN5 = 2263,
	PORT136_FN5 = 2264,
	PORT137_FN5 = 2265,
	PORT138_FN5 = 2266,
	PORT139_FN5 = 2267,
	PORT140_FN5 = 2268,
	PORT141_FN5 = 2269,
	PORT142_FN5 = 2270,
	PORT143_FN5 = 2271,
	PORT144_FN5 = 2272,
	PORT145_FN5 = 2273,
	PORT146_FN5 = 2274,
	PORT147_FN5 = 2275,
	PORT148_FN5 = 2276,
	PORT149_FN5 = 2277,
	PORT150_FN5 = 2278,
	PORT151_FN5 = 2279,
	PORT152_FN5 = 2280,
	PORT153_FN5 = 2281,
	PORT154_FN5 = 2282,
	PORT155_FN5 = 2283,
	PORT156_FN5 = 2284,
	PORT157_FN5 = 2285,
	PORT158_FN5 = 2286,
	PORT159_FN5 = 2287,
	PORT160_FN5___2 = 2288,
	PORT161_FN5___2 = 2289,
	PORT162_FN5___2 = 2290,
	PORT163_FN5___2 = 2291,
	PORT164_FN5___2 = 2292,
	PORT165_FN5___2 = 2293,
	PORT166_FN5___2 = 2294,
	PORT167_FN5___2 = 2295,
	PORT168_FN5___2 = 2296,
	PORT169_FN5___2 = 2297,
	PORT170_FN5___2 = 2298,
	PORT171_FN5___2 = 2299,
	PORT172_FN5___2 = 2300,
	PORT173_FN5___2 = 2301,
	PORT174_FN5___2 = 2302,
	PORT175_FN5___2 = 2303,
	PORT176_FN5___2 = 2304,
	PORT177_FN5___2 = 2305,
	PORT178_FN5___2 = 2306,
	PORT179_FN5 = 2307,
	PORT180_FN5 = 2308,
	PORT181_FN5 = 2309,
	PORT182_FN5 = 2310,
	PORT183_FN5 = 2311,
	PORT184_FN5 = 2312,
	PORT185_FN5 = 2313,
	PORT186_FN5 = 2314,
	PORT187_FN5 = 2315,
	PORT188_FN5 = 2316,
	PORT189_FN5 = 2317,
	PORT190_FN5 = 2318,
	PORT191_FN5 = 2319,
	PORT192_FN5___2 = 2320,
	PORT193_FN5___2 = 2321,
	PORT194_FN5___2 = 2322,
	PORT195_FN5___2 = 2323,
	PORT196_FN5___2 = 2324,
	PORT197_FN5___2 = 2325,
	PORT198_FN5___2 = 2326,
	PORT199_FN5___2 = 2327,
	PORT200_FN5___2 = 2328,
	PORT201_FN5___2 = 2329,
	PORT202_FN5___2 = 2330,
	PORT203_FN5___2 = 2331,
	PORT204_FN5___2 = 2332,
	PORT205_FN5___2 = 2333,
	PORT206_FN5___2 = 2334,
	PORT207_FN5___2 = 2335,
	PORT208_FN5___2 = 2336,
	PORT209_FN5___2 = 2337,
	PORT210_FN5___2 = 2338,
	PORT211_FN5___2 = 2339,
	PORT0_FN6___2 = 2340,
	PORT1_FN6___2 = 2341,
	PORT2_FN6___2 = 2342,
	PORT3_FN6___2 = 2343,
	PORT4_FN6___2 = 2344,
	PORT5_FN6___2 = 2345,
	PORT6_FN6___2 = 2346,
	PORT7_FN6___2 = 2347,
	PORT8_FN6___2 = 2348,
	PORT9_FN6___2 = 2349,
	PORT10_FN6___2 = 2350,
	PORT11_FN6___2 = 2351,
	PORT12_FN6___2 = 2352,
	PORT13_FN6___2 = 2353,
	PORT14_FN6___2 = 2354,
	PORT15_FN6___2 = 2355,
	PORT16_FN6___2 = 2356,
	PORT17_FN6___2 = 2357,
	PORT18_FN6___2 = 2358,
	PORT19_FN6___2 = 2359,
	PORT20_FN6___2 = 2360,
	PORT21_FN6___2 = 2361,
	PORT22_FN6___2 = 2362,
	PORT23_FN6___2 = 2363,
	PORT24_FN6___2 = 2364,
	PORT25_FN6___2 = 2365,
	PORT26_FN6___2 = 2366,
	PORT27_FN6___2 = 2367,
	PORT28_FN6___2 = 2368,
	PORT29_FN6___2 = 2369,
	PORT30_FN6___2 = 2370,
	PORT31_FN6 = 2371,
	PORT32_FN6___2 = 2372,
	PORT33_FN6___2 = 2373,
	PORT34_FN6___2 = 2374,
	PORT35_FN6___2 = 2375,
	PORT36_FN6___2 = 2376,
	PORT37_FN6___2 = 2377,
	PORT38_FN6___2 = 2378,
	PORT39_FN6___2 = 2379,
	PORT40_FN6___2 = 2380,
	PORT41_FN6 = 2381,
	PORT42_FN6 = 2382,
	PORT43_FN6 = 2383,
	PORT44_FN6 = 2384,
	PORT45_FN6 = 2385,
	PORT46_FN6 = 2386,
	PORT47_FN6 = 2387,
	PORT48_FN6 = 2388,
	PORT49_FN6 = 2389,
	PORT50_FN6 = 2390,
	PORT51_FN6 = 2391,
	PORT52_FN6 = 2392,
	PORT53_FN6 = 2393,
	PORT54_FN6 = 2394,
	PORT55_FN6 = 2395,
	PORT56_FN6 = 2396,
	PORT57_FN6 = 2397,
	PORT58_FN6 = 2398,
	PORT59_FN6 = 2399,
	PORT60_FN6 = 2400,
	PORT61_FN6 = 2401,
	PORT62_FN6 = 2402,
	PORT63_FN6 = 2403,
	PORT64_FN6___2 = 2404,
	PORT65_FN6___2 = 2405,
	PORT66_FN6___2 = 2406,
	PORT67_FN6___2 = 2407,
	PORT68_FN6___2 = 2408,
	PORT69_FN6___2 = 2409,
	PORT70_FN6___2 = 2410,
	PORT71_FN6___2 = 2411,
	PORT72_FN6___2 = 2412,
	PORT73_FN6___2 = 2413,
	PORT74_FN6___2 = 2414,
	PORT75_FN6___2 = 2415,
	PORT76_FN6___2 = 2416,
	PORT77_FN6___2 = 2417,
	PORT78_FN6___2 = 2418,
	PORT79_FN6___2 = 2419,
	PORT80_FN6___2 = 2420,
	PORT81_FN6___2 = 2421,
	PORT82_FN6___2 = 2422,
	PORT83_FN6___2 = 2423,
	PORT84_FN6___2 = 2424,
	PORT85_FN6___2 = 2425,
	PORT86_FN6 = 2426,
	PORT87_FN6 = 2427,
	PORT88_FN6 = 2428,
	PORT89_FN6 = 2429,
	PORT90_FN6 = 2430,
	PORT91_FN6 = 2431,
	PORT92_FN6 = 2432,
	PORT93_FN6 = 2433,
	PORT94_FN6 = 2434,
	PORT95_FN6 = 2435,
	PORT96_FN6___2 = 2436,
	PORT97_FN6___2 = 2437,
	PORT98_FN6___2 = 2438,
	PORT99_FN6___2 = 2439,
	PORT100_FN6___2 = 2440,
	PORT101_FN6___2 = 2441,
	PORT102_FN6___2 = 2442,
	PORT103_FN6___2 = 2443,
	PORT104_FN6___2 = 2444,
	PORT105_FN6___2 = 2445,
	PORT106_FN6___2 = 2446,
	PORT107_FN6___2 = 2447,
	PORT108_FN6___2 = 2448,
	PORT109_FN6___2 = 2449,
	PORT110_FN6___2 = 2450,
	PORT111_FN6___2 = 2451,
	PORT112_FN6___2 = 2452,
	PORT113_FN6___2 = 2453,
	PORT114_FN6___2 = 2454,
	PORT115_FN6___2 = 2455,
	PORT116_FN6___2 = 2456,
	PORT117_FN6___2 = 2457,
	PORT118_FN6___2 = 2458,
	PORT119_FN6___2 = 2459,
	PORT120_FN6___2 = 2460,
	PORT121_FN6___2 = 2461,
	PORT122_FN6___2 = 2462,
	PORT123_FN6___2 = 2463,
	PORT124_FN6___2 = 2464,
	PORT125_FN6___2 = 2465,
	PORT126_FN6___2 = 2466,
	PORT127_FN6 = 2467,
	PORT128_FN6___2 = 2468,
	PORT129_FN6___2 = 2469,
	PORT130_FN6___2 = 2470,
	PORT131_FN6___2 = 2471,
	PORT132_FN6___2 = 2472,
	PORT133_FN6___2 = 2473,
	PORT134_FN6___2 = 2474,
	PORT135_FN6 = 2475,
	PORT136_FN6 = 2476,
	PORT137_FN6 = 2477,
	PORT138_FN6 = 2478,
	PORT139_FN6 = 2479,
	PORT140_FN6 = 2480,
	PORT141_FN6 = 2481,
	PORT142_FN6 = 2482,
	PORT143_FN6 = 2483,
	PORT144_FN6 = 2484,
	PORT145_FN6 = 2485,
	PORT146_FN6 = 2486,
	PORT147_FN6 = 2487,
	PORT148_FN6 = 2488,
	PORT149_FN6 = 2489,
	PORT150_FN6 = 2490,
	PORT151_FN6 = 2491,
	PORT152_FN6 = 2492,
	PORT153_FN6 = 2493,
	PORT154_FN6 = 2494,
	PORT155_FN6 = 2495,
	PORT156_FN6 = 2496,
	PORT157_FN6 = 2497,
	PORT158_FN6 = 2498,
	PORT159_FN6 = 2499,
	PORT160_FN6___2 = 2500,
	PORT161_FN6___2 = 2501,
	PORT162_FN6___2 = 2502,
	PORT163_FN6___2 = 2503,
	PORT164_FN6___2 = 2504,
	PORT165_FN6___2 = 2505,
	PORT166_FN6___2 = 2506,
	PORT167_FN6___2 = 2507,
	PORT168_FN6___2 = 2508,
	PORT169_FN6___2 = 2509,
	PORT170_FN6___2 = 2510,
	PORT171_FN6___2 = 2511,
	PORT172_FN6___2 = 2512,
	PORT173_FN6___2 = 2513,
	PORT174_FN6___2 = 2514,
	PORT175_FN6___2 = 2515,
	PORT176_FN6___2 = 2516,
	PORT177_FN6___2 = 2517,
	PORT178_FN6___2 = 2518,
	PORT179_FN6 = 2519,
	PORT180_FN6 = 2520,
	PORT181_FN6 = 2521,
	PORT182_FN6 = 2522,
	PORT183_FN6 = 2523,
	PORT184_FN6 = 2524,
	PORT185_FN6 = 2525,
	PORT186_FN6 = 2526,
	PORT187_FN6 = 2527,
	PORT188_FN6 = 2528,
	PORT189_FN6 = 2529,
	PORT190_FN6 = 2530,
	PORT191_FN6 = 2531,
	PORT192_FN6___2 = 2532,
	PORT193_FN6___2 = 2533,
	PORT194_FN6___2 = 2534,
	PORT195_FN6___2 = 2535,
	PORT196_FN6___2 = 2536,
	PORT197_FN6___2 = 2537,
	PORT198_FN6___2 = 2538,
	PORT199_FN6___2 = 2539,
	PORT200_FN6___2 = 2540,
	PORT201_FN6___2 = 2541,
	PORT202_FN6___2 = 2542,
	PORT203_FN6___2 = 2543,
	PORT204_FN6___2 = 2544,
	PORT205_FN6___2 = 2545,
	PORT206_FN6___2 = 2546,
	PORT207_FN6___2 = 2547,
	PORT208_FN6___2 = 2548,
	PORT209_FN6___2 = 2549,
	PORT210_FN6___2 = 2550,
	PORT211_FN6___2 = 2551,
	PORT0_FN7___2 = 2552,
	PORT1_FN7___2 = 2553,
	PORT2_FN7___2 = 2554,
	PORT3_FN7___2 = 2555,
	PORT4_FN7___2 = 2556,
	PORT5_FN7___2 = 2557,
	PORT6_FN7___2 = 2558,
	PORT7_FN7___2 = 2559,
	PORT8_FN7___2 = 2560,
	PORT9_FN7___2 = 2561,
	PORT10_FN7___2 = 2562,
	PORT11_FN7___2 = 2563,
	PORT12_FN7___2 = 2564,
	PORT13_FN7___2 = 2565,
	PORT14_FN7___2 = 2566,
	PORT15_FN7___2 = 2567,
	PORT16_FN7___2 = 2568,
	PORT17_FN7___2 = 2569,
	PORT18_FN7___2 = 2570,
	PORT19_FN7___2 = 2571,
	PORT20_FN7___2 = 2572,
	PORT21_FN7___2 = 2573,
	PORT22_FN7___2 = 2574,
	PORT23_FN7___2 = 2575,
	PORT24_FN7___2 = 2576,
	PORT25_FN7___2 = 2577,
	PORT26_FN7___2 = 2578,
	PORT27_FN7___2 = 2579,
	PORT28_FN7___2 = 2580,
	PORT29_FN7___2 = 2581,
	PORT30_FN7___2 = 2582,
	PORT31_FN7 = 2583,
	PORT32_FN7___2 = 2584,
	PORT33_FN7___2 = 2585,
	PORT34_FN7___2 = 2586,
	PORT35_FN7___2 = 2587,
	PORT36_FN7___2 = 2588,
	PORT37_FN7___2 = 2589,
	PORT38_FN7___2 = 2590,
	PORT39_FN7___2 = 2591,
	PORT40_FN7___2 = 2592,
	PORT41_FN7 = 2593,
	PORT42_FN7 = 2594,
	PORT43_FN7 = 2595,
	PORT44_FN7 = 2596,
	PORT45_FN7 = 2597,
	PORT46_FN7 = 2598,
	PORT47_FN7 = 2599,
	PORT48_FN7 = 2600,
	PORT49_FN7 = 2601,
	PORT50_FN7 = 2602,
	PORT51_FN7 = 2603,
	PORT52_FN7 = 2604,
	PORT53_FN7 = 2605,
	PORT54_FN7 = 2606,
	PORT55_FN7 = 2607,
	PORT56_FN7 = 2608,
	PORT57_FN7 = 2609,
	PORT58_FN7 = 2610,
	PORT59_FN7 = 2611,
	PORT60_FN7 = 2612,
	PORT61_FN7 = 2613,
	PORT62_FN7 = 2614,
	PORT63_FN7 = 2615,
	PORT64_FN7___2 = 2616,
	PORT65_FN7___2 = 2617,
	PORT66_FN7___2 = 2618,
	PORT67_FN7___2 = 2619,
	PORT68_FN7___2 = 2620,
	PORT69_FN7___2 = 2621,
	PORT70_FN7___2 = 2622,
	PORT71_FN7___2 = 2623,
	PORT72_FN7___2 = 2624,
	PORT73_FN7___2 = 2625,
	PORT74_FN7___2 = 2626,
	PORT75_FN7___2 = 2627,
	PORT76_FN7___2 = 2628,
	PORT77_FN7___2 = 2629,
	PORT78_FN7___2 = 2630,
	PORT79_FN7___2 = 2631,
	PORT80_FN7___2 = 2632,
	PORT81_FN7___2 = 2633,
	PORT82_FN7___2 = 2634,
	PORT83_FN7___2 = 2635,
	PORT84_FN7___2 = 2636,
	PORT85_FN7___2 = 2637,
	PORT86_FN7 = 2638,
	PORT87_FN7 = 2639,
	PORT88_FN7 = 2640,
	PORT89_FN7 = 2641,
	PORT90_FN7 = 2642,
	PORT91_FN7 = 2643,
	PORT92_FN7 = 2644,
	PORT93_FN7 = 2645,
	PORT94_FN7 = 2646,
	PORT95_FN7 = 2647,
	PORT96_FN7___2 = 2648,
	PORT97_FN7___2 = 2649,
	PORT98_FN7___2 = 2650,
	PORT99_FN7___2 = 2651,
	PORT100_FN7___2 = 2652,
	PORT101_FN7___2 = 2653,
	PORT102_FN7___2 = 2654,
	PORT103_FN7___2 = 2655,
	PORT104_FN7___2 = 2656,
	PORT105_FN7___2 = 2657,
	PORT106_FN7___2 = 2658,
	PORT107_FN7___2 = 2659,
	PORT108_FN7___2 = 2660,
	PORT109_FN7___2 = 2661,
	PORT110_FN7___2 = 2662,
	PORT111_FN7___2 = 2663,
	PORT112_FN7___2 = 2664,
	PORT113_FN7___2 = 2665,
	PORT114_FN7___2 = 2666,
	PORT115_FN7___2 = 2667,
	PORT116_FN7___2 = 2668,
	PORT117_FN7___2 = 2669,
	PORT118_FN7___2 = 2670,
	PORT119_FN7___2 = 2671,
	PORT120_FN7___2 = 2672,
	PORT121_FN7___2 = 2673,
	PORT122_FN7___2 = 2674,
	PORT123_FN7___2 = 2675,
	PORT124_FN7___2 = 2676,
	PORT125_FN7___2 = 2677,
	PORT126_FN7___2 = 2678,
	PORT127_FN7 = 2679,
	PORT128_FN7___2 = 2680,
	PORT129_FN7___2 = 2681,
	PORT130_FN7___2 = 2682,
	PORT131_FN7___2 = 2683,
	PORT132_FN7___2 = 2684,
	PORT133_FN7___2 = 2685,
	PORT134_FN7___2 = 2686,
	PORT135_FN7 = 2687,
	PORT136_FN7 = 2688,
	PORT137_FN7 = 2689,
	PORT138_FN7 = 2690,
	PORT139_FN7 = 2691,
	PORT140_FN7 = 2692,
	PORT141_FN7 = 2693,
	PORT142_FN7 = 2694,
	PORT143_FN7 = 2695,
	PORT144_FN7 = 2696,
	PORT145_FN7 = 2697,
	PORT146_FN7 = 2698,
	PORT147_FN7 = 2699,
	PORT148_FN7 = 2700,
	PORT149_FN7 = 2701,
	PORT150_FN7 = 2702,
	PORT151_FN7 = 2703,
	PORT152_FN7 = 2704,
	PORT153_FN7 = 2705,
	PORT154_FN7 = 2706,
	PORT155_FN7 = 2707,
	PORT156_FN7 = 2708,
	PORT157_FN7 = 2709,
	PORT158_FN7 = 2710,
	PORT159_FN7 = 2711,
	PORT160_FN7___2 = 2712,
	PORT161_FN7___2 = 2713,
	PORT162_FN7___2 = 2714,
	PORT163_FN7___2 = 2715,
	PORT164_FN7___2 = 2716,
	PORT165_FN7___2 = 2717,
	PORT166_FN7___2 = 2718,
	PORT167_FN7___2 = 2719,
	PORT168_FN7___2 = 2720,
	PORT169_FN7___2 = 2721,
	PORT170_FN7___2 = 2722,
	PORT171_FN7___2 = 2723,
	PORT172_FN7___2 = 2724,
	PORT173_FN7___2 = 2725,
	PORT174_FN7___2 = 2726,
	PORT175_FN7___2 = 2727,
	PORT176_FN7___2 = 2728,
	PORT177_FN7___2 = 2729,
	PORT178_FN7___2 = 2730,
	PORT179_FN7 = 2731,
	PORT180_FN7 = 2732,
	PORT181_FN7 = 2733,
	PORT182_FN7 = 2734,
	PORT183_FN7 = 2735,
	PORT184_FN7 = 2736,
	PORT185_FN7 = 2737,
	PORT186_FN7 = 2738,
	PORT187_FN7 = 2739,
	PORT188_FN7 = 2740,
	PORT189_FN7 = 2741,
	PORT190_FN7 = 2742,
	PORT191_FN7 = 2743,
	PORT192_FN7___2 = 2744,
	PORT193_FN7___2 = 2745,
	PORT194_FN7___2 = 2746,
	PORT195_FN7___2 = 2747,
	PORT196_FN7___2 = 2748,
	PORT197_FN7___2 = 2749,
	PORT198_FN7___2 = 2750,
	PORT199_FN7___2 = 2751,
	PORT200_FN7___2 = 2752,
	PORT201_FN7___2 = 2753,
	PORT202_FN7___2 = 2754,
	PORT203_FN7___2 = 2755,
	PORT204_FN7___2 = 2756,
	PORT205_FN7___2 = 2757,
	PORT206_FN7___2 = 2758,
	PORT207_FN7___2 = 2759,
	PORT208_FN7___2 = 2760,
	PORT209_FN7___2 = 2761,
	PORT210_FN7___2 = 2762,
	PORT211_FN7___2 = 2763,
	MSEL1CR_31_0___2 = 2764,
	MSEL1CR_31_1___2 = 2765,
	MSEL1CR_30_0 = 2766,
	MSEL1CR_30_1 = 2767,
	MSEL1CR_29_0 = 2768,
	MSEL1CR_29_1 = 2769,
	MSEL1CR_28_0 = 2770,
	MSEL1CR_28_1 = 2771,
	MSEL1CR_27_0___2 = 2772,
	MSEL1CR_27_1___2 = 2773,
	MSEL1CR_26_0 = 2774,
	MSEL1CR_26_1 = 2775,
	MSEL1CR_16_0___2 = 2776,
	MSEL1CR_16_1___2 = 2777,
	MSEL1CR_15_0___2 = 2778,
	MSEL1CR_15_1___2 = 2779,
	MSEL1CR_14_0___2 = 2780,
	MSEL1CR_14_1___2 = 2781,
	MSEL1CR_13_0___2 = 2782,
	MSEL1CR_13_1___2 = 2783,
	MSEL1CR_12_0___2 = 2784,
	MSEL1CR_12_1___2 = 2785,
	MSEL1CR_9_0 = 2786,
	MSEL1CR_9_1 = 2787,
	MSEL1CR_7_0 = 2788,
	MSEL1CR_7_1 = 2789,
	MSEL1CR_6_0 = 2790,
	MSEL1CR_6_1 = 2791,
	MSEL1CR_5_0 = 2792,
	MSEL1CR_5_1 = 2793,
	MSEL1CR_4_0 = 2794,
	MSEL1CR_4_1 = 2795,
	MSEL1CR_3_0 = 2796,
	MSEL1CR_3_1 = 2797,
	MSEL1CR_2_0 = 2798,
	MSEL1CR_2_1 = 2799,
	MSEL1CR_0_0 = 2800,
	MSEL1CR_0_1 = 2801,
	MSEL3CR_15_0___2 = 2802,
	MSEL3CR_15_1___2 = 2803,
	MSEL3CR_6_0 = 2804,
	MSEL3CR_6_1 = 2805,
	MSEL4CR_19_0___2 = 2806,
	MSEL4CR_19_1___2 = 2807,
	MSEL4CR_18_0___2 = 2808,
	MSEL4CR_18_1___2 = 2809,
	MSEL4CR_15_0___2 = 2810,
	MSEL4CR_15_1___2 = 2811,
	MSEL4CR_10_0___2 = 2812,
	MSEL4CR_10_1___2 = 2813,
	MSEL4CR_6_0 = 2814,
	MSEL4CR_6_1 = 2815,
	MSEL4CR_4_0 = 2816,
	MSEL4CR_4_1 = 2817,
	MSEL4CR_1_0 = 2818,
	MSEL4CR_1_1 = 2819,
	MSEL5CR_31_0___2 = 2820,
	MSEL5CR_31_1___2 = 2821,
	MSEL5CR_30_0___2 = 2822,
	MSEL5CR_30_1___2 = 2823,
	MSEL5CR_29_0___2 = 2824,
	MSEL5CR_29_1___2 = 2825,
	MSEL5CR_27_0___2 = 2826,
	MSEL5CR_27_1___2 = 2827,
	MSEL5CR_25_0___2 = 2828,
	MSEL5CR_25_1___2 = 2829,
	MSEL5CR_23_0___2 = 2830,
	MSEL5CR_23_1___2 = 2831,
	MSEL5CR_21_0___2 = 2832,
	MSEL5CR_21_1___2 = 2833,
	MSEL5CR_19_0___2 = 2834,
	MSEL5CR_19_1___2 = 2835,
	MSEL5CR_17_0___2 = 2836,
	MSEL5CR_17_1___2 = 2837,
	MSEL5CR_15_0___2 = 2838,
	MSEL5CR_15_1___2 = 2839,
	MSEL5CR_14_0___2 = 2840,
	MSEL5CR_14_1___2 = 2841,
	MSEL5CR_13_0___2 = 2842,
	MSEL5CR_13_1___2 = 2843,
	MSEL5CR_12_0___2 = 2844,
	MSEL5CR_12_1___2 = 2845,
	MSEL5CR_11_0___2 = 2846,
	MSEL5CR_11_1___2 = 2847,
	MSEL5CR_10_0___2 = 2848,
	MSEL5CR_10_1___2 = 2849,
	MSEL5CR_8_0 = 2850,
	MSEL5CR_8_1 = 2851,
	MSEL5CR_7_0 = 2852,
	MSEL5CR_7_1 = 2853,
	MSEL5CR_6_0 = 2854,
	MSEL5CR_6_1 = 2855,
	MSEL5CR_5_0 = 2856,
	MSEL5CR_5_1 = 2857,
	MSEL5CR_4_0 = 2858,
	MSEL5CR_4_1 = 2859,
	MSEL5CR_3_0 = 2860,
	MSEL5CR_3_1 = 2861,
	MSEL5CR_2_0 = 2862,
	MSEL5CR_2_1 = 2863,
	MSEL5CR_0_0 = 2864,
	MSEL5CR_0_1 = 2865,
	PINMUX_FUNCTION_END___3 = 2866,
	PINMUX_MARK_BEGIN___3 = 2867,
	IRQ0_PORT2_MARK = 2868,
	IRQ0_PORT13_MARK = 2869,
	IRQ1_MARK___2 = 2870,
	IRQ2_PORT11_MARK = 2871,
	IRQ2_PORT12_MARK = 2872,
	IRQ3_PORT10_MARK = 2873,
	IRQ3_PORT14_MARK = 2874,
	IRQ4_PORT15_MARK = 2875,
	IRQ4_PORT172_MARK = 2876,
	IRQ5_PORT0_MARK = 2877,
	IRQ5_PORT1_MARK = 2878,
	IRQ6_PORT121_MARK = 2879,
	IRQ6_PORT173_MARK = 2880,
	IRQ7_PORT120_MARK = 2881,
	IRQ7_PORT209_MARK = 2882,
	IRQ8_MARK___2 = 2883,
	IRQ9_PORT118_MARK = 2884,
	IRQ9_PORT210_MARK = 2885,
	IRQ10_MARK___2 = 2886,
	IRQ11_MARK___2 = 2887,
	IRQ12_PORT42_MARK = 2888,
	IRQ12_PORT97_MARK = 2889,
	IRQ13_PORT64_MARK = 2890,
	IRQ13_PORT98_MARK = 2891,
	IRQ14_PORT63_MARK = 2892,
	IRQ14_PORT99_MARK = 2893,
	IRQ15_PORT62_MARK = 2894,
	IRQ15_PORT100_MARK = 2895,
	IRQ16_PORT68_MARK = 2896,
	IRQ16_PORT211_MARK = 2897,
	IRQ17_MARK___2 = 2898,
	IRQ18_MARK___2 = 2899,
	IRQ19_MARK___2 = 2900,
	IRQ20_MARK___2 = 2901,
	IRQ21_MARK___2 = 2902,
	IRQ22_MARK___2 = 2903,
	IRQ23_MARK___2 = 2904,
	IRQ24_MARK___2 = 2905,
	IRQ25_MARK___2 = 2906,
	IRQ26_PORT58_MARK = 2907,
	IRQ26_PORT81_MARK = 2908,
	IRQ27_PORT57_MARK = 2909,
	IRQ27_PORT168_MARK = 2910,
	IRQ28_PORT56_MARK = 2911,
	IRQ28_PORT169_MARK = 2912,
	IRQ29_PORT50_MARK = 2913,
	IRQ29_PORT170_MARK = 2914,
	IRQ30_PORT49_MARK = 2915,
	IRQ30_PORT171_MARK = 2916,
	IRQ31_PORT41_MARK = 2917,
	IRQ31_PORT167_MARK = 2918,
	DBGMDT2_MARK = 2919,
	DBGMDT1_MARK = 2920,
	DBGMDT0_MARK = 2921,
	DBGMD10_MARK = 2922,
	DBGMD11_MARK = 2923,
	DBGMD20_MARK = 2924,
	DBGMD21_MARK = 2925,
	FSIAISLD_PORT0_MARK = 2926,
	FSIAISLD_PORT5_MARK = 2927,
	FSIASPDIF_PORT9_MARK = 2928,
	FSIASPDIF_PORT18_MARK = 2929,
	FSIAOSLD1_MARK = 2930,
	FSIAOSLD2_MARK = 2931,
	FSIAOLR_MARK___2 = 2932,
	FSIAOBT_MARK___2 = 2933,
	FSIAOSLD_MARK___2 = 2934,
	FSIAOMC_MARK___2 = 2935,
	FSIACK_MARK___2 = 2936,
	FSIAILR_MARK___2 = 2937,
	FSIAIBT_MARK___2 = 2938,
	FSIBCK_MARK___2 = 2939,
	FMSISLD_PORT1_MARK = 2940,
	FMSISLD_PORT6_MARK = 2941,
	FMSIILR_MARK = 2942,
	FMSIIBT_MARK = 2943,
	FMSIOLR_MARK = 2944,
	FMSIOBT_MARK = 2945,
	FMSICK_MARK = 2946,
	FMSOILR_MARK = 2947,
	FMSOIBT_MARK = 2948,
	FMSOOLR_MARK = 2949,
	FMSOOBT_MARK = 2950,
	FMSOSLD_MARK = 2951,
	FMSOCK_MARK = 2952,
	SCIFA0_SCK_MARK___2 = 2953,
	SCIFA0_CTS_MARK___2 = 2954,
	SCIFA0_RTS_MARK___2 = 2955,
	SCIFA0_RXD_MARK___2 = 2956,
	SCIFA0_TXD_MARK___2 = 2957,
	SCIFA1_CTS_MARK___2 = 2958,
	SCIFA1_SCK_MARK___2 = 2959,
	SCIFA1_RXD_MARK___2 = 2960,
	SCIFA1_TXD_MARK___2 = 2961,
	SCIFA1_RTS_MARK___2 = 2962,
	SCIFA2_SCK_PORT22_MARK = 2963,
	SCIFA2_SCK_PORT199_MARK = 2964,
	SCIFA2_RXD_MARK = 2965,
	SCIFA2_TXD_MARK = 2966,
	SCIFA2_CTS_MARK = 2967,
	SCIFA2_RTS_MARK = 2968,
	SCIFA3_RTS_PORT105_MARK = 2969,
	SCIFA3_SCK_PORT116_MARK = 2970,
	SCIFA3_CTS_PORT117_MARK = 2971,
	SCIFA3_RXD_PORT174_MARK = 2972,
	SCIFA3_TXD_PORT175_MARK = 2973,
	SCIFA3_RTS_PORT161_MARK = 2974,
	SCIFA3_SCK_PORT158_MARK = 2975,
	SCIFA3_CTS_PORT162_MARK = 2976,
	SCIFA3_RXD_PORT159_MARK = 2977,
	SCIFA3_TXD_PORT160_MARK = 2978,
	SCIFA4_RXD_PORT12_MARK = 2979,
	SCIFA4_TXD_PORT13_MARK = 2980,
	SCIFA4_RXD_PORT204_MARK = 2981,
	SCIFA4_TXD_PORT203_MARK = 2982,
	SCIFA4_RXD_PORT94_MARK = 2983,
	SCIFA4_TXD_PORT93_MARK = 2984,
	SCIFA4_SCK_PORT21_MARK = 2985,
	SCIFA4_SCK_PORT205_MARK = 2986,
	SCIFA5_TXD_PORT20_MARK = 2987,
	SCIFA5_RXD_PORT10_MARK = 2988,
	SCIFA5_RXD_PORT207_MARK = 2989,
	SCIFA5_TXD_PORT208_MARK = 2990,
	SCIFA5_TXD_PORT91_MARK = 2991,
	SCIFA5_RXD_PORT92_MARK = 2992,
	SCIFA5_SCK_PORT23_MARK = 2993,
	SCIFA5_SCK_PORT206_MARK = 2994,
	SCIFA6_SCK_MARK = 2995,
	SCIFA6_RXD_MARK = 2996,
	SCIFA6_TXD_MARK = 2997,
	SCIFA7_TXD_MARK = 2998,
	SCIFA7_RXD_MARK = 2999,
	SCIFB_SCK_PORT190_MARK = 3000,
	SCIFB_RXD_PORT191_MARK = 3001,
	SCIFB_TXD_PORT192_MARK = 3002,
	SCIFB_RTS_PORT186_MARK = 3003,
	SCIFB_CTS_PORT187_MARK = 3004,
	SCIFB_SCK_PORT2_MARK = 3005,
	SCIFB_RXD_PORT3_MARK = 3006,
	SCIFB_TXD_PORT4_MARK = 3007,
	SCIFB_RTS_PORT172_MARK = 3008,
	SCIFB_CTS_PORT173_MARK = 3009,
	LCD0_D0_MARK = 3010,
	LCD0_D1_MARK = 3011,
	LCD0_D2_MARK = 3012,
	LCD0_D3_MARK = 3013,
	LCD0_D4_MARK = 3014,
	LCD0_D5_MARK = 3015,
	LCD0_D6_MARK = 3016,
	LCD0_D7_MARK = 3017,
	LCD0_D8_MARK = 3018,
	LCD0_D9_MARK = 3019,
	LCD0_D10_MARK = 3020,
	LCD0_D11_MARK = 3021,
	LCD0_D12_MARK = 3022,
	LCD0_D13_MARK = 3023,
	LCD0_D14_MARK = 3024,
	LCD0_D15_MARK = 3025,
	LCD0_D16_MARK = 3026,
	LCD0_D17_MARK = 3027,
	LCD0_DON_MARK = 3028,
	LCD0_VCPWC_MARK = 3029,
	LCD0_VEPWC_MARK = 3030,
	LCD0_DCK_MARK = 3031,
	LCD0_VSYN_MARK = 3032,
	LCD0_HSYN_MARK = 3033,
	LCD0_DISP_MARK = 3034,
	LCD0_WR_MARK = 3035,
	LCD0_RD_MARK = 3036,
	LCD0_CS_MARK = 3037,
	LCD0_RS_MARK = 3038,
	LCD0_D21_PORT158_MARK = 3039,
	LCD0_D23_PORT159_MARK = 3040,
	LCD0_D22_PORT160_MARK = 3041,
	LCD0_D20_PORT161_MARK = 3042,
	LCD0_D19_PORT162_MARK = 3043,
	LCD0_D18_PORT163_MARK = 3044,
	LCD0_LCLK_PORT165_MARK = 3045,
	LCD0_D18_PORT40_MARK = 3046,
	LCD0_D22_PORT0_MARK = 3047,
	LCD0_D23_PORT1_MARK = 3048,
	LCD0_D21_PORT2_MARK = 3049,
	LCD0_D20_PORT3_MARK = 3050,
	LCD0_D19_PORT4_MARK = 3051,
	LCD0_LCLK_PORT102_MARK = 3052,
	LCD1_D0_MARK = 3053,
	LCD1_D1_MARK = 3054,
	LCD1_D2_MARK = 3055,
	LCD1_D3_MARK = 3056,
	LCD1_D4_MARK = 3057,
	LCD1_D5_MARK = 3058,
	LCD1_D6_MARK = 3059,
	LCD1_D7_MARK = 3060,
	LCD1_D8_MARK = 3061,
	LCD1_D9_MARK = 3062,
	LCD1_D10_MARK = 3063,
	LCD1_D11_MARK = 3064,
	LCD1_D12_MARK = 3065,
	LCD1_D13_MARK = 3066,
	LCD1_D14_MARK = 3067,
	LCD1_D15_MARK = 3068,
	LCD1_D16_MARK = 3069,
	LCD1_D17_MARK = 3070,
	LCD1_D18_MARK = 3071,
	LCD1_D19_MARK = 3072,
	LCD1_D20_MARK = 3073,
	LCD1_D21_MARK = 3074,
	LCD1_D22_MARK = 3075,
	LCD1_D23_MARK = 3076,
	LCD1_DON_MARK = 3077,
	LCD1_VCPWC_MARK = 3078,
	LCD1_LCLK_MARK = 3079,
	LCD1_VEPWC_MARK = 3080,
	LCD1_DCK_MARK = 3081,
	LCD1_VSYN_MARK = 3082,
	LCD1_HSYN_MARK = 3083,
	LCD1_DISP_MARK = 3084,
	LCD1_RS_MARK = 3085,
	LCD1_CS_MARK = 3086,
	LCD1_RD_MARK = 3087,
	LCD1_WR_MARK = 3088,
	RSPI_SSL0_A_MARK = 3089,
	RSPI_SSL1_A_MARK = 3090,
	RSPI_SSL2_A_MARK = 3091,
	RSPI_SSL3_A_MARK = 3092,
	RSPI_CK_A_MARK = 3093,
	RSPI_MOSI_A_MARK = 3094,
	RSPI_MISO_A_MARK = 3095,
	VIO_CKO1_MARK = 3096,
	VIO_CKO2_MARK = 3097,
	VIO_CKO_1_MARK = 3098,
	VIO_CKO_MARK = 3099,
	VIO0_D0_MARK = 3100,
	VIO0_D1_MARK = 3101,
	VIO0_D2_MARK = 3102,
	VIO0_D3_MARK = 3103,
	VIO0_D4_MARK = 3104,
	VIO0_D5_MARK = 3105,
	VIO0_D6_MARK = 3106,
	VIO0_D7_MARK = 3107,
	VIO0_D8_MARK = 3108,
	VIO0_D9_MARK = 3109,
	VIO0_D10_MARK = 3110,
	VIO0_D11_MARK = 3111,
	VIO0_D12_MARK = 3112,
	VIO0_VD_MARK = 3113,
	VIO0_HD_MARK = 3114,
	VIO0_CLK_MARK = 3115,
	VIO0_FIELD_MARK = 3116,
	VIO0_D13_PORT26_MARK = 3117,
	VIO0_D14_PORT25_MARK = 3118,
	VIO0_D15_PORT24_MARK = 3119,
	VIO0_D13_PORT22_MARK = 3120,
	VIO0_D14_PORT95_MARK = 3121,
	VIO0_D15_PORT96_MARK = 3122,
	VIO1_D0_MARK = 3123,
	VIO1_D1_MARK = 3124,
	VIO1_D2_MARK = 3125,
	VIO1_D3_MARK = 3126,
	VIO1_D4_MARK = 3127,
	VIO1_D5_MARK = 3128,
	VIO1_D6_MARK = 3129,
	VIO1_D7_MARK = 3130,
	VIO1_VD_MARK = 3131,
	VIO1_HD_MARK = 3132,
	VIO1_CLK_MARK = 3133,
	VIO1_FIELD_MARK = 3134,
	TPU0TO0_MARK___2 = 3135,
	TPU0TO1_MARK___2 = 3136,
	TPU0TO3_MARK___2 = 3137,
	TPU0TO2_PORT66_MARK = 3138,
	TPU0TO2_PORT202_MARK = 3139,
	STP0_IPD0_MARK = 3140,
	STP0_IPD1_MARK = 3141,
	STP0_IPD2_MARK = 3142,
	STP0_IPD3_MARK = 3143,
	STP0_IPD4_MARK = 3144,
	STP0_IPD5_MARK = 3145,
	STP0_IPD6_MARK = 3146,
	STP0_IPD7_MARK = 3147,
	STP0_IPEN_MARK = 3148,
	STP0_IPCLK_MARK = 3149,
	STP0_IPSYNC_MARK = 3150,
	STP1_IPD1_MARK = 3151,
	STP1_IPD2_MARK = 3152,
	STP1_IPD3_MARK = 3153,
	STP1_IPD4_MARK = 3154,
	STP1_IPD5_MARK = 3155,
	STP1_IPD6_MARK = 3156,
	STP1_IPD7_MARK = 3157,
	STP1_IPCLK_MARK = 3158,
	STP1_IPSYNC_MARK = 3159,
	STP1_IPD0_PORT186_MARK = 3160,
	STP1_IPEN_PORT187_MARK = 3161,
	STP1_IPD0_PORT194_MARK = 3162,
	STP1_IPEN_PORT193_MARK = 3163,
	SIM_RST_MARK = 3164,
	SIM_CLK_MARK = 3165,
	SIM_D_PORT22_MARK = 3166,
	SIM_D_PORT199_MARK = 3167,
	SDHI0_D0_MARK = 3168,
	SDHI0_D1_MARK = 3169,
	SDHI0_D2_MARK = 3170,
	SDHI0_D3_MARK = 3171,
	SDHI0_CD_MARK = 3172,
	SDHI0_WP_MARK = 3173,
	SDHI0_CMD_MARK = 3174,
	SDHI0_CLK_MARK = 3175,
	SDHI1_D0_MARK = 3176,
	SDHI1_D1_MARK = 3177,
	SDHI1_D2_MARK = 3178,
	SDHI1_D3_MARK = 3179,
	SDHI1_CD_MARK = 3180,
	SDHI1_WP_MARK = 3181,
	SDHI1_CMD_MARK = 3182,
	SDHI1_CLK_MARK = 3183,
	SDHI2_D0_MARK = 3184,
	SDHI2_D1_MARK = 3185,
	SDHI2_D2_MARK = 3186,
	SDHI2_D3_MARK = 3187,
	SDHI2_CLK_MARK = 3188,
	SDHI2_CMD_MARK = 3189,
	SDHI2_CD_PORT24_MARK = 3190,
	SDHI2_WP_PORT25_MARK = 3191,
	SDHI2_WP_PORT177_MARK = 3192,
	SDHI2_CD_PORT202_MARK = 3193,
	MSIOF2_TXD_MARK___2 = 3194,
	MSIOF2_RXD_MARK___2 = 3195,
	MSIOF2_TSCK_MARK = 3196,
	MSIOF2_SS2_MARK___2 = 3197,
	MSIOF2_TSYNC_MARK = 3198,
	MSIOF2_SS1_MARK___2 = 3199,
	MSIOF2_MCK1_MARK = 3200,
	MSIOF2_MCK0_MARK = 3201,
	MSIOF2_RSYNC_MARK = 3202,
	MSIOF2_RSCK_MARK = 3203,
	KEYIN4_MARK___2 = 3204,
	KEYIN5_MARK___2 = 3205,
	KEYIN6_MARK___2 = 3206,
	KEYIN7_MARK___2 = 3207,
	KEYOUT0_MARK___2 = 3208,
	KEYOUT1_MARK___2 = 3209,
	KEYOUT2_MARK___2 = 3210,
	KEYOUT3_MARK___2 = 3211,
	KEYOUT4_MARK___2 = 3212,
	KEYOUT5_MARK___2 = 3213,
	KEYOUT6_MARK___2 = 3214,
	KEYOUT7_MARK___2 = 3215,
	KEYIN0_PORT43_MARK = 3216,
	KEYIN1_PORT44_MARK = 3217,
	KEYIN2_PORT45_MARK = 3218,
	KEYIN3_PORT46_MARK = 3219,
	KEYIN0_PORT58_MARK = 3220,
	KEYIN1_PORT57_MARK = 3221,
	KEYIN2_PORT56_MARK = 3222,
	KEYIN3_PORT55_MARK = 3223,
	DV_D0_MARK = 3224,
	DV_D1_MARK = 3225,
	DV_D2_MARK = 3226,
	DV_D3_MARK = 3227,
	DV_D4_MARK = 3228,
	DV_D5_MARK = 3229,
	DV_D6_MARK = 3230,
	DV_D7_MARK = 3231,
	DV_D8_MARK = 3232,
	DV_D9_MARK = 3233,
	DV_D10_MARK = 3234,
	DV_D11_MARK = 3235,
	DV_D12_MARK = 3236,
	DV_D13_MARK = 3237,
	DV_D14_MARK = 3238,
	DV_D15_MARK = 3239,
	DV_CLK_MARK = 3240,
	DV_VSYNC_MARK = 3241,
	DV_HSYNC_MARK = 3242,
	MEMC_AD0_MARK = 3243,
	MEMC_AD1_MARK = 3244,
	MEMC_AD2_MARK = 3245,
	MEMC_AD3_MARK = 3246,
	MEMC_AD4_MARK = 3247,
	MEMC_AD5_MARK = 3248,
	MEMC_AD6_MARK = 3249,
	MEMC_AD7_MARK = 3250,
	MEMC_AD8_MARK = 3251,
	MEMC_AD9_MARK = 3252,
	MEMC_AD10_MARK = 3253,
	MEMC_AD11_MARK = 3254,
	MEMC_AD12_MARK = 3255,
	MEMC_AD13_MARK = 3256,
	MEMC_AD14_MARK = 3257,
	MEMC_AD15_MARK = 3258,
	MEMC_CS0_MARK = 3259,
	MEMC_INT_MARK = 3260,
	MEMC_NWE_MARK = 3261,
	MEMC_NOE_MARK = 3262,
	MEMC_CS1_MARK = 3263,
	MEMC_ADV_MARK = 3264,
	MEMC_WAIT_MARK = 3265,
	MEMC_BUSCLK_MARK = 3266,
	MEMC_A1_MARK = 3267,
	MEMC_DREQ0_MARK = 3268,
	MEMC_DREQ1_MARK = 3269,
	MEMC_A0_MARK = 3270,
	MMC0_D0_PORT68_MARK = 3271,
	MMC0_D1_PORT69_MARK = 3272,
	MMC0_D2_PORT70_MARK = 3273,
	MMC0_D3_PORT71_MARK = 3274,
	MMC0_D4_PORT72_MARK = 3275,
	MMC0_D5_PORT73_MARK = 3276,
	MMC0_D6_PORT74_MARK = 3277,
	MMC0_D7_PORT75_MARK = 3278,
	MMC0_CLK_PORT66_MARK = 3279,
	MMC0_CMD_PORT67_MARK = 3280,
	MMC1_D0_PORT149_MARK = 3281,
	MMC1_D1_PORT148_MARK = 3282,
	MMC1_D2_PORT147_MARK = 3283,
	MMC1_D3_PORT146_MARK = 3284,
	MMC1_D4_PORT145_MARK = 3285,
	MMC1_D5_PORT144_MARK = 3286,
	MMC1_D6_PORT143_MARK = 3287,
	MMC1_D7_PORT142_MARK = 3288,
	MMC1_CLK_PORT103_MARK = 3289,
	MMC1_CMD_PORT104_MARK = 3290,
	MSIOF0_SS1_MARK___2 = 3291,
	MSIOF0_SS2_MARK___2 = 3292,
	MSIOF0_RXD_MARK___2 = 3293,
	MSIOF0_TXD_MARK___2 = 3294,
	MSIOF0_MCK0_MARK = 3295,
	MSIOF0_MCK1_MARK = 3296,
	MSIOF0_RSYNC_MARK = 3297,
	MSIOF0_RSCK_MARK = 3298,
	MSIOF0_TSCK_MARK = 3299,
	MSIOF0_TSYNC_MARK = 3300,
	MSIOF1_RSCK_MARK = 3301,
	MSIOF1_RSYNC_MARK = 3302,
	MSIOF1_MCK0_MARK = 3303,
	MSIOF1_MCK1_MARK = 3304,
	MSIOF1_SS2_PORT116_MARK = 3305,
	MSIOF1_SS1_PORT117_MARK = 3306,
	MSIOF1_RXD_PORT118_MARK = 3307,
	MSIOF1_TXD_PORT119_MARK = 3308,
	MSIOF1_TSYNC_PORT120_MARK = 3309,
	MSIOF1_TSCK_PORT121_MARK = 3310,
	MSIOF1_SS1_PORT67_MARK = 3311,
	MSIOF1_TSCK_PORT72_MARK = 3312,
	MSIOF1_TSYNC_PORT73_MARK = 3313,
	MSIOF1_TXD_PORT74_MARK = 3314,
	MSIOF1_RXD_PORT75_MARK = 3315,
	MSIOF1_SS2_PORT202_MARK = 3316,
	GPO0_MARK = 3317,
	GPI0_MARK = 3318,
	GPO1_MARK = 3319,
	GPI1_MARK = 3320,
	USB0_OCI_MARK = 3321,
	USB0_PPON_MARK = 3322,
	VBUS_MARK = 3323,
	USB1_OCI_MARK = 3324,
	USB1_PPON_MARK = 3325,
	BBIF1_RXD_MARK = 3326,
	BBIF1_TXD_MARK = 3327,
	BBIF1_TSYNC_MARK = 3328,
	BBIF1_TSCK_MARK = 3329,
	BBIF1_RSCK_MARK = 3330,
	BBIF1_RSYNC_MARK = 3331,
	BBIF1_FLOW_MARK = 3332,
	BBIF1_RX_FLOW_N_MARK = 3333,
	BBIF2_TXD2_PORT5_MARK = 3334,
	BBIF2_RXD2_PORT60_MARK = 3335,
	BBIF2_TSYNC2_PORT6_MARK = 3336,
	BBIF2_TSCK2_PORT59_MARK = 3337,
	BBIF2_RXD2_PORT90_MARK = 3338,
	BBIF2_TXD2_PORT183_MARK = 3339,
	BBIF2_TSCK2_PORT89_MARK = 3340,
	BBIF2_TSYNC2_PORT184_MARK = 3341,
	CS0_MARK = 3342,
	CS2_MARK = 3343,
	CS4_MARK = 3344,
	CS5B_MARK = 3345,
	CS6A_MARK = 3346,
	CS5A_PORT105_MARK = 3347,
	CS5A_PORT19_MARK = 3348,
	IOIS16_MARK = 3349,
	A0_MARK___2 = 3350,
	A1_MARK___2 = 3351,
	A2_MARK___2 = 3352,
	A3_MARK___2 = 3353,
	A4_FOE_MARK = 3354,
	A5_FCDE_MARK = 3355,
	A6_MARK___2 = 3356,
	A7_MARK___2 = 3357,
	A8_MARK___2 = 3358,
	A9_MARK___2 = 3359,
	A10_MARK___2 = 3360,
	A11_MARK = 3361,
	A12_MARK = 3362,
	A13_MARK = 3363,
	A14_MARK = 3364,
	A15_MARK = 3365,
	A16_MARK = 3366,
	A17_MARK = 3367,
	A18_MARK = 3368,
	A19_MARK = 3369,
	A20_MARK = 3370,
	A21_MARK = 3371,
	A22_MARK = 3372,
	A23_MARK = 3373,
	A24_MARK = 3374,
	A25_MARK = 3375,
	A26_MARK = 3376,
	D0_NAF0_MARK = 3377,
	D1_NAF1_MARK = 3378,
	D2_NAF2_MARK = 3379,
	D3_NAF3_MARK = 3380,
	D4_NAF4_MARK = 3381,
	D5_NAF5_MARK = 3382,
	D6_NAF6_MARK = 3383,
	D7_NAF7_MARK = 3384,
	D8_NAF8_MARK = 3385,
	D9_NAF9_MARK = 3386,
	D10_NAF10_MARK = 3387,
	D11_NAF11_MARK = 3388,
	D12_NAF12_MARK = 3389,
	D13_NAF13_MARK = 3390,
	D14_NAF14_MARK = 3391,
	D15_NAF15_MARK = 3392,
	D16_MARK = 3393,
	D17_MARK = 3394,
	D18_MARK = 3395,
	D19_MARK = 3396,
	D20_MARK = 3397,
	D21_MARK = 3398,
	D22_MARK = 3399,
	D23_MARK = 3400,
	D24_MARK = 3401,
	D25_MARK = 3402,
	D26_MARK = 3403,
	D27_MARK = 3404,
	D28_MARK = 3405,
	D29_MARK = 3406,
	D30_MARK = 3407,
	D31_MARK = 3408,
	WE0_FWE_MARK = 3409,
	WE1_MARK = 3410,
	WE2_ICIORD_MARK = 3411,
	WE3_ICIOWR_MARK = 3412,
	CKO_MARK___2 = 3413,
	BS_MARK___2 = 3414,
	RDWR_MARK = 3415,
	RD_FSC_MARK = 3416,
	WAIT_PORT177_MARK = 3417,
	WAIT_PORT90_MARK = 3418,
	FCE0_MARK = 3419,
	FCE1_MARK = 3420,
	FRB_MARK = 3421,
	IRDA_FIRSEL_MARK___2 = 3422,
	IRDA_IN_MARK___2 = 3423,
	IRDA_OUT_MARK___2 = 3424,
	IDE_D0_MARK = 3425,
	IDE_D1_MARK = 3426,
	IDE_D2_MARK = 3427,
	IDE_D3_MARK = 3428,
	IDE_D4_MARK = 3429,
	IDE_D5_MARK = 3430,
	IDE_D6_MARK = 3431,
	IDE_D7_MARK = 3432,
	IDE_D8_MARK = 3433,
	IDE_D9_MARK = 3434,
	IDE_D10_MARK = 3435,
	IDE_D11_MARK = 3436,
	IDE_D12_MARK = 3437,
	IDE_D13_MARK = 3438,
	IDE_D14_MARK = 3439,
	IDE_D15_MARK = 3440,
	IDE_A0_MARK = 3441,
	IDE_A1_MARK = 3442,
	IDE_A2_MARK = 3443,
	IDE_CS0_MARK = 3444,
	IDE_CS1_MARK = 3445,
	IDE_IOWR_MARK = 3446,
	IDE_IORD_MARK = 3447,
	IDE_IORDY_MARK = 3448,
	IDE_INT_MARK = 3449,
	IDE_RST_MARK = 3450,
	IDE_DIRECTION_MARK = 3451,
	IDE_EXBUF_ENB_MARK = 3452,
	IDE_IODACK_MARK = 3453,
	IDE_IODREQ_MARK = 3454,
	RMII_CRS_DV_MARK = 3455,
	RMII_RX_ER_MARK = 3456,
	RMII_RXD0_MARK = 3457,
	RMII_RXD1_MARK = 3458,
	RMII_TX_EN_MARK = 3459,
	RMII_TXD0_MARK = 3460,
	RMII_MDC_MARK = 3461,
	RMII_TXD1_MARK = 3462,
	RMII_MDIO_MARK = 3463,
	RMII_REF50CK_MARK = 3464,
	RMII_REF125CK_MARK = 3465,
	ET_TX_CLK_MARK = 3466,
	ET_TX_EN_MARK = 3467,
	ET_ETXD0_MARK = 3468,
	ET_ETXD1_MARK = 3469,
	ET_ETXD2_MARK = 3470,
	ET_ETXD3_MARK = 3471,
	ET_ETXD4_MARK = 3472,
	ET_ETXD5_MARK = 3473,
	ET_ETXD6_MARK = 3474,
	ET_ETXD7_MARK = 3475,
	ET_COL_MARK = 3476,
	ET_TX_ER_MARK = 3477,
	ET_RX_CLK_MARK = 3478,
	ET_RX_DV_MARK = 3479,
	ET_ERXD0_MARK = 3480,
	ET_ERXD1_MARK = 3481,
	ET_ERXD2_MARK = 3482,
	ET_ERXD3_MARK = 3483,
	ET_ERXD4_MARK = 3484,
	ET_ERXD5_MARK = 3485,
	ET_ERXD6_MARK = 3486,
	ET_ERXD7_MARK = 3487,
	ET_RX_ER_MARK = 3488,
	ET_CRS_MARK = 3489,
	ET_MDC_MARK = 3490,
	ET_MDIO_MARK = 3491,
	ET_LINK_MARK = 3492,
	ET_PHY_INT_MARK = 3493,
	ET_WOL_MARK = 3494,
	ET_GTX_CLK_MARK = 3495,
	DREQ0_MARK = 3496,
	DACK0_MARK = 3497,
	DREQ1_MARK = 3498,
	DACK1_MARK = 3499,
	RESETOUTS_MARK = 3500,
	RESETP_PULLUP_MARK = 3501,
	RESETP_PLAIN_MARK = 3502,
	IROUT_MARK = 3503,
	SDENC_CPG_MARK = 3504,
	SDENC_DV_CLKI_MARK = 3505,
	HDMI_HPD_MARK = 3506,
	HDMI_CEC_MARK = 3507,
	EDEBGREQ_PULLUP_MARK = 3508,
	EDEBGREQ_PULLDOWN_MARK = 3509,
	TRACEAUD_FROM_VIO_MARK = 3510,
	TRACEAUD_FROM_LCDC0_MARK = 3511,
	TRACEAUD_FROM_MEMC_MARK = 3512,
	PINMUX_MARK_END___3 = 3513,
};

struct r8a7740_portcr_group {
	unsigned int end_pin;
	unsigned int offset;
};

union vin_data {
	unsigned int data24[24];
	unsigned int data20[20];
	unsigned int data16[16];
	unsigned int data12[12];
	unsigned int data10[10];
	unsigned int data8[8];
	unsigned int data4[4];
};

enum {
	PINMUX_RESERVED___4 = 0,
	PINMUX_DATA_BEGIN___4 = 1,
	GP_0_0_DATA = 2,
	GP_0_1_DATA = 3,
	GP_0_2_DATA = 4,
	GP_0_3_DATA = 5,
	GP_0_4_DATA = 6,
	GP_0_5_DATA = 7,
	GP_0_6_DATA = 8,
	GP_0_7_DATA = 9,
	GP_0_8_DATA = 10,
	GP_0_9_DATA = 11,
	GP_0_10_DATA = 12,
	GP_0_11_DATA = 13,
	GP_0_12_DATA = 14,
	GP_0_13_DATA = 15,
	GP_0_14_DATA = 16,
	GP_0_15_DATA = 17,
	GP_0_16_DATA = 18,
	GP_0_17_DATA = 19,
	GP_0_18_DATA = 20,
	GP_0_19_DATA = 21,
	GP_0_20_DATA = 22,
	GP_0_21_DATA = 23,
	GP_0_22_DATA = 24,
	GP_0_23_DATA = 25,
	GP_0_24_DATA = 26,
	GP_0_25_DATA = 27,
	GP_0_26_DATA = 28,
	GP_0_27_DATA = 29,
	GP_0_28_DATA = 30,
	GP_0_29_DATA = 31,
	GP_0_30_DATA = 32,
	GP_0_31_DATA = 33,
	GP_1_0_DATA = 34,
	GP_1_1_DATA = 35,
	GP_1_2_DATA = 36,
	GP_1_3_DATA = 37,
	GP_1_4_DATA = 38,
	GP_1_5_DATA = 39,
	GP_1_6_DATA = 40,
	GP_1_7_DATA = 41,
	GP_1_8_DATA = 42,
	GP_1_9_DATA = 43,
	GP_1_10_DATA = 44,
	GP_1_11_DATA = 45,
	GP_1_12_DATA = 46,
	GP_1_13_DATA = 47,
	GP_1_14_DATA = 48,
	GP_1_15_DATA = 49,
	GP_1_16_DATA = 50,
	GP_1_17_DATA = 51,
	GP_1_18_DATA = 52,
	GP_1_19_DATA = 53,
	GP_1_20_DATA = 54,
	GP_1_21_DATA = 55,
	GP_1_22_DATA = 56,
	GP_1_23_DATA = 57,
	GP_1_24_DATA = 58,
	GP_1_25_DATA = 59,
	GP_1_26_DATA = 60,
	GP_1_27_DATA = 61,
	GP_1_28_DATA = 62,
	GP_1_29_DATA = 63,
	GP_2_0_DATA = 64,
	GP_2_1_DATA = 65,
	GP_2_2_DATA = 66,
	GP_2_3_DATA = 67,
	GP_2_4_DATA = 68,
	GP_2_5_DATA = 69,
	GP_2_6_DATA = 70,
	GP_2_7_DATA = 71,
	GP_2_8_DATA = 72,
	GP_2_9_DATA = 73,
	GP_2_10_DATA = 74,
	GP_2_11_DATA = 75,
	GP_2_12_DATA = 76,
	GP_2_13_DATA = 77,
	GP_2_14_DATA = 78,
	GP_2_15_DATA = 79,
	GP_2_16_DATA = 80,
	GP_2_17_DATA = 81,
	GP_2_18_DATA = 82,
	GP_2_19_DATA = 83,
	GP_2_20_DATA = 84,
	GP_2_21_DATA = 85,
	GP_2_22_DATA = 86,
	GP_2_23_DATA = 87,
	GP_2_24_DATA = 88,
	GP_2_25_DATA = 89,
	GP_2_26_DATA = 90,
	GP_2_27_DATA = 91,
	GP_2_28_DATA = 92,
	GP_2_29_DATA = 93,
	GP_3_0_DATA = 94,
	GP_3_1_DATA = 95,
	GP_3_2_DATA = 96,
	GP_3_3_DATA = 97,
	GP_3_4_DATA = 98,
	GP_3_5_DATA = 99,
	GP_3_6_DATA = 100,
	GP_3_7_DATA = 101,
	GP_3_8_DATA = 102,
	GP_3_9_DATA = 103,
	GP_3_10_DATA = 104,
	GP_3_11_DATA = 105,
	GP_3_12_DATA = 106,
	GP_3_13_DATA = 107,
	GP_3_14_DATA = 108,
	GP_3_15_DATA = 109,
	GP_3_16_DATA = 110,
	GP_3_17_DATA = 111,
	GP_3_18_DATA = 112,
	GP_3_19_DATA = 113,
	GP_3_20_DATA = 114,
	GP_3_21_DATA = 115,
	GP_3_22_DATA = 116,
	GP_3_23_DATA = 117,
	GP_3_24_DATA = 118,
	GP_3_25_DATA = 119,
	GP_3_26_DATA = 120,
	GP_3_27_DATA = 121,
	GP_3_28_DATA = 122,
	GP_3_29_DATA = 123,
	GP_3_30_DATA = 124,
	GP_3_31_DATA = 125,
	GP_4_0_DATA = 126,
	GP_4_1_DATA = 127,
	GP_4_2_DATA = 128,
	GP_4_3_DATA = 129,
	GP_4_4_DATA = 130,
	GP_4_5_DATA = 131,
	GP_4_6_DATA = 132,
	GP_4_7_DATA = 133,
	GP_4_8_DATA = 134,
	GP_4_9_DATA = 135,
	GP_4_10_DATA = 136,
	GP_4_11_DATA = 137,
	GP_4_12_DATA = 138,
	GP_4_13_DATA = 139,
	GP_4_14_DATA = 140,
	GP_4_15_DATA = 141,
	GP_4_16_DATA = 142,
	GP_4_17_DATA = 143,
	GP_4_18_DATA = 144,
	GP_4_19_DATA = 145,
	GP_4_20_DATA = 146,
	GP_4_21_DATA = 147,
	GP_4_22_DATA = 148,
	GP_4_23_DATA = 149,
	GP_4_24_DATA = 150,
	GP_4_25_DATA = 151,
	GP_4_26_DATA = 152,
	GP_4_27_DATA = 153,
	GP_4_28_DATA = 154,
	GP_4_29_DATA = 155,
	GP_4_30_DATA = 156,
	GP_4_31_DATA = 157,
	GP_5_0_DATA = 158,
	GP_5_1_DATA = 159,
	GP_5_2_DATA = 160,
	GP_5_3_DATA = 161,
	GP_5_4_DATA = 162,
	GP_5_5_DATA = 163,
	GP_5_6_DATA = 164,
	GP_5_7_DATA = 165,
	GP_5_8_DATA = 166,
	GP_5_9_DATA = 167,
	GP_5_10_DATA = 168,
	GP_5_11_DATA = 169,
	GP_5_12_DATA = 170,
	GP_5_13_DATA = 171,
	GP_5_14_DATA = 172,
	GP_5_15_DATA = 173,
	GP_5_16_DATA = 174,
	GP_5_17_DATA = 175,
	GP_5_18_DATA = 176,
	GP_5_19_DATA = 177,
	GP_5_20_DATA = 178,
	GP_5_21_DATA = 179,
	GP_5_22_DATA = 180,
	GP_5_23_DATA = 181,
	GP_5_24_DATA = 182,
	GP_5_25_DATA = 183,
	GP_5_26_DATA = 184,
	GP_5_27_DATA = 185,
	GP_5_28_DATA = 186,
	GP_5_29_DATA = 187,
	GP_5_30_DATA = 188,
	GP_5_31_DATA = 189,
	PINMUX_DATA_END___4 = 190,
	PINMUX_FUNCTION_BEGIN___4 = 191,
	GP_0_0_FN = 192,
	GP_0_1_FN = 193,
	GP_0_2_FN = 194,
	GP_0_3_FN = 195,
	GP_0_4_FN = 196,
	GP_0_5_FN = 197,
	GP_0_6_FN = 198,
	GP_0_7_FN = 199,
	GP_0_8_FN = 200,
	GP_0_9_FN = 201,
	GP_0_10_FN = 202,
	GP_0_11_FN = 203,
	GP_0_12_FN = 204,
	GP_0_13_FN = 205,
	GP_0_14_FN = 206,
	GP_0_15_FN = 207,
	GP_0_16_FN = 208,
	GP_0_17_FN = 209,
	GP_0_18_FN = 210,
	GP_0_19_FN = 211,
	GP_0_20_FN = 212,
	GP_0_21_FN = 213,
	GP_0_22_FN = 214,
	GP_0_23_FN = 215,
	GP_0_24_FN = 216,
	GP_0_25_FN = 217,
	GP_0_26_FN = 218,
	GP_0_27_FN = 219,
	GP_0_28_FN = 220,
	GP_0_29_FN = 221,
	GP_0_30_FN = 222,
	GP_0_31_FN = 223,
	GP_1_0_FN = 224,
	GP_1_1_FN = 225,
	GP_1_2_FN = 226,
	GP_1_3_FN = 227,
	GP_1_4_FN = 228,
	GP_1_5_FN = 229,
	GP_1_6_FN = 230,
	GP_1_7_FN = 231,
	GP_1_8_FN = 232,
	GP_1_9_FN = 233,
	GP_1_10_FN = 234,
	GP_1_11_FN = 235,
	GP_1_12_FN = 236,
	GP_1_13_FN = 237,
	GP_1_14_FN = 238,
	GP_1_15_FN = 239,
	GP_1_16_FN = 240,
	GP_1_17_FN = 241,
	GP_1_18_FN = 242,
	GP_1_19_FN = 243,
	GP_1_20_FN = 244,
	GP_1_21_FN = 245,
	GP_1_22_FN = 246,
	GP_1_23_FN = 247,
	GP_1_24_FN = 248,
	GP_1_25_FN = 249,
	GP_1_26_FN = 250,
	GP_1_27_FN = 251,
	GP_1_28_FN = 252,
	GP_1_29_FN = 253,
	GP_2_0_FN = 254,
	GP_2_1_FN = 255,
	GP_2_2_FN = 256,
	GP_2_3_FN = 257,
	GP_2_4_FN = 258,
	GP_2_5_FN = 259,
	GP_2_6_FN = 260,
	GP_2_7_FN = 261,
	GP_2_8_FN = 262,
	GP_2_9_FN = 263,
	GP_2_10_FN = 264,
	GP_2_11_FN = 265,
	GP_2_12_FN = 266,
	GP_2_13_FN = 267,
	GP_2_14_FN = 268,
	GP_2_15_FN = 269,
	GP_2_16_FN = 270,
	GP_2_17_FN = 271,
	GP_2_18_FN = 272,
	GP_2_19_FN = 273,
	GP_2_20_FN = 274,
	GP_2_21_FN = 275,
	GP_2_22_FN = 276,
	GP_2_23_FN = 277,
	GP_2_24_FN = 278,
	GP_2_25_FN = 279,
	GP_2_26_FN = 280,
	GP_2_27_FN = 281,
	GP_2_28_FN = 282,
	GP_2_29_FN = 283,
	GP_3_0_FN = 284,
	GP_3_1_FN = 285,
	GP_3_2_FN = 286,
	GP_3_3_FN = 287,
	GP_3_4_FN = 288,
	GP_3_5_FN = 289,
	GP_3_6_FN = 290,
	GP_3_7_FN = 291,
	GP_3_8_FN = 292,
	GP_3_9_FN = 293,
	GP_3_10_FN = 294,
	GP_3_11_FN = 295,
	GP_3_12_FN = 296,
	GP_3_13_FN = 297,
	GP_3_14_FN = 298,
	GP_3_15_FN = 299,
	GP_3_16_FN = 300,
	GP_3_17_FN = 301,
	GP_3_18_FN = 302,
	GP_3_19_FN = 303,
	GP_3_20_FN = 304,
	GP_3_21_FN = 305,
	GP_3_22_FN = 306,
	GP_3_23_FN = 307,
	GP_3_24_FN = 308,
	GP_3_25_FN = 309,
	GP_3_26_FN = 310,
	GP_3_27_FN = 311,
	GP_3_28_FN = 312,
	GP_3_29_FN = 313,
	GP_3_30_FN = 314,
	GP_3_31_FN = 315,
	GP_4_0_FN = 316,
	GP_4_1_FN = 317,
	GP_4_2_FN = 318,
	GP_4_3_FN = 319,
	GP_4_4_FN = 320,
	GP_4_5_FN = 321,
	GP_4_6_FN = 322,
	GP_4_7_FN = 323,
	GP_4_8_FN = 324,
	GP_4_9_FN = 325,
	GP_4_10_FN = 326,
	GP_4_11_FN = 327,
	GP_4_12_FN = 328,
	GP_4_13_FN = 329,
	GP_4_14_FN = 330,
	GP_4_15_FN = 331,
	GP_4_16_FN = 332,
	GP_4_17_FN = 333,
	GP_4_18_FN = 334,
	GP_4_19_FN = 335,
	GP_4_20_FN = 336,
	GP_4_21_FN = 337,
	GP_4_22_FN = 338,
	GP_4_23_FN = 339,
	GP_4_24_FN = 340,
	GP_4_25_FN = 341,
	GP_4_26_FN = 342,
	GP_4_27_FN = 343,
	GP_4_28_FN = 344,
	GP_4_29_FN = 345,
	GP_4_30_FN = 346,
	GP_4_31_FN = 347,
	GP_5_0_FN = 348,
	GP_5_1_FN = 349,
	GP_5_2_FN = 350,
	GP_5_3_FN = 351,
	GP_5_4_FN = 352,
	GP_5_5_FN = 353,
	GP_5_6_FN = 354,
	GP_5_7_FN = 355,
	GP_5_8_FN = 356,
	GP_5_9_FN = 357,
	GP_5_10_FN = 358,
	GP_5_11_FN = 359,
	GP_5_12_FN = 360,
	GP_5_13_FN = 361,
	GP_5_14_FN = 362,
	GP_5_15_FN = 363,
	GP_5_16_FN = 364,
	GP_5_17_FN = 365,
	GP_5_18_FN = 366,
	GP_5_19_FN = 367,
	GP_5_20_FN = 368,
	GP_5_21_FN = 369,
	GP_5_22_FN = 370,
	GP_5_23_FN = 371,
	GP_5_24_FN = 372,
	GP_5_25_FN = 373,
	GP_5_26_FN = 374,
	GP_5_27_FN = 375,
	GP_5_28_FN = 376,
	GP_5_29_FN = 377,
	GP_5_30_FN = 378,
	GP_5_31_FN = 379,
	FN_IP0_2_0 = 380,
	FN_IP0_5_3 = 381,
	FN_IP0_8_6 = 382,
	FN_IP0_11_9 = 383,
	FN_IP0_15_12 = 384,
	FN_IP0_19_16 = 385,
	FN_IP0_22_20 = 386,
	FN_IP0_26_23 = 387,
	FN_IP0_30_27 = 388,
	FN_IP1_3_0 = 389,
	FN_IP1_7_4 = 390,
	FN_IP1_11_8 = 391,
	FN_IP1_14_12 = 392,
	FN_IP1_17_15 = 393,
	FN_IP1_21_18 = 394,
	FN_IP1_25_22 = 395,
	FN_IP1_27_26 = 396,
	FN_IP1_29_28 = 397,
	FN_IP2_2_0 = 398,
	FN_IP2_5_3 = 399,
	FN_IP2_8_6 = 400,
	FN_IP2_11_9 = 401,
	FN_IP2_14_12 = 402,
	FN_IP2_17_15 = 403,
	FN_IP2_21_18 = 404,
	FN_IP2_25_22 = 405,
	FN_IP2_28_26 = 406,
	FN_IP3_3_0 = 407,
	FN_IP3_7_4 = 408,
	FN_IP3_11_8 = 409,
	FN_IP3_14_12 = 410,
	FN_IP3_17_15 = 411,
	FN_IP3_19_18 = 412,
	FN_IP3_22_20 = 413,
	FN_IP3_25_23 = 414,
	FN_IP3_28_26 = 415,
	FN_IP3_31_29 = 416,
	FN_IP4_2_0 = 417,
	FN_IP4_5_3 = 418,
	FN_IP4_8_6 = 419,
	FN_IP4_11_9 = 420,
	FN_IP4_14_12 = 421,
	FN_IP4_17_15 = 422,
	FN_IP4_20_18 = 423,
	FN_IP4_23_21 = 424,
	FN_IP4_26_24 = 425,
	FN_IP4_29_27 = 426,
	FN_IP5_2_0 = 427,
	FN_IP5_5_3 = 428,
	FN_IP5_9_6 = 429,
	FN_IP5_12_10 = 430,
	FN_IP5_14_13 = 431,
	FN_IP5_17_15 = 432,
	FN_IP5_20_18 = 433,
	FN_IP5_23_21 = 434,
	FN_IP5_26_24 = 435,
	FN_IP5_29_27 = 436,
	FN_IP6_2_0 = 437,
	FN_IP6_5_3 = 438,
	FN_IP6_8_6 = 439,
	FN_IP6_10_9 = 440,
	FN_IP6_13_11 = 441,
	FN_IP7_28_27 = 442,
	FN_IP7_30_29 = 443,
	FN_IP8_1_0 = 444,
	FN_IP8_3_2 = 445,
	FN_IP8_5_4 = 446,
	FN_IP8_7_6 = 447,
	FN_IP8_9_8 = 448,
	FN_IP8_11_10 = 449,
	FN_IP8_13_12 = 450,
	FN_IP8_15_14 = 451,
	FN_IP8_17_16 = 452,
	FN_IP8_19_18 = 453,
	FN_IP8_21_20 = 454,
	FN_IP8_23_22 = 455,
	FN_IP8_25_24 = 456,
	FN_IP8_26 = 457,
	FN_IP8_27 = 458,
	FN_VI1_DATA7_VI1_B7 = 459,
	FN_IP6_16_14 = 460,
	FN_IP6_19_17 = 461,
	FN_IP6_22_20 = 462,
	FN_IP6_25_23 = 463,
	FN_IP6_28_26 = 464,
	FN_IP6_31_29 = 465,
	FN_IP7_2_0 = 466,
	FN_IP7_5_3 = 467,
	FN_IP7_7_6 = 468,
	FN_IP7_9_8 = 469,
	FN_IP7_12_10 = 470,
	FN_IP7_15_13 = 471,
	FN_IP8_28 = 472,
	FN_IP8_30_29 = 473,
	FN_IP9_1_0 = 474,
	FN_IP9_3_2 = 475,
	FN_IP9_5_4 = 476,
	FN_IP9_7_6 = 477,
	FN_IP9_11_8 = 478,
	FN_IP9_15_12 = 479,
	FN_IP9_17_16 = 480,
	FN_IP9_19_18 = 481,
	FN_IP9_21_20 = 482,
	FN_IP9_23_22 = 483,
	FN_IP9_25_24 = 484,
	FN_IP9_27_26 = 485,
	FN_IP9_31_28 = 486,
	FN_IP10_3_0 = 487,
	FN_IP10_6_4 = 488,
	FN_IP10_10_7 = 489,
	FN_IP10_14_11 = 490,
	FN_IP10_18_15 = 491,
	FN_IP10_22_19 = 492,
	FN_IP10_25_23 = 493,
	FN_IP10_29_26 = 494,
	FN_IP11_3_0 = 495,
	FN_IP11_4 = 496,
	FN_IP11_6_5 = 497,
	FN_IP11_8_7 = 498,
	FN_IP11_10_9 = 499,
	FN_IP11_12_11 = 500,
	FN_IP11_14_13 = 501,
	FN_IP11_17_15 = 502,
	FN_IP11_21_18 = 503,
	FN_IP11_23_22 = 504,
	FN_IP11_26_24 = 505,
	FN_IP11_29_27 = 506,
	FN_IP11_31_30 = 507,
	FN_IP12_1_0 = 508,
	FN_IP12_3_2 = 509,
	FN_IP12_5_4 = 510,
	FN_IP12_7_6 = 511,
	FN_IP12_10_8 = 512,
	FN_IP12_13_11 = 513,
	FN_IP12_16_14 = 514,
	FN_IP12_19_17 = 515,
	FN_IP12_22_20 = 516,
	FN_IP12_24_23 = 517,
	FN_IP12_27_25 = 518,
	FN_IP12_30_28 = 519,
	FN_IP13_2_0 = 520,
	FN_IP13_6_3 = 521,
	FN_IP13_9_7 = 522,
	FN_IP13_12_10 = 523,
	FN_IP13_15_13 = 524,
	FN_IP13_18_16 = 525,
	FN_IP13_22_19 = 526,
	FN_IP13_25_23 = 527,
	FN_IP13_28_26 = 528,
	FN_IP13_30_29 = 529,
	FN_IP14_2_0 = 530,
	FN_IP14_5_3 = 531,
	FN_IP14_8_6 = 532,
	FN_IP14_11_9 = 533,
	FN_IP14_15_12 = 534,
	FN_IP14_18_16 = 535,
	FN_IP14_21_19 = 536,
	FN_IP14_24_22 = 537,
	FN_IP14_27_25 = 538,
	FN_IP14_30_28 = 539,
	FN_IP15_2_0 = 540,
	FN_IP15_5_3 = 541,
	FN_IP15_8_6 = 542,
	FN_IP15_11_9 = 543,
	FN_IP15_13_12 = 544,
	FN_IP15_15_14 = 545,
	FN_IP15_17_16 = 546,
	FN_IP15_19_18 = 547,
	FN_IP15_22_20 = 548,
	FN_IP15_25_23 = 549,
	FN_IP15_27_26 = 550,
	FN_IP15_29_28 = 551,
	FN_IP16_2_0 = 552,
	FN_IP16_5_3 = 553,
	FN_USB0_PWEN = 554,
	FN_USB0_OVC_VBUS = 555,
	FN_IP16_6 = 556,
	FN_IP16_7 = 557,
	FN_USB2_PWEN = 558,
	FN_USB2_OVC = 559,
	FN_AVS1 = 560,
	FN_AVS2 = 561,
	FN_DU_DOTCLKIN0 = 562,
	FN_IP7_26_25 = 563,
	FN_DU_DOTCLKIN2 = 564,
	FN_IP7_18_16 = 565,
	FN_IP7_21_19 = 566,
	FN_IP7_24_22 = 567,
	FN_D0 = 568,
	FN_MSIOF3_SCK_B = 569,
	FN_VI3_DATA0 = 570,
	FN_VI0_G4 = 571,
	FN_VI0_G4_B = 572,
	FN_D1 = 573,
	FN_MSIOF3_SYNC_B = 574,
	FN_VI3_DATA1 = 575,
	FN_VI0_G5 = 576,
	FN_VI0_G5_B = 577,
	FN_D2 = 578,
	FN_MSIOF3_RXD_B = 579,
	FN_VI3_DATA2 = 580,
	FN_VI0_G6 = 581,
	FN_VI0_G6_B = 582,
	FN_D3 = 583,
	FN_MSIOF3_TXD_B = 584,
	FN_VI3_DATA3 = 585,
	FN_VI0_G7 = 586,
	FN_VI0_G7_B = 587,
	FN_D4 = 588,
	FN_SCIFB1_RXD_F = 589,
	FN_SCIFB0_RXD_C = 590,
	FN_VI3_DATA4 = 591,
	FN_VI0_R0 = 592,
	FN_VI0_R0_B = 593,
	FN_RX0_B = 594,
	FN_D5 = 595,
	FN_SCIFB1_TXD_F = 596,
	FN_SCIFB0_TXD_C = 597,
	FN_VI3_DATA5 = 598,
	FN_VI0_R1 = 599,
	FN_VI0_R1_B = 600,
	FN_TX0_B = 601,
	FN_D6 = 602,
	FN_IIC2_SCL_C = 603,
	FN_VI3_DATA6 = 604,
	FN_VI0_R2 = 605,
	FN_VI0_R2_B = 606,
	FN_I2C2_SCL_C = 607,
	FN_D7 = 608,
	FN_AD_DI_B = 609,
	FN_IIC2_SDA_C = 610,
	FN_VI3_DATA7 = 611,
	FN_VI0_R3 = 612,
	FN_VI0_R3_B = 613,
	FN_I2C2_SDA_C = 614,
	FN_TCLK1 = 615,
	FN_D8 = 616,
	FN_SCIFA1_SCK_C = 617,
	FN_AVB_TXD0 = 618,
	FN_VI0_G0 = 619,
	FN_VI0_G0_B = 620,
	FN_VI2_DATA0_VI2_B0 = 621,
	FN_D9 = 622,
	FN_SCIFA1_RXD_C = 623,
	FN_AVB_TXD1 = 624,
	FN_VI0_G1 = 625,
	FN_VI0_G1_B = 626,
	FN_VI2_DATA1_VI2_B1 = 627,
	FN_D10 = 628,
	FN_SCIFA1_TXD_C = 629,
	FN_AVB_TXD2 = 630,
	FN_VI0_G2 = 631,
	FN_VI0_G2_B = 632,
	FN_VI2_DATA2_VI2_B2 = 633,
	FN_D11 = 634,
	FN_SCIFA1_CTS_N_C = 635,
	FN_AVB_TXD3 = 636,
	FN_VI0_G3 = 637,
	FN_VI0_G3_B = 638,
	FN_VI2_DATA3_VI2_B3 = 639,
	FN_D12 = 640,
	FN_SCIFA1_RTS_N_C = 641,
	FN_AVB_TXD4 = 642,
	FN_VI0_HSYNC_N = 643,
	FN_VI0_HSYNC_N_B = 644,
	FN_VI2_DATA4_VI2_B4 = 645,
	FN_D13 = 646,
	FN_AVB_TXD5 = 647,
	FN_VI0_VSYNC_N = 648,
	FN_VI0_VSYNC_N_B = 649,
	FN_VI2_DATA5_VI2_B5 = 650,
	FN_D14 = 651,
	FN_SCIFB1_RXD_C = 652,
	FN_AVB_TXD6 = 653,
	FN_RX1_B = 654,
	FN_VI0_CLKENB = 655,
	FN_VI0_CLKENB_B = 656,
	FN_VI2_DATA6_VI2_B6 = 657,
	FN_D15 = 658,
	FN_SCIFB1_TXD_C = 659,
	FN_AVB_TXD7 = 660,
	FN_TX1_B = 661,
	FN_VI0_FIELD = 662,
	FN_VI0_FIELD_B = 663,
	FN_VI2_DATA7_VI2_B7 = 664,
	FN_A0 = 665,
	FN_PWM3 = 666,
	FN_A1 = 667,
	FN_PWM4 = 668,
	FN_A2 = 669,
	FN_PWM5 = 670,
	FN_MSIOF1_SS1_B = 671,
	FN_A3 = 672,
	FN_PWM6 = 673,
	FN_MSIOF1_SS2_B = 674,
	FN_A4 = 675,
	FN_MSIOF1_TXD_B = 676,
	FN_TPU0TO0 = 677,
	FN_A5 = 678,
	FN_SCIFA1_TXD_B = 679,
	FN_TPU0TO1 = 680,
	FN_A6 = 681,
	FN_SCIFA1_RTS_N_B = 682,
	FN_TPU0TO2 = 683,
	FN_A7 = 684,
	FN_SCIFA1_SCK_B = 685,
	FN_AUDIO_CLKOUT_B = 686,
	FN_TPU0TO3 = 687,
	FN_A8 = 688,
	FN_SCIFA1_RXD_B = 689,
	FN_SSI_SCK5_B = 690,
	FN_VI0_R4 = 691,
	FN_VI0_R4_B = 692,
	FN_SCIFB2_RXD_C = 693,
	FN_RX2_B = 694,
	FN_VI2_DATA0_VI2_B0_B = 695,
	FN_A9 = 696,
	FN_SCIFA1_CTS_N_B = 697,
	FN_SSI_WS5_B = 698,
	FN_VI0_R5 = 699,
	FN_VI0_R5_B = 700,
	FN_SCIFB2_TXD_C = 701,
	FN_TX2_B = 702,
	FN_VI2_DATA1_VI2_B1_B = 703,
	FN_A10 = 704,
	FN_SSI_SDATA5_B = 705,
	FN_MSIOF2_SYNC = 706,
	FN_VI0_R6 = 707,
	FN_VI0_R6_B = 708,
	FN_VI2_DATA2_VI2_B2_B = 709,
	FN_A11 = 710,
	FN_SCIFB2_CTS_N_B = 711,
	FN_MSIOF2_SCK = 712,
	FN_VI1_R0 = 713,
	FN_VI1_R0_B = 714,
	FN_VI2_G0 = 715,
	FN_VI2_DATA3_VI2_B3_B = 716,
	FN_A12 = 717,
	FN_SCIFB2_RXD_B = 718,
	FN_MSIOF2_TXD = 719,
	FN_VI1_R1 = 720,
	FN_VI1_R1_B = 721,
	FN_VI2_G1 = 722,
	FN_VI2_DATA4_VI2_B4_B = 723,
	FN_A13 = 724,
	FN_SCIFB2_RTS_N_B = 725,
	FN_EX_WAIT2 = 726,
	FN_MSIOF2_RXD = 727,
	FN_VI1_R2 = 728,
	FN_VI1_R2_B = 729,
	FN_VI2_G2 = 730,
	FN_VI2_DATA5_VI2_B5_B = 731,
	FN_A14 = 732,
	FN_SCIFB2_TXD_B = 733,
	FN_ATACS11_N = 734,
	FN_MSIOF2_SS1 = 735,
	FN_A15 = 736,
	FN_SCIFB2_SCK_B = 737,
	FN_ATARD1_N = 738,
	FN_MSIOF2_SS2 = 739,
	FN_A16 = 740,
	FN_ATAWR1_N = 741,
	FN_A17 = 742,
	FN_AD_DO_B = 743,
	FN_ATADIR1_N = 744,
	FN_A18 = 745,
	FN_AD_CLK_B = 746,
	FN_ATAG1_N = 747,
	FN_A19 = 748,
	FN_AD_NCS_N_B = 749,
	FN_ATACS01_N = 750,
	FN_EX_WAIT0_B = 751,
	FN_A20 = 752,
	FN_SPCLK = 753,
	FN_VI1_R3 = 754,
	FN_VI1_R3_B = 755,
	FN_VI2_G4 = 756,
	FN_A21 = 757,
	FN_MOSI_IO0 = 758,
	FN_VI1_R4 = 759,
	FN_VI1_R4_B = 760,
	FN_VI2_G5 = 761,
	FN_A22 = 762,
	FN_MISO_IO1 = 763,
	FN_VI1_R5 = 764,
	FN_VI1_R5_B = 765,
	FN_VI2_G6 = 766,
	FN_A23 = 767,
	FN_IO2 = 768,
	FN_VI1_G7 = 769,
	FN_VI1_G7_B = 770,
	FN_VI2_G7 = 771,
	FN_A24 = 772,
	FN_IO3 = 773,
	FN_VI1_R7 = 774,
	FN_VI1_R7_B = 775,
	FN_VI2_CLKENB = 776,
	FN_VI2_CLKENB_B = 777,
	FN_A25 = 778,
	FN_SSL = 779,
	FN_VI1_G6 = 780,
	FN_VI1_G6_B = 781,
	FN_VI2_FIELD = 782,
	FN_VI2_FIELD_B = 783,
	FN_CS0_N = 784,
	FN_VI1_R6 = 785,
	FN_VI1_R6_B = 786,
	FN_VI2_G3 = 787,
	FN_MSIOF0_SS2_B = 788,
	FN_CS1_N_A26 = 789,
	FN_SPEEDIN = 790,
	FN_VI0_R7 = 791,
	FN_VI0_R7_B = 792,
	FN_VI2_CLK = 793,
	FN_VI2_CLK_B = 794,
	FN_EX_CS0_N = 795,
	FN_HRX1_B = 796,
	FN_VI1_G5 = 797,
	FN_VI1_G5_B = 798,
	FN_VI2_R0 = 799,
	FN_HTX0_B = 800,
	FN_MSIOF0_SS1_B = 801,
	FN_EX_CS1_N = 802,
	FN_GPS_CLK = 803,
	FN_HCTS1_N_B = 804,
	FN_VI1_FIELD = 805,
	FN_VI1_FIELD_B = 806,
	FN_VI2_R1 = 807,
	FN_EX_CS2_N = 808,
	FN_GPS_SIGN = 809,
	FN_HRTS1_N_B = 810,
	FN_VI3_CLKENB = 811,
	FN_VI1_G0 = 812,
	FN_VI1_G0_B = 813,
	FN_VI2_R2 = 814,
	FN_EX_CS3_N = 815,
	FN_GPS_MAG = 816,
	FN_VI3_FIELD = 817,
	FN_VI1_G1 = 818,
	FN_VI1_G1_B = 819,
	FN_VI2_R3 = 820,
	FN_EX_CS4_N = 821,
	FN_MSIOF1_SCK_B = 822,
	FN_VI3_HSYNC_N = 823,
	FN_VI2_HSYNC_N = 824,
	FN_IIC1_SCL = 825,
	FN_VI2_HSYNC_N_B = 826,
	FN_INTC_EN0_N = 827,
	FN_I2C1_SCL = 828,
	FN_EX_CS5_N = 829,
	FN_CAN0_RX = 830,
	FN_MSIOF1_RXD_B = 831,
	FN_VI3_VSYNC_N = 832,
	FN_VI1_G2 = 833,
	FN_VI1_G2_B = 834,
	FN_VI2_R4 = 835,
	FN_IIC1_SDA = 836,
	FN_INTC_EN1_N = 837,
	FN_I2C1_SDA = 838,
	FN_BS_N = 839,
	FN_IETX = 840,
	FN_HTX1_B = 841,
	FN_CAN1_TX = 842,
	FN_DRACK0 = 843,
	FN_IETX_C = 844,
	FN_RD_N = 845,
	FN_CAN0_TX = 846,
	FN_SCIFA0_SCK_B = 847,
	FN_RD_WR_N = 848,
	FN_VI1_G3 = 849,
	FN_VI1_G3_B = 850,
	FN_VI2_R5 = 851,
	FN_SCIFA0_RXD_B = 852,
	FN_INTC_IRQ4_N = 853,
	FN_WE0_N = 854,
	FN_IECLK = 855,
	FN_CAN_CLK = 856,
	FN_VI2_VSYNC_N = 857,
	FN_SCIFA0_TXD_B = 858,
	FN_VI2_VSYNC_N_B = 859,
	FN_WE1_N = 860,
	FN_IERX = 861,
	FN_CAN1_RX = 862,
	FN_VI1_G4 = 863,
	FN_VI1_G4_B = 864,
	FN_VI2_R6 = 865,
	FN_SCIFA0_CTS_N_B = 866,
	FN_IERX_C = 867,
	FN_EX_WAIT0 = 868,
	FN_IRQ3 = 869,
	FN_INTC_IRQ3_N = 870,
	FN_VI3_CLK = 871,
	FN_SCIFA0_RTS_N_B = 872,
	FN_HRX0_B = 873,
	FN_MSIOF0_SCK_B = 874,
	FN_DREQ0_N = 875,
	FN_VI1_HSYNC_N = 876,
	FN_VI1_HSYNC_N_B = 877,
	FN_VI2_R7 = 878,
	FN_SSI_SCK78_C = 879,
	FN_SSI_WS78_B = 880,
	FN_DACK0 = 881,
	FN_IRQ0 = 882,
	FN_INTC_IRQ0_N = 883,
	FN_SSI_SCK6_B = 884,
	FN_VI1_VSYNC_N = 885,
	FN_VI1_VSYNC_N_B = 886,
	FN_SSI_WS78_C = 887,
	FN_DREQ1_N = 888,
	FN_VI1_CLKENB = 889,
	FN_VI1_CLKENB_B = 890,
	FN_SSI_SDATA7_C = 891,
	FN_SSI_SCK78_B = 892,
	FN_DACK1 = 893,
	FN_IRQ1 = 894,
	FN_INTC_IRQ1_N = 895,
	FN_SSI_WS6_B = 896,
	FN_SSI_SDATA8_C = 897,
	FN_DREQ2_N = 898,
	FN_HSCK1_B = 899,
	FN_HCTS0_N_B = 900,
	FN_MSIOF0_TXD_B = 901,
	FN_DACK2 = 902,
	FN_IRQ2 = 903,
	FN_INTC_IRQ2_N = 904,
	FN_SSI_SDATA6_B = 905,
	FN_HRTS0_N_B = 906,
	FN_MSIOF0_RXD_B = 907,
	FN_ETH_CRS_DV = 908,
	FN_STP_ISCLK_0_B = 909,
	FN_TS_SDEN0_D = 910,
	FN_GLO_Q0_C = 911,
	FN_IIC2_SCL_E = 912,
	FN_I2C2_SCL_E = 913,
	FN_ETH_RX_ER = 914,
	FN_STP_ISD_0_B = 915,
	FN_TS_SPSYNC0_D = 916,
	FN_GLO_Q1_C = 917,
	FN_IIC2_SDA_E = 918,
	FN_I2C2_SDA_E = 919,
	FN_ETH_RXD0 = 920,
	FN_STP_ISEN_0_B = 921,
	FN_TS_SDAT0_D = 922,
	FN_GLO_I0_C = 923,
	FN_SCIFB1_SCK_G = 924,
	FN_SCK1_E = 925,
	FN_ETH_RXD1 = 926,
	FN_HRX0_E = 927,
	FN_STP_ISSYNC_0_B = 928,
	FN_TS_SCK0_D = 929,
	FN_GLO_I1_C = 930,
	FN_SCIFB1_RXD_G = 931,
	FN_RX1_E = 932,
	FN_ETH_LINK = 933,
	FN_HTX0_E = 934,
	FN_STP_IVCXO27_0_B = 935,
	FN_SCIFB1_TXD_G = 936,
	FN_TX1_E = 937,
	FN_ETH_REF_CLK = 938,
	FN_HCTS0_N_E = 939,
	FN_STP_IVCXO27_1_B = 940,
	FN_HRX0_F = 941,
	FN_ETH_MDIO = 942,
	FN_HRTS0_N_E = 943,
	FN_SIM0_D_C = 944,
	FN_HCTS0_N_F = 945,
	FN_ETH_TXD1 = 946,
	FN_HTX0_F = 947,
	FN_BPFCLK_G = 948,
	FN_ETH_TX_EN = 949,
	FN_SIM0_CLK_C = 950,
	FN_HRTS0_N_F = 951,
	FN_ETH_MAGIC = 952,
	FN_SIM0_RST_C = 953,
	FN_ETH_TXD0 = 954,
	FN_STP_ISCLK_1_B = 955,
	FN_TS_SDEN1_C = 956,
	FN_GLO_SCLK_C = 957,
	FN_ETH_MDC = 958,
	FN_STP_ISD_1_B = 959,
	FN_TS_SPSYNC1_C = 960,
	FN_GLO_SDATA_C = 961,
	FN_PWM0 = 962,
	FN_SCIFA2_SCK_C = 963,
	FN_STP_ISEN_1_B = 964,
	FN_TS_SDAT1_C = 965,
	FN_GLO_SS_C = 966,
	FN_PWM1 = 967,
	FN_SCIFA2_TXD_C = 968,
	FN_STP_ISSYNC_1_B = 969,
	FN_TS_SCK1_C = 970,
	FN_GLO_RFON_C = 971,
	FN_PCMOE_N = 972,
	FN_PWM2 = 973,
	FN_PWMFSW0 = 974,
	FN_SCIFA2_RXD_C = 975,
	FN_PCMWE_N = 976,
	FN_IECLK_C = 977,
	FN_DU_DOTCLKIN1 = 978,
	FN_AUDIO_CLKC = 979,
	FN_AUDIO_CLKOUT_C = 980,
	FN_VI0_CLK = 981,
	FN_ATACS00_N = 982,
	FN_AVB_RXD1 = 983,
	FN_VI0_DATA0_VI0_B0 = 984,
	FN_ATACS10_N = 985,
	FN_AVB_RXD2 = 986,
	FN_VI0_DATA1_VI0_B1 = 987,
	FN_ATARD0_N = 988,
	FN_AVB_RXD3 = 989,
	FN_VI0_DATA2_VI0_B2 = 990,
	FN_ATAWR0_N = 991,
	FN_AVB_RXD4 = 992,
	FN_VI0_DATA3_VI0_B3 = 993,
	FN_ATADIR0_N = 994,
	FN_AVB_RXD5 = 995,
	FN_VI0_DATA4_VI0_B4 = 996,
	FN_ATAG0_N = 997,
	FN_AVB_RXD6 = 998,
	FN_VI0_DATA5_VI0_B5 = 999,
	FN_EX_WAIT1 = 1000,
	FN_AVB_RXD7 = 1001,
	FN_VI0_DATA6_VI0_B6 = 1002,
	FN_AVB_RX_ER = 1003,
	FN_VI0_DATA7_VI0_B7 = 1004,
	FN_AVB_RX_CLK = 1005,
	FN_VI1_CLK = 1006,
	FN_AVB_RX_DV = 1007,
	FN_VI1_DATA0_VI1_B0 = 1008,
	FN_SCIFA1_SCK_D = 1009,
	FN_AVB_CRS = 1010,
	FN_VI1_DATA1_VI1_B1 = 1011,
	FN_SCIFA1_RXD_D = 1012,
	FN_AVB_MDC = 1013,
	FN_VI1_DATA2_VI1_B2 = 1014,
	FN_SCIFA1_TXD_D = 1015,
	FN_AVB_MDIO = 1016,
	FN_VI1_DATA3_VI1_B3 = 1017,
	FN_SCIFA1_CTS_N_D = 1018,
	FN_AVB_GTX_CLK = 1019,
	FN_VI1_DATA4_VI1_B4 = 1020,
	FN_SCIFA1_RTS_N_D = 1021,
	FN_AVB_MAGIC = 1022,
	FN_VI1_DATA5_VI1_B5 = 1023,
	FN_AVB_PHY_INT = 1024,
	FN_VI1_DATA6_VI1_B6 = 1025,
	FN_AVB_GTXREFCLK = 1026,
	FN_SD0_CLK = 1027,
	FN_VI1_DATA0_VI1_B0_B = 1028,
	FN_SD0_CMD = 1029,
	FN_SCIFB1_SCK_B = 1030,
	FN_VI1_DATA1_VI1_B1_B = 1031,
	FN_SD0_DAT0 = 1032,
	FN_SCIFB1_RXD_B = 1033,
	FN_VI1_DATA2_VI1_B2_B = 1034,
	FN_SD0_DAT1 = 1035,
	FN_SCIFB1_TXD_B = 1036,
	FN_VI1_DATA3_VI1_B3_B = 1037,
	FN_SD0_DAT2 = 1038,
	FN_SCIFB1_CTS_N_B = 1039,
	FN_VI1_DATA4_VI1_B4_B = 1040,
	FN_SD0_DAT3 = 1041,
	FN_SCIFB1_RTS_N_B = 1042,
	FN_VI1_DATA5_VI1_B5_B = 1043,
	FN_SD0_CD = 1044,
	FN_MMC0_D6 = 1045,
	FN_TS_SDEN0_B = 1046,
	FN_USB0_EXTP = 1047,
	FN_GLO_SCLK = 1048,
	FN_VI1_DATA6_VI1_B6_B = 1049,
	FN_IIC1_SCL_B = 1050,
	FN_I2C1_SCL_B = 1051,
	FN_VI2_DATA6_VI2_B6_B = 1052,
	FN_SD0_WP = 1053,
	FN_MMC0_D7 = 1054,
	FN_TS_SPSYNC0_B = 1055,
	FN_USB0_IDIN = 1056,
	FN_GLO_SDATA = 1057,
	FN_VI1_DATA7_VI1_B7_B = 1058,
	FN_IIC1_SDA_B = 1059,
	FN_I2C1_SDA_B = 1060,
	FN_VI2_DATA7_VI2_B7_B = 1061,
	FN_SD1_CLK = 1062,
	FN_AVB_TX_EN = 1063,
	FN_SD1_CMD = 1064,
	FN_AVB_TX_ER = 1065,
	FN_SCIFB0_SCK_B = 1066,
	FN_SD1_DAT0 = 1067,
	FN_AVB_TX_CLK = 1068,
	FN_SCIFB0_RXD_B = 1069,
	FN_SD1_DAT1 = 1070,
	FN_AVB_LINK = 1071,
	FN_SCIFB0_TXD_B = 1072,
	FN_SD1_DAT2 = 1073,
	FN_AVB_COL = 1074,
	FN_SCIFB0_CTS_N_B = 1075,
	FN_SD1_DAT3 = 1076,
	FN_AVB_RXD0 = 1077,
	FN_SCIFB0_RTS_N_B = 1078,
	FN_SD1_CD = 1079,
	FN_MMC1_D6 = 1080,
	FN_TS_SDEN1 = 1081,
	FN_USB1_EXTP = 1082,
	FN_GLO_SS = 1083,
	FN_VI0_CLK_B = 1084,
	FN_IIC2_SCL_D = 1085,
	FN_I2C2_SCL_D = 1086,
	FN_SIM0_CLK_B = 1087,
	FN_VI3_CLK_B = 1088,
	FN_SD1_WP = 1089,
	FN_MMC1_D7 = 1090,
	FN_TS_SPSYNC1 = 1091,
	FN_USB1_IDIN = 1092,
	FN_GLO_RFON = 1093,
	FN_VI1_CLK_B = 1094,
	FN_IIC2_SDA_D = 1095,
	FN_I2C2_SDA_D = 1096,
	FN_SIM0_D_B = 1097,
	FN_SD2_CLK = 1098,
	FN_MMC0_CLK = 1099,
	FN_SIM0_CLK = 1100,
	FN_VI0_DATA0_VI0_B0_B = 1101,
	FN_TS_SDEN0_C = 1102,
	FN_GLO_SCLK_B = 1103,
	FN_VI3_DATA0_B = 1104,
	FN_SD2_CMD = 1105,
	FN_MMC0_CMD = 1106,
	FN_SIM0_D = 1107,
	FN_VI0_DATA1_VI0_B1_B = 1108,
	FN_SCIFB1_SCK_E = 1109,
	FN_SCK1_D = 1110,
	FN_TS_SPSYNC0_C = 1111,
	FN_GLO_SDATA_B = 1112,
	FN_VI3_DATA1_B = 1113,
	FN_SD2_DAT0 = 1114,
	FN_MMC0_D0 = 1115,
	FN_FMCLK_B = 1116,
	FN_VI0_DATA2_VI0_B2_B = 1117,
	FN_SCIFB1_RXD_E = 1118,
	FN_RX1_D = 1119,
	FN_TS_SDAT0_C = 1120,
	FN_GLO_SS_B = 1121,
	FN_VI3_DATA2_B = 1122,
	FN_SD2_DAT1 = 1123,
	FN_MMC0_D1 = 1124,
	FN_FMIN_B = 1125,
	FN_VI0_DATA3_VI0_B3_B = 1126,
	FN_SCIFB1_TXD_E = 1127,
	FN_TX1_D = 1128,
	FN_TS_SCK0_C = 1129,
	FN_GLO_RFON_B = 1130,
	FN_VI3_DATA3_B = 1131,
	FN_SD2_DAT2 = 1132,
	FN_MMC0_D2 = 1133,
	FN_BPFCLK_B = 1134,
	FN_VI0_DATA4_VI0_B4_B = 1135,
	FN_HRX0_D = 1136,
	FN_TS_SDEN1_B = 1137,
	FN_GLO_Q0_B = 1138,
	FN_VI3_DATA4_B = 1139,
	FN_SD2_DAT3 = 1140,
	FN_MMC0_D3 = 1141,
	FN_SIM0_RST = 1142,
	FN_VI0_DATA5_VI0_B5_B = 1143,
	FN_HTX0_D = 1144,
	FN_TS_SPSYNC1_B = 1145,
	FN_GLO_Q1_B = 1146,
	FN_VI3_DATA5_B = 1147,
	FN_SD2_CD = 1148,
	FN_MMC0_D4 = 1149,
	FN_TS_SDAT0_B = 1150,
	FN_USB2_EXTP = 1151,
	FN_GLO_I0 = 1152,
	FN_VI0_DATA6_VI0_B6_B = 1153,
	FN_HCTS0_N_D = 1154,
	FN_TS_SDAT1_B = 1155,
	FN_GLO_I0_B = 1156,
	FN_VI3_DATA6_B = 1157,
	FN_SD2_WP = 1158,
	FN_MMC0_D5 = 1159,
	FN_TS_SCK0_B = 1160,
	FN_USB2_IDIN = 1161,
	FN_GLO_I1 = 1162,
	FN_VI0_DATA7_VI0_B7_B = 1163,
	FN_HRTS0_N_D = 1164,
	FN_TS_SCK1_B = 1165,
	FN_GLO_I1_B = 1166,
	FN_VI3_DATA7_B = 1167,
	FN_SD3_CLK = 1168,
	FN_MMC1_CLK = 1169,
	FN_SD3_CMD = 1170,
	FN_MMC1_CMD = 1171,
	FN_MTS_N = 1172,
	FN_SD3_DAT0 = 1173,
	FN_MMC1_D0 = 1174,
	FN_STM_N = 1175,
	FN_SD3_DAT1 = 1176,
	FN_MMC1_D1 = 1177,
	FN_MDATA = 1178,
	FN_SD3_DAT2 = 1179,
	FN_MMC1_D2 = 1180,
	FN_SDATA = 1181,
	FN_SD3_DAT3 = 1182,
	FN_MMC1_D3 = 1183,
	FN_SCKZ = 1184,
	FN_SD3_CD = 1185,
	FN_MMC1_D4 = 1186,
	FN_TS_SDAT1 = 1187,
	FN_VSP = 1188,
	FN_GLO_Q0 = 1189,
	FN_SIM0_RST_B = 1190,
	FN_SD3_WP = 1191,
	FN_MMC1_D5 = 1192,
	FN_TS_SCK1 = 1193,
	FN_GLO_Q1 = 1194,
	FN_FMIN_C = 1195,
	FN_FMIN_E = 1196,
	FN_FMIN_F = 1197,
	FN_MLB_CLK = 1198,
	FN_IIC2_SCL_B = 1199,
	FN_I2C2_SCL_B = 1200,
	FN_MLB_SIG = 1201,
	FN_SCIFB1_RXD_D = 1202,
	FN_RX1_C = 1203,
	FN_IIC2_SDA_B = 1204,
	FN_I2C2_SDA_B = 1205,
	FN_MLB_DAT = 1206,
	FN_SCIFB1_TXD_D = 1207,
	FN_TX1_C = 1208,
	FN_BPFCLK_C = 1209,
	FN_SSI_SCK0129 = 1210,
	FN_CAN_CLK_B = 1211,
	FN_MOUT0 = 1212,
	FN_SSI_WS0129 = 1213,
	FN_CAN0_TX_B = 1214,
	FN_MOUT1 = 1215,
	FN_SSI_SDATA0 = 1216,
	FN_CAN0_RX_B = 1217,
	FN_MOUT2 = 1218,
	FN_SSI_SDATA1 = 1219,
	FN_CAN1_TX_B = 1220,
	FN_MOUT5 = 1221,
	FN_SSI_SDATA2 = 1222,
	FN_CAN1_RX_B = 1223,
	FN_SSI_SCK1 = 1224,
	FN_MOUT6 = 1225,
	FN_SSI_SCK34 = 1226,
	FN_STP_OPWM_0 = 1227,
	FN_SCIFB0_SCK = 1228,
	FN_MSIOF1_SCK = 1229,
	FN_CAN_DEBUG_HW_TRIGGER = 1230,
	FN_SSI_WS34 = 1231,
	FN_STP_IVCXO27_0 = 1232,
	FN_SCIFB0_RXD = 1233,
	FN_MSIOF1_SYNC = 1234,
	FN_CAN_STEP0 = 1235,
	FN_SSI_SDATA3 = 1236,
	FN_STP_ISCLK_0 = 1237,
	FN_SCIFB0_TXD = 1238,
	FN_MSIOF1_SS1 = 1239,
	FN_CAN_TXCLK = 1240,
	FN_SSI_SCK4 = 1241,
	FN_STP_ISD_0 = 1242,
	FN_SCIFB0_CTS_N = 1243,
	FN_MSIOF1_SS2 = 1244,
	FN_SSI_SCK5_C = 1245,
	FN_CAN_DEBUGOUT0 = 1246,
	FN_SSI_WS4 = 1247,
	FN_STP_ISEN_0 = 1248,
	FN_SCIFB0_RTS_N = 1249,
	FN_MSIOF1_TXD = 1250,
	FN_SSI_WS5_C = 1251,
	FN_CAN_DEBUGOUT1 = 1252,
	FN_SSI_SDATA4 = 1253,
	FN_STP_ISSYNC_0 = 1254,
	FN_MSIOF1_RXD = 1255,
	FN_CAN_DEBUGOUT2 = 1256,
	FN_SSI_SCK5 = 1257,
	FN_SCIFB1_SCK = 1258,
	FN_IERX_B = 1259,
	FN_DU2_EXHSYNC_DU2_HSYNC = 1260,
	FN_QSTH_QHS = 1261,
	FN_CAN_DEBUGOUT3 = 1262,
	FN_SSI_WS5 = 1263,
	FN_SCIFB1_RXD = 1264,
	FN_IECLK_B = 1265,
	FN_DU2_EXVSYNC_DU2_VSYNC = 1266,
	FN_QSTB_QHE = 1267,
	FN_CAN_DEBUGOUT4 = 1268,
	FN_SSI_SDATA5 = 1269,
	FN_SCIFB1_TXD = 1270,
	FN_IETX_B = 1271,
	FN_DU2_DR2 = 1272,
	FN_LCDOUT2 = 1273,
	FN_CAN_DEBUGOUT5 = 1274,
	FN_SSI_SCK6 = 1275,
	FN_SCIFB1_CTS_N = 1276,
	FN_BPFCLK_D = 1277,
	FN_DU2_DR3 = 1278,
	FN_LCDOUT3 = 1279,
	FN_CAN_DEBUGOUT6 = 1280,
	FN_BPFCLK_F = 1281,
	FN_SSI_WS6 = 1282,
	FN_SCIFB1_RTS_N = 1283,
	FN_CAN0_TX_D = 1284,
	FN_DU2_DR4 = 1285,
	FN_LCDOUT4 = 1286,
	FN_CAN_DEBUGOUT7 = 1287,
	FN_SSI_SDATA6 = 1288,
	FN_FMIN_D = 1289,
	FN_DU2_DR5 = 1290,
	FN_LCDOUT5 = 1291,
	FN_CAN_DEBUGOUT8 = 1292,
	FN_SSI_SCK78 = 1293,
	FN_STP_IVCXO27_1 = 1294,
	FN_SCK1 = 1295,
	FN_SCIFA1_SCK = 1296,
	FN_DU2_DR6 = 1297,
	FN_LCDOUT6 = 1298,
	FN_CAN_DEBUGOUT9 = 1299,
	FN_SSI_WS78 = 1300,
	FN_STP_ISCLK_1 = 1301,
	FN_SCIFB2_SCK = 1302,
	FN_SCIFA2_CTS_N = 1303,
	FN_DU2_DR7 = 1304,
	FN_LCDOUT7 = 1305,
	FN_CAN_DEBUGOUT10 = 1306,
	FN_SSI_SDATA7 = 1307,
	FN_STP_ISD_1 = 1308,
	FN_SCIFB2_RXD = 1309,
	FN_SCIFA2_RTS_N = 1310,
	FN_TCLK2 = 1311,
	FN_QSTVA_QVS = 1312,
	FN_CAN_DEBUGOUT11 = 1313,
	FN_BPFCLK_E = 1314,
	FN_SSI_SDATA7_B = 1315,
	FN_FMIN_G = 1316,
	FN_SSI_SDATA8 = 1317,
	FN_STP_ISEN_1 = 1318,
	FN_SCIFB2_TXD = 1319,
	FN_CAN0_TX_C = 1320,
	FN_CAN_DEBUGOUT12 = 1321,
	FN_SSI_SDATA8_B = 1322,
	FN_SSI_SDATA9 = 1323,
	FN_STP_ISSYNC_1 = 1324,
	FN_SCIFB2_CTS_N = 1325,
	FN_SSI_WS1 = 1326,
	FN_SSI_SDATA5_C = 1327,
	FN_CAN_DEBUGOUT13 = 1328,
	FN_AUDIO_CLKA = 1329,
	FN_SCIFB2_RTS_N = 1330,
	FN_CAN_DEBUGOUT14 = 1331,
	FN_AUDIO_CLKB = 1332,
	FN_SCIF_CLK = 1333,
	FN_CAN0_RX_D = 1334,
	FN_DVC_MUTE = 1335,
	FN_CAN0_RX_C = 1336,
	FN_CAN_DEBUGOUT15 = 1337,
	FN_REMOCON = 1338,
	FN_SCIFA0_SCK = 1339,
	FN_HSCK1 = 1340,
	FN_SCK0 = 1341,
	FN_MSIOF3_SS2 = 1342,
	FN_DU2_DG2 = 1343,
	FN_LCDOUT10 = 1344,
	FN_IIC1_SDA_C = 1345,
	FN_I2C1_SDA_C = 1346,
	FN_SCIFA0_RXD = 1347,
	FN_HRX1 = 1348,
	FN_RX0 = 1349,
	FN_DU2_DR0 = 1350,
	FN_LCDOUT0 = 1351,
	FN_SCIFA0_TXD = 1352,
	FN_HTX1 = 1353,
	FN_TX0 = 1354,
	FN_DU2_DR1 = 1355,
	FN_LCDOUT1 = 1356,
	FN_SCIFA0_CTS_N = 1357,
	FN_HCTS1_N = 1358,
	FN_CTS0_N = 1359,
	FN_MSIOF3_SYNC = 1360,
	FN_DU2_DG3 = 1361,
	FN_LCDOUT11 = 1362,
	FN_PWM0_B = 1363,
	FN_IIC1_SCL_C = 1364,
	FN_I2C1_SCL_C = 1365,
	FN_SCIFA0_RTS_N = 1366,
	FN_HRTS1_N = 1367,
	FN_RTS0_N = 1368,
	FN_MSIOF3_SS1 = 1369,
	FN_DU2_DG0 = 1370,
	FN_LCDOUT8 = 1371,
	FN_PWM1_B = 1372,
	FN_SCIFA1_RXD = 1373,
	FN_AD_DI = 1374,
	FN_RX1 = 1375,
	FN_DU2_EXODDF_DU2_ODDF_DISP_CDE = 1376,
	FN_QCPV_QDE = 1377,
	FN_SCIFA1_TXD = 1378,
	FN_AD_DO = 1379,
	FN_TX1 = 1380,
	FN_DU2_DG1 = 1381,
	FN_LCDOUT9 = 1382,
	FN_SCIFA1_CTS_N = 1383,
	FN_AD_CLK = 1384,
	FN_CTS1_N = 1385,
	FN_MSIOF3_RXD = 1386,
	FN_DU0_DOTCLKOUT = 1387,
	FN_QCLK = 1388,
	FN_SCIFA1_RTS_N = 1389,
	FN_AD_NCS_N = 1390,
	FN_RTS1_N = 1391,
	FN_MSIOF3_TXD = 1392,
	FN_DU1_DOTCLKOUT = 1393,
	FN_QSTVB_QVE = 1394,
	FN_HRTS0_N_C = 1395,
	FN_SCIFA2_SCK = 1396,
	FN_FMCLK = 1397,
	FN_SCK2 = 1398,
	FN_MSIOF3_SCK = 1399,
	FN_DU2_DG7 = 1400,
	FN_LCDOUT15 = 1401,
	FN_SCIF_CLK_B = 1402,
	FN_SCIFA2_RXD = 1403,
	FN_FMIN = 1404,
	FN_TX2 = 1405,
	FN_DU2_DB0 = 1406,
	FN_LCDOUT16 = 1407,
	FN_IIC2_SCL = 1408,
	FN_I2C2_SCL = 1409,
	FN_SCIFA2_TXD = 1410,
	FN_BPFCLK = 1411,
	FN_RX2 = 1412,
	FN_DU2_DB1 = 1413,
	FN_LCDOUT17 = 1414,
	FN_IIC2_SDA = 1415,
	FN_I2C2_SDA = 1416,
	FN_HSCK0 = 1417,
	FN_TS_SDEN0 = 1418,
	FN_DU2_DG4 = 1419,
	FN_LCDOUT12 = 1420,
	FN_HCTS0_N_C = 1421,
	FN_HRX0 = 1422,
	FN_DU2_DB2 = 1423,
	FN_LCDOUT18 = 1424,
	FN_HTX0 = 1425,
	FN_DU2_DB3 = 1426,
	FN_LCDOUT19 = 1427,
	FN_HCTS0_N = 1428,
	FN_SSI_SCK9 = 1429,
	FN_DU2_DB4 = 1430,
	FN_LCDOUT20 = 1431,
	FN_HRTS0_N = 1432,
	FN_SSI_WS9 = 1433,
	FN_DU2_DB5 = 1434,
	FN_LCDOUT21 = 1435,
	FN_MSIOF0_SCK = 1436,
	FN_TS_SDAT0 = 1437,
	FN_ADICLK = 1438,
	FN_DU2_DB6 = 1439,
	FN_LCDOUT22 = 1440,
	FN_MSIOF0_SYNC = 1441,
	FN_TS_SCK0 = 1442,
	FN_SSI_SCK2 = 1443,
	FN_ADIDATA = 1444,
	FN_DU2_DB7 = 1445,
	FN_LCDOUT23 = 1446,
	FN_HRX0_C = 1447,
	FN_MSIOF0_SS1 = 1448,
	FN_ADICHS0 = 1449,
	FN_DU2_DG5 = 1450,
	FN_LCDOUT13 = 1451,
	FN_MSIOF0_TXD = 1452,
	FN_ADICHS1 = 1453,
	FN_DU2_DG6 = 1454,
	FN_LCDOUT14 = 1455,
	FN_MSIOF0_SS2 = 1456,
	FN_AUDIO_CLKOUT = 1457,
	FN_ADICHS2 = 1458,
	FN_DU2_DISP = 1459,
	FN_QPOLA = 1460,
	FN_HTX0_C = 1461,
	FN_SCIFA2_TXD_B = 1462,
	FN_MSIOF0_RXD = 1463,
	FN_TS_SPSYNC0 = 1464,
	FN_SSI_WS2 = 1465,
	FN_ADICS_SAMP = 1466,
	FN_DU2_CDE = 1467,
	FN_QPOLB = 1468,
	FN_SCIFA2_RXD_B = 1469,
	FN_USB1_PWEN = 1470,
	FN_AUDIO_CLKOUT_D = 1471,
	FN_USB1_OVC = 1472,
	FN_TCLK1_B = 1473,
	FN_SEL_SCIF1_0 = 1474,
	FN_SEL_SCIF1_1 = 1475,
	FN_SEL_SCIF1_2 = 1476,
	FN_SEL_SCIF1_3 = 1477,
	FN_SEL_SCIF1_4 = 1478,
	FN_SEL_SCIFB_0 = 1479,
	FN_SEL_SCIFB_1 = 1480,
	FN_SEL_SCIFB_2 = 1481,
	FN_SEL_SCIFB2_0 = 1482,
	FN_SEL_SCIFB2_1 = 1483,
	FN_SEL_SCIFB2_2 = 1484,
	FN_SEL_SCIFB1_0 = 1485,
	FN_SEL_SCIFB1_1 = 1486,
	FN_SEL_SCIFB1_2 = 1487,
	FN_SEL_SCIFB1_3 = 1488,
	FN_SEL_SCIFB1_4 = 1489,
	FN_SEL_SCIFB1_5 = 1490,
	FN_SEL_SCIFB1_6 = 1491,
	FN_SEL_SCIFA1_0 = 1492,
	FN_SEL_SCIFA1_1 = 1493,
	FN_SEL_SCIFA1_2 = 1494,
	FN_SEL_SCIFA1_3 = 1495,
	FN_SEL_SCIF0_0 = 1496,
	FN_SEL_SCIF0_1 = 1497,
	FN_SEL_SCFA_0 = 1498,
	FN_SEL_SCFA_1 = 1499,
	FN_SEL_SOF1_0 = 1500,
	FN_SEL_SOF1_1 = 1501,
	FN_SEL_SSI7_0 = 1502,
	FN_SEL_SSI7_1 = 1503,
	FN_SEL_SSI7_2 = 1504,
	FN_SEL_SSI6_0 = 1505,
	FN_SEL_SSI6_1 = 1506,
	FN_SEL_SSI5_0 = 1507,
	FN_SEL_SSI5_1 = 1508,
	FN_SEL_SSI5_2 = 1509,
	FN_SEL_VI3_0 = 1510,
	FN_SEL_VI3_1 = 1511,
	FN_SEL_VI2_0 = 1512,
	FN_SEL_VI2_1 = 1513,
	FN_SEL_VI1_0 = 1514,
	FN_SEL_VI1_1 = 1515,
	FN_SEL_VI0_0 = 1516,
	FN_SEL_VI0_1 = 1517,
	FN_SEL_TSIF1_0 = 1518,
	FN_SEL_TSIF1_1 = 1519,
	FN_SEL_TSIF1_2 = 1520,
	FN_SEL_LBS_0 = 1521,
	FN_SEL_LBS_1 = 1522,
	FN_SEL_TSIF0_0 = 1523,
	FN_SEL_TSIF0_1 = 1524,
	FN_SEL_TSIF0_2 = 1525,
	FN_SEL_TSIF0_3 = 1526,
	FN_SEL_SOF3_0 = 1527,
	FN_SEL_SOF3_1 = 1528,
	FN_SEL_SOF0_0 = 1529,
	FN_SEL_SOF0_1 = 1530,
	FN_SEL_TMU1_0 = 1531,
	FN_SEL_TMU1_1 = 1532,
	FN_SEL_HSCIF1_0 = 1533,
	FN_SEL_HSCIF1_1 = 1534,
	FN_SEL_SCIFCLK_0 = 1535,
	FN_SEL_SCIFCLK_1 = 1536,
	FN_SEL_CAN0_0 = 1537,
	FN_SEL_CAN0_1 = 1538,
	FN_SEL_CAN0_2 = 1539,
	FN_SEL_CAN0_3 = 1540,
	FN_SEL_CANCLK_0 = 1541,
	FN_SEL_CANCLK_1 = 1542,
	FN_SEL_SCIFA2_0 = 1543,
	FN_SEL_SCIFA2_1 = 1544,
	FN_SEL_SCIFA2_2 = 1545,
	FN_SEL_CAN1_0 = 1546,
	FN_SEL_CAN1_1 = 1547,
	FN_SEL_SCIF2_0 = 1548,
	FN_SEL_SCIF2_1 = 1549,
	FN_SEL_ADI_0 = 1550,
	FN_SEL_ADI_1 = 1551,
	FN_SEL_SSP_0 = 1552,
	FN_SEL_SSP_1 = 1553,
	FN_SEL_FM_0 = 1554,
	FN_SEL_FM_1 = 1555,
	FN_SEL_FM_2 = 1556,
	FN_SEL_FM_3 = 1557,
	FN_SEL_FM_4 = 1558,
	FN_SEL_FM_5 = 1559,
	FN_SEL_FM_6 = 1560,
	FN_SEL_HSCIF0_0 = 1561,
	FN_SEL_HSCIF0_1 = 1562,
	FN_SEL_HSCIF0_2 = 1563,
	FN_SEL_HSCIF0_3 = 1564,
	FN_SEL_HSCIF0_4 = 1565,
	FN_SEL_HSCIF0_5 = 1566,
	FN_SEL_GPS_0 = 1567,
	FN_SEL_GPS_1 = 1568,
	FN_SEL_GPS_2 = 1569,
	FN_SEL_SIM_0 = 1570,
	FN_SEL_SIM_1 = 1571,
	FN_SEL_SIM_2 = 1572,
	FN_SEL_SSI8_0 = 1573,
	FN_SEL_SSI8_1 = 1574,
	FN_SEL_SSI8_2 = 1575,
	FN_SEL_IICDVFS_0 = 1576,
	FN_SEL_IICDVFS_1 = 1577,
	FN_SEL_IIC0_0 = 1578,
	FN_SEL_IIC0_1 = 1579,
	FN_SEL_IEB_0 = 1580,
	FN_SEL_IEB_1 = 1581,
	FN_SEL_IEB_2 = 1582,
	FN_SEL_IIC2_0 = 1583,
	FN_SEL_IIC2_1 = 1584,
	FN_SEL_IIC2_2 = 1585,
	FN_SEL_IIC2_3 = 1586,
	FN_SEL_IIC2_4 = 1587,
	FN_SEL_IIC1_0 = 1588,
	FN_SEL_IIC1_1 = 1589,
	FN_SEL_IIC1_2 = 1590,
	FN_SEL_I2C2_0 = 1591,
	FN_SEL_I2C2_1 = 1592,
	FN_SEL_I2C2_2 = 1593,
	FN_SEL_I2C2_3 = 1594,
	FN_SEL_I2C2_4 = 1595,
	FN_SEL_I2C1_0 = 1596,
	FN_SEL_I2C1_1 = 1597,
	FN_SEL_I2C1_2 = 1598,
	PINMUX_FUNCTION_END___4 = 1599,
	PINMUX_MARK_BEGIN___4 = 1600,
	VI1_DATA7_VI1_B7_MARK = 1601,
	USB0_PWEN_MARK = 1602,
	USB0_OVC_VBUS_MARK = 1603,
	USB2_PWEN_MARK = 1604,
	USB2_OVC_MARK = 1605,
	AVS1_MARK = 1606,
	AVS2_MARK = 1607,
	DU_DOTCLKIN0_MARK = 1608,
	DU_DOTCLKIN2_MARK = 1609,
	D0_MARK___2 = 1610,
	MSIOF3_SCK_B_MARK = 1611,
	VI3_DATA0_MARK = 1612,
	VI0_G4_MARK = 1613,
	VI0_G4_B_MARK = 1614,
	D1_MARK___2 = 1615,
	MSIOF3_SYNC_B_MARK = 1616,
	VI3_DATA1_MARK = 1617,
	VI0_G5_MARK = 1618,
	VI0_G5_B_MARK = 1619,
	D2_MARK___2 = 1620,
	MSIOF3_RXD_B_MARK = 1621,
	VI3_DATA2_MARK = 1622,
	VI0_G6_MARK = 1623,
	VI0_G6_B_MARK = 1624,
	D3_MARK___2 = 1625,
	MSIOF3_TXD_B_MARK = 1626,
	VI3_DATA3_MARK = 1627,
	VI0_G7_MARK = 1628,
	VI0_G7_B_MARK = 1629,
	D4_MARK___2 = 1630,
	SCIFB1_RXD_F_MARK = 1631,
	SCIFB0_RXD_C_MARK = 1632,
	VI3_DATA4_MARK = 1633,
	VI0_R0_MARK = 1634,
	VI0_R0_B_MARK = 1635,
	RX0_B_MARK = 1636,
	D5_MARK___2 = 1637,
	SCIFB1_TXD_F_MARK = 1638,
	SCIFB0_TXD_C_MARK = 1639,
	VI3_DATA5_MARK = 1640,
	VI0_R1_MARK = 1641,
	VI0_R1_B_MARK = 1642,
	TX0_B_MARK = 1643,
	D6_MARK___2 = 1644,
	IIC2_SCL_C_MARK = 1645,
	VI3_DATA6_MARK = 1646,
	VI0_R2_MARK = 1647,
	VI0_R2_B_MARK = 1648,
	I2C2_SCL_C_MARK = 1649,
	D7_MARK___2 = 1650,
	AD_DI_B_MARK = 1651,
	IIC2_SDA_C_MARK = 1652,
	VI3_DATA7_MARK = 1653,
	VI0_R3_MARK = 1654,
	VI0_R3_B_MARK = 1655,
	I2C2_SDA_C_MARK = 1656,
	TCLK1_MARK = 1657,
	D8_MARK___2 = 1658,
	SCIFA1_SCK_C_MARK = 1659,
	AVB_TXD0_MARK = 1660,
	VI0_G0_MARK = 1661,
	VI0_G0_B_MARK = 1662,
	VI2_DATA0_VI2_B0_MARK = 1663,
	D9_MARK___2 = 1664,
	SCIFA1_RXD_C_MARK = 1665,
	AVB_TXD1_MARK = 1666,
	VI0_G1_MARK = 1667,
	VI0_G1_B_MARK = 1668,
	VI2_DATA1_VI2_B1_MARK = 1669,
	D10_MARK___2 = 1670,
	SCIFA1_TXD_C_MARK = 1671,
	AVB_TXD2_MARK = 1672,
	VI0_G2_MARK = 1673,
	VI0_G2_B_MARK = 1674,
	VI2_DATA2_VI2_B2_MARK = 1675,
	D11_MARK___2 = 1676,
	SCIFA1_CTS_N_C_MARK = 1677,
	AVB_TXD3_MARK = 1678,
	VI0_G3_MARK = 1679,
	VI0_G3_B_MARK = 1680,
	VI2_DATA3_VI2_B3_MARK = 1681,
	D12_MARK___2 = 1682,
	SCIFA1_RTS_N_C_MARK = 1683,
	AVB_TXD4_MARK = 1684,
	VI0_HSYNC_N_MARK = 1685,
	VI0_HSYNC_N_B_MARK = 1686,
	VI2_DATA4_VI2_B4_MARK = 1687,
	D13_MARK___2 = 1688,
	AVB_TXD5_MARK = 1689,
	VI0_VSYNC_N_MARK = 1690,
	VI0_VSYNC_N_B_MARK = 1691,
	VI2_DATA5_VI2_B5_MARK = 1692,
	D14_MARK___2 = 1693,
	SCIFB1_RXD_C_MARK = 1694,
	AVB_TXD6_MARK = 1695,
	RX1_B_MARK = 1696,
	VI0_CLKENB_MARK = 1697,
	VI0_CLKENB_B_MARK = 1698,
	VI2_DATA6_VI2_B6_MARK = 1699,
	D15_MARK___2 = 1700,
	SCIFB1_TXD_C_MARK = 1701,
	AVB_TXD7_MARK = 1702,
	TX1_B_MARK = 1703,
	VI0_FIELD_MARK = 1704,
	VI0_FIELD_B_MARK = 1705,
	VI2_DATA7_VI2_B7_MARK = 1706,
	A0_MARK___3 = 1707,
	PWM3_MARK = 1708,
	A1_MARK___3 = 1709,
	PWM4_MARK = 1710,
	A2_MARK___3 = 1711,
	PWM5_MARK = 1712,
	MSIOF1_SS1_B_MARK = 1713,
	A3_MARK___3 = 1714,
	PWM6_MARK = 1715,
	MSIOF1_SS2_B_MARK = 1716,
	A4_MARK___2 = 1717,
	MSIOF1_TXD_B_MARK = 1718,
	TPU0TO0_MARK___3 = 1719,
	A5_MARK___2 = 1720,
	SCIFA1_TXD_B_MARK = 1721,
	TPU0TO1_MARK___3 = 1722,
	A6_MARK___3 = 1723,
	SCIFA1_RTS_N_B_MARK = 1724,
	TPU0TO2_MARK___2 = 1725,
	A7_MARK___3 = 1726,
	SCIFA1_SCK_B_MARK = 1727,
	AUDIO_CLKOUT_B_MARK = 1728,
	TPU0TO3_MARK___3 = 1729,
	A8_MARK___3 = 1730,
	SCIFA1_RXD_B_MARK = 1731,
	SSI_SCK5_B_MARK = 1732,
	VI0_R4_MARK = 1733,
	VI0_R4_B_MARK = 1734,
	SCIFB2_RXD_C_MARK = 1735,
	RX2_B_MARK = 1736,
	VI2_DATA0_VI2_B0_B_MARK = 1737,
	A9_MARK___3 = 1738,
	SCIFA1_CTS_N_B_MARK = 1739,
	SSI_WS5_B_MARK = 1740,
	VI0_R5_MARK = 1741,
	VI0_R5_B_MARK = 1742,
	SCIFB2_TXD_C_MARK = 1743,
	TX2_B_MARK = 1744,
	VI2_DATA1_VI2_B1_B_MARK = 1745,
	A10_MARK___3 = 1746,
	SSI_SDATA5_B_MARK = 1747,
	MSIOF2_SYNC_MARK___2 = 1748,
	VI0_R6_MARK = 1749,
	VI0_R6_B_MARK = 1750,
	VI2_DATA2_VI2_B2_B_MARK = 1751,
	A11_MARK___2 = 1752,
	SCIFB2_CTS_N_B_MARK = 1753,
	MSIOF2_SCK_MARK___2 = 1754,
	VI1_R0_MARK = 1755,
	VI1_R0_B_MARK = 1756,
	VI2_G0_MARK = 1757,
	VI2_DATA3_VI2_B3_B_MARK = 1758,
	A12_MARK___2 = 1759,
	SCIFB2_RXD_B_MARK = 1760,
	MSIOF2_TXD_MARK___3 = 1761,
	VI1_R1_MARK = 1762,
	VI1_R1_B_MARK = 1763,
	VI2_G1_MARK = 1764,
	VI2_DATA4_VI2_B4_B_MARK = 1765,
	A13_MARK___2 = 1766,
	SCIFB2_RTS_N_B_MARK = 1767,
	EX_WAIT2_MARK = 1768,
	MSIOF2_RXD_MARK___3 = 1769,
	VI1_R2_MARK = 1770,
	VI1_R2_B_MARK = 1771,
	VI2_G2_MARK = 1772,
	VI2_DATA5_VI2_B5_B_MARK = 1773,
	A14_MARK___2 = 1774,
	SCIFB2_TXD_B_MARK = 1775,
	ATACS11_N_MARK = 1776,
	MSIOF2_SS1_MARK___3 = 1777,
	A15_MARK___2 = 1778,
	SCIFB2_SCK_B_MARK = 1779,
	ATARD1_N_MARK = 1780,
	MSIOF2_SS2_MARK___3 = 1781,
	A16_MARK___2 = 1782,
	ATAWR1_N_MARK = 1783,
	A17_MARK___2 = 1784,
	AD_DO_B_MARK = 1785,
	ATADIR1_N_MARK = 1786,
	A18_MARK___2 = 1787,
	AD_CLK_B_MARK = 1788,
	ATAG1_N_MARK = 1789,
	A19_MARK___2 = 1790,
	AD_NCS_N_B_MARK = 1791,
	ATACS01_N_MARK = 1792,
	EX_WAIT0_B_MARK = 1793,
	A20_MARK___2 = 1794,
	SPCLK_MARK = 1795,
	VI1_R3_MARK = 1796,
	VI1_R3_B_MARK = 1797,
	VI2_G4_MARK = 1798,
	A21_MARK___2 = 1799,
	MOSI_IO0_MARK = 1800,
	VI1_R4_MARK = 1801,
	VI1_R4_B_MARK = 1802,
	VI2_G5_MARK = 1803,
	A22_MARK___2 = 1804,
	MISO_IO1_MARK = 1805,
	VI1_R5_MARK = 1806,
	VI1_R5_B_MARK = 1807,
	VI2_G6_MARK = 1808,
	A23_MARK___2 = 1809,
	IO2_MARK = 1810,
	VI1_G7_MARK = 1811,
	VI1_G7_B_MARK = 1812,
	VI2_G7_MARK = 1813,
	A24_MARK___2 = 1814,
	IO3_MARK = 1815,
	VI1_R7_MARK = 1816,
	VI1_R7_B_MARK = 1817,
	VI2_CLKENB_MARK = 1818,
	VI2_CLKENB_B_MARK = 1819,
	A25_MARK___2 = 1820,
	SSL_MARK = 1821,
	VI1_G6_MARK = 1822,
	VI1_G6_B_MARK = 1823,
	VI2_FIELD_MARK = 1824,
	VI2_FIELD_B_MARK = 1825,
	CS0_N_MARK___2 = 1826,
	VI1_R6_MARK = 1827,
	VI1_R6_B_MARK = 1828,
	VI2_G3_MARK = 1829,
	MSIOF0_SS2_B_MARK = 1830,
	CS1_N_A26_MARK = 1831,
	SPEEDIN_MARK = 1832,
	VI0_R7_MARK = 1833,
	VI0_R7_B_MARK = 1834,
	VI2_CLK_MARK = 1835,
	VI2_CLK_B_MARK = 1836,
	EX_CS0_N_MARK = 1837,
	HRX1_B_MARK = 1838,
	VI1_G5_MARK = 1839,
	VI1_G5_B_MARK = 1840,
	VI2_R0_MARK = 1841,
	HTX0_B_MARK = 1842,
	MSIOF0_SS1_B_MARK = 1843,
	EX_CS1_N_MARK = 1844,
	GPS_CLK_MARK = 1845,
	HCTS1_N_B_MARK = 1846,
	VI1_FIELD_MARK = 1847,
	VI1_FIELD_B_MARK = 1848,
	VI2_R1_MARK = 1849,
	EX_CS2_N_MARK = 1850,
	GPS_SIGN_MARK = 1851,
	HRTS1_N_B_MARK = 1852,
	VI3_CLKENB_MARK = 1853,
	VI1_G0_MARK = 1854,
	VI1_G0_B_MARK = 1855,
	VI2_R2_MARK = 1856,
	EX_CS3_N_MARK = 1857,
	GPS_MAG_MARK = 1858,
	VI3_FIELD_MARK = 1859,
	VI1_G1_MARK = 1860,
	VI1_G1_B_MARK = 1861,
	VI2_R3_MARK = 1862,
	EX_CS4_N_MARK = 1863,
	MSIOF1_SCK_B_MARK = 1864,
	VI3_HSYNC_N_MARK = 1865,
	VI2_HSYNC_N_MARK = 1866,
	IIC1_SCL_MARK___2 = 1867,
	VI2_HSYNC_N_B_MARK = 1868,
	INTC_EN0_N_MARK = 1869,
	I2C1_SCL_MARK = 1870,
	EX_CS5_N_MARK = 1871,
	CAN0_RX_MARK = 1872,
	MSIOF1_RXD_B_MARK = 1873,
	VI3_VSYNC_N_MARK = 1874,
	VI1_G2_MARK = 1875,
	VI1_G2_B_MARK = 1876,
	VI2_R4_MARK = 1877,
	IIC1_SDA_MARK___2 = 1878,
	INTC_EN1_N_MARK = 1879,
	I2C1_SDA_MARK = 1880,
	BS_N_MARK = 1881,
	IETX_MARK = 1882,
	HTX1_B_MARK = 1883,
	CAN1_TX_MARK = 1884,
	DRACK0_MARK = 1885,
	IETX_C_MARK = 1886,
	RD_N_MARK___2 = 1887,
	CAN0_TX_MARK = 1888,
	SCIFA0_SCK_B_MARK = 1889,
	RD_WR_N_MARK = 1890,
	VI1_G3_MARK = 1891,
	VI1_G3_B_MARK = 1892,
	VI2_R5_MARK = 1893,
	SCIFA0_RXD_B_MARK = 1894,
	INTC_IRQ4_N_MARK = 1895,
	WE0_N_MARK___2 = 1896,
	IECLK_MARK = 1897,
	CAN_CLK_MARK = 1898,
	VI2_VSYNC_N_MARK = 1899,
	SCIFA0_TXD_B_MARK = 1900,
	VI2_VSYNC_N_B_MARK = 1901,
	WE1_N_MARK___2 = 1902,
	IERX_MARK = 1903,
	CAN1_RX_MARK = 1904,
	VI1_G4_MARK = 1905,
	VI1_G4_B_MARK = 1906,
	VI2_R6_MARK = 1907,
	SCIFA0_CTS_N_B_MARK = 1908,
	IERX_C_MARK = 1909,
	EX_WAIT0_MARK = 1910,
	IRQ3_MARK___2 = 1911,
	INTC_IRQ3_N_MARK = 1912,
	VI3_CLK_MARK = 1913,
	SCIFA0_RTS_N_B_MARK = 1914,
	HRX0_B_MARK = 1915,
	MSIOF0_SCK_B_MARK = 1916,
	DREQ0_N_MARK = 1917,
	VI1_HSYNC_N_MARK = 1918,
	VI1_HSYNC_N_B_MARK = 1919,
	VI2_R7_MARK = 1920,
	SSI_SCK78_C_MARK = 1921,
	SSI_WS78_B_MARK = 1922,
	DACK0_MARK___2 = 1923,
	IRQ0_MARK___2 = 1924,
	INTC_IRQ0_N_MARK = 1925,
	SSI_SCK6_B_MARK = 1926,
	VI1_VSYNC_N_MARK = 1927,
	VI1_VSYNC_N_B_MARK = 1928,
	SSI_WS78_C_MARK = 1929,
	DREQ1_N_MARK = 1930,
	VI1_CLKENB_MARK = 1931,
	VI1_CLKENB_B_MARK = 1932,
	SSI_SDATA7_C_MARK = 1933,
	SSI_SCK78_B_MARK = 1934,
	DACK1_MARK___2 = 1935,
	IRQ1_MARK___3 = 1936,
	INTC_IRQ1_N_MARK = 1937,
	SSI_WS6_B_MARK = 1938,
	SSI_SDATA8_C_MARK = 1939,
	DREQ2_N_MARK = 1940,
	HSCK1_B_MARK = 1941,
	HCTS0_N_B_MARK = 1942,
	MSIOF0_TXD_B_MARK = 1943,
	DACK2_MARK = 1944,
	IRQ2_MARK___2 = 1945,
	INTC_IRQ2_N_MARK = 1946,
	SSI_SDATA6_B_MARK = 1947,
	HRTS0_N_B_MARK = 1948,
	MSIOF0_RXD_B_MARK = 1949,
	ETH_CRS_DV_MARK = 1950,
	STP_ISCLK_0_B_MARK = 1951,
	TS_SDEN0_D_MARK = 1952,
	GLO_Q0_C_MARK = 1953,
	IIC2_SCL_E_MARK = 1954,
	I2C2_SCL_E_MARK = 1955,
	ETH_RX_ER_MARK = 1956,
	STP_ISD_0_B_MARK = 1957,
	TS_SPSYNC0_D_MARK = 1958,
	GLO_Q1_C_MARK = 1959,
	IIC2_SDA_E_MARK = 1960,
	I2C2_SDA_E_MARK = 1961,
	ETH_RXD0_MARK = 1962,
	STP_ISEN_0_B_MARK = 1963,
	TS_SDAT0_D_MARK = 1964,
	GLO_I0_C_MARK = 1965,
	SCIFB1_SCK_G_MARK = 1966,
	SCK1_E_MARK = 1967,
	ETH_RXD1_MARK = 1968,
	HRX0_E_MARK = 1969,
	STP_ISSYNC_0_B_MARK = 1970,
	TS_SCK0_D_MARK = 1971,
	GLO_I1_C_MARK = 1972,
	SCIFB1_RXD_G_MARK = 1973,
	RX1_E_MARK = 1974,
	ETH_LINK_MARK = 1975,
	HTX0_E_MARK = 1976,
	STP_IVCXO27_0_B_MARK = 1977,
	SCIFB1_TXD_G_MARK = 1978,
	TX1_E_MARK = 1979,
	ETH_REF_CLK_MARK = 1980,
	HCTS0_N_E_MARK = 1981,
	STP_IVCXO27_1_B_MARK = 1982,
	HRX0_F_MARK = 1983,
	ETH_MDIO_MARK = 1984,
	HRTS0_N_E_MARK = 1985,
	SIM0_D_C_MARK = 1986,
	HCTS0_N_F_MARK = 1987,
	ETH_TXD1_MARK = 1988,
	HTX0_F_MARK = 1989,
	BPFCLK_G_MARK = 1990,
	ETH_TX_EN_MARK = 1991,
	SIM0_CLK_C_MARK = 1992,
	HRTS0_N_F_MARK = 1993,
	ETH_MAGIC_MARK = 1994,
	SIM0_RST_C_MARK = 1995,
	ETH_TXD0_MARK = 1996,
	STP_ISCLK_1_B_MARK = 1997,
	TS_SDEN1_C_MARK = 1998,
	GLO_SCLK_C_MARK = 1999,
	ETH_MDC_MARK = 2000,
	STP_ISD_1_B_MARK = 2001,
	TS_SPSYNC1_C_MARK = 2002,
	GLO_SDATA_C_MARK = 2003,
	PWM0_MARK___2 = 2004,
	SCIFA2_SCK_C_MARK = 2005,
	STP_ISEN_1_B_MARK = 2006,
	TS_SDAT1_C_MARK = 2007,
	GLO_SS_C_MARK = 2008,
	PWM1_MARK___2 = 2009,
	SCIFA2_TXD_C_MARK = 2010,
	STP_ISSYNC_1_B_MARK = 2011,
	TS_SCK1_C_MARK = 2012,
	GLO_RFON_C_MARK = 2013,
	PCMOE_N_MARK = 2014,
	PWM2_MARK = 2015,
	PWMFSW0_MARK = 2016,
	SCIFA2_RXD_C_MARK = 2017,
	PCMWE_N_MARK = 2018,
	IECLK_C_MARK = 2019,
	DU_DOTCLKIN1_MARK = 2020,
	AUDIO_CLKC_MARK = 2021,
	AUDIO_CLKOUT_C_MARK = 2022,
	VI0_CLK_MARK = 2023,
	ATACS00_N_MARK = 2024,
	AVB_RXD1_MARK = 2025,
	VI0_DATA0_VI0_B0_MARK = 2026,
	ATACS10_N_MARK = 2027,
	AVB_RXD2_MARK = 2028,
	VI0_DATA1_VI0_B1_MARK = 2029,
	ATARD0_N_MARK = 2030,
	AVB_RXD3_MARK = 2031,
	VI0_DATA2_VI0_B2_MARK = 2032,
	ATAWR0_N_MARK = 2033,
	AVB_RXD4_MARK = 2034,
	VI0_DATA3_VI0_B3_MARK = 2035,
	ATADIR0_N_MARK = 2036,
	AVB_RXD5_MARK = 2037,
	VI0_DATA4_VI0_B4_MARK = 2038,
	ATAG0_N_MARK = 2039,
	AVB_RXD6_MARK = 2040,
	VI0_DATA5_VI0_B5_MARK = 2041,
	EX_WAIT1_MARK = 2042,
	AVB_RXD7_MARK = 2043,
	VI0_DATA6_VI0_B6_MARK = 2044,
	AVB_RX_ER_MARK = 2045,
	VI0_DATA7_VI0_B7_MARK = 2046,
	AVB_RX_CLK_MARK = 2047,
	VI1_CLK_MARK = 2048,
	AVB_RX_DV_MARK = 2049,
	VI1_DATA0_VI1_B0_MARK = 2050,
	SCIFA1_SCK_D_MARK = 2051,
	AVB_CRS_MARK = 2052,
	VI1_DATA1_VI1_B1_MARK = 2053,
	SCIFA1_RXD_D_MARK = 2054,
	AVB_MDC_MARK = 2055,
	VI1_DATA2_VI1_B2_MARK = 2056,
	SCIFA1_TXD_D_MARK = 2057,
	AVB_MDIO_MARK = 2058,
	VI1_DATA3_VI1_B3_MARK = 2059,
	SCIFA1_CTS_N_D_MARK = 2060,
	AVB_GTX_CLK_MARK = 2061,
	VI1_DATA4_VI1_B4_MARK = 2062,
	SCIFA1_RTS_N_D_MARK = 2063,
	AVB_MAGIC_MARK = 2064,
	VI1_DATA5_VI1_B5_MARK = 2065,
	AVB_PHY_INT_MARK = 2066,
	VI1_DATA6_VI1_B6_MARK = 2067,
	AVB_GTXREFCLK_MARK = 2068,
	SD0_CLK_MARK = 2069,
	VI1_DATA0_VI1_B0_B_MARK = 2070,
	SD0_CMD_MARK = 2071,
	SCIFB1_SCK_B_MARK = 2072,
	VI1_DATA1_VI1_B1_B_MARK = 2073,
	SD0_DAT0_MARK = 2074,
	SCIFB1_RXD_B_MARK = 2075,
	VI1_DATA2_VI1_B2_B_MARK = 2076,
	SD0_DAT1_MARK = 2077,
	SCIFB1_TXD_B_MARK = 2078,
	VI1_DATA3_VI1_B3_B_MARK = 2079,
	SD0_DAT2_MARK = 2080,
	SCIFB1_CTS_N_B_MARK = 2081,
	VI1_DATA4_VI1_B4_B_MARK = 2082,
	SD0_DAT3_MARK = 2083,
	SCIFB1_RTS_N_B_MARK = 2084,
	VI1_DATA5_VI1_B5_B_MARK = 2085,
	SD0_CD_MARK = 2086,
	MMC0_D6_MARK = 2087,
	TS_SDEN0_B_MARK = 2088,
	USB0_EXTP_MARK = 2089,
	GLO_SCLK_MARK = 2090,
	VI1_DATA6_VI1_B6_B_MARK = 2091,
	IIC1_SCL_B_MARK = 2092,
	I2C1_SCL_B_MARK = 2093,
	VI2_DATA6_VI2_B6_B_MARK = 2094,
	SD0_WP_MARK = 2095,
	MMC0_D7_MARK = 2096,
	TS_SPSYNC0_B_MARK = 2097,
	USB0_IDIN_MARK = 2098,
	GLO_SDATA_MARK = 2099,
	VI1_DATA7_VI1_B7_B_MARK = 2100,
	IIC1_SDA_B_MARK = 2101,
	I2C1_SDA_B_MARK = 2102,
	VI2_DATA7_VI2_B7_B_MARK = 2103,
	SD1_CLK_MARK = 2104,
	AVB_TX_EN_MARK = 2105,
	SD1_CMD_MARK = 2106,
	AVB_TX_ER_MARK = 2107,
	SCIFB0_SCK_B_MARK = 2108,
	SD1_DAT0_MARK = 2109,
	AVB_TX_CLK_MARK = 2110,
	SCIFB0_RXD_B_MARK = 2111,
	SD1_DAT1_MARK = 2112,
	AVB_LINK_MARK = 2113,
	SCIFB0_TXD_B_MARK = 2114,
	SD1_DAT2_MARK = 2115,
	AVB_COL_MARK = 2116,
	SCIFB0_CTS_N_B_MARK = 2117,
	SD1_DAT3_MARK = 2118,
	AVB_RXD0_MARK = 2119,
	SCIFB0_RTS_N_B_MARK = 2120,
	SD1_CD_MARK = 2121,
	MMC1_D6_MARK = 2122,
	TS_SDEN1_MARK = 2123,
	USB1_EXTP_MARK = 2124,
	GLO_SS_MARK = 2125,
	VI0_CLK_B_MARK = 2126,
	IIC2_SCL_D_MARK = 2127,
	I2C2_SCL_D_MARK = 2128,
	SIM0_CLK_B_MARK = 2129,
	VI3_CLK_B_MARK = 2130,
	SD1_WP_MARK = 2131,
	MMC1_D7_MARK = 2132,
	TS_SPSYNC1_MARK = 2133,
	USB1_IDIN_MARK = 2134,
	GLO_RFON_MARK = 2135,
	VI1_CLK_B_MARK = 2136,
	IIC2_SDA_D_MARK = 2137,
	I2C2_SDA_D_MARK = 2138,
	SIM0_D_B_MARK = 2139,
	SD2_CLK_MARK = 2140,
	MMC0_CLK_MARK = 2141,
	SIM0_CLK_MARK___2 = 2142,
	VI0_DATA0_VI0_B0_B_MARK = 2143,
	TS_SDEN0_C_MARK = 2144,
	GLO_SCLK_B_MARK = 2145,
	VI3_DATA0_B_MARK = 2146,
	SD2_CMD_MARK = 2147,
	MMC0_CMD_MARK = 2148,
	SIM0_D_MARK = 2149,
	VI0_DATA1_VI0_B1_B_MARK = 2150,
	SCIFB1_SCK_E_MARK = 2151,
	SCK1_D_MARK = 2152,
	TS_SPSYNC0_C_MARK = 2153,
	GLO_SDATA_B_MARK = 2154,
	VI3_DATA1_B_MARK = 2155,
	SD2_DAT0_MARK = 2156,
	MMC0_D0_MARK = 2157,
	FMCLK_B_MARK = 2158,
	VI0_DATA2_VI0_B2_B_MARK = 2159,
	SCIFB1_RXD_E_MARK = 2160,
	RX1_D_MARK = 2161,
	TS_SDAT0_C_MARK = 2162,
	GLO_SS_B_MARK = 2163,
	VI3_DATA2_B_MARK = 2164,
	SD2_DAT1_MARK = 2165,
	MMC0_D1_MARK = 2166,
	FMIN_B_MARK = 2167,
	VI0_DATA3_VI0_B3_B_MARK = 2168,
	SCIFB1_TXD_E_MARK = 2169,
	TX1_D_MARK = 2170,
	TS_SCK0_C_MARK = 2171,
	GLO_RFON_B_MARK = 2172,
	VI3_DATA3_B_MARK = 2173,
	SD2_DAT2_MARK = 2174,
	MMC0_D2_MARK = 2175,
	BPFCLK_B_MARK = 2176,
	VI0_DATA4_VI0_B4_B_MARK = 2177,
	HRX0_D_MARK = 2178,
	TS_SDEN1_B_MARK = 2179,
	GLO_Q0_B_MARK = 2180,
	VI3_DATA4_B_MARK = 2181,
	SD2_DAT3_MARK = 2182,
	MMC0_D3_MARK = 2183,
	SIM0_RST_MARK___2 = 2184,
	VI0_DATA5_VI0_B5_B_MARK = 2185,
	HTX0_D_MARK = 2186,
	TS_SPSYNC1_B_MARK = 2187,
	GLO_Q1_B_MARK = 2188,
	VI3_DATA5_B_MARK = 2189,
	SD2_CD_MARK = 2190,
	MMC0_D4_MARK = 2191,
	TS_SDAT0_B_MARK = 2192,
	USB2_EXTP_MARK = 2193,
	GLO_I0_MARK = 2194,
	VI0_DATA6_VI0_B6_B_MARK = 2195,
	HCTS0_N_D_MARK = 2196,
	TS_SDAT1_B_MARK = 2197,
	GLO_I0_B_MARK = 2198,
	VI3_DATA6_B_MARK = 2199,
	SD2_WP_MARK = 2200,
	MMC0_D5_MARK = 2201,
	TS_SCK0_B_MARK = 2202,
	USB2_IDIN_MARK = 2203,
	GLO_I1_MARK = 2204,
	VI0_DATA7_VI0_B7_B_MARK = 2205,
	HRTS0_N_D_MARK = 2206,
	TS_SCK1_B_MARK = 2207,
	GLO_I1_B_MARK = 2208,
	VI3_DATA7_B_MARK = 2209,
	SD3_CLK_MARK = 2210,
	MMC1_CLK_MARK = 2211,
	SD3_CMD_MARK = 2212,
	MMC1_CMD_MARK = 2213,
	MTS_N_MARK = 2214,
	SD3_DAT0_MARK = 2215,
	MMC1_D0_MARK = 2216,
	STM_N_MARK = 2217,
	SD3_DAT1_MARK = 2218,
	MMC1_D1_MARK = 2219,
	MDATA_MARK = 2220,
	SD3_DAT2_MARK = 2221,
	MMC1_D2_MARK = 2222,
	SDATA_MARK = 2223,
	SD3_DAT3_MARK = 2224,
	MMC1_D3_MARK = 2225,
	SCKZ_MARK = 2226,
	SD3_CD_MARK = 2227,
	MMC1_D4_MARK = 2228,
	TS_SDAT1_MARK = 2229,
	VSP_MARK = 2230,
	GLO_Q0_MARK = 2231,
	SIM0_RST_B_MARK = 2232,
	SD3_WP_MARK = 2233,
	MMC1_D5_MARK = 2234,
	TS_SCK1_MARK = 2235,
	GLO_Q1_MARK = 2236,
	FMIN_C_MARK = 2237,
	FMIN_E_MARK = 2238,
	FMIN_F_MARK = 2239,
	MLB_CLK_MARK = 2240,
	IIC2_SCL_B_MARK = 2241,
	I2C2_SCL_B_MARK = 2242,
	MLB_SIG_MARK = 2243,
	SCIFB1_RXD_D_MARK = 2244,
	RX1_C_MARK = 2245,
	IIC2_SDA_B_MARK = 2246,
	I2C2_SDA_B_MARK = 2247,
	MLB_DAT_MARK = 2248,
	SCIFB1_TXD_D_MARK = 2249,
	TX1_C_MARK = 2250,
	BPFCLK_C_MARK = 2251,
	SSI_SCK0129_MARK = 2252,
	CAN_CLK_B_MARK = 2253,
	MOUT0_MARK = 2254,
	SSI_WS0129_MARK = 2255,
	CAN0_TX_B_MARK = 2256,
	MOUT1_MARK = 2257,
	SSI_SDATA0_MARK = 2258,
	CAN0_RX_B_MARK = 2259,
	MOUT2_MARK = 2260,
	SSI_SDATA1_MARK = 2261,
	CAN1_TX_B_MARK = 2262,
	MOUT5_MARK = 2263,
	SSI_SDATA2_MARK = 2264,
	CAN1_RX_B_MARK = 2265,
	SSI_SCK1_MARK = 2266,
	MOUT6_MARK = 2267,
	SSI_SCK34_MARK = 2268,
	STP_OPWM_0_MARK___2 = 2269,
	SCIFB0_SCK_MARK___2 = 2270,
	MSIOF1_SCK_MARK___2 = 2271,
	CAN_DEBUG_HW_TRIGGER_MARK = 2272,
	SSI_WS34_MARK = 2273,
	STP_IVCXO27_0_MARK = 2274,
	SCIFB0_RXD_MARK___2 = 2275,
	MSIOF1_SYNC_MARK___2 = 2276,
	CAN_STEP0_MARK = 2277,
	SSI_SDATA3_MARK = 2278,
	STP_ISCLK_0_MARK___2 = 2279,
	SCIFB0_TXD_MARK___2 = 2280,
	MSIOF1_SS1_MARK___2 = 2281,
	CAN_TXCLK_MARK = 2282,
	SSI_SCK4_MARK = 2283,
	STP_ISD_0_MARK___2 = 2284,
	SCIFB0_CTS_N_MARK = 2285,
	MSIOF1_SS2_MARK___2 = 2286,
	SSI_SCK5_C_MARK = 2287,
	CAN_DEBUGOUT0_MARK = 2288,
	SSI_WS4_MARK = 2289,
	STP_ISEN_0_MARK___2 = 2290,
	SCIFB0_RTS_N_MARK = 2291,
	MSIOF1_TXD_MARK___2 = 2292,
	SSI_WS5_C_MARK = 2293,
	CAN_DEBUGOUT1_MARK = 2294,
	SSI_SDATA4_MARK = 2295,
	STP_ISSYNC_0_MARK___2 = 2296,
	MSIOF1_RXD_MARK___2 = 2297,
	CAN_DEBUGOUT2_MARK = 2298,
	SSI_SCK5_MARK = 2299,
	SCIFB1_SCK_MARK = 2300,
	IERX_B_MARK = 2301,
	DU2_EXHSYNC_DU2_HSYNC_MARK = 2302,
	QSTH_QHS_MARK = 2303,
	CAN_DEBUGOUT3_MARK = 2304,
	SSI_WS5_MARK = 2305,
	SCIFB1_RXD_MARK = 2306,
	IECLK_B_MARK = 2307,
	DU2_EXVSYNC_DU2_VSYNC_MARK = 2308,
	QSTB_QHE_MARK = 2309,
	CAN_DEBUGOUT4_MARK = 2310,
	SSI_SDATA5_MARK = 2311,
	SCIFB1_TXD_MARK = 2312,
	IETX_B_MARK = 2313,
	DU2_DR2_MARK = 2314,
	LCDOUT2_MARK = 2315,
	CAN_DEBUGOUT5_MARK = 2316,
	SSI_SCK6_MARK = 2317,
	SCIFB1_CTS_N_MARK = 2318,
	BPFCLK_D_MARK = 2319,
	DU2_DR3_MARK = 2320,
	LCDOUT3_MARK = 2321,
	CAN_DEBUGOUT6_MARK = 2322,
	BPFCLK_F_MARK = 2323,
	SSI_WS6_MARK = 2324,
	SCIFB1_RTS_N_MARK = 2325,
	CAN0_TX_D_MARK = 2326,
	DU2_DR4_MARK = 2327,
	LCDOUT4_MARK = 2328,
	CAN_DEBUGOUT7_MARK = 2329,
	SSI_SDATA6_MARK = 2330,
	FMIN_D_MARK = 2331,
	DU2_DR5_MARK = 2332,
	LCDOUT5_MARK = 2333,
	CAN_DEBUGOUT8_MARK = 2334,
	SSI_SCK78_MARK = 2335,
	STP_IVCXO27_1_MARK = 2336,
	SCK1_MARK = 2337,
	SCIFA1_SCK_MARK___3 = 2338,
	DU2_DR6_MARK = 2339,
	LCDOUT6_MARK = 2340,
	CAN_DEBUGOUT9_MARK = 2341,
	SSI_WS78_MARK = 2342,
	STP_ISCLK_1_MARK___2 = 2343,
	SCIFB2_SCK_MARK = 2344,
	SCIFA2_CTS_N_MARK = 2345,
	DU2_DR7_MARK = 2346,
	LCDOUT7_MARK = 2347,
	CAN_DEBUGOUT10_MARK = 2348,
	SSI_SDATA7_MARK = 2349,
	STP_ISD_1_MARK___2 = 2350,
	SCIFB2_RXD_MARK = 2351,
	SCIFA2_RTS_N_MARK = 2352,
	TCLK2_MARK = 2353,
	QSTVA_QVS_MARK = 2354,
	CAN_DEBUGOUT11_MARK = 2355,
	BPFCLK_E_MARK = 2356,
	SSI_SDATA7_B_MARK = 2357,
	FMIN_G_MARK = 2358,
	SSI_SDATA8_MARK = 2359,
	STP_ISEN_1_MARK___2 = 2360,
	SCIFB2_TXD_MARK = 2361,
	CAN0_TX_C_MARK = 2362,
	CAN_DEBUGOUT12_MARK = 2363,
	SSI_SDATA8_B_MARK = 2364,
	SSI_SDATA9_MARK = 2365,
	STP_ISSYNC_1_MARK___2 = 2366,
	SCIFB2_CTS_N_MARK = 2367,
	SSI_WS1_MARK = 2368,
	SSI_SDATA5_C_MARK = 2369,
	CAN_DEBUGOUT13_MARK = 2370,
	AUDIO_CLKA_MARK = 2371,
	SCIFB2_RTS_N_MARK = 2372,
	CAN_DEBUGOUT14_MARK = 2373,
	AUDIO_CLKB_MARK = 2374,
	SCIF_CLK_MARK = 2375,
	CAN0_RX_D_MARK = 2376,
	DVC_MUTE_MARK = 2377,
	CAN0_RX_C_MARK = 2378,
	CAN_DEBUGOUT15_MARK = 2379,
	REMOCON_MARK = 2380,
	SCIFA0_SCK_MARK___3 = 2381,
	HSCK1_MARK = 2382,
	SCK0_MARK = 2383,
	MSIOF3_SS2_MARK___2 = 2384,
	DU2_DG2_MARK = 2385,
	LCDOUT10_MARK = 2386,
	IIC1_SDA_C_MARK = 2387,
	I2C1_SDA_C_MARK = 2388,
	SCIFA0_RXD_MARK___3 = 2389,
	HRX1_MARK = 2390,
	RX0_MARK = 2391,
	DU2_DR0_MARK = 2392,
	LCDOUT0_MARK = 2393,
	SCIFA0_TXD_MARK___3 = 2394,
	HTX1_MARK = 2395,
	TX0_MARK = 2396,
	DU2_DR1_MARK = 2397,
	LCDOUT1_MARK = 2398,
	SCIFA0_CTS_N_MARK = 2399,
	HCTS1_N_MARK = 2400,
	CTS0_N_MARK = 2401,
	MSIOF3_SYNC_MARK___2 = 2402,
	DU2_DG3_MARK = 2403,
	LCDOUT11_MARK = 2404,
	PWM0_B_MARK = 2405,
	IIC1_SCL_C_MARK = 2406,
	I2C1_SCL_C_MARK = 2407,
	SCIFA0_RTS_N_MARK = 2408,
	HRTS1_N_MARK = 2409,
	RTS0_N_MARK = 2410,
	MSIOF3_SS1_MARK___2 = 2411,
	DU2_DG0_MARK = 2412,
	LCDOUT8_MARK = 2413,
	PWM1_B_MARK = 2414,
	SCIFA1_RXD_MARK___3 = 2415,
	AD_DI_MARK = 2416,
	RX1_MARK = 2417,
	DU2_EXODDF_DU2_ODDF_DISP_CDE_MARK = 2418,
	QCPV_QDE_MARK = 2419,
	SCIFA1_TXD_MARK___3 = 2420,
	AD_DO_MARK = 2421,
	TX1_MARK = 2422,
	DU2_DG1_MARK = 2423,
	LCDOUT9_MARK = 2424,
	SCIFA1_CTS_N_MARK = 2425,
	AD_CLK_MARK = 2426,
	CTS1_N_MARK = 2427,
	MSIOF3_RXD_MARK___2 = 2428,
	DU0_DOTCLKOUT_MARK___2 = 2429,
	QCLK_MARK = 2430,
	SCIFA1_RTS_N_MARK = 2431,
	AD_NCS_N_MARK = 2432,
	RTS1_N_MARK = 2433,
	MSIOF3_TXD_MARK___2 = 2434,
	DU1_DOTCLKOUT_MARK = 2435,
	QSTVB_QVE_MARK = 2436,
	HRTS0_N_C_MARK = 2437,
	SCIFA2_SCK_MARK = 2438,
	FMCLK_MARK = 2439,
	SCK2_MARK = 2440,
	MSIOF3_SCK_MARK___2 = 2441,
	DU2_DG7_MARK = 2442,
	LCDOUT15_MARK = 2443,
	SCIF_CLK_B_MARK = 2444,
	SCIFA2_RXD_MARK___2 = 2445,
	FMIN_MARK = 2446,
	TX2_MARK = 2447,
	DU2_DB0_MARK = 2448,
	LCDOUT16_MARK = 2449,
	IIC2_SCL_MARK = 2450,
	I2C2_SCL_MARK = 2451,
	SCIFA2_TXD_MARK___2 = 2452,
	BPFCLK_MARK = 2453,
	RX2_MARK = 2454,
	DU2_DB1_MARK = 2455,
	LCDOUT17_MARK = 2456,
	IIC2_SDA_MARK = 2457,
	I2C2_SDA_MARK = 2458,
	HSCK0_MARK = 2459,
	TS_SDEN0_MARK = 2460,
	DU2_DG4_MARK = 2461,
	LCDOUT12_MARK = 2462,
	HCTS0_N_C_MARK = 2463,
	HRX0_MARK = 2464,
	DU2_DB2_MARK = 2465,
	LCDOUT18_MARK = 2466,
	HTX0_MARK = 2467,
	DU2_DB3_MARK = 2468,
	LCDOUT19_MARK = 2469,
	HCTS0_N_MARK = 2470,
	SSI_SCK9_MARK = 2471,
	DU2_DB4_MARK = 2472,
	LCDOUT20_MARK = 2473,
	HRTS0_N_MARK = 2474,
	SSI_WS9_MARK = 2475,
	DU2_DB5_MARK = 2476,
	LCDOUT21_MARK = 2477,
	MSIOF0_SCK_MARK___2 = 2478,
	TS_SDAT0_MARK = 2479,
	ADICLK_MARK = 2480,
	DU2_DB6_MARK = 2481,
	LCDOUT22_MARK = 2482,
	MSIOF0_SYNC_MARK___2 = 2483,
	TS_SCK0_MARK = 2484,
	SSI_SCK2_MARK = 2485,
	ADIDATA_MARK = 2486,
	DU2_DB7_MARK = 2487,
	LCDOUT23_MARK = 2488,
	HRX0_C_MARK = 2489,
	MSIOF0_SS1_MARK___3 = 2490,
	ADICHS0_MARK = 2491,
	DU2_DG5_MARK = 2492,
	LCDOUT13_MARK = 2493,
	MSIOF0_TXD_MARK___3 = 2494,
	ADICHS1_MARK = 2495,
	DU2_DG6_MARK = 2496,
	LCDOUT14_MARK = 2497,
	MSIOF0_SS2_MARK___3 = 2498,
	AUDIO_CLKOUT_MARK = 2499,
	ADICHS2_MARK = 2500,
	DU2_DISP_MARK = 2501,
	QPOLA_MARK = 2502,
	HTX0_C_MARK = 2503,
	SCIFA2_TXD_B_MARK = 2504,
	MSIOF0_RXD_MARK___3 = 2505,
	TS_SPSYNC0_MARK = 2506,
	SSI_WS2_MARK = 2507,
	ADICS_SAMP_MARK = 2508,
	DU2_CDE_MARK = 2509,
	QPOLB_MARK = 2510,
	SCIFA2_RXD_B_MARK = 2511,
	USB1_PWEN_MARK = 2512,
	AUDIO_CLKOUT_D_MARK = 2513,
	USB1_OVC_MARK = 2514,
	TCLK1_B_MARK = 2515,
	IIC0_SCL_MARK___2 = 2516,
	IIC0_SDA_MARK___2 = 2517,
	I2C0_SCL_MARK = 2518,
	I2C0_SDA_MARK = 2519,
	IIC3_SCL_MARK = 2520,
	IIC3_SDA_MARK = 2521,
	I2C3_SCL_MARK = 2522,
	I2C3_SDA_MARK = 2523,
	PINMUX_MARK_END___4 = 2524,
};

enum {
	GP_LAST = 191,
	PIN_IIC0_SDA = 192,
	PIN_IIC0_SCL = 193,
	PIN_IIC3_SDA = 194,
	PIN_IIC3_SCL = 195,
};

enum {
	PINMUX_RESERVED___5 = 0,
	PINMUX_DATA_BEGIN___5 = 1,
	GP_0_0_DATA___2 = 2,
	GP_0_1_DATA___2 = 3,
	GP_0_2_DATA___2 = 4,
	GP_0_3_DATA___2 = 5,
	GP_0_4_DATA___2 = 6,
	GP_0_5_DATA___2 = 7,
	GP_0_6_DATA___2 = 8,
	GP_0_7_DATA___2 = 9,
	GP_0_8_DATA___2 = 10,
	GP_0_9_DATA___2 = 11,
	GP_0_10_DATA___2 = 12,
	GP_0_11_DATA___2 = 13,
	GP_0_12_DATA___2 = 14,
	GP_0_13_DATA___2 = 15,
	GP_0_14_DATA___2 = 16,
	GP_0_15_DATA___2 = 17,
	GP_0_16_DATA___2 = 18,
	GP_0_17_DATA___2 = 19,
	GP_0_18_DATA___2 = 20,
	GP_0_19_DATA___2 = 21,
	GP_0_20_DATA___2 = 22,
	GP_0_21_DATA___2 = 23,
	GP_0_22_DATA___2 = 24,
	GP_0_23_DATA___2 = 25,
	GP_0_24_DATA___2 = 26,
	GP_0_25_DATA___2 = 27,
	GP_0_26_DATA___2 = 28,
	GP_0_27_DATA___2 = 29,
	GP_0_28_DATA___2 = 30,
	GP_0_29_DATA___2 = 31,
	GP_0_30_DATA___2 = 32,
	GP_0_31_DATA___2 = 33,
	GP_1_0_DATA___2 = 34,
	GP_1_1_DATA___2 = 35,
	GP_1_2_DATA___2 = 36,
	GP_1_3_DATA___2 = 37,
	GP_1_4_DATA___2 = 38,
	GP_1_5_DATA___2 = 39,
	GP_1_6_DATA___2 = 40,
	GP_1_7_DATA___2 = 41,
	GP_1_8_DATA___2 = 42,
	GP_1_9_DATA___2 = 43,
	GP_1_10_DATA___2 = 44,
	GP_1_11_DATA___2 = 45,
	GP_1_12_DATA___2 = 46,
	GP_1_13_DATA___2 = 47,
	GP_1_14_DATA___2 = 48,
	GP_1_15_DATA___2 = 49,
	GP_1_16_DATA___2 = 50,
	GP_1_17_DATA___2 = 51,
	GP_1_18_DATA___2 = 52,
	GP_1_19_DATA___2 = 53,
	GP_1_20_DATA___2 = 54,
	GP_1_21_DATA___2 = 55,
	GP_1_22_DATA___2 = 56,
	GP_1_23_DATA___2 = 57,
	GP_1_24_DATA___2 = 58,
	GP_1_25_DATA___2 = 59,
	GP_2_0_DATA___2 = 60,
	GP_2_1_DATA___2 = 61,
	GP_2_2_DATA___2 = 62,
	GP_2_3_DATA___2 = 63,
	GP_2_4_DATA___2 = 64,
	GP_2_5_DATA___2 = 65,
	GP_2_6_DATA___2 = 66,
	GP_2_7_DATA___2 = 67,
	GP_2_8_DATA___2 = 68,
	GP_2_9_DATA___2 = 69,
	GP_2_10_DATA___2 = 70,
	GP_2_11_DATA___2 = 71,
	GP_2_12_DATA___2 = 72,
	GP_2_13_DATA___2 = 73,
	GP_2_14_DATA___2 = 74,
	GP_2_15_DATA___2 = 75,
	GP_2_16_DATA___2 = 76,
	GP_2_17_DATA___2 = 77,
	GP_2_18_DATA___2 = 78,
	GP_2_19_DATA___2 = 79,
	GP_2_20_DATA___2 = 80,
	GP_2_21_DATA___2 = 81,
	GP_2_22_DATA___2 = 82,
	GP_2_23_DATA___2 = 83,
	GP_2_24_DATA___2 = 84,
	GP_2_25_DATA___2 = 85,
	GP_2_26_DATA___2 = 86,
	GP_2_27_DATA___2 = 87,
	GP_2_28_DATA___2 = 88,
	GP_2_29_DATA___2 = 89,
	GP_2_30_DATA = 90,
	GP_2_31_DATA = 91,
	GP_3_0_DATA___2 = 92,
	GP_3_1_DATA___2 = 93,
	GP_3_2_DATA___2 = 94,
	GP_3_3_DATA___2 = 95,
	GP_3_4_DATA___2 = 96,
	GP_3_5_DATA___2 = 97,
	GP_3_6_DATA___2 = 98,
	GP_3_7_DATA___2 = 99,
	GP_3_8_DATA___2 = 100,
	GP_3_9_DATA___2 = 101,
	GP_3_10_DATA___2 = 102,
	GP_3_11_DATA___2 = 103,
	GP_3_12_DATA___2 = 104,
	GP_3_13_DATA___2 = 105,
	GP_3_14_DATA___2 = 106,
	GP_3_15_DATA___2 = 107,
	GP_3_16_DATA___2 = 108,
	GP_3_17_DATA___2 = 109,
	GP_3_18_DATA___2 = 110,
	GP_3_19_DATA___2 = 111,
	GP_3_20_DATA___2 = 112,
	GP_3_21_DATA___2 = 113,
	GP_3_22_DATA___2 = 114,
	GP_3_23_DATA___2 = 115,
	GP_3_24_DATA___2 = 116,
	GP_3_25_DATA___2 = 117,
	GP_3_26_DATA___2 = 118,
	GP_3_27_DATA___2 = 119,
	GP_3_28_DATA___2 = 120,
	GP_3_29_DATA___2 = 121,
	GP_3_30_DATA___2 = 122,
	GP_3_31_DATA___2 = 123,
	GP_4_0_DATA___2 = 124,
	GP_4_1_DATA___2 = 125,
	GP_4_2_DATA___2 = 126,
	GP_4_3_DATA___2 = 127,
	GP_4_4_DATA___2 = 128,
	GP_4_5_DATA___2 = 129,
	GP_4_6_DATA___2 = 130,
	GP_4_7_DATA___2 = 131,
	GP_4_8_DATA___2 = 132,
	GP_4_9_DATA___2 = 133,
	GP_4_10_DATA___2 = 134,
	GP_4_11_DATA___2 = 135,
	GP_4_12_DATA___2 = 136,
	GP_4_13_DATA___2 = 137,
	GP_4_14_DATA___2 = 138,
	GP_4_15_DATA___2 = 139,
	GP_4_16_DATA___2 = 140,
	GP_4_17_DATA___2 = 141,
	GP_4_18_DATA___2 = 142,
	GP_4_19_DATA___2 = 143,
	GP_4_20_DATA___2 = 144,
	GP_4_21_DATA___2 = 145,
	GP_4_22_DATA___2 = 146,
	GP_4_23_DATA___2 = 147,
	GP_4_24_DATA___2 = 148,
	GP_4_25_DATA___2 = 149,
	GP_4_26_DATA___2 = 150,
	GP_4_27_DATA___2 = 151,
	GP_4_28_DATA___2 = 152,
	GP_4_29_DATA___2 = 153,
	GP_4_30_DATA___2 = 154,
	GP_4_31_DATA___2 = 155,
	GP_5_0_DATA___2 = 156,
	GP_5_1_DATA___2 = 157,
	GP_5_2_DATA___2 = 158,
	GP_5_3_DATA___2 = 159,
	GP_5_4_DATA___2 = 160,
	GP_5_5_DATA___2 = 161,
	GP_5_6_DATA___2 = 162,
	GP_5_7_DATA___2 = 163,
	GP_5_8_DATA___2 = 164,
	GP_5_9_DATA___2 = 165,
	GP_5_10_DATA___2 = 166,
	GP_5_11_DATA___2 = 167,
	GP_5_12_DATA___2 = 168,
	GP_5_13_DATA___2 = 169,
	GP_5_14_DATA___2 = 170,
	GP_5_15_DATA___2 = 171,
	GP_5_16_DATA___2 = 172,
	GP_5_17_DATA___2 = 173,
	GP_5_18_DATA___2 = 174,
	GP_5_19_DATA___2 = 175,
	GP_5_20_DATA___2 = 176,
	GP_5_21_DATA___2 = 177,
	GP_5_22_DATA___2 = 178,
	GP_5_23_DATA___2 = 179,
	GP_5_24_DATA___2 = 180,
	GP_5_25_DATA___2 = 181,
	GP_5_26_DATA___2 = 182,
	GP_5_27_DATA___2 = 183,
	GP_5_28_DATA___2 = 184,
	GP_5_29_DATA___2 = 185,
	GP_5_30_DATA___2 = 186,
	GP_5_31_DATA___2 = 187,
	GP_6_0_DATA = 188,
	GP_6_1_DATA = 189,
	GP_6_2_DATA = 190,
	GP_6_3_DATA = 191,
	GP_6_4_DATA = 192,
	GP_6_5_DATA = 193,
	GP_6_6_DATA = 194,
	GP_6_7_DATA = 195,
	GP_6_8_DATA = 196,
	GP_6_9_DATA = 197,
	GP_6_10_DATA = 198,
	GP_6_11_DATA = 199,
	GP_6_12_DATA = 200,
	GP_6_13_DATA = 201,
	GP_6_14_DATA = 202,
	GP_6_15_DATA = 203,
	GP_6_16_DATA = 204,
	GP_6_17_DATA = 205,
	GP_6_18_DATA = 206,
	GP_6_19_DATA = 207,
	GP_6_20_DATA = 208,
	GP_6_21_DATA = 209,
	GP_6_22_DATA = 210,
	GP_6_23_DATA = 211,
	GP_6_24_DATA = 212,
	GP_6_25_DATA = 213,
	GP_6_26_DATA = 214,
	GP_6_27_DATA = 215,
	GP_6_28_DATA = 216,
	GP_6_29_DATA = 217,
	GP_6_30_DATA = 218,
	GP_6_31_DATA = 219,
	GP_7_0_DATA = 220,
	GP_7_1_DATA = 221,
	GP_7_2_DATA = 222,
	GP_7_3_DATA = 223,
	GP_7_4_DATA = 224,
	GP_7_5_DATA = 225,
	GP_7_6_DATA = 226,
	GP_7_7_DATA = 227,
	GP_7_8_DATA = 228,
	GP_7_9_DATA = 229,
	GP_7_10_DATA = 230,
	GP_7_11_DATA = 231,
	GP_7_12_DATA = 232,
	GP_7_13_DATA = 233,
	GP_7_14_DATA = 234,
	GP_7_15_DATA = 235,
	GP_7_16_DATA = 236,
	GP_7_17_DATA = 237,
	GP_7_18_DATA = 238,
	GP_7_19_DATA = 239,
	GP_7_20_DATA = 240,
	GP_7_21_DATA = 241,
	GP_7_22_DATA = 242,
	GP_7_23_DATA = 243,
	GP_7_24_DATA = 244,
	GP_7_25_DATA = 245,
	PINMUX_DATA_END___5 = 246,
	PINMUX_FUNCTION_BEGIN___5 = 247,
	GP_0_0_FN___2 = 248,
	GP_0_1_FN___2 = 249,
	GP_0_2_FN___2 = 250,
	GP_0_3_FN___2 = 251,
	GP_0_4_FN___2 = 252,
	GP_0_5_FN___2 = 253,
	GP_0_6_FN___2 = 254,
	GP_0_7_FN___2 = 255,
	GP_0_8_FN___2 = 256,
	GP_0_9_FN___2 = 257,
	GP_0_10_FN___2 = 258,
	GP_0_11_FN___2 = 259,
	GP_0_12_FN___2 = 260,
	GP_0_13_FN___2 = 261,
	GP_0_14_FN___2 = 262,
	GP_0_15_FN___2 = 263,
	GP_0_16_FN___2 = 264,
	GP_0_17_FN___2 = 265,
	GP_0_18_FN___2 = 266,
	GP_0_19_FN___2 = 267,
	GP_0_20_FN___2 = 268,
	GP_0_21_FN___2 = 269,
	GP_0_22_FN___2 = 270,
	GP_0_23_FN___2 = 271,
	GP_0_24_FN___2 = 272,
	GP_0_25_FN___2 = 273,
	GP_0_26_FN___2 = 274,
	GP_0_27_FN___2 = 275,
	GP_0_28_FN___2 = 276,
	GP_0_29_FN___2 = 277,
	GP_0_30_FN___2 = 278,
	GP_0_31_FN___2 = 279,
	GP_1_0_FN___2 = 280,
	GP_1_1_FN___2 = 281,
	GP_1_2_FN___2 = 282,
	GP_1_3_FN___2 = 283,
	GP_1_4_FN___2 = 284,
	GP_1_5_FN___2 = 285,
	GP_1_6_FN___2 = 286,
	GP_1_7_FN___2 = 287,
	GP_1_8_FN___2 = 288,
	GP_1_9_FN___2 = 289,
	GP_1_10_FN___2 = 290,
	GP_1_11_FN___2 = 291,
	GP_1_12_FN___2 = 292,
	GP_1_13_FN___2 = 293,
	GP_1_14_FN___2 = 294,
	GP_1_15_FN___2 = 295,
	GP_1_16_FN___2 = 296,
	GP_1_17_FN___2 = 297,
	GP_1_18_FN___2 = 298,
	GP_1_19_FN___2 = 299,
	GP_1_20_FN___2 = 300,
	GP_1_21_FN___2 = 301,
	GP_1_22_FN___2 = 302,
	GP_1_23_FN___2 = 303,
	GP_1_24_FN___2 = 304,
	GP_1_25_FN___2 = 305,
	GP_2_0_FN___2 = 306,
	GP_2_1_FN___2 = 307,
	GP_2_2_FN___2 = 308,
	GP_2_3_FN___2 = 309,
	GP_2_4_FN___2 = 310,
	GP_2_5_FN___2 = 311,
	GP_2_6_FN___2 = 312,
	GP_2_7_FN___2 = 313,
	GP_2_8_FN___2 = 314,
	GP_2_9_FN___2 = 315,
	GP_2_10_FN___2 = 316,
	GP_2_11_FN___2 = 317,
	GP_2_12_FN___2 = 318,
	GP_2_13_FN___2 = 319,
	GP_2_14_FN___2 = 320,
	GP_2_15_FN___2 = 321,
	GP_2_16_FN___2 = 322,
	GP_2_17_FN___2 = 323,
	GP_2_18_FN___2 = 324,
	GP_2_19_FN___2 = 325,
	GP_2_20_FN___2 = 326,
	GP_2_21_FN___2 = 327,
	GP_2_22_FN___2 = 328,
	GP_2_23_FN___2 = 329,
	GP_2_24_FN___2 = 330,
	GP_2_25_FN___2 = 331,
	GP_2_26_FN___2 = 332,
	GP_2_27_FN___2 = 333,
	GP_2_28_FN___2 = 334,
	GP_2_29_FN___2 = 335,
	GP_2_30_FN = 336,
	GP_2_31_FN = 337,
	GP_3_0_FN___2 = 338,
	GP_3_1_FN___2 = 339,
	GP_3_2_FN___2 = 340,
	GP_3_3_FN___2 = 341,
	GP_3_4_FN___2 = 342,
	GP_3_5_FN___2 = 343,
	GP_3_6_FN___2 = 344,
	GP_3_7_FN___2 = 345,
	GP_3_8_FN___2 = 346,
	GP_3_9_FN___2 = 347,
	GP_3_10_FN___2 = 348,
	GP_3_11_FN___2 = 349,
	GP_3_12_FN___2 = 350,
	GP_3_13_FN___2 = 351,
	GP_3_14_FN___2 = 352,
	GP_3_15_FN___2 = 353,
	GP_3_16_FN___2 = 354,
	GP_3_17_FN___2 = 355,
	GP_3_18_FN___2 = 356,
	GP_3_19_FN___2 = 357,
	GP_3_20_FN___2 = 358,
	GP_3_21_FN___2 = 359,
	GP_3_22_FN___2 = 360,
	GP_3_23_FN___2 = 361,
	GP_3_24_FN___2 = 362,
	GP_3_25_FN___2 = 363,
	GP_3_26_FN___2 = 364,
	GP_3_27_FN___2 = 365,
	GP_3_28_FN___2 = 366,
	GP_3_29_FN___2 = 367,
	GP_3_30_FN___2 = 368,
	GP_3_31_FN___2 = 369,
	GP_4_0_FN___2 = 370,
	GP_4_1_FN___2 = 371,
	GP_4_2_FN___2 = 372,
	GP_4_3_FN___2 = 373,
	GP_4_4_FN___2 = 374,
	GP_4_5_FN___2 = 375,
	GP_4_6_FN___2 = 376,
	GP_4_7_FN___2 = 377,
	GP_4_8_FN___2 = 378,
	GP_4_9_FN___2 = 379,
	GP_4_10_FN___2 = 380,
	GP_4_11_FN___2 = 381,
	GP_4_12_FN___2 = 382,
	GP_4_13_FN___2 = 383,
	GP_4_14_FN___2 = 384,
	GP_4_15_FN___2 = 385,
	GP_4_16_FN___2 = 386,
	GP_4_17_FN___2 = 387,
	GP_4_18_FN___2 = 388,
	GP_4_19_FN___2 = 389,
	GP_4_20_FN___2 = 390,
	GP_4_21_FN___2 = 391,
	GP_4_22_FN___2 = 392,
	GP_4_23_FN___2 = 393,
	GP_4_24_FN___2 = 394,
	GP_4_25_FN___2 = 395,
	GP_4_26_FN___2 = 396,
	GP_4_27_FN___2 = 397,
	GP_4_28_FN___2 = 398,
	GP_4_29_FN___2 = 399,
	GP_4_30_FN___2 = 400,
	GP_4_31_FN___2 = 401,
	GP_5_0_FN___2 = 402,
	GP_5_1_FN___2 = 403,
	GP_5_2_FN___2 = 404,
	GP_5_3_FN___2 = 405,
	GP_5_4_FN___2 = 406,
	GP_5_5_FN___2 = 407,
	GP_5_6_FN___2 = 408,
	GP_5_7_FN___2 = 409,
	GP_5_8_FN___2 = 410,
	GP_5_9_FN___2 = 411,
	GP_5_10_FN___2 = 412,
	GP_5_11_FN___2 = 413,
	GP_5_12_FN___2 = 414,
	GP_5_13_FN___2 = 415,
	GP_5_14_FN___2 = 416,
	GP_5_15_FN___2 = 417,
	GP_5_16_FN___2 = 418,
	GP_5_17_FN___2 = 419,
	GP_5_18_FN___2 = 420,
	GP_5_19_FN___2 = 421,
	GP_5_20_FN___2 = 422,
	GP_5_21_FN___2 = 423,
	GP_5_22_FN___2 = 424,
	GP_5_23_FN___2 = 425,
	GP_5_24_FN___2 = 426,
	GP_5_25_FN___2 = 427,
	GP_5_26_FN___2 = 428,
	GP_5_27_FN___2 = 429,
	GP_5_28_FN___2 = 430,
	GP_5_29_FN___2 = 431,
	GP_5_30_FN___2 = 432,
	GP_5_31_FN___2 = 433,
	GP_6_0_FN = 434,
	GP_6_1_FN = 435,
	GP_6_2_FN = 436,
	GP_6_3_FN = 437,
	GP_6_4_FN = 438,
	GP_6_5_FN = 439,
	GP_6_6_FN = 440,
	GP_6_7_FN = 441,
	GP_6_8_FN = 442,
	GP_6_9_FN = 443,
	GP_6_10_FN = 444,
	GP_6_11_FN = 445,
	GP_6_12_FN = 446,
	GP_6_13_FN = 447,
	GP_6_14_FN = 448,
	GP_6_15_FN = 449,
	GP_6_16_FN = 450,
	GP_6_17_FN = 451,
	GP_6_18_FN = 452,
	GP_6_19_FN = 453,
	GP_6_20_FN = 454,
	GP_6_21_FN = 455,
	GP_6_22_FN = 456,
	GP_6_23_FN = 457,
	GP_6_24_FN = 458,
	GP_6_25_FN = 459,
	GP_6_26_FN = 460,
	GP_6_27_FN = 461,
	GP_6_28_FN = 462,
	GP_6_29_FN = 463,
	GP_6_30_FN = 464,
	GP_6_31_FN = 465,
	GP_7_0_FN = 466,
	GP_7_1_FN = 467,
	GP_7_2_FN = 468,
	GP_7_3_FN = 469,
	GP_7_4_FN = 470,
	GP_7_5_FN = 471,
	GP_7_6_FN = 472,
	GP_7_7_FN = 473,
	GP_7_8_FN = 474,
	GP_7_9_FN = 475,
	GP_7_10_FN = 476,
	GP_7_11_FN = 477,
	GP_7_12_FN = 478,
	GP_7_13_FN = 479,
	GP_7_14_FN = 480,
	GP_7_15_FN = 481,
	GP_7_16_FN = 482,
	GP_7_17_FN = 483,
	GP_7_18_FN = 484,
	GP_7_19_FN = 485,
	GP_7_20_FN = 486,
	GP_7_21_FN = 487,
	GP_7_22_FN = 488,
	GP_7_23_FN = 489,
	GP_7_24_FN = 490,
	GP_7_25_FN = 491,
	FN_IP0_0 = 492,
	FN_IP0_1 = 493,
	FN_IP0_2 = 494,
	FN_IP0_3 = 495,
	FN_IP0_4 = 496,
	FN_IP0_5 = 497,
	FN_IP0_6 = 498,
	FN_IP0_7 = 499,
	FN_IP0_8 = 500,
	FN_IP0_9 = 501,
	FN_IP0_10 = 502,
	FN_IP0_11 = 503,
	FN_IP0_12 = 504,
	FN_IP0_13 = 505,
	FN_IP0_14 = 506,
	FN_IP0_15 = 507,
	FN_IP0_18_16 = 508,
	FN_IP0_20_19 = 509,
	FN_IP0_22_21 = 510,
	FN_IP0_24_23 = 511,
	FN_IP0_26_25 = 512,
	FN_IP0_28_27 = 513,
	FN_IP0_30_29 = 514,
	FN_IP1_1_0 = 515,
	FN_IP1_3_2 = 516,
	FN_IP1_5_4 = 517,
	FN_IP1_7_6 = 518,
	FN_IP1_10_8 = 519,
	FN_IP1_13_11 = 520,
	FN_IP1_16_14 = 521,
	FN_IP1_19_17 = 522,
	FN_IP1_22_20 = 523,
	FN_IP1_25_23 = 524,
	FN_IP1_28_26 = 525,
	FN_IP1_31_29 = 526,
	FN_IP2_2_0___2 = 527,
	FN_IP2_4_3 = 528,
	FN_IP2_6_5 = 529,
	FN_IP2_9_7 = 530,
	FN_IP2_12_10 = 531,
	FN_IP2_15_13 = 532,
	FN_IP2_18_16 = 533,
	FN_IP2_20_19 = 534,
	FN_IP2_22_21 = 535,
	FN_EX_CS0_N___2 = 536,
	FN_IP2_24_23 = 537,
	FN_IP2_26_25 = 538,
	FN_IP2_29_27 = 539,
	FN_IP3_2_0 = 540,
	FN_IP3_5_3 = 541,
	FN_IP3_8_6 = 542,
	FN_RD_N___2 = 543,
	FN_IP3_11_9 = 544,
	FN_IP3_13_12 = 545,
	FN_IP3_15_14 = 546,
	FN_IP3_17_16 = 547,
	FN_IP3_19_18___2 = 548,
	FN_IP3_21_20 = 549,
	FN_IP3_27_25 = 550,
	FN_IP3_30_28 = 551,
	FN_IP4_1_0 = 552,
	FN_IP4_4_2 = 553,
	FN_IP4_7_5 = 554,
	FN_IP4_9_8 = 555,
	FN_IP4_12_10 = 556,
	FN_IP4_15_13 = 557,
	FN_IP4_18_16 = 558,
	FN_IP4_19 = 559,
	FN_IP4_20 = 560,
	FN_IP4_21 = 561,
	FN_IP4_23_22 = 562,
	FN_IP4_25_24 = 563,
	FN_IP4_27_26 = 564,
	FN_IP4_30_28 = 565,
	FN_IP5_2_0___2 = 566,
	FN_IP5_5_3___2 = 567,
	FN_IP5_8_6 = 568,
	FN_IP5_11_9 = 569,
	FN_IP5_14_12 = 570,
	FN_IP5_16_15 = 571,
	FN_IP5_19_17 = 572,
	FN_IP5_21_20 = 573,
	FN_IP5_23_22 = 574,
	FN_IP5_25_24 = 575,
	FN_IP5_28_26 = 576,
	FN_IP5_31_29 = 577,
	FN_AUDIO_CLKA___2 = 578,
	FN_IP6_2_0___2 = 579,
	FN_IP6_5_3___2 = 580,
	FN_IP6_7_6 = 581,
	FN_IP7_5_3___2 = 582,
	FN_IP7_8_6 = 583,
	FN_IP7_10_9 = 584,
	FN_IP7_12_11 = 585,
	FN_IP7_14_13 = 586,
	FN_IP7_16_15 = 587,
	FN_IP7_18_17 = 588,
	FN_IP7_20_19 = 589,
	FN_IP7_23_21 = 590,
	FN_IP7_26_24 = 591,
	FN_IP7_29_27 = 592,
	FN_IP8_2_0 = 593,
	FN_IP8_5_3 = 594,
	FN_IP8_8_6 = 595,
	FN_IP8_11_9 = 596,
	FN_IP8_14_12 = 597,
	FN_IP8_17_15 = 598,
	FN_IP8_20_18 = 599,
	FN_IP8_23_21 = 600,
	FN_IP8_25_24___2 = 601,
	FN_IP8_27_26 = 602,
	FN_IP8_30_28 = 603,
	FN_IP9_2_0 = 604,
	FN_IP9_5_3 = 605,
	FN_IP9_6 = 606,
	FN_IP9_7 = 607,
	FN_IP9_10_8 = 608,
	FN_IP9_11 = 609,
	FN_IP9_12 = 610,
	FN_IP9_15_13 = 611,
	FN_IP9_16 = 612,
	FN_IP9_18_17 = 613,
	FN_VI0_CLK___2 = 614,
	FN_IP9_20_19 = 615,
	FN_IP9_22_21 = 616,
	FN_IP9_24_23 = 617,
	FN_IP9_26_25 = 618,
	FN_VI0_DATA0_VI0_B0___2 = 619,
	FN_VI0_DATA1_VI0_B1___2 = 620,
	FN_VI0_DATA2_VI0_B2___2 = 621,
	FN_IP9_28_27 = 622,
	FN_VI0_DATA4_VI0_B4___2 = 623,
	FN_VI0_DATA5_VI0_B5___2 = 624,
	FN_VI0_DATA6_VI0_B6___2 = 625,
	FN_VI0_DATA7_VI0_B7___2 = 626,
	FN_IP9_31_29 = 627,
	FN_IP10_2_0 = 628,
	FN_IP10_5_3 = 629,
	FN_IP10_8_6 = 630,
	FN_IP10_11_9 = 631,
	FN_IP10_14_12 = 632,
	FN_IP10_16_15 = 633,
	FN_IP10_18_17 = 634,
	FN_IP10_21_19 = 635,
	FN_IP10_24_22 = 636,
	FN_IP10_26_25 = 637,
	FN_IP10_28_27 = 638,
	FN_IP10_31_29 = 639,
	FN_IP11_2_0 = 640,
	FN_IP11_5_3 = 641,
	FN_IP11_8_6 = 642,
	FN_IP15_1_0 = 643,
	FN_IP15_3_2 = 644,
	FN_IP15_5_4 = 645,
	FN_IP11_11_9 = 646,
	FN_IP11_14_12 = 647,
	FN_IP11_16_15 = 648,
	FN_IP11_18_17 = 649,
	FN_IP11_19 = 650,
	FN_IP11_20 = 651,
	FN_IP11_21 = 652,
	FN_IP11_22 = 653,
	FN_IP11_23 = 654,
	FN_IP11_24 = 655,
	FN_IP11_25 = 656,
	FN_IP11_26 = 657,
	FN_IP11_27 = 658,
	FN_IP11_29_28 = 659,
	FN_IP11_31_30___2 = 660,
	FN_IP12_1_0___2 = 661,
	FN_IP12_3_2___2 = 662,
	FN_IP12_6_4 = 663,
	FN_IP12_9_7 = 664,
	FN_IP12_12_10 = 665,
	FN_IP12_15_13 = 666,
	FN_IP12_17_16 = 667,
	FN_IP12_19_18 = 668,
	FN_IP12_21_20 = 669,
	FN_IP12_23_22 = 670,
	FN_IP12_26_24 = 671,
	FN_IP12_29_27 = 672,
	FN_IP13_2_0___2 = 673,
	FN_IP13_4_3 = 674,
	FN_IP13_6_5 = 675,
	FN_IP13_9_7___2 = 676,
	FN_IP3_24_22 = 677,
	FN_IP13_10 = 678,
	FN_IP13_11 = 679,
	FN_IP13_12 = 680,
	FN_IP13_13 = 681,
	FN_IP13_14 = 682,
	FN_IP13_15 = 683,
	FN_IP13_18_16___2 = 684,
	FN_IP13_21_19 = 685,
	FN_IP13_22 = 686,
	FN_IP13_24_23 = 687,
	FN_SD1_CLK___2 = 688,
	FN_IP13_25 = 689,
	FN_IP13_26 = 690,
	FN_IP13_27 = 691,
	FN_IP13_30_28 = 692,
	FN_IP14_1_0 = 693,
	FN_IP14_2 = 694,
	FN_IP14_3 = 695,
	FN_IP14_4 = 696,
	FN_IP14_5 = 697,
	FN_IP14_6 = 698,
	FN_IP14_7 = 699,
	FN_IP14_10_8 = 700,
	FN_IP14_13_11 = 701,
	FN_IP14_16_14 = 702,
	FN_IP14_19_17 = 703,
	FN_IP14_22_20 = 704,
	FN_IP14_25_23 = 705,
	FN_IP14_28_26 = 706,
	FN_IP14_31_29 = 707,
	FN_USB1_OVC___2 = 708,
	FN_DU0_DOTCLKIN = 709,
	FN_IP15_17_15 = 710,
	FN_IP15_20_18 = 711,
	FN_IP15_23_21 = 712,
	FN_IP15_26_24 = 713,
	FN_IP15_29_27 = 714,
	FN_IP16_2_0___2 = 715,
	FN_IP16_5_3___2 = 716,
	FN_IP16_7_6 = 717,
	FN_IP16_9_8 = 718,
	FN_IP16_11_10 = 719,
	FN_IP6_9_8 = 720,
	FN_IP6_11_10 = 721,
	FN_IP6_13_12 = 722,
	FN_IP6_15_14 = 723,
	FN_IP6_18_16 = 724,
	FN_IP6_20_19 = 725,
	FN_IP6_23_21 = 726,
	FN_IP6_26_24 = 727,
	FN_IP6_29_27 = 728,
	FN_IP7_2_0___2 = 729,
	FN_IP15_8_6___2 = 730,
	FN_IP15_11_9___2 = 731,
	FN_IP15_14_12 = 732,
	FN_USB0_PWEN___2 = 733,
	FN_USB0_OVC = 734,
	FN_USB1_PWEN___2 = 735,
	FN_D0___2 = 736,
	FN_D1___2 = 737,
	FN_D2___2 = 738,
	FN_D3___2 = 739,
	FN_D4___2 = 740,
	FN_D5___2 = 741,
	FN_D6___2 = 742,
	FN_D7___2 = 743,
	FN_D8___2 = 744,
	FN_D9___2 = 745,
	FN_D10___2 = 746,
	FN_D11___2 = 747,
	FN_D12___2 = 748,
	FN_D13___2 = 749,
	FN_D14___2 = 750,
	FN_D15___2 = 751,
	FN_A0___2 = 752,
	FN_ATAWR0_N_C = 753,
	FN_MSIOF0_SCK_B___2 = 754,
	FN_I2C0_SCL_C = 755,
	FN_PWM2_B = 756,
	FN_A1___2 = 757,
	FN_MSIOF0_SYNC_B = 758,
	FN_A2___2 = 759,
	FN_MSIOF0_SS1_B___2 = 760,
	FN_A3___2 = 761,
	FN_MSIOF0_SS2_B___2 = 762,
	FN_A4___2 = 763,
	FN_MSIOF0_TXD_B___2 = 764,
	FN_A5___2 = 765,
	FN_MSIOF0_RXD_B___2 = 766,
	FN_A6___2 = 767,
	FN_MSIOF1_SCK___2 = 768,
	FN_A7___2 = 769,
	FN_MSIOF1_SYNC___2 = 770,
	FN_A8___2 = 771,
	FN_MSIOF1_SS1___2 = 772,
	FN_I2C0_SCL = 773,
	FN_A9___2 = 774,
	FN_MSIOF1_SS2___2 = 775,
	FN_I2C0_SDA = 776,
	FN_A10___2 = 777,
	FN_MSIOF1_TXD___2 = 778,
	FN_MSIOF1_TXD_D = 779,
	FN_A11___2 = 780,
	FN_MSIOF1_RXD___2 = 781,
	FN_I2C3_SCL_D = 782,
	FN_MSIOF1_RXD_D = 783,
	FN_A12___2 = 784,
	FN_FMCLK___2 = 785,
	FN_I2C3_SDA_D = 786,
	FN_MSIOF1_SCK_D = 787,
	FN_A13___2 = 788,
	FN_ATAG0_N_C = 789,
	FN_BPFCLK___2 = 790,
	FN_MSIOF1_SS1_D = 791,
	FN_A14___2 = 792,
	FN_ATADIR0_N_C = 793,
	FN_FMIN___2 = 794,
	FN_FMIN_C___2 = 795,
	FN_MSIOF1_SYNC_D = 796,
	FN_A15___2 = 797,
	FN_BPFCLK_C___2 = 798,
	FN_A16___2 = 799,
	FN_DREQ2_B = 800,
	FN_FMCLK_C = 801,
	FN_SCIFA1_SCK_B___2 = 802,
	FN_A17___2 = 803,
	FN_DACK2_B = 804,
	FN_I2C0_SDA_C = 805,
	FN_A18___2 = 806,
	FN_DREQ1 = 807,
	FN_SCIFA1_RXD_C___2 = 808,
	FN_SCIFB1_RXD_C___2 = 809,
	FN_A19___2 = 810,
	FN_DACK1___2 = 811,
	FN_SCIFA1_TXD_C___2 = 812,
	FN_SCIFB1_TXD_C___2 = 813,
	FN_SCIFB1_SCK_B___2 = 814,
	FN_A20___2 = 815,
	FN_SPCLK___2 = 816,
	FN_A21___2 = 817,
	FN_ATAWR0_N_B = 818,
	FN_MOSI_IO0___2 = 819,
	FN_A22___2 = 820,
	FN_MISO_IO1___2 = 821,
	FN_FMCLK_B___2 = 822,
	FN_TX0___2 = 823,
	FN_SCIFA0_TXD___2 = 824,
	FN_A23___2 = 825,
	FN_IO2___2 = 826,
	FN_BPFCLK_B___2 = 827,
	FN_RX0___2 = 828,
	FN_SCIFA0_RXD___2 = 829,
	FN_A24___2 = 830,
	FN_DREQ2 = 831,
	FN_IO3___2 = 832,
	FN_TX1___2 = 833,
	FN_SCIFA1_TXD___2 = 834,
	FN_A25___2 = 835,
	FN_DACK2___2 = 836,
	FN_SSL___2 = 837,
	FN_DREQ1_C = 838,
	FN_RX1___2 = 839,
	FN_SCIFA1_RXD___2 = 840,
	FN_CS0_N___2 = 841,
	FN_ATAG0_N_B = 842,
	FN_I2C1_SCL___2 = 843,
	FN_CS1_N_A26___2 = 844,
	FN_ATADIR0_N_B = 845,
	FN_I2C1_SDA___2 = 846,
	FN_EX_CS1_N___2 = 847,
	FN_MSIOF2_SCK___2 = 848,
	FN_EX_CS2_N___2 = 849,
	FN_ATAWR0_N___2 = 850,
	FN_MSIOF2_SYNC___2 = 851,
	FN_EX_CS3_N___2 = 852,
	FN_ATADIR0_N___2 = 853,
	FN_MSIOF2_TXD___2 = 854,
	FN_ATAG0_N___2 = 855,
	FN_EX_WAIT1___2 = 856,
	FN_EX_CS4_N___2 = 857,
	FN_ATARD0_N___2 = 858,
	FN_MSIOF2_RXD___2 = 859,
	FN_EX_WAIT2___2 = 860,
	FN_EX_CS5_N___2 = 861,
	FN_ATACS00_N___2 = 862,
	FN_MSIOF2_SS1___2 = 863,
	FN_HRX1_B___2 = 864,
	FN_SCIFB1_RXD_B___2 = 865,
	FN_PWM1___2 = 866,
	FN_TPU_TO1 = 867,
	FN_BS_N___2 = 868,
	FN_ATACS10_N___2 = 869,
	FN_MSIOF2_SS2___2 = 870,
	FN_HTX1_B___2 = 871,
	FN_SCIFB1_TXD_B___2 = 872,
	FN_PWM2___2 = 873,
	FN_TPU_TO2 = 874,
	FN_RD_WR_N___2 = 875,
	FN_HRX2_B = 876,
	FN_FMIN_B___2 = 877,
	FN_SCIFB0_RXD_B___2 = 878,
	FN_DREQ1_D = 879,
	FN_WE0_N___2 = 880,
	FN_HCTS2_N_B = 881,
	FN_SCIFB0_TXD_B___2 = 882,
	FN_WE1_N___2 = 883,
	FN_ATARD0_N_B = 884,
	FN_HTX2_B = 885,
	FN_SCIFB0_RTS_N_B___2 = 886,
	FN_EX_WAIT0___2 = 887,
	FN_HRTS2_N_B = 888,
	FN_SCIFB0_CTS_N_B___2 = 889,
	FN_DREQ0 = 890,
	FN_PWM3___2 = 891,
	FN_TPU_TO3 = 892,
	FN_DACK0___2 = 893,
	FN_DRACK0___2 = 894,
	FN_REMOCON___2 = 895,
	FN_SPEEDIN___2 = 896,
	FN_HSCK0_C = 897,
	FN_HSCK2_C = 898,
	FN_SCIFB0_SCK_B___2 = 899,
	FN_SCIFB2_SCK_B___2 = 900,
	FN_DREQ2_C = 901,
	FN_HTX2_D = 902,
	FN_SSI_SCK0129___2 = 903,
	FN_HRX0_C___2 = 904,
	FN_HRX2_C = 905,
	FN_SCIFB0_RXD_C___2 = 906,
	FN_SCIFB2_RXD_C___2 = 907,
	FN_SSI_WS0129___2 = 908,
	FN_HTX0_C___2 = 909,
	FN_HTX2_C = 910,
	FN_SCIFB0_TXD_C___2 = 911,
	FN_SCIFB2_TXD_C___2 = 912,
	FN_SSI_SDATA0___2 = 913,
	FN_I2C0_SCL_B = 914,
	FN_IIC0_SCL_B = 915,
	FN_MSIOF2_SCK_C = 916,
	FN_SSI_SCK1___2 = 917,
	FN_I2C0_SDA_B = 918,
	FN_IIC0_SDA_B = 919,
	FN_MSIOF2_SYNC_C = 920,
	FN_GLO_I0_D = 921,
	FN_SSI_WS1___2 = 922,
	FN_I2C1_SCL_B___2 = 923,
	FN_IIC1_SCL_B___2 = 924,
	FN_MSIOF2_TXD_C = 925,
	FN_GLO_I1_D = 926,
	FN_SSI_SDATA1___2 = 927,
	FN_I2C1_SDA_B___2 = 928,
	FN_IIC1_SDA_B___2 = 929,
	FN_MSIOF2_RXD_C = 930,
	FN_SSI_SCK2___2 = 931,
	FN_I2C2_SCL___2 = 932,
	FN_GPS_CLK_B = 933,
	FN_GLO_Q0_D = 934,
	FN_HSCK1_E = 935,
	FN_SSI_WS2___2 = 936,
	FN_I2C2_SDA___2 = 937,
	FN_GPS_SIGN_B = 938,
	FN_RX2_E = 939,
	FN_GLO_Q1_D = 940,
	FN_HCTS1_N_E = 941,
	FN_SSI_SDATA2___2 = 942,
	FN_GPS_MAG_B = 943,
	FN_TX2_E = 944,
	FN_HRTS1_N_E = 945,
	FN_SSI_SCK34___2 = 946,
	FN_SSI_WS34___2 = 947,
	FN_SSI_SDATA3___2 = 948,
	FN_SSI_SCK4___2 = 949,
	FN_GLO_SS_D = 950,
	FN_SSI_WS4___2 = 951,
	FN_GLO_RFON_D = 952,
	FN_SSI_SDATA4___2 = 953,
	FN_MSIOF2_SCK_D = 954,
	FN_SSI_SCK5___2 = 955,
	FN_MSIOF1_SCK_C = 956,
	FN_TS_SDATA0 = 957,
	FN_GLO_I0___2 = 958,
	FN_MSIOF2_SYNC_D = 959,
	FN_VI1_R2_B___2 = 960,
	FN_SSI_WS5___2 = 961,
	FN_MSIOF1_SYNC_C = 962,
	FN_TS_SCK0___2 = 963,
	FN_GLO_I1___2 = 964,
	FN_MSIOF2_TXD_D = 965,
	FN_VI1_R3_B___2 = 966,
	FN_SSI_SDATA5___2 = 967,
	FN_MSIOF1_TXD_C = 968,
	FN_TS_SDEN0___2 = 969,
	FN_GLO_Q0___2 = 970,
	FN_MSIOF2_SS1_D = 971,
	FN_VI1_R4_B___2 = 972,
	FN_SSI_SCK6___2 = 973,
	FN_MSIOF1_RXD_C = 974,
	FN_TS_SPSYNC0___2 = 975,
	FN_GLO_Q1___2 = 976,
	FN_MSIOF2_RXD_D = 977,
	FN_VI1_R5_B___2 = 978,
	FN_SSI_WS6___2 = 979,
	FN_GLO_SCLK___2 = 980,
	FN_MSIOF2_SS2_D = 981,
	FN_VI1_R6_B___2 = 982,
	FN_SSI_SDATA6___2 = 983,
	FN_STP_IVCXO27_0_B___2 = 984,
	FN_GLO_SDATA___2 = 985,
	FN_VI1_R7_B___2 = 986,
	FN_SSI_SCK78___2 = 987,
	FN_STP_ISCLK_0_B___2 = 988,
	FN_GLO_SS___2 = 989,
	FN_SSI_WS78___2 = 990,
	FN_TX0_D = 991,
	FN_STP_ISD_0_B___2 = 992,
	FN_GLO_RFON___2 = 993,
	FN_SSI_SDATA7___2 = 994,
	FN_RX0_D = 995,
	FN_STP_ISEN_0_B___2 = 996,
	FN_SSI_SDATA8___2 = 997,
	FN_TX1_D___2 = 998,
	FN_STP_ISSYNC_0_B___2 = 999,
	FN_SSI_SCK9___2 = 1000,
	FN_RX1_D___2 = 1001,
	FN_GLO_SCLK_D = 1002,
	FN_SSI_WS9___2 = 1003,
	FN_TX3_D = 1004,
	FN_CAN0_TX_D___2 = 1005,
	FN_GLO_SDATA_D = 1006,
	FN_SSI_SDATA9___2 = 1007,
	FN_RX3_D = 1008,
	FN_CAN0_RX_D___2 = 1009,
	FN_AUDIO_CLKB___2 = 1010,
	FN_STP_OPWM_0_B = 1011,
	FN_MSIOF1_SCK_B___2 = 1012,
	FN_SCIF_CLK___2 = 1013,
	FN_DVC_MUTE___2 = 1014,
	FN_BPFCLK_E___2 = 1015,
	FN_AUDIO_CLKC___2 = 1016,
	FN_SCIFB0_SCK_C = 1017,
	FN_MSIOF1_SYNC_B = 1018,
	FN_RX2___2 = 1019,
	FN_SCIFA2_RXD___2 = 1020,
	FN_FMIN_E___2 = 1021,
	FN_AUDIO_CLKOUT___2 = 1022,
	FN_MSIOF1_SS1_B___2 = 1023,
	FN_TX2___2 = 1024,
	FN_SCIFA2_TXD___2 = 1025,
	FN_IRQ0___2 = 1026,
	FN_SCIFB1_RXD_D___2 = 1027,
	FN_INTC_IRQ0_N___2 = 1028,
	FN_IRQ1___2 = 1029,
	FN_SCIFB1_SCK_C = 1030,
	FN_INTC_IRQ1_N___2 = 1031,
	FN_IRQ2___2 = 1032,
	FN_SCIFB1_TXD_D___2 = 1033,
	FN_INTC_IRQ2_N___2 = 1034,
	FN_IRQ3___2 = 1035,
	FN_I2C4_SCL_C = 1036,
	FN_MSIOF2_TXD_E = 1037,
	FN_INTC_IRQ3_N___2 = 1038,
	FN_IRQ4 = 1039,
	FN_HRX1_C = 1040,
	FN_I2C4_SDA_C = 1041,
	FN_MSIOF2_RXD_E = 1042,
	FN_INTC_IRQ4_N___2 = 1043,
	FN_IRQ5 = 1044,
	FN_HTX1_C = 1045,
	FN_I2C1_SCL_E = 1046,
	FN_MSIOF2_SCK_E = 1047,
	FN_IRQ6 = 1048,
	FN_HSCK1_C = 1049,
	FN_MSIOF1_SS2_B___2 = 1050,
	FN_I2C1_SDA_E = 1051,
	FN_MSIOF2_SYNC_E = 1052,
	FN_IRQ7 = 1053,
	FN_HCTS1_N_C = 1054,
	FN_MSIOF1_TXD_B___2 = 1055,
	FN_GPS_CLK_C = 1056,
	FN_GPS_CLK_D = 1057,
	FN_IRQ8 = 1058,
	FN_HRTS1_N_C = 1059,
	FN_MSIOF1_RXD_B___2 = 1060,
	FN_GPS_SIGN_C = 1061,
	FN_GPS_SIGN_D = 1062,
	FN_IRQ9 = 1063,
	FN_DU1_DOTCLKIN_B = 1064,
	FN_CAN_CLK_D = 1065,
	FN_GPS_MAG_C = 1066,
	FN_SCIF_CLK_B___2 = 1067,
	FN_GPS_MAG_D = 1068,
	FN_DU1_DR0 = 1069,
	FN_LCDOUT0___2 = 1070,
	FN_VI1_DATA0_B = 1071,
	FN_TX0_B___2 = 1072,
	FN_SCIFA0_TXD_B___2 = 1073,
	FN_MSIOF2_SCK_B = 1074,
	FN_DU1_DR1 = 1075,
	FN_LCDOUT1___2 = 1076,
	FN_VI1_DATA1_B = 1077,
	FN_RX0_B___2 = 1078,
	FN_SCIFA0_RXD_B___2 = 1079,
	FN_MSIOF2_SYNC_B = 1080,
	FN_DU1_DR2 = 1081,
	FN_LCDOUT2___2 = 1082,
	FN_SSI_SCK0129_B = 1083,
	FN_DU1_DR3 = 1084,
	FN_LCDOUT3___2 = 1085,
	FN_SSI_WS0129_B = 1086,
	FN_DU1_DR4 = 1087,
	FN_LCDOUT4___2 = 1088,
	FN_SSI_SDATA0_B = 1089,
	FN_DU1_DR5 = 1090,
	FN_LCDOUT5___2 = 1091,
	FN_SSI_SCK1_B = 1092,
	FN_DU1_DR6 = 1093,
	FN_LCDOUT6___2 = 1094,
	FN_SSI_WS1_B = 1095,
	FN_DU1_DR7 = 1096,
	FN_LCDOUT7___2 = 1097,
	FN_SSI_SDATA1_B = 1098,
	FN_DU1_DG0 = 1099,
	FN_LCDOUT8___2 = 1100,
	FN_VI1_DATA2_B = 1101,
	FN_TX1_B___2 = 1102,
	FN_SCIFA1_TXD_B___2 = 1103,
	FN_MSIOF2_SS1_B = 1104,
	FN_DU1_DG1 = 1105,
	FN_LCDOUT9___2 = 1106,
	FN_VI1_DATA3_B = 1107,
	FN_RX1_B___2 = 1108,
	FN_SCIFA1_RXD_B___2 = 1109,
	FN_MSIOF2_SS2_B = 1110,
	FN_DU1_DG2 = 1111,
	FN_LCDOUT10___2 = 1112,
	FN_VI1_DATA4_B = 1113,
	FN_SCIF1_SCK_B = 1114,
	FN_SCIFA1_SCK___2 = 1115,
	FN_SSI_SCK78_B___2 = 1116,
	FN_DU1_DG3 = 1117,
	FN_LCDOUT11___2 = 1118,
	FN_VI1_DATA5_B = 1119,
	FN_SSI_WS78_B___2 = 1120,
	FN_DU1_DG4 = 1121,
	FN_LCDOUT12___2 = 1122,
	FN_VI1_DATA6_B = 1123,
	FN_HRX0_B___2 = 1124,
	FN_SCIFB2_RXD_B___2 = 1125,
	FN_SSI_SDATA7_B___2 = 1126,
	FN_DU1_DG5 = 1127,
	FN_LCDOUT13___2 = 1128,
	FN_VI1_DATA7_B = 1129,
	FN_HCTS0_N_B___2 = 1130,
	FN_SCIFB2_TXD_B___2 = 1131,
	FN_SSI_SDATA8_B___2 = 1132,
	FN_DU1_DG6 = 1133,
	FN_LCDOUT14___2 = 1134,
	FN_HRTS0_N_B___2 = 1135,
	FN_SCIFB2_CTS_N_B___2 = 1136,
	FN_SSI_SCK9_B = 1137,
	FN_DU1_DG7 = 1138,
	FN_LCDOUT15___2 = 1139,
	FN_HTX0_B___2 = 1140,
	FN_SCIFB2_RTS_N_B___2 = 1141,
	FN_SSI_WS9_B = 1142,
	FN_DU1_DB0 = 1143,
	FN_LCDOUT16___2 = 1144,
	FN_VI1_CLK_B___2 = 1145,
	FN_TX2_B___2 = 1146,
	FN_SCIFA2_TXD_B___2 = 1147,
	FN_MSIOF2_TXD_B = 1148,
	FN_DU1_DB1 = 1149,
	FN_LCDOUT17___2 = 1150,
	FN_VI1_HSYNC_N_B___2 = 1151,
	FN_RX2_B___2 = 1152,
	FN_SCIFA2_RXD_B___2 = 1153,
	FN_MSIOF2_RXD_B = 1154,
	FN_DU1_DB2 = 1155,
	FN_LCDOUT18___2 = 1156,
	FN_VI1_VSYNC_N_B___2 = 1157,
	FN_SCIF2_SCK_B = 1158,
	FN_SCIFA2_SCK___2 = 1159,
	FN_SSI_SDATA9_B = 1160,
	FN_DU1_DB3 = 1161,
	FN_LCDOUT19___2 = 1162,
	FN_VI1_CLKENB_B___2 = 1163,
	FN_DU1_DB4 = 1164,
	FN_LCDOUT20___2 = 1165,
	FN_VI1_FIELD_B___2 = 1166,
	FN_CAN1_RX___2 = 1167,
	FN_DU1_DB5 = 1168,
	FN_LCDOUT21___2 = 1169,
	FN_TX3 = 1170,
	FN_SCIFA3_TXD = 1171,
	FN_CAN1_TX___2 = 1172,
	FN_DU1_DB6 = 1173,
	FN_LCDOUT22___2 = 1174,
	FN_I2C3_SCL_C = 1175,
	FN_RX3 = 1176,
	FN_SCIFA3_RXD = 1177,
	FN_DU1_DB7 = 1178,
	FN_LCDOUT23___2 = 1179,
	FN_I2C3_SDA_C = 1180,
	FN_SCIF3_SCK = 1181,
	FN_SCIFA3_SCK = 1182,
	FN_DU1_DOTCLKIN = 1183,
	FN_QSTVA_QVS___2 = 1184,
	FN_DU1_DOTCLKOUT0 = 1185,
	FN_QCLK___2 = 1186,
	FN_DU1_DOTCLKOUT1 = 1187,
	FN_QSTVB_QVE___2 = 1188,
	FN_CAN0_TX___2 = 1189,
	FN_TX3_B = 1190,
	FN_I2C2_SCL_B___2 = 1191,
	FN_PWM4___2 = 1192,
	FN_DU1_EXHSYNC_DU1_HSYNC = 1193,
	FN_QSTH_QHS___2 = 1194,
	FN_DU1_EXVSYNC_DU1_VSYNC = 1195,
	FN_QSTB_QHE___2 = 1196,
	FN_DU1_EXODDF_DU1_ODDF_DISP_CDE = 1197,
	FN_QCPV_QDE___2 = 1198,
	FN_CAN0_RX___2 = 1199,
	FN_RX3_B = 1200,
	FN_I2C2_SDA_B___2 = 1201,
	FN_DU1_DISP = 1202,
	FN_QPOLA___2 = 1203,
	FN_DU1_CDE = 1204,
	FN_QPOLB___2 = 1205,
	FN_PWM4_B = 1206,
	FN_VI0_CLKENB___2 = 1207,
	FN_TX4 = 1208,
	FN_SCIFA4_TXD = 1209,
	FN_TS_SDATA0_D = 1210,
	FN_VI0_FIELD___2 = 1211,
	FN_RX4 = 1212,
	FN_SCIFA4_RXD = 1213,
	FN_TS_SCK0_D___2 = 1214,
	FN_VI0_HSYNC_N___2 = 1215,
	FN_TX5 = 1216,
	FN_SCIFA5_TXD = 1217,
	FN_TS_SDEN0_D___2 = 1218,
	FN_VI0_VSYNC_N___2 = 1219,
	FN_RX5 = 1220,
	FN_SCIFA5_RXD = 1221,
	FN_TS_SPSYNC0_D___2 = 1222,
	FN_VI0_DATA3_VI0_B3___2 = 1223,
	FN_SCIF3_SCK_B = 1224,
	FN_SCIFA3_SCK_B = 1225,
	FN_VI0_G0___2 = 1226,
	FN_IIC1_SCL___2 = 1227,
	FN_STP_IVCXO27_0_C = 1228,
	FN_I2C4_SCL = 1229,
	FN_HCTS2_N = 1230,
	FN_SCIFB2_CTS_N___2 = 1231,
	FN_ATAWR1_N___2 = 1232,
	FN_VI0_G1___2 = 1233,
	FN_IIC1_SDA___2 = 1234,
	FN_STP_ISCLK_0_C = 1235,
	FN_I2C4_SDA = 1236,
	FN_HRTS2_N = 1237,
	FN_SCIFB2_RTS_N___2 = 1238,
	FN_ATADIR1_N___2 = 1239,
	FN_VI0_G2___2 = 1240,
	FN_VI2_HSYNC_N___2 = 1241,
	FN_STP_ISD_0_C = 1242,
	FN_I2C3_SCL_B = 1243,
	FN_HSCK2 = 1244,
	FN_SCIFB2_SCK___2 = 1245,
	FN_ATARD1_N___2 = 1246,
	FN_VI0_G3___2 = 1247,
	FN_VI2_VSYNC_N___2 = 1248,
	FN_STP_ISEN_0_C = 1249,
	FN_I2C3_SDA_B = 1250,
	FN_HRX2 = 1251,
	FN_SCIFB2_RXD___2 = 1252,
	FN_ATACS01_N___2 = 1253,
	FN_VI0_G4___2 = 1254,
	FN_VI2_CLKENB___2 = 1255,
	FN_STP_ISSYNC_0_C = 1256,
	FN_HTX2 = 1257,
	FN_SCIFB2_TXD___2 = 1258,
	FN_SCIFB0_SCK_D = 1259,
	FN_VI0_G5___2 = 1260,
	FN_VI2_FIELD___2 = 1261,
	FN_STP_OPWM_0_C = 1262,
	FN_FMCLK_D = 1263,
	FN_CAN0_TX_E = 1264,
	FN_HTX1_D = 1265,
	FN_SCIFB0_TXD_D = 1266,
	FN_VI0_G6___2 = 1267,
	FN_VI2_CLK___2 = 1268,
	FN_BPFCLK_D___2 = 1269,
	FN_VI0_G7___2 = 1270,
	FN_VI2_DATA0 = 1271,
	FN_FMIN_D___2 = 1272,
	FN_VI0_R0___2 = 1273,
	FN_VI2_DATA1 = 1274,
	FN_GLO_I0_B___2 = 1275,
	FN_TS_SDATA0_C = 1276,
	FN_ATACS11_N___2 = 1277,
	FN_VI0_R1___2 = 1278,
	FN_VI2_DATA2 = 1279,
	FN_GLO_I1_B___2 = 1280,
	FN_TS_SCK0_C___2 = 1281,
	FN_ATAG1_N___2 = 1282,
	FN_VI0_R2___2 = 1283,
	FN_VI2_DATA3 = 1284,
	FN_GLO_Q0_B___2 = 1285,
	FN_TS_SDEN0_C___2 = 1286,
	FN_VI0_R3___2 = 1287,
	FN_VI2_DATA4 = 1288,
	FN_GLO_Q1_B___2 = 1289,
	FN_TS_SPSYNC0_C___2 = 1290,
	FN_VI0_R4___2 = 1291,
	FN_VI2_DATA5 = 1292,
	FN_GLO_SCLK_B___2 = 1293,
	FN_TX0_C = 1294,
	FN_I2C1_SCL_D = 1295,
	FN_VI0_R5___2 = 1296,
	FN_VI2_DATA6 = 1297,
	FN_GLO_SDATA_B___2 = 1298,
	FN_RX0_C = 1299,
	FN_I2C1_SDA_D = 1300,
	FN_VI0_R6___2 = 1301,
	FN_VI2_DATA7 = 1302,
	FN_GLO_SS_B___2 = 1303,
	FN_TX1_C___2 = 1304,
	FN_I2C4_SCL_B = 1305,
	FN_VI0_R7___2 = 1306,
	FN_GLO_RFON_B___2 = 1307,
	FN_RX1_C___2 = 1308,
	FN_CAN0_RX_E = 1309,
	FN_I2C4_SDA_B = 1310,
	FN_HRX1_D = 1311,
	FN_SCIFB0_RXD_D = 1312,
	FN_VI1_HSYNC_N___2 = 1313,
	FN_AVB_RXD0___2 = 1314,
	FN_TS_SDATA0_B = 1315,
	FN_TX4_B = 1316,
	FN_SCIFA4_TXD_B = 1317,
	FN_VI1_VSYNC_N___2 = 1318,
	FN_AVB_RXD1___2 = 1319,
	FN_TS_SCK0_B___2 = 1320,
	FN_RX4_B = 1321,
	FN_SCIFA4_RXD_B = 1322,
	FN_VI1_CLKENB___2 = 1323,
	FN_AVB_RXD2___2 = 1324,
	FN_TS_SDEN0_B___2 = 1325,
	FN_VI1_FIELD___2 = 1326,
	FN_AVB_RXD3___2 = 1327,
	FN_TS_SPSYNC0_B___2 = 1328,
	FN_VI1_CLK___2 = 1329,
	FN_AVB_RXD4___2 = 1330,
	FN_VI1_DATA0 = 1331,
	FN_AVB_RXD5___2 = 1332,
	FN_VI1_DATA1 = 1333,
	FN_AVB_RXD6___2 = 1334,
	FN_VI1_DATA2 = 1335,
	FN_AVB_RXD7___2 = 1336,
	FN_VI1_DATA3 = 1337,
	FN_AVB_RX_ER___2 = 1338,
	FN_VI1_DATA4 = 1339,
	FN_AVB_MDIO___2 = 1340,
	FN_VI1_DATA5 = 1341,
	FN_AVB_RX_DV___2 = 1342,
	FN_VI1_DATA6 = 1343,
	FN_AVB_MAGIC___2 = 1344,
	FN_VI1_DATA7 = 1345,
	FN_AVB_MDC___2 = 1346,
	FN_ETH_MDIO___2 = 1347,
	FN_AVB_RX_CLK___2 = 1348,
	FN_I2C2_SCL_C___2 = 1349,
	FN_ETH_CRS_DV___2 = 1350,
	FN_AVB_LINK___2 = 1351,
	FN_I2C2_SDA_C___2 = 1352,
	FN_ETH_RX_ER___2 = 1353,
	FN_AVB_CRS___2 = 1354,
	FN_I2C3_SCL = 1355,
	FN_IIC0_SCL___2 = 1356,
	FN_ETH_RXD0___2 = 1357,
	FN_AVB_PHY_INT___2 = 1358,
	FN_I2C3_SDA = 1359,
	FN_IIC0_SDA___2 = 1360,
	FN_ETH_RXD1___2 = 1361,
	FN_AVB_GTXREFCLK___2 = 1362,
	FN_CAN0_TX_C___2 = 1363,
	FN_I2C2_SCL_D___2 = 1364,
	FN_MSIOF1_RXD_E = 1365,
	FN_ETH_LINK___2 = 1366,
	FN_AVB_TXD0___2 = 1367,
	FN_CAN0_RX_C___2 = 1368,
	FN_I2C2_SDA_D___2 = 1369,
	FN_MSIOF1_SCK_E = 1370,
	FN_ETH_REFCLK = 1371,
	FN_AVB_TXD1___2 = 1372,
	FN_SCIFA3_RXD_B = 1373,
	FN_CAN1_RX_C = 1374,
	FN_MSIOF1_SYNC_E = 1375,
	FN_ETH_TXD1___2 = 1376,
	FN_AVB_TXD2___2 = 1377,
	FN_SCIFA3_TXD_B = 1378,
	FN_CAN1_TX_C = 1379,
	FN_MSIOF1_TXD_E = 1380,
	FN_ETH_TX_EN___2 = 1381,
	FN_AVB_TXD3___2 = 1382,
	FN_TCLK1_B___2 = 1383,
	FN_CAN_CLK_B___2 = 1384,
	FN_ETH_MAGIC___2 = 1385,
	FN_AVB_TXD4___2 = 1386,
	FN_IETX_C___2 = 1387,
	FN_ETH_TXD0___2 = 1388,
	FN_AVB_TXD5___2 = 1389,
	FN_IECLK_C___2 = 1390,
	FN_ETH_MDC___2 = 1391,
	FN_AVB_TXD6___2 = 1392,
	FN_IERX_C___2 = 1393,
	FN_STP_IVCXO27_0___2 = 1394,
	FN_AVB_TXD7___2 = 1395,
	FN_SCIFB2_TXD_D = 1396,
	FN_ADIDATA_B = 1397,
	FN_MSIOF0_SYNC_C = 1398,
	FN_STP_ISCLK_0___2 = 1399,
	FN_AVB_TX_EN___2 = 1400,
	FN_SCIFB2_RXD_D = 1401,
	FN_ADICS_SAMP_B = 1402,
	FN_MSIOF0_SCK_C = 1403,
	FN_STP_ISD_0___2 = 1404,
	FN_AVB_TX_ER___2 = 1405,
	FN_SCIFB2_SCK_C = 1406,
	FN_ADICLK_B = 1407,
	FN_MSIOF0_SS1_C = 1408,
	FN_STP_ISEN_0___2 = 1409,
	FN_AVB_TX_CLK___2 = 1410,
	FN_ADICHS0_B = 1411,
	FN_MSIOF0_SS2_C = 1412,
	FN_STP_ISSYNC_0___2 = 1413,
	FN_AVB_COL___2 = 1414,
	FN_ADICHS1_B = 1415,
	FN_MSIOF0_RXD_C = 1416,
	FN_STP_OPWM_0___2 = 1417,
	FN_AVB_GTX_CLK___2 = 1418,
	FN_PWM0_B___2 = 1419,
	FN_ADICHS2_B = 1420,
	FN_MSIOF0_TXD_C = 1421,
	FN_SD0_CLK___2 = 1422,
	FN_SPCLK_B = 1423,
	FN_SD0_CMD___2 = 1424,
	FN_MOSI_IO0_B = 1425,
	FN_SD0_DATA0 = 1426,
	FN_MISO_IO1_B = 1427,
	FN_SD0_DATA1 = 1428,
	FN_IO2_B = 1429,
	FN_SD0_DATA2 = 1430,
	FN_IO3_B = 1431,
	FN_SD0_DATA3 = 1432,
	FN_SSL_B = 1433,
	FN_SD0_CD___2 = 1434,
	FN_MMC_D6_B = 1435,
	FN_SIM0_RST_B___2 = 1436,
	FN_CAN0_RX_F = 1437,
	FN_SCIFA5_TXD_B = 1438,
	FN_TX3_C = 1439,
	FN_SD0_WP___2 = 1440,
	FN_MMC_D7_B = 1441,
	FN_SIM0_D_B___2 = 1442,
	FN_CAN0_TX_F = 1443,
	FN_SCIFA5_RXD_B = 1444,
	FN_RX3_C = 1445,
	FN_SD1_CMD___2 = 1446,
	FN_REMOCON_B = 1447,
	FN_SD1_DATA0 = 1448,
	FN_SPEEDIN_B = 1449,
	FN_SD1_DATA1 = 1450,
	FN_IETX_B___2 = 1451,
	FN_SD1_DATA2 = 1452,
	FN_IECLK_B___2 = 1453,
	FN_SD1_DATA3 = 1454,
	FN_IERX_B___2 = 1455,
	FN_SD1_CD___2 = 1456,
	FN_PWM0___2 = 1457,
	FN_TPU_TO0 = 1458,
	FN_I2C1_SCL_C___2 = 1459,
	FN_SD1_WP___2 = 1460,
	FN_PWM1_B___2 = 1461,
	FN_I2C1_SDA_C___2 = 1462,
	FN_SD2_CLK___2 = 1463,
	FN_MMC_CLK = 1464,
	FN_SD2_CMD___2 = 1465,
	FN_MMC_CMD = 1466,
	FN_SD2_DATA0 = 1467,
	FN_MMC_D0 = 1468,
	FN_SD2_DATA1 = 1469,
	FN_MMC_D1 = 1470,
	FN_SD2_DATA2 = 1471,
	FN_MMC_D2 = 1472,
	FN_SD2_DATA3 = 1473,
	FN_MMC_D3 = 1474,
	FN_SD2_CD___2 = 1475,
	FN_MMC_D4 = 1476,
	FN_IIC1_SCL_C___2 = 1477,
	FN_TX5_B = 1478,
	FN_SCIFA5_TXD_C = 1479,
	FN_SD2_WP___2 = 1480,
	FN_MMC_D5 = 1481,
	FN_IIC1_SDA_C___2 = 1482,
	FN_RX5_B = 1483,
	FN_SCIFA5_RXD_C = 1484,
	FN_MSIOF0_SCK___2 = 1485,
	FN_RX2_C = 1486,
	FN_ADIDATA___2 = 1487,
	FN_VI1_CLK_C = 1488,
	FN_VI1_G0_B___2 = 1489,
	FN_MSIOF0_SYNC___2 = 1490,
	FN_TX2_C = 1491,
	FN_ADICS_SAMP___2 = 1492,
	FN_VI1_CLKENB_C = 1493,
	FN_VI1_G1_B___2 = 1494,
	FN_MSIOF0_TXD___2 = 1495,
	FN_ADICLK___2 = 1496,
	FN_VI1_FIELD_C = 1497,
	FN_VI1_G2_B___2 = 1498,
	FN_MSIOF0_RXD___2 = 1499,
	FN_ADICHS0___2 = 1500,
	FN_VI1_DATA0_C = 1501,
	FN_VI1_G3_B___2 = 1502,
	FN_MSIOF0_SS1___2 = 1503,
	FN_MMC_D6 = 1504,
	FN_ADICHS1___2 = 1505,
	FN_TX0_E = 1506,
	FN_VI1_HSYNC_N_C = 1507,
	FN_IIC0_SCL_C = 1508,
	FN_VI1_G4_B___2 = 1509,
	FN_MSIOF0_SS2___2 = 1510,
	FN_MMC_D7 = 1511,
	FN_ADICHS2___2 = 1512,
	FN_RX0_E = 1513,
	FN_VI1_VSYNC_N_C = 1514,
	FN_IIC0_SDA_C = 1515,
	FN_VI1_G5_B___2 = 1516,
	FN_SIM0_RST___2 = 1517,
	FN_IETX___2 = 1518,
	FN_CAN1_TX_D = 1519,
	FN_SIM0_CLK___2 = 1520,
	FN_IECLK___2 = 1521,
	FN_CAN_CLK_C = 1522,
	FN_SIM0_D___2 = 1523,
	FN_IERX___2 = 1524,
	FN_CAN1_RX_D = 1525,
	FN_GPS_CLK___2 = 1526,
	FN_DU1_DOTCLKIN_C = 1527,
	FN_AUDIO_CLKB_B = 1528,
	FN_PWM5_B = 1529,
	FN_SCIFA3_TXD_C = 1530,
	FN_GPS_SIGN___2 = 1531,
	FN_TX4_C = 1532,
	FN_SCIFA4_TXD_C = 1533,
	FN_PWM5___2 = 1534,
	FN_VI1_G6_B___2 = 1535,
	FN_SCIFA3_RXD_C = 1536,
	FN_GPS_MAG___2 = 1537,
	FN_RX4_C = 1538,
	FN_SCIFA4_RXD_C = 1539,
	FN_PWM6___2 = 1540,
	FN_VI1_G7_B___2 = 1541,
	FN_SCIFA3_SCK_C = 1542,
	FN_HCTS0_N___2 = 1543,
	FN_SCIFB0_CTS_N___2 = 1544,
	FN_GLO_I0_C___2 = 1545,
	FN_TCLK1___2 = 1546,
	FN_VI1_DATA1_C = 1547,
	FN_HRTS0_N___2 = 1548,
	FN_SCIFB0_RTS_N___2 = 1549,
	FN_GLO_I1_C___2 = 1550,
	FN_VI1_DATA2_C = 1551,
	FN_HSCK0___2 = 1552,
	FN_SCIFB0_SCK___2 = 1553,
	FN_GLO_Q0_C___2 = 1554,
	FN_CAN_CLK___2 = 1555,
	FN_TCLK2___2 = 1556,
	FN_VI1_DATA3_C = 1557,
	FN_HRX0___2 = 1558,
	FN_SCIFB0_RXD___2 = 1559,
	FN_GLO_Q1_C___2 = 1560,
	FN_CAN0_RX_B___2 = 1561,
	FN_VI1_DATA4_C = 1562,
	FN_HTX0___2 = 1563,
	FN_SCIFB0_TXD___2 = 1564,
	FN_GLO_SCLK_C___2 = 1565,
	FN_CAN0_TX_B___2 = 1566,
	FN_VI1_DATA5_C = 1567,
	FN_HRX1___2 = 1568,
	FN_SCIFB1_RXD___2 = 1569,
	FN_VI1_R0_B___2 = 1570,
	FN_GLO_SDATA_C___2 = 1571,
	FN_VI1_DATA6_C = 1572,
	FN_HTX1___2 = 1573,
	FN_SCIFB1_TXD___2 = 1574,
	FN_VI1_R1_B___2 = 1575,
	FN_GLO_SS_C___2 = 1576,
	FN_VI1_DATA7_C = 1577,
	FN_HSCK1___2 = 1578,
	FN_SCIFB1_SCK___2 = 1579,
	FN_MLB_CLK___2 = 1580,
	FN_GLO_RFON_C___2 = 1581,
	FN_HCTS1_N___2 = 1582,
	FN_SCIFB1_CTS_N___2 = 1583,
	FN_MLB_SIG___2 = 1584,
	FN_CAN1_TX_B___2 = 1585,
	FN_HRTS1_N___2 = 1586,
	FN_SCIFB1_RTS_N___2 = 1587,
	FN_MLB_DAT___2 = 1588,
	FN_CAN1_RX_B___2 = 1589,
	FN_SEL_SCIF1_0___2 = 1590,
	FN_SEL_SCIF1_1___2 = 1591,
	FN_SEL_SCIF1_2___2 = 1592,
	FN_SEL_SCIF1_3___2 = 1593,
	FN_SEL_SCIFB_0___2 = 1594,
	FN_SEL_SCIFB_1___2 = 1595,
	FN_SEL_SCIFB_2___2 = 1596,
	FN_SEL_SCIFB_3 = 1597,
	FN_SEL_SCIFB2_0___2 = 1598,
	FN_SEL_SCIFB2_1___2 = 1599,
	FN_SEL_SCIFB2_2___2 = 1600,
	FN_SEL_SCIFB2_3 = 1601,
	FN_SEL_SCIFB1_0___2 = 1602,
	FN_SEL_SCIFB1_1___2 = 1603,
	FN_SEL_SCIFB1_2___2 = 1604,
	FN_SEL_SCIFB1_3___2 = 1605,
	FN_SEL_SCIFA1_0___2 = 1606,
	FN_SEL_SCIFA1_1___2 = 1607,
	FN_SEL_SCIFA1_2___2 = 1608,
	FN_SEL_SSI9_0 = 1609,
	FN_SEL_SSI9_1 = 1610,
	FN_SEL_SCFA_0___2 = 1611,
	FN_SEL_SCFA_1___2 = 1612,
	FN_SEL_QSP_0 = 1613,
	FN_SEL_QSP_1 = 1614,
	FN_SEL_SSI7_0___2 = 1615,
	FN_SEL_SSI7_1___2 = 1616,
	FN_SEL_HSCIF1_0___2 = 1617,
	FN_SEL_HSCIF1_1___2 = 1618,
	FN_SEL_HSCIF1_2 = 1619,
	FN_SEL_HSCIF1_3 = 1620,
	FN_SEL_HSCIF1_4 = 1621,
	FN_SEL_VI1_0___2 = 1622,
	FN_SEL_VI1_1___2 = 1623,
	FN_SEL_VI1_2 = 1624,
	FN_SEL_TMU1_0___2 = 1625,
	FN_SEL_TMU1_1___2 = 1626,
	FN_SEL_LBS_0___2 = 1627,
	FN_SEL_LBS_1___2 = 1628,
	FN_SEL_LBS_2 = 1629,
	FN_SEL_LBS_3 = 1630,
	FN_SEL_TSIF0_0___2 = 1631,
	FN_SEL_TSIF0_1___2 = 1632,
	FN_SEL_TSIF0_2___2 = 1633,
	FN_SEL_TSIF0_3___2 = 1634,
	FN_SEL_SOF0_0___2 = 1635,
	FN_SEL_SOF0_1___2 = 1636,
	FN_SEL_SOF0_2 = 1637,
	FN_SEL_SCIF0_0___2 = 1638,
	FN_SEL_SCIF0_1___2 = 1639,
	FN_SEL_SCIF0_2 = 1640,
	FN_SEL_SCIF0_3 = 1641,
	FN_SEL_SCIF0_4 = 1642,
	FN_SEL_SCIF_0 = 1643,
	FN_SEL_SCIF_1 = 1644,
	FN_SEL_CAN0_0___2 = 1645,
	FN_SEL_CAN0_1___2 = 1646,
	FN_SEL_CAN0_2___2 = 1647,
	FN_SEL_CAN0_3___2 = 1648,
	FN_SEL_CAN0_4 = 1649,
	FN_SEL_CAN0_5 = 1650,
	FN_SEL_CAN1_0___2 = 1651,
	FN_SEL_CAN1_1___2 = 1652,
	FN_SEL_CAN1_2 = 1653,
	FN_SEL_CAN1_3 = 1654,
	FN_SEL_SCIFA2_0___2 = 1655,
	FN_SEL_SCIFA2_1___2 = 1656,
	FN_SEL_SCIF4_0 = 1657,
	FN_SEL_SCIF4_1 = 1658,
	FN_SEL_SCIF4_2 = 1659,
	FN_SEL_ADG_0 = 1660,
	FN_SEL_ADG_1 = 1661,
	FN_SEL_FM_0___2 = 1662,
	FN_SEL_FM_1___2 = 1663,
	FN_SEL_FM_2___2 = 1664,
	FN_SEL_FM_3___2 = 1665,
	FN_SEL_FM_4___2 = 1666,
	FN_SEL_SCIFA5_0 = 1667,
	FN_SEL_SCIFA5_1 = 1668,
	FN_SEL_SCIFA5_2 = 1669,
	FN_SEL_GPS_0___2 = 1670,
	FN_SEL_GPS_1___2 = 1671,
	FN_SEL_GPS_2___2 = 1672,
	FN_SEL_GPS_3 = 1673,
	FN_SEL_SCIFA4_0 = 1674,
	FN_SEL_SCIFA4_1 = 1675,
	FN_SEL_SCIFA4_2 = 1676,
	FN_SEL_SCIFA3_0 = 1677,
	FN_SEL_SCIFA3_1 = 1678,
	FN_SEL_SCIFA3_2 = 1679,
	FN_SEL_SIM_0___2 = 1680,
	FN_SEL_SIM_1___2 = 1681,
	FN_SEL_SSI8_0___2 = 1682,
	FN_SEL_SSI8_1___2 = 1683,
	FN_SEL_HSCIF2_0 = 1684,
	FN_SEL_HSCIF2_1 = 1685,
	FN_SEL_HSCIF2_2 = 1686,
	FN_SEL_HSCIF2_3 = 1687,
	FN_SEL_CANCLK_0___2 = 1688,
	FN_SEL_CANCLK_1___2 = 1689,
	FN_SEL_CANCLK_2 = 1690,
	FN_SEL_CANCLK_3 = 1691,
	FN_SEL_IIC1_0___2 = 1692,
	FN_SEL_IIC1_1___2 = 1693,
	FN_SEL_IIC1_2___2 = 1694,
	FN_SEL_IIC0_0___2 = 1695,
	FN_SEL_IIC0_1___2 = 1696,
	FN_SEL_IIC0_2 = 1697,
	FN_SEL_I2C4_0 = 1698,
	FN_SEL_I2C4_1 = 1699,
	FN_SEL_I2C4_2 = 1700,
	FN_SEL_I2C3_0 = 1701,
	FN_SEL_I2C3_1 = 1702,
	FN_SEL_I2C3_2 = 1703,
	FN_SEL_I2C3_3 = 1704,
	FN_SEL_SCIF3_0 = 1705,
	FN_SEL_SCIF3_1 = 1706,
	FN_SEL_SCIF3_2 = 1707,
	FN_SEL_SCIF3_3 = 1708,
	FN_SEL_IEB_0___2 = 1709,
	FN_SEL_IEB_1___2 = 1710,
	FN_SEL_IEB_2___2 = 1711,
	FN_SEL_MMC_0 = 1712,
	FN_SEL_MMC_1 = 1713,
	FN_SEL_SCIF5_0 = 1714,
	FN_SEL_SCIF5_1 = 1715,
	FN_SEL_I2C2_0___2 = 1716,
	FN_SEL_I2C2_1___2 = 1717,
	FN_SEL_I2C2_2___2 = 1718,
	FN_SEL_I2C2_3___2 = 1719,
	FN_SEL_I2C1_0___2 = 1720,
	FN_SEL_I2C1_1___2 = 1721,
	FN_SEL_I2C1_2___2 = 1722,
	FN_SEL_I2C1_3 = 1723,
	FN_SEL_I2C1_4 = 1724,
	FN_SEL_I2C0_0 = 1725,
	FN_SEL_I2C0_1 = 1726,
	FN_SEL_I2C0_2 = 1727,
	FN_SEL_SOF1_0___2 = 1728,
	FN_SEL_SOF1_1___2 = 1729,
	FN_SEL_SOF1_2 = 1730,
	FN_SEL_SOF1_3 = 1731,
	FN_SEL_SOF1_4 = 1732,
	FN_SEL_HSCIF0_0___2 = 1733,
	FN_SEL_HSCIF0_1___2 = 1734,
	FN_SEL_HSCIF0_2___2 = 1735,
	FN_SEL_DIS_0 = 1736,
	FN_SEL_DIS_1 = 1737,
	FN_SEL_DIS_2 = 1738,
	FN_SEL_RAD_0 = 1739,
	FN_SEL_RAD_1 = 1740,
	FN_SEL_RCN_0 = 1741,
	FN_SEL_RCN_1 = 1742,
	FN_SEL_RSP_0 = 1743,
	FN_SEL_RSP_1 = 1744,
	FN_SEL_SCIF2_0___2 = 1745,
	FN_SEL_SCIF2_1___2 = 1746,
	FN_SEL_SCIF2_2 = 1747,
	FN_SEL_SCIF2_3 = 1748,
	FN_SEL_SCIF2_4 = 1749,
	FN_SEL_SOF2_0 = 1750,
	FN_SEL_SOF2_1 = 1751,
	FN_SEL_SOF2_2 = 1752,
	FN_SEL_SOF2_3 = 1753,
	FN_SEL_SOF2_4 = 1754,
	FN_SEL_SSI1_0 = 1755,
	FN_SEL_SSI1_1 = 1756,
	FN_SEL_SSI0_0 = 1757,
	FN_SEL_SSI0_1 = 1758,
	FN_SEL_SSP_0___2 = 1759,
	FN_SEL_SSP_1___2 = 1760,
	FN_SEL_SSP_2 = 1761,
	PINMUX_FUNCTION_END___5 = 1762,
	PINMUX_MARK_BEGIN___5 = 1763,
	EX_CS0_N_MARK___2 = 1764,
	RD_N_MARK___3 = 1765,
	AUDIO_CLKA_MARK___2 = 1766,
	VI0_CLK_MARK___2 = 1767,
	VI0_DATA0_VI0_B0_MARK___2 = 1768,
	VI0_DATA1_VI0_B1_MARK___2 = 1769,
	VI0_DATA2_VI0_B2_MARK___2 = 1770,
	VI0_DATA4_VI0_B4_MARK___2 = 1771,
	VI0_DATA5_VI0_B5_MARK___2 = 1772,
	VI0_DATA6_VI0_B6_MARK___2 = 1773,
	VI0_DATA7_VI0_B7_MARK___2 = 1774,
	SD1_CLK_MARK___2 = 1775,
	USB0_PWEN_MARK___2 = 1776,
	USB0_OVC_MARK = 1777,
	USB1_PWEN_MARK___2 = 1778,
	USB1_OVC_MARK___2 = 1779,
	DU0_DOTCLKIN_MARK___2 = 1780,
	D0_MARK___3 = 1781,
	D1_MARK___3 = 1782,
	D2_MARK___3 = 1783,
	D3_MARK___3 = 1784,
	D4_MARK___3 = 1785,
	D5_MARK___3 = 1786,
	D6_MARK___3 = 1787,
	D7_MARK___3 = 1788,
	D8_MARK___3 = 1789,
	D9_MARK___3 = 1790,
	D10_MARK___3 = 1791,
	D11_MARK___3 = 1792,
	D12_MARK___3 = 1793,
	D13_MARK___3 = 1794,
	D14_MARK___3 = 1795,
	D15_MARK___3 = 1796,
	A0_MARK___4 = 1797,
	ATAWR0_N_C_MARK = 1798,
	MSIOF0_SCK_B_MARK___2 = 1799,
	I2C0_SCL_C_MARK = 1800,
	PWM2_B_MARK = 1801,
	A1_MARK___4 = 1802,
	MSIOF0_SYNC_B_MARK = 1803,
	A2_MARK___4 = 1804,
	MSIOF0_SS1_B_MARK___2 = 1805,
	A3_MARK___4 = 1806,
	MSIOF0_SS2_B_MARK___2 = 1807,
	A4_MARK___3 = 1808,
	MSIOF0_TXD_B_MARK___2 = 1809,
	A5_MARK___3 = 1810,
	MSIOF0_RXD_B_MARK___2 = 1811,
	A6_MARK___4 = 1812,
	MSIOF1_SCK_MARK___3 = 1813,
	A7_MARK___4 = 1814,
	MSIOF1_SYNC_MARK___3 = 1815,
	A8_MARK___4 = 1816,
	MSIOF1_SS1_MARK___3 = 1817,
	I2C0_SCL_MARK___2 = 1818,
	A9_MARK___4 = 1819,
	MSIOF1_SS2_MARK___3 = 1820,
	I2C0_SDA_MARK___2 = 1821,
	A10_MARK___4 = 1822,
	MSIOF1_TXD_MARK___3 = 1823,
	MSIOF1_TXD_D_MARK = 1824,
	A11_MARK___3 = 1825,
	MSIOF1_RXD_MARK___3 = 1826,
	I2C3_SCL_D_MARK = 1827,
	MSIOF1_RXD_D_MARK = 1828,
	A12_MARK___3 = 1829,
	FMCLK_MARK___2 = 1830,
	I2C3_SDA_D_MARK = 1831,
	MSIOF1_SCK_D_MARK = 1832,
	A13_MARK___3 = 1833,
	ATAG0_N_C_MARK = 1834,
	BPFCLK_MARK___2 = 1835,
	MSIOF1_SS1_D_MARK = 1836,
	A14_MARK___3 = 1837,
	ATADIR0_N_C_MARK = 1838,
	FMIN_MARK___2 = 1839,
	FMIN_C_MARK___2 = 1840,
	MSIOF1_SYNC_D_MARK = 1841,
	A15_MARK___3 = 1842,
	BPFCLK_C_MARK___2 = 1843,
	A16_MARK___3 = 1844,
	DREQ2_B_MARK = 1845,
	FMCLK_C_MARK = 1846,
	SCIFA1_SCK_B_MARK___2 = 1847,
	A17_MARK___3 = 1848,
	DACK2_B_MARK = 1849,
	I2C0_SDA_C_MARK = 1850,
	A18_MARK___3 = 1851,
	DREQ1_MARK___2 = 1852,
	SCIFA1_RXD_C_MARK___2 = 1853,
	SCIFB1_RXD_C_MARK___2 = 1854,
	A19_MARK___3 = 1855,
	DACK1_MARK___3 = 1856,
	SCIFA1_TXD_C_MARK___2 = 1857,
	SCIFB1_TXD_C_MARK___2 = 1858,
	SCIFB1_SCK_B_MARK___2 = 1859,
	A20_MARK___3 = 1860,
	SPCLK_MARK___2 = 1861,
	A21_MARK___3 = 1862,
	ATAWR0_N_B_MARK = 1863,
	MOSI_IO0_MARK___2 = 1864,
	A22_MARK___3 = 1865,
	MISO_IO1_MARK___2 = 1866,
	FMCLK_B_MARK___2 = 1867,
	TX0_MARK___2 = 1868,
	SCIFA0_TXD_MARK___4 = 1869,
	A23_MARK___3 = 1870,
	IO2_MARK___2 = 1871,
	BPFCLK_B_MARK___2 = 1872,
	RX0_MARK___2 = 1873,
	SCIFA0_RXD_MARK___4 = 1874,
	A24_MARK___3 = 1875,
	DREQ2_MARK = 1876,
	IO3_MARK___2 = 1877,
	TX1_MARK___2 = 1878,
	SCIFA1_TXD_MARK___4 = 1879,
	A25_MARK___3 = 1880,
	DACK2_MARK___2 = 1881,
	SSL_MARK___2 = 1882,
	DREQ1_C_MARK = 1883,
	RX1_MARK___2 = 1884,
	SCIFA1_RXD_MARK___4 = 1885,
	CS0_N_MARK___3 = 1886,
	ATAG0_N_B_MARK = 1887,
	I2C1_SCL_MARK___2 = 1888,
	CS1_N_A26_MARK___2 = 1889,
	ATADIR0_N_B_MARK = 1890,
	I2C1_SDA_MARK___2 = 1891,
	EX_CS1_N_MARK___2 = 1892,
	MSIOF2_SCK_MARK___3 = 1893,
	EX_CS2_N_MARK___2 = 1894,
	ATAWR0_N_MARK___2 = 1895,
	MSIOF2_SYNC_MARK___3 = 1896,
	EX_CS3_N_MARK___2 = 1897,
	ATADIR0_N_MARK___2 = 1898,
	MSIOF2_TXD_MARK___4 = 1899,
	ATAG0_N_MARK___2 = 1900,
	EX_WAIT1_MARK___2 = 1901,
	EX_CS4_N_MARK___2 = 1902,
	ATARD0_N_MARK___2 = 1903,
	MSIOF2_RXD_MARK___4 = 1904,
	EX_WAIT2_MARK___2 = 1905,
	EX_CS5_N_MARK___2 = 1906,
	ATACS00_N_MARK___2 = 1907,
	MSIOF2_SS1_MARK___4 = 1908,
	HRX1_B_MARK___2 = 1909,
	SCIFB1_RXD_B_MARK___2 = 1910,
	PWM1_MARK___3 = 1911,
	TPU_TO1_MARK = 1912,
	BS_N_MARK___2 = 1913,
	ATACS10_N_MARK___2 = 1914,
	MSIOF2_SS2_MARK___4 = 1915,
	HTX1_B_MARK___2 = 1916,
	SCIFB1_TXD_B_MARK___2 = 1917,
	PWM2_MARK___2 = 1918,
	TPU_TO2_MARK = 1919,
	RD_WR_N_MARK___2 = 1920,
	HRX2_B_MARK = 1921,
	FMIN_B_MARK___2 = 1922,
	SCIFB0_RXD_B_MARK___2 = 1923,
	DREQ1_D_MARK = 1924,
	WE0_N_MARK___3 = 1925,
	HCTS2_N_B_MARK = 1926,
	SCIFB0_TXD_B_MARK___2 = 1927,
	WE1_N_MARK___3 = 1928,
	ATARD0_N_B_MARK = 1929,
	HTX2_B_MARK = 1930,
	SCIFB0_RTS_N_B_MARK___2 = 1931,
	EX_WAIT0_MARK___2 = 1932,
	HRTS2_N_B_MARK = 1933,
	SCIFB0_CTS_N_B_MARK___2 = 1934,
	DREQ0_MARK___2 = 1935,
	PWM3_MARK___2 = 1936,
	TPU_TO3_MARK = 1937,
	DACK0_MARK___3 = 1938,
	DRACK0_MARK___2 = 1939,
	REMOCON_MARK___2 = 1940,
	SPEEDIN_MARK___2 = 1941,
	HSCK0_C_MARK = 1942,
	HSCK2_C_MARK = 1943,
	SCIFB0_SCK_B_MARK___2 = 1944,
	SCIFB2_SCK_B_MARK___2 = 1945,
	DREQ2_C_MARK = 1946,
	HTX2_D_MARK = 1947,
	SSI_SCK0129_MARK___2 = 1948,
	HRX0_C_MARK___2 = 1949,
	HRX2_C_MARK = 1950,
	SCIFB0_RXD_C_MARK___2 = 1951,
	SCIFB2_RXD_C_MARK___2 = 1952,
	SSI_WS0129_MARK___2 = 1953,
	HTX0_C_MARK___2 = 1954,
	HTX2_C_MARK = 1955,
	SCIFB0_TXD_C_MARK___2 = 1956,
	SCIFB2_TXD_C_MARK___2 = 1957,
	SSI_SDATA0_MARK___2 = 1958,
	I2C0_SCL_B_MARK = 1959,
	IIC0_SCL_B_MARK = 1960,
	MSIOF2_SCK_C_MARK = 1961,
	SSI_SCK1_MARK___2 = 1962,
	I2C0_SDA_B_MARK = 1963,
	IIC0_SDA_B_MARK = 1964,
	MSIOF2_SYNC_C_MARK = 1965,
	GLO_I0_D_MARK = 1966,
	SSI_WS1_MARK___2 = 1967,
	I2C1_SCL_B_MARK___2 = 1968,
	IIC1_SCL_B_MARK___2 = 1969,
	MSIOF2_TXD_C_MARK = 1970,
	GLO_I1_D_MARK = 1971,
	SSI_SDATA1_MARK___2 = 1972,
	I2C1_SDA_B_MARK___2 = 1973,
	IIC1_SDA_B_MARK___2 = 1974,
	MSIOF2_RXD_C_MARK = 1975,
	SSI_SCK2_MARK___2 = 1976,
	I2C2_SCL_MARK___2 = 1977,
	GPS_CLK_B_MARK = 1978,
	GLO_Q0_D_MARK = 1979,
	HSCK1_E_MARK = 1980,
	SSI_WS2_MARK___2 = 1981,
	I2C2_SDA_MARK___2 = 1982,
	GPS_SIGN_B_MARK = 1983,
	RX2_E_MARK = 1984,
	GLO_Q1_D_MARK = 1985,
	HCTS1_N_E_MARK = 1986,
	SSI_SDATA2_MARK___2 = 1987,
	GPS_MAG_B_MARK = 1988,
	TX2_E_MARK = 1989,
	HRTS1_N_E_MARK = 1990,
	SSI_SCK34_MARK___2 = 1991,
	SSI_WS34_MARK___2 = 1992,
	SSI_SDATA3_MARK___2 = 1993,
	SSI_SCK4_MARK___2 = 1994,
	GLO_SS_D_MARK = 1995,
	SSI_WS4_MARK___2 = 1996,
	GLO_RFON_D_MARK = 1997,
	SSI_SDATA4_MARK___2 = 1998,
	MSIOF2_SCK_D_MARK = 1999,
	SSI_SCK5_MARK___2 = 2000,
	MSIOF1_SCK_C_MARK = 2001,
	TS_SDATA0_MARK = 2002,
	GLO_I0_MARK___2 = 2003,
	MSIOF2_SYNC_D_MARK = 2004,
	VI1_R2_B_MARK___2 = 2005,
	SSI_WS5_MARK___2 = 2006,
	MSIOF1_SYNC_C_MARK = 2007,
	TS_SCK0_MARK___2 = 2008,
	GLO_I1_MARK___2 = 2009,
	MSIOF2_TXD_D_MARK = 2010,
	VI1_R3_B_MARK___2 = 2011,
	SSI_SDATA5_MARK___2 = 2012,
	MSIOF1_TXD_C_MARK = 2013,
	TS_SDEN0_MARK___2 = 2014,
	GLO_Q0_MARK___2 = 2015,
	MSIOF2_SS1_D_MARK = 2016,
	VI1_R4_B_MARK___2 = 2017,
	SSI_SCK6_MARK___2 = 2018,
	MSIOF1_RXD_C_MARK = 2019,
	TS_SPSYNC0_MARK___2 = 2020,
	GLO_Q1_MARK___2 = 2021,
	MSIOF2_RXD_D_MARK = 2022,
	VI1_R5_B_MARK___2 = 2023,
	SSI_WS6_MARK___2 = 2024,
	GLO_SCLK_MARK___2 = 2025,
	MSIOF2_SS2_D_MARK = 2026,
	VI1_R6_B_MARK___2 = 2027,
	SSI_SDATA6_MARK___2 = 2028,
	STP_IVCXO27_0_B_MARK___2 = 2029,
	GLO_SDATA_MARK___2 = 2030,
	VI1_R7_B_MARK___2 = 2031,
	SSI_SCK78_MARK___2 = 2032,
	STP_ISCLK_0_B_MARK___2 = 2033,
	GLO_SS_MARK___2 = 2034,
	SSI_WS78_MARK___2 = 2035,
	TX0_D_MARK = 2036,
	STP_ISD_0_B_MARK___2 = 2037,
	GLO_RFON_MARK___2 = 2038,
	SSI_SDATA7_MARK___2 = 2039,
	RX0_D_MARK = 2040,
	STP_ISEN_0_B_MARK___2 = 2041,
	SSI_SDATA8_MARK___2 = 2042,
	TX1_D_MARK___2 = 2043,
	STP_ISSYNC_0_B_MARK___2 = 2044,
	SSI_SCK9_MARK___2 = 2045,
	RX1_D_MARK___2 = 2046,
	GLO_SCLK_D_MARK = 2047,
	SSI_WS9_MARK___2 = 2048,
	TX3_D_MARK = 2049,
	CAN0_TX_D_MARK___2 = 2050,
	GLO_SDATA_D_MARK = 2051,
	SSI_SDATA9_MARK___2 = 2052,
	RX3_D_MARK = 2053,
	CAN0_RX_D_MARK___2 = 2054,
	AUDIO_CLKB_MARK___2 = 2055,
	STP_OPWM_0_B_MARK = 2056,
	MSIOF1_SCK_B_MARK___2 = 2057,
	SCIF_CLK_MARK___2 = 2058,
	DVC_MUTE_MARK___2 = 2059,
	BPFCLK_E_MARK___2 = 2060,
	AUDIO_CLKC_MARK___2 = 2061,
	SCIFB0_SCK_C_MARK = 2062,
	MSIOF1_SYNC_B_MARK = 2063,
	RX2_MARK___2 = 2064,
	SCIFA2_RXD_MARK___3 = 2065,
	FMIN_E_MARK___2 = 2066,
	AUDIO_CLKOUT_MARK___2 = 2067,
	MSIOF1_SS1_B_MARK___2 = 2068,
	TX2_MARK___2 = 2069,
	SCIFA2_TXD_MARK___3 = 2070,
	IRQ0_MARK___3 = 2071,
	SCIFB1_RXD_D_MARK___2 = 2072,
	INTC_IRQ0_N_MARK___2 = 2073,
	IRQ1_MARK___4 = 2074,
	SCIFB1_SCK_C_MARK = 2075,
	INTC_IRQ1_N_MARK___2 = 2076,
	IRQ2_MARK___3 = 2077,
	SCIFB1_TXD_D_MARK___2 = 2078,
	INTC_IRQ2_N_MARK___2 = 2079,
	IRQ3_MARK___3 = 2080,
	I2C4_SCL_C_MARK = 2081,
	MSIOF2_TXD_E_MARK = 2082,
	INTC_IRQ3_N_MARK___2 = 2083,
	IRQ4_MARK___2 = 2084,
	HRX1_C_MARK = 2085,
	I2C4_SDA_C_MARK = 2086,
	MSIOF2_RXD_E_MARK = 2087,
	INTC_IRQ4_N_MARK___2 = 2088,
	IRQ5_MARK___2 = 2089,
	HTX1_C_MARK = 2090,
	I2C1_SCL_E_MARK = 2091,
	MSIOF2_SCK_E_MARK = 2092,
	IRQ6_MARK___2 = 2093,
	HSCK1_C_MARK = 2094,
	MSIOF1_SS2_B_MARK___2 = 2095,
	I2C1_SDA_E_MARK = 2096,
	MSIOF2_SYNC_E_MARK = 2097,
	IRQ7_MARK___2 = 2098,
	HCTS1_N_C_MARK = 2099,
	MSIOF1_TXD_B_MARK___2 = 2100,
	GPS_CLK_C_MARK = 2101,
	GPS_CLK_D_MARK = 2102,
	IRQ8_MARK___3 = 2103,
	HRTS1_N_C_MARK = 2104,
	MSIOF1_RXD_B_MARK___2 = 2105,
	GPS_SIGN_C_MARK = 2106,
	GPS_SIGN_D_MARK = 2107,
	IRQ9_MARK___2 = 2108,
	DU1_DOTCLKIN_B_MARK = 2109,
	CAN_CLK_D_MARK = 2110,
	GPS_MAG_C_MARK = 2111,
	SCIF_CLK_B_MARK___2 = 2112,
	GPS_MAG_D_MARK = 2113,
	DU1_DR0_MARK = 2114,
	LCDOUT0_MARK___2 = 2115,
	VI1_DATA0_B_MARK = 2116,
	TX0_B_MARK___2 = 2117,
	SCIFA0_TXD_B_MARK___2 = 2118,
	MSIOF2_SCK_B_MARK = 2119,
	DU1_DR1_MARK = 2120,
	LCDOUT1_MARK___2 = 2121,
	VI1_DATA1_B_MARK = 2122,
	RX0_B_MARK___2 = 2123,
	SCIFA0_RXD_B_MARK___2 = 2124,
	MSIOF2_SYNC_B_MARK = 2125,
	DU1_DR2_MARK = 2126,
	LCDOUT2_MARK___2 = 2127,
	SSI_SCK0129_B_MARK = 2128,
	DU1_DR3_MARK = 2129,
	LCDOUT3_MARK___2 = 2130,
	SSI_WS0129_B_MARK = 2131,
	DU1_DR4_MARK = 2132,
	LCDOUT4_MARK___2 = 2133,
	SSI_SDATA0_B_MARK = 2134,
	DU1_DR5_MARK = 2135,
	LCDOUT5_MARK___2 = 2136,
	SSI_SCK1_B_MARK = 2137,
	DU1_DR6_MARK = 2138,
	LCDOUT6_MARK___2 = 2139,
	SSI_WS1_B_MARK = 2140,
	DU1_DR7_MARK = 2141,
	LCDOUT7_MARK___2 = 2142,
	SSI_SDATA1_B_MARK = 2143,
	DU1_DG0_MARK = 2144,
	LCDOUT8_MARK___2 = 2145,
	VI1_DATA2_B_MARK = 2146,
	TX1_B_MARK___2 = 2147,
	SCIFA1_TXD_B_MARK___2 = 2148,
	MSIOF2_SS1_B_MARK = 2149,
	DU1_DG1_MARK = 2150,
	LCDOUT9_MARK___2 = 2151,
	VI1_DATA3_B_MARK = 2152,
	RX1_B_MARK___2 = 2153,
	SCIFA1_RXD_B_MARK___2 = 2154,
	MSIOF2_SS2_B_MARK = 2155,
	DU1_DG2_MARK = 2156,
	LCDOUT10_MARK___2 = 2157,
	VI1_DATA4_B_MARK = 2158,
	SCIF1_SCK_B_MARK = 2159,
	SCIFA1_SCK_MARK___4 = 2160,
	SSI_SCK78_B_MARK___2 = 2161,
	DU1_DG3_MARK = 2162,
	LCDOUT11_MARK___2 = 2163,
	VI1_DATA5_B_MARK = 2164,
	SSI_WS78_B_MARK___2 = 2165,
	DU1_DG4_MARK = 2166,
	LCDOUT12_MARK___2 = 2167,
	VI1_DATA6_B_MARK = 2168,
	HRX0_B_MARK___2 = 2169,
	SCIFB2_RXD_B_MARK___2 = 2170,
	SSI_SDATA7_B_MARK___2 = 2171,
	DU1_DG5_MARK = 2172,
	LCDOUT13_MARK___2 = 2173,
	VI1_DATA7_B_MARK = 2174,
	HCTS0_N_B_MARK___2 = 2175,
	SCIFB2_TXD_B_MARK___2 = 2176,
	SSI_SDATA8_B_MARK___2 = 2177,
	DU1_DG6_MARK = 2178,
	LCDOUT14_MARK___2 = 2179,
	HRTS0_N_B_MARK___2 = 2180,
	SCIFB2_CTS_N_B_MARK___2 = 2181,
	SSI_SCK9_B_MARK = 2182,
	DU1_DG7_MARK = 2183,
	LCDOUT15_MARK___2 = 2184,
	HTX0_B_MARK___2 = 2185,
	SCIFB2_RTS_N_B_MARK___2 = 2186,
	SSI_WS9_B_MARK = 2187,
	DU1_DB0_MARK = 2188,
	LCDOUT16_MARK___2 = 2189,
	VI1_CLK_B_MARK___2 = 2190,
	TX2_B_MARK___2 = 2191,
	SCIFA2_TXD_B_MARK___2 = 2192,
	MSIOF2_TXD_B_MARK = 2193,
	DU1_DB1_MARK = 2194,
	LCDOUT17_MARK___2 = 2195,
	VI1_HSYNC_N_B_MARK___2 = 2196,
	RX2_B_MARK___2 = 2197,
	SCIFA2_RXD_B_MARK___2 = 2198,
	MSIOF2_RXD_B_MARK = 2199,
	DU1_DB2_MARK = 2200,
	LCDOUT18_MARK___2 = 2201,
	VI1_VSYNC_N_B_MARK___2 = 2202,
	SCIF2_SCK_B_MARK = 2203,
	SCIFA2_SCK_MARK___2 = 2204,
	SSI_SDATA9_B_MARK = 2205,
	DU1_DB3_MARK = 2206,
	LCDOUT19_MARK___2 = 2207,
	VI1_CLKENB_B_MARK___2 = 2208,
	DU1_DB4_MARK = 2209,
	LCDOUT20_MARK___2 = 2210,
	VI1_FIELD_B_MARK___2 = 2211,
	CAN1_RX_MARK___2 = 2212,
	DU1_DB5_MARK = 2213,
	LCDOUT21_MARK___2 = 2214,
	TX3_MARK = 2215,
	SCIFA3_TXD_MARK = 2216,
	CAN1_TX_MARK___2 = 2217,
	DU1_DB6_MARK = 2218,
	LCDOUT22_MARK___2 = 2219,
	I2C3_SCL_C_MARK = 2220,
	RX3_MARK = 2221,
	SCIFA3_RXD_MARK = 2222,
	DU1_DB7_MARK = 2223,
	LCDOUT23_MARK___2 = 2224,
	I2C3_SDA_C_MARK = 2225,
	SCIF3_SCK_MARK = 2226,
	SCIFA3_SCK_MARK = 2227,
	DU1_DOTCLKIN_MARK = 2228,
	QSTVA_QVS_MARK___2 = 2229,
	DU1_DOTCLKOUT0_MARK = 2230,
	QCLK_MARK___2 = 2231,
	DU1_DOTCLKOUT1_MARK = 2232,
	QSTVB_QVE_MARK___2 = 2233,
	CAN0_TX_MARK___2 = 2234,
	TX3_B_MARK = 2235,
	I2C2_SCL_B_MARK___2 = 2236,
	PWM4_MARK___2 = 2237,
	DU1_EXHSYNC_DU1_HSYNC_MARK = 2238,
	QSTH_QHS_MARK___2 = 2239,
	DU1_EXVSYNC_DU1_VSYNC_MARK = 2240,
	QSTB_QHE_MARK___2 = 2241,
	DU1_EXODDF_DU1_ODDF_DISP_CDE_MARK = 2242,
	QCPV_QDE_MARK___2 = 2243,
	CAN0_RX_MARK___2 = 2244,
	RX3_B_MARK = 2245,
	I2C2_SDA_B_MARK___2 = 2246,
	DU1_DISP_MARK = 2247,
	QPOLA_MARK___2 = 2248,
	DU1_CDE_MARK = 2249,
	QPOLB_MARK___2 = 2250,
	PWM4_B_MARK = 2251,
	VI0_CLKENB_MARK___2 = 2252,
	TX4_MARK = 2253,
	SCIFA4_TXD_MARK = 2254,
	TS_SDATA0_D_MARK = 2255,
	VI0_FIELD_MARK___2 = 2256,
	RX4_MARK = 2257,
	SCIFA4_RXD_MARK = 2258,
	TS_SCK0_D_MARK___2 = 2259,
	VI0_HSYNC_N_MARK___2 = 2260,
	TX5_MARK = 2261,
	SCIFA5_TXD_MARK = 2262,
	TS_SDEN0_D_MARK___2 = 2263,
	VI0_VSYNC_N_MARK___2 = 2264,
	RX5_MARK = 2265,
	SCIFA5_RXD_MARK = 2266,
	TS_SPSYNC0_D_MARK___2 = 2267,
	VI0_DATA3_VI0_B3_MARK___2 = 2268,
	SCIF3_SCK_B_MARK = 2269,
	SCIFA3_SCK_B_MARK = 2270,
	VI0_G0_MARK___2 = 2271,
	IIC1_SCL_MARK___3 = 2272,
	STP_IVCXO27_0_C_MARK = 2273,
	I2C4_SCL_MARK = 2274,
	HCTS2_N_MARK = 2275,
	SCIFB2_CTS_N_MARK___2 = 2276,
	ATAWR1_N_MARK___2 = 2277,
	VI0_G1_MARK___2 = 2278,
	IIC1_SDA_MARK___3 = 2279,
	STP_ISCLK_0_C_MARK = 2280,
	I2C4_SDA_MARK = 2281,
	HRTS2_N_MARK = 2282,
	SCIFB2_RTS_N_MARK___2 = 2283,
	ATADIR1_N_MARK___2 = 2284,
	VI0_G2_MARK___2 = 2285,
	VI2_HSYNC_N_MARK___2 = 2286,
	STP_ISD_0_C_MARK = 2287,
	I2C3_SCL_B_MARK = 2288,
	HSCK2_MARK = 2289,
	SCIFB2_SCK_MARK___2 = 2290,
	ATARD1_N_MARK___2 = 2291,
	VI0_G3_MARK___2 = 2292,
	VI2_VSYNC_N_MARK___2 = 2293,
	STP_ISEN_0_C_MARK = 2294,
	I2C3_SDA_B_MARK = 2295,
	HRX2_MARK = 2296,
	SCIFB2_RXD_MARK___2 = 2297,
	ATACS01_N_MARK___2 = 2298,
	VI0_G4_MARK___2 = 2299,
	VI2_CLKENB_MARK___2 = 2300,
	STP_ISSYNC_0_C_MARK = 2301,
	HTX2_MARK = 2302,
	SCIFB2_TXD_MARK___2 = 2303,
	SCIFB0_SCK_D_MARK = 2304,
	VI0_G5_MARK___2 = 2305,
	VI2_FIELD_MARK___2 = 2306,
	STP_OPWM_0_C_MARK = 2307,
	FMCLK_D_MARK = 2308,
	CAN0_TX_E_MARK = 2309,
	HTX1_D_MARK = 2310,
	SCIFB0_TXD_D_MARK = 2311,
	VI0_G6_MARK___2 = 2312,
	VI2_CLK_MARK___2 = 2313,
	BPFCLK_D_MARK___2 = 2314,
	VI0_G7_MARK___2 = 2315,
	VI2_DATA0_MARK = 2316,
	FMIN_D_MARK___2 = 2317,
	VI0_R0_MARK___2 = 2318,
	VI2_DATA1_MARK = 2319,
	GLO_I0_B_MARK___2 = 2320,
	TS_SDATA0_C_MARK = 2321,
	ATACS11_N_MARK___2 = 2322,
	VI0_R1_MARK___2 = 2323,
	VI2_DATA2_MARK = 2324,
	GLO_I1_B_MARK___2 = 2325,
	TS_SCK0_C_MARK___2 = 2326,
	ATAG1_N_MARK___2 = 2327,
	VI0_R2_MARK___2 = 2328,
	VI2_DATA3_MARK = 2329,
	GLO_Q0_B_MARK___2 = 2330,
	TS_SDEN0_C_MARK___2 = 2331,
	VI0_R3_MARK___2 = 2332,
	VI2_DATA4_MARK = 2333,
	GLO_Q1_B_MARK___2 = 2334,
	TS_SPSYNC0_C_MARK___2 = 2335,
	VI0_R4_MARK___2 = 2336,
	VI2_DATA5_MARK = 2337,
	GLO_SCLK_B_MARK___2 = 2338,
	TX0_C_MARK = 2339,
	I2C1_SCL_D_MARK = 2340,
	VI0_R5_MARK___2 = 2341,
	VI2_DATA6_MARK = 2342,
	GLO_SDATA_B_MARK___2 = 2343,
	RX0_C_MARK = 2344,
	I2C1_SDA_D_MARK = 2345,
	VI0_R6_MARK___2 = 2346,
	VI2_DATA7_MARK = 2347,
	GLO_SS_B_MARK___2 = 2348,
	TX1_C_MARK___2 = 2349,
	I2C4_SCL_B_MARK = 2350,
	VI0_R7_MARK___2 = 2351,
	GLO_RFON_B_MARK___2 = 2352,
	RX1_C_MARK___2 = 2353,
	CAN0_RX_E_MARK = 2354,
	I2C4_SDA_B_MARK = 2355,
	HRX1_D_MARK = 2356,
	SCIFB0_RXD_D_MARK = 2357,
	VI1_HSYNC_N_MARK___2 = 2358,
	AVB_RXD0_MARK___2 = 2359,
	TS_SDATA0_B_MARK = 2360,
	TX4_B_MARK = 2361,
	SCIFA4_TXD_B_MARK = 2362,
	VI1_VSYNC_N_MARK___2 = 2363,
	AVB_RXD1_MARK___2 = 2364,
	TS_SCK0_B_MARK___2 = 2365,
	RX4_B_MARK = 2366,
	SCIFA4_RXD_B_MARK = 2367,
	VI1_CLKENB_MARK___2 = 2368,
	AVB_RXD2_MARK___2 = 2369,
	TS_SDEN0_B_MARK___2 = 2370,
	VI1_FIELD_MARK___2 = 2371,
	AVB_RXD3_MARK___2 = 2372,
	TS_SPSYNC0_B_MARK___2 = 2373,
	VI1_CLK_MARK___2 = 2374,
	AVB_RXD4_MARK___2 = 2375,
	VI1_DATA0_MARK = 2376,
	AVB_RXD5_MARK___2 = 2377,
	VI1_DATA1_MARK = 2378,
	AVB_RXD6_MARK___2 = 2379,
	VI1_DATA2_MARK = 2380,
	AVB_RXD7_MARK___2 = 2381,
	VI1_DATA3_MARK = 2382,
	AVB_RX_ER_MARK___2 = 2383,
	VI1_DATA4_MARK = 2384,
	AVB_MDIO_MARK___2 = 2385,
	VI1_DATA5_MARK = 2386,
	AVB_RX_DV_MARK___2 = 2387,
	VI1_DATA6_MARK = 2388,
	AVB_MAGIC_MARK___2 = 2389,
	VI1_DATA7_MARK = 2390,
	AVB_MDC_MARK___2 = 2391,
	ETH_MDIO_MARK___2 = 2392,
	AVB_RX_CLK_MARK___2 = 2393,
	I2C2_SCL_C_MARK___2 = 2394,
	ETH_CRS_DV_MARK___2 = 2395,
	AVB_LINK_MARK___2 = 2396,
	I2C2_SDA_C_MARK___2 = 2397,
	ETH_RX_ER_MARK___2 = 2398,
	AVB_CRS_MARK___2 = 2399,
	I2C3_SCL_MARK___2 = 2400,
	IIC0_SCL_MARK___3 = 2401,
	ETH_RXD0_MARK___2 = 2402,
	AVB_PHY_INT_MARK___2 = 2403,
	I2C3_SDA_MARK___2 = 2404,
	IIC0_SDA_MARK___3 = 2405,
	ETH_RXD1_MARK___2 = 2406,
	AVB_GTXREFCLK_MARK___2 = 2407,
	CAN0_TX_C_MARK___2 = 2408,
	I2C2_SCL_D_MARK___2 = 2409,
	MSIOF1_RXD_E_MARK = 2410,
	ETH_LINK_MARK___2 = 2411,
	AVB_TXD0_MARK___2 = 2412,
	CAN0_RX_C_MARK___2 = 2413,
	I2C2_SDA_D_MARK___2 = 2414,
	MSIOF1_SCK_E_MARK = 2415,
	ETH_REFCLK_MARK = 2416,
	AVB_TXD1_MARK___2 = 2417,
	SCIFA3_RXD_B_MARK = 2418,
	CAN1_RX_C_MARK = 2419,
	MSIOF1_SYNC_E_MARK = 2420,
	ETH_TXD1_MARK___2 = 2421,
	AVB_TXD2_MARK___2 = 2422,
	SCIFA3_TXD_B_MARK = 2423,
	CAN1_TX_C_MARK = 2424,
	MSIOF1_TXD_E_MARK = 2425,
	ETH_TX_EN_MARK___2 = 2426,
	AVB_TXD3_MARK___2 = 2427,
	TCLK1_B_MARK___2 = 2428,
	CAN_CLK_B_MARK___2 = 2429,
	ETH_MAGIC_MARK___2 = 2430,
	AVB_TXD4_MARK___2 = 2431,
	IETX_C_MARK___2 = 2432,
	ETH_TXD0_MARK___2 = 2433,
	AVB_TXD5_MARK___2 = 2434,
	IECLK_C_MARK___2 = 2435,
	ETH_MDC_MARK___2 = 2436,
	AVB_TXD6_MARK___2 = 2437,
	IERX_C_MARK___2 = 2438,
	STP_IVCXO27_0_MARK___2 = 2439,
	AVB_TXD7_MARK___2 = 2440,
	SCIFB2_TXD_D_MARK = 2441,
	ADIDATA_B_MARK = 2442,
	MSIOF0_SYNC_C_MARK = 2443,
	STP_ISCLK_0_MARK___3 = 2444,
	AVB_TX_EN_MARK___2 = 2445,
	SCIFB2_RXD_D_MARK = 2446,
	ADICS_SAMP_B_MARK = 2447,
	MSIOF0_SCK_C_MARK = 2448,
	STP_ISD_0_MARK___3 = 2449,
	AVB_TX_ER_MARK___2 = 2450,
	SCIFB2_SCK_C_MARK = 2451,
	ADICLK_B_MARK = 2452,
	MSIOF0_SS1_C_MARK = 2453,
	STP_ISEN_0_MARK___3 = 2454,
	AVB_TX_CLK_MARK___2 = 2455,
	ADICHS0_B_MARK = 2456,
	MSIOF0_SS2_C_MARK = 2457,
	STP_ISSYNC_0_MARK___3 = 2458,
	AVB_COL_MARK___2 = 2459,
	ADICHS1_B_MARK = 2460,
	MSIOF0_RXD_C_MARK = 2461,
	STP_OPWM_0_MARK___3 = 2462,
	AVB_GTX_CLK_MARK___2 = 2463,
	PWM0_B_MARK___2 = 2464,
	ADICHS2_B_MARK = 2465,
	MSIOF0_TXD_C_MARK = 2466,
	SD0_CLK_MARK___2 = 2467,
	SPCLK_B_MARK = 2468,
	SD0_CMD_MARK___2 = 2469,
	MOSI_IO0_B_MARK = 2470,
	SD0_DATA0_MARK = 2471,
	MISO_IO1_B_MARK = 2472,
	SD0_DATA1_MARK = 2473,
	IO2_B_MARK = 2474,
	SD0_DATA2_MARK = 2475,
	IO3_B_MARK = 2476,
	SD0_DATA3_MARK = 2477,
	SSL_B_MARK = 2478,
	SD0_CD_MARK___2 = 2479,
	MMC_D6_B_MARK = 2480,
	SIM0_RST_B_MARK___2 = 2481,
	CAN0_RX_F_MARK = 2482,
	SCIFA5_TXD_B_MARK = 2483,
	TX3_C_MARK = 2484,
	SD0_WP_MARK___2 = 2485,
	MMC_D7_B_MARK = 2486,
	SIM0_D_B_MARK___2 = 2487,
	CAN0_TX_F_MARK = 2488,
	SCIFA5_RXD_B_MARK = 2489,
	RX3_C_MARK = 2490,
	SD1_CMD_MARK___2 = 2491,
	REMOCON_B_MARK = 2492,
	SD1_DATA0_MARK = 2493,
	SPEEDIN_B_MARK = 2494,
	SD1_DATA1_MARK = 2495,
	IETX_B_MARK___2 = 2496,
	SD1_DATA2_MARK = 2497,
	IECLK_B_MARK___2 = 2498,
	SD1_DATA3_MARK = 2499,
	IERX_B_MARK___2 = 2500,
	SD1_CD_MARK___2 = 2501,
	PWM0_MARK___3 = 2502,
	TPU_TO0_MARK = 2503,
	I2C1_SCL_C_MARK___2 = 2504,
	SD1_WP_MARK___2 = 2505,
	PWM1_B_MARK___2 = 2506,
	I2C1_SDA_C_MARK___2 = 2507,
	SD2_CLK_MARK___2 = 2508,
	MMC_CLK_MARK = 2509,
	SD2_CMD_MARK___2 = 2510,
	MMC_CMD_MARK = 2511,
	SD2_DATA0_MARK = 2512,
	MMC_D0_MARK = 2513,
	SD2_DATA1_MARK = 2514,
	MMC_D1_MARK = 2515,
	SD2_DATA2_MARK = 2516,
	MMC_D2_MARK = 2517,
	SD2_DATA3_MARK = 2518,
	MMC_D3_MARK = 2519,
	SD2_CD_MARK___2 = 2520,
	MMC_D4_MARK = 2521,
	IIC1_SCL_C_MARK___2 = 2522,
	TX5_B_MARK = 2523,
	SCIFA5_TXD_C_MARK = 2524,
	SD2_WP_MARK___2 = 2525,
	MMC_D5_MARK = 2526,
	IIC1_SDA_C_MARK___2 = 2527,
	RX5_B_MARK = 2528,
	SCIFA5_RXD_C_MARK = 2529,
	MSIOF0_SCK_MARK___3 = 2530,
	RX2_C_MARK = 2531,
	ADIDATA_MARK___2 = 2532,
	VI1_CLK_C_MARK = 2533,
	VI1_G0_B_MARK___2 = 2534,
	MSIOF0_SYNC_MARK___3 = 2535,
	TX2_C_MARK = 2536,
	ADICS_SAMP_MARK___2 = 2537,
	VI1_CLKENB_C_MARK = 2538,
	VI1_G1_B_MARK___2 = 2539,
	MSIOF0_TXD_MARK___4 = 2540,
	ADICLK_MARK___2 = 2541,
	VI1_FIELD_C_MARK = 2542,
	VI1_G2_B_MARK___2 = 2543,
	MSIOF0_RXD_MARK___4 = 2544,
	ADICHS0_MARK___2 = 2545,
	VI1_DATA0_C_MARK = 2546,
	VI1_G3_B_MARK___2 = 2547,
	MSIOF0_SS1_MARK___4 = 2548,
	MMC_D6_MARK = 2549,
	ADICHS1_MARK___2 = 2550,
	TX0_E_MARK = 2551,
	VI1_HSYNC_N_C_MARK = 2552,
	IIC0_SCL_C_MARK = 2553,
	VI1_G4_B_MARK___2 = 2554,
	MSIOF0_SS2_MARK___4 = 2555,
	MMC_D7_MARK = 2556,
	ADICHS2_MARK___2 = 2557,
	RX0_E_MARK = 2558,
	VI1_VSYNC_N_C_MARK = 2559,
	IIC0_SDA_C_MARK = 2560,
	VI1_G5_B_MARK___2 = 2561,
	SIM0_RST_MARK___3 = 2562,
	IETX_MARK___2 = 2563,
	CAN1_TX_D_MARK = 2564,
	SIM0_CLK_MARK___3 = 2565,
	IECLK_MARK___2 = 2566,
	CAN_CLK_C_MARK = 2567,
	SIM0_D_MARK___2 = 2568,
	IERX_MARK___2 = 2569,
	CAN1_RX_D_MARK = 2570,
	GPS_CLK_MARK___2 = 2571,
	DU1_DOTCLKIN_C_MARK = 2572,
	AUDIO_CLKB_B_MARK = 2573,
	PWM5_B_MARK = 2574,
	SCIFA3_TXD_C_MARK = 2575,
	GPS_SIGN_MARK___2 = 2576,
	TX4_C_MARK = 2577,
	SCIFA4_TXD_C_MARK = 2578,
	PWM5_MARK___2 = 2579,
	VI1_G6_B_MARK___2 = 2580,
	SCIFA3_RXD_C_MARK = 2581,
	GPS_MAG_MARK___2 = 2582,
	RX4_C_MARK = 2583,
	SCIFA4_RXD_C_MARK = 2584,
	PWM6_MARK___2 = 2585,
	VI1_G7_B_MARK___2 = 2586,
	SCIFA3_SCK_C_MARK = 2587,
	HCTS0_N_MARK___2 = 2588,
	SCIFB0_CTS_N_MARK___2 = 2589,
	GLO_I0_C_MARK___2 = 2590,
	TCLK1_MARK___2 = 2591,
	VI1_DATA1_C_MARK = 2592,
	HRTS0_N_MARK___2 = 2593,
	SCIFB0_RTS_N_MARK___2 = 2594,
	GLO_I1_C_MARK___2 = 2595,
	VI1_DATA2_C_MARK = 2596,
	HSCK0_MARK___2 = 2597,
	SCIFB0_SCK_MARK___3 = 2598,
	GLO_Q0_C_MARK___2 = 2599,
	CAN_CLK_MARK___2 = 2600,
	TCLK2_MARK___2 = 2601,
	VI1_DATA3_C_MARK = 2602,
	HRX0_MARK___2 = 2603,
	SCIFB0_RXD_MARK___3 = 2604,
	GLO_Q1_C_MARK___2 = 2605,
	CAN0_RX_B_MARK___2 = 2606,
	VI1_DATA4_C_MARK = 2607,
	HTX0_MARK___2 = 2608,
	SCIFB0_TXD_MARK___3 = 2609,
	GLO_SCLK_C_MARK___2 = 2610,
	CAN0_TX_B_MARK___2 = 2611,
	VI1_DATA5_C_MARK = 2612,
	HRX1_MARK___2 = 2613,
	SCIFB1_RXD_MARK___2 = 2614,
	VI1_R0_B_MARK___2 = 2615,
	GLO_SDATA_C_MARK___2 = 2616,
	VI1_DATA6_C_MARK = 2617,
	HTX1_MARK___2 = 2618,
	SCIFB1_TXD_MARK___2 = 2619,
	VI1_R1_B_MARK___2 = 2620,
	GLO_SS_C_MARK___2 = 2621,
	VI1_DATA7_C_MARK = 2622,
	HSCK1_MARK___2 = 2623,
	SCIFB1_SCK_MARK___2 = 2624,
	MLB_CLK_MARK___2 = 2625,
	GLO_RFON_C_MARK___2 = 2626,
	HCTS1_N_MARK___2 = 2627,
	SCIFB1_CTS_N_MARK___2 = 2628,
	MLB_SIG_MARK___2 = 2629,
	CAN1_TX_B_MARK___2 = 2630,
	HRTS1_N_MARK___2 = 2631,
	SCIFB1_RTS_N_MARK___2 = 2632,
	MLB_DAT_MARK___2 = 2633,
	CAN1_RX_B_MARK___2 = 2634,
	PINMUX_MARK_END___5 = 2635,
};

union vin_data12 {
	unsigned int data12[12];
	unsigned int data10[10];
	unsigned int data8[8];
};

enum {
	PINMUX_RESERVED___6 = 0,
	PINMUX_DATA_BEGIN___6 = 1,
	GP_0_0_DATA___3 = 2,
	GP_0_1_DATA___3 = 3,
	GP_0_2_DATA___3 = 4,
	GP_0_3_DATA___3 = 5,
	GP_0_4_DATA___3 = 6,
	GP_0_5_DATA___3 = 7,
	GP_0_6_DATA___3 = 8,
	GP_0_7_DATA___3 = 9,
	GP_0_8_DATA___3 = 10,
	GP_0_9_DATA___3 = 11,
	GP_0_10_DATA___3 = 12,
	GP_0_11_DATA___3 = 13,
	GP_0_12_DATA___3 = 14,
	GP_0_13_DATA___3 = 15,
	GP_0_14_DATA___3 = 16,
	GP_0_15_DATA___3 = 17,
	GP_0_16_DATA___3 = 18,
	GP_0_17_DATA___3 = 19,
	GP_0_18_DATA___3 = 20,
	GP_0_19_DATA___3 = 21,
	GP_0_20_DATA___3 = 22,
	GP_0_21_DATA___3 = 23,
	GP_0_22_DATA___3 = 24,
	GP_0_23_DATA___3 = 25,
	GP_0_24_DATA___3 = 26,
	GP_0_25_DATA___3 = 27,
	GP_0_26_DATA___3 = 28,
	GP_0_27_DATA___3 = 29,
	GP_0_28_DATA___3 = 30,
	GP_0_29_DATA___3 = 31,
	GP_0_30_DATA___3 = 32,
	GP_0_31_DATA___3 = 33,
	GP_1_0_DATA___3 = 34,
	GP_1_1_DATA___3 = 35,
	GP_1_2_DATA___3 = 36,
	GP_1_3_DATA___3 = 37,
	GP_1_4_DATA___3 = 38,
	GP_1_5_DATA___3 = 39,
	GP_1_6_DATA___3 = 40,
	GP_1_7_DATA___3 = 41,
	GP_1_8_DATA___3 = 42,
	GP_1_9_DATA___3 = 43,
	GP_1_10_DATA___3 = 44,
	GP_1_11_DATA___3 = 45,
	GP_1_12_DATA___3 = 46,
	GP_1_13_DATA___3 = 47,
	GP_1_14_DATA___3 = 48,
	GP_1_15_DATA___3 = 49,
	GP_1_16_DATA___3 = 50,
	GP_1_17_DATA___3 = 51,
	GP_1_18_DATA___3 = 52,
	GP_1_19_DATA___3 = 53,
	GP_1_20_DATA___3 = 54,
	GP_1_21_DATA___3 = 55,
	GP_1_22_DATA___3 = 56,
	GP_1_23_DATA___3 = 57,
	GP_1_24_DATA___3 = 58,
	GP_1_25_DATA___3 = 59,
	GP_2_0_DATA___3 = 60,
	GP_2_1_DATA___3 = 61,
	GP_2_2_DATA___3 = 62,
	GP_2_3_DATA___3 = 63,
	GP_2_4_DATA___3 = 64,
	GP_2_5_DATA___3 = 65,
	GP_2_6_DATA___3 = 66,
	GP_2_7_DATA___3 = 67,
	GP_2_8_DATA___3 = 68,
	GP_2_9_DATA___3 = 69,
	GP_2_10_DATA___3 = 70,
	GP_2_11_DATA___3 = 71,
	GP_2_12_DATA___3 = 72,
	GP_2_13_DATA___3 = 73,
	GP_2_14_DATA___3 = 74,
	GP_2_15_DATA___3 = 75,
	GP_2_16_DATA___3 = 76,
	GP_2_17_DATA___3 = 77,
	GP_2_18_DATA___3 = 78,
	GP_2_19_DATA___3 = 79,
	GP_2_20_DATA___3 = 80,
	GP_2_21_DATA___3 = 81,
	GP_2_22_DATA___3 = 82,
	GP_2_23_DATA___3 = 83,
	GP_2_24_DATA___3 = 84,
	GP_2_25_DATA___3 = 85,
	GP_2_26_DATA___3 = 86,
	GP_2_27_DATA___3 = 87,
	GP_2_28_DATA___3 = 88,
	GP_2_29_DATA___3 = 89,
	GP_2_30_DATA___2 = 90,
	GP_2_31_DATA___2 = 91,
	GP_3_0_DATA___3 = 92,
	GP_3_1_DATA___3 = 93,
	GP_3_2_DATA___3 = 94,
	GP_3_3_DATA___3 = 95,
	GP_3_4_DATA___3 = 96,
	GP_3_5_DATA___3 = 97,
	GP_3_6_DATA___3 = 98,
	GP_3_7_DATA___3 = 99,
	GP_3_8_DATA___3 = 100,
	GP_3_9_DATA___3 = 101,
	GP_3_10_DATA___3 = 102,
	GP_3_11_DATA___3 = 103,
	GP_3_12_DATA___3 = 104,
	GP_3_13_DATA___3 = 105,
	GP_3_14_DATA___3 = 106,
	GP_3_15_DATA___3 = 107,
	GP_3_16_DATA___3 = 108,
	GP_3_17_DATA___3 = 109,
	GP_3_18_DATA___3 = 110,
	GP_3_19_DATA___3 = 111,
	GP_3_20_DATA___3 = 112,
	GP_3_21_DATA___3 = 113,
	GP_3_22_DATA___3 = 114,
	GP_3_23_DATA___3 = 115,
	GP_3_24_DATA___3 = 116,
	GP_3_25_DATA___3 = 117,
	GP_3_26_DATA___3 = 118,
	GP_3_27_DATA___3 = 119,
	GP_3_28_DATA___3 = 120,
	GP_3_29_DATA___3 = 121,
	GP_3_30_DATA___3 = 122,
	GP_3_31_DATA___3 = 123,
	GP_4_0_DATA___3 = 124,
	GP_4_1_DATA___3 = 125,
	GP_4_2_DATA___3 = 126,
	GP_4_3_DATA___3 = 127,
	GP_4_4_DATA___3 = 128,
	GP_4_5_DATA___3 = 129,
	GP_4_6_DATA___3 = 130,
	GP_4_7_DATA___3 = 131,
	GP_4_8_DATA___3 = 132,
	GP_4_9_DATA___3 = 133,
	GP_4_10_DATA___3 = 134,
	GP_4_11_DATA___3 = 135,
	GP_4_12_DATA___3 = 136,
	GP_4_13_DATA___3 = 137,
	GP_4_14_DATA___3 = 138,
	GP_4_15_DATA___3 = 139,
	GP_4_16_DATA___3 = 140,
	GP_4_17_DATA___3 = 141,
	GP_4_18_DATA___3 = 142,
	GP_4_19_DATA___3 = 143,
	GP_4_20_DATA___3 = 144,
	GP_4_21_DATA___3 = 145,
	GP_4_22_DATA___3 = 146,
	GP_4_23_DATA___3 = 147,
	GP_4_24_DATA___3 = 148,
	GP_4_25_DATA___3 = 149,
	GP_4_26_DATA___3 = 150,
	GP_4_27_DATA___3 = 151,
	GP_4_28_DATA___3 = 152,
	GP_4_29_DATA___3 = 153,
	GP_4_30_DATA___3 = 154,
	GP_4_31_DATA___3 = 155,
	GP_5_0_DATA___3 = 156,
	GP_5_1_DATA___3 = 157,
	GP_5_2_DATA___3 = 158,
	GP_5_3_DATA___3 = 159,
	GP_5_4_DATA___3 = 160,
	GP_5_5_DATA___3 = 161,
	GP_5_6_DATA___3 = 162,
	GP_5_7_DATA___3 = 163,
	GP_5_8_DATA___3 = 164,
	GP_5_9_DATA___3 = 165,
	GP_5_10_DATA___3 = 166,
	GP_5_11_DATA___3 = 167,
	GP_5_12_DATA___3 = 168,
	GP_5_13_DATA___3 = 169,
	GP_5_14_DATA___3 = 170,
	GP_5_15_DATA___3 = 171,
	GP_5_16_DATA___3 = 172,
	GP_5_17_DATA___3 = 173,
	GP_5_18_DATA___3 = 174,
	GP_5_19_DATA___3 = 175,
	GP_5_20_DATA___3 = 176,
	GP_5_21_DATA___3 = 177,
	GP_5_22_DATA___3 = 178,
	GP_5_23_DATA___3 = 179,
	GP_5_24_DATA___3 = 180,
	GP_5_25_DATA___3 = 181,
	GP_5_26_DATA___3 = 182,
	GP_5_27_DATA___3 = 183,
	GP_6_0_DATA___2 = 184,
	GP_6_1_DATA___2 = 185,
	GP_6_2_DATA___2 = 186,
	GP_6_3_DATA___2 = 187,
	GP_6_4_DATA___2 = 188,
	GP_6_5_DATA___2 = 189,
	GP_6_6_DATA___2 = 190,
	GP_6_7_DATA___2 = 191,
	GP_6_8_DATA___2 = 192,
	GP_6_9_DATA___2 = 193,
	GP_6_10_DATA___2 = 194,
	GP_6_11_DATA___2 = 195,
	GP_6_12_DATA___2 = 196,
	GP_6_13_DATA___2 = 197,
	GP_6_14_DATA___2 = 198,
	GP_6_15_DATA___2 = 199,
	GP_6_16_DATA___2 = 200,
	GP_6_17_DATA___2 = 201,
	GP_6_18_DATA___2 = 202,
	GP_6_19_DATA___2 = 203,
	GP_6_20_DATA___2 = 204,
	GP_6_21_DATA___2 = 205,
	GP_6_22_DATA___2 = 206,
	GP_6_23_DATA___2 = 207,
	GP_6_24_DATA___2 = 208,
	GP_6_25_DATA___2 = 209,
	PINMUX_DATA_END___6 = 210,
	PINMUX_FUNCTION_BEGIN___6 = 211,
	GP_0_0_FN___3 = 212,
	GP_0_1_FN___3 = 213,
	GP_0_2_FN___3 = 214,
	GP_0_3_FN___3 = 215,
	GP_0_4_FN___3 = 216,
	GP_0_5_FN___3 = 217,
	GP_0_6_FN___3 = 218,
	GP_0_7_FN___3 = 219,
	GP_0_8_FN___3 = 220,
	GP_0_9_FN___3 = 221,
	GP_0_10_FN___3 = 222,
	GP_0_11_FN___3 = 223,
	GP_0_12_FN___3 = 224,
	GP_0_13_FN___3 = 225,
	GP_0_14_FN___3 = 226,
	GP_0_15_FN___3 = 227,
	GP_0_16_FN___3 = 228,
	GP_0_17_FN___3 = 229,
	GP_0_18_FN___3 = 230,
	GP_0_19_FN___3 = 231,
	GP_0_20_FN___3 = 232,
	GP_0_21_FN___3 = 233,
	GP_0_22_FN___3 = 234,
	GP_0_23_FN___3 = 235,
	GP_0_24_FN___3 = 236,
	GP_0_25_FN___3 = 237,
	GP_0_26_FN___3 = 238,
	GP_0_27_FN___3 = 239,
	GP_0_28_FN___3 = 240,
	GP_0_29_FN___3 = 241,
	GP_0_30_FN___3 = 242,
	GP_0_31_FN___3 = 243,
	GP_1_0_FN___3 = 244,
	GP_1_1_FN___3 = 245,
	GP_1_2_FN___3 = 246,
	GP_1_3_FN___3 = 247,
	GP_1_4_FN___3 = 248,
	GP_1_5_FN___3 = 249,
	GP_1_6_FN___3 = 250,
	GP_1_7_FN___3 = 251,
	GP_1_8_FN___3 = 252,
	GP_1_9_FN___3 = 253,
	GP_1_10_FN___3 = 254,
	GP_1_11_FN___3 = 255,
	GP_1_12_FN___3 = 256,
	GP_1_13_FN___3 = 257,
	GP_1_14_FN___3 = 258,
	GP_1_15_FN___3 = 259,
	GP_1_16_FN___3 = 260,
	GP_1_17_FN___3 = 261,
	GP_1_18_FN___3 = 262,
	GP_1_19_FN___3 = 263,
	GP_1_20_FN___3 = 264,
	GP_1_21_FN___3 = 265,
	GP_1_22_FN___3 = 266,
	GP_1_23_FN___3 = 267,
	GP_1_24_FN___3 = 268,
	GP_1_25_FN___3 = 269,
	GP_2_0_FN___3 = 270,
	GP_2_1_FN___3 = 271,
	GP_2_2_FN___3 = 272,
	GP_2_3_FN___3 = 273,
	GP_2_4_FN___3 = 274,
	GP_2_5_FN___3 = 275,
	GP_2_6_FN___3 = 276,
	GP_2_7_FN___3 = 277,
	GP_2_8_FN___3 = 278,
	GP_2_9_FN___3 = 279,
	GP_2_10_FN___3 = 280,
	GP_2_11_FN___3 = 281,
	GP_2_12_FN___3 = 282,
	GP_2_13_FN___3 = 283,
	GP_2_14_FN___3 = 284,
	GP_2_15_FN___3 = 285,
	GP_2_16_FN___3 = 286,
	GP_2_17_FN___3 = 287,
	GP_2_18_FN___3 = 288,
	GP_2_19_FN___3 = 289,
	GP_2_20_FN___3 = 290,
	GP_2_21_FN___3 = 291,
	GP_2_22_FN___3 = 292,
	GP_2_23_FN___3 = 293,
	GP_2_24_FN___3 = 294,
	GP_2_25_FN___3 = 295,
	GP_2_26_FN___3 = 296,
	GP_2_27_FN___3 = 297,
	GP_2_28_FN___3 = 298,
	GP_2_29_FN___3 = 299,
	GP_2_30_FN___2 = 300,
	GP_2_31_FN___2 = 301,
	GP_3_0_FN___3 = 302,
	GP_3_1_FN___3 = 303,
	GP_3_2_FN___3 = 304,
	GP_3_3_FN___3 = 305,
	GP_3_4_FN___3 = 306,
	GP_3_5_FN___3 = 307,
	GP_3_6_FN___3 = 308,
	GP_3_7_FN___3 = 309,
	GP_3_8_FN___3 = 310,
	GP_3_9_FN___3 = 311,
	GP_3_10_FN___3 = 312,
	GP_3_11_FN___3 = 313,
	GP_3_12_FN___3 = 314,
	GP_3_13_FN___3 = 315,
	GP_3_14_FN___3 = 316,
	GP_3_15_FN___3 = 317,
	GP_3_16_FN___3 = 318,
	GP_3_17_FN___3 = 319,
	GP_3_18_FN___3 = 320,
	GP_3_19_FN___3 = 321,
	GP_3_20_FN___3 = 322,
	GP_3_21_FN___3 = 323,
	GP_3_22_FN___3 = 324,
	GP_3_23_FN___3 = 325,
	GP_3_24_FN___3 = 326,
	GP_3_25_FN___3 = 327,
	GP_3_26_FN___3 = 328,
	GP_3_27_FN___3 = 329,
	GP_3_28_FN___3 = 330,
	GP_3_29_FN___3 = 331,
	GP_3_30_FN___3 = 332,
	GP_3_31_FN___3 = 333,
	GP_4_0_FN___3 = 334,
	GP_4_1_FN___3 = 335,
	GP_4_2_FN___3 = 336,
	GP_4_3_FN___3 = 337,
	GP_4_4_FN___3 = 338,
	GP_4_5_FN___3 = 339,
	GP_4_6_FN___3 = 340,
	GP_4_7_FN___3 = 341,
	GP_4_8_FN___3 = 342,
	GP_4_9_FN___3 = 343,
	GP_4_10_FN___3 = 344,
	GP_4_11_FN___3 = 345,
	GP_4_12_FN___3 = 346,
	GP_4_13_FN___3 = 347,
	GP_4_14_FN___3 = 348,
	GP_4_15_FN___3 = 349,
	GP_4_16_FN___3 = 350,
	GP_4_17_FN___3 = 351,
	GP_4_18_FN___3 = 352,
	GP_4_19_FN___3 = 353,
	GP_4_20_FN___3 = 354,
	GP_4_21_FN___3 = 355,
	GP_4_22_FN___3 = 356,
	GP_4_23_FN___3 = 357,
	GP_4_24_FN___3 = 358,
	GP_4_25_FN___3 = 359,
	GP_4_26_FN___3 = 360,
	GP_4_27_FN___3 = 361,
	GP_4_28_FN___3 = 362,
	GP_4_29_FN___3 = 363,
	GP_4_30_FN___3 = 364,
	GP_4_31_FN___3 = 365,
	GP_5_0_FN___3 = 366,
	GP_5_1_FN___3 = 367,
	GP_5_2_FN___3 = 368,
	GP_5_3_FN___3 = 369,
	GP_5_4_FN___3 = 370,
	GP_5_5_FN___3 = 371,
	GP_5_6_FN___3 = 372,
	GP_5_7_FN___3 = 373,
	GP_5_8_FN___3 = 374,
	GP_5_9_FN___3 = 375,
	GP_5_10_FN___3 = 376,
	GP_5_11_FN___3 = 377,
	GP_5_12_FN___3 = 378,
	GP_5_13_FN___3 = 379,
	GP_5_14_FN___3 = 380,
	GP_5_15_FN___3 = 381,
	GP_5_16_FN___3 = 382,
	GP_5_17_FN___3 = 383,
	GP_5_18_FN___3 = 384,
	GP_5_19_FN___3 = 385,
	GP_5_20_FN___3 = 386,
	GP_5_21_FN___3 = 387,
	GP_5_22_FN___3 = 388,
	GP_5_23_FN___3 = 389,
	GP_5_24_FN___3 = 390,
	GP_5_25_FN___3 = 391,
	GP_5_26_FN___3 = 392,
	GP_5_27_FN___3 = 393,
	GP_6_0_FN___2 = 394,
	GP_6_1_FN___2 = 395,
	GP_6_2_FN___2 = 396,
	GP_6_3_FN___2 = 397,
	GP_6_4_FN___2 = 398,
	GP_6_5_FN___2 = 399,
	GP_6_6_FN___2 = 400,
	GP_6_7_FN___2 = 401,
	GP_6_8_FN___2 = 402,
	GP_6_9_FN___2 = 403,
	GP_6_10_FN___2 = 404,
	GP_6_11_FN___2 = 405,
	GP_6_12_FN___2 = 406,
	GP_6_13_FN___2 = 407,
	GP_6_14_FN___2 = 408,
	GP_6_15_FN___2 = 409,
	GP_6_16_FN___2 = 410,
	GP_6_17_FN___2 = 411,
	GP_6_18_FN___2 = 412,
	GP_6_19_FN___2 = 413,
	GP_6_20_FN___2 = 414,
	GP_6_21_FN___2 = 415,
	GP_6_22_FN___2 = 416,
	GP_6_23_FN___2 = 417,
	GP_6_24_FN___2 = 418,
	GP_6_25_FN___2 = 419,
	FN_IP0_23_22 = 420,
	FN_IP0_24 = 421,
	FN_IP0_25 = 422,
	FN_IP0_27_26 = 423,
	FN_IP0_29_28 = 424,
	FN_IP0_31_30 = 425,
	FN_IP1_1_0___2 = 426,
	FN_IP1_3_2___2 = 427,
	FN_IP1_5_4___2 = 428,
	FN_IP1_7_6___2 = 429,
	FN_IP1_10_8___2 = 430,
	FN_IP1_12_11 = 431,
	FN_IP1_14_13 = 432,
	FN_IP1_17_15___2 = 433,
	FN_IP1_19_18 = 434,
	FN_IP1_21_20 = 435,
	FN_IP1_23_22 = 436,
	FN_IP1_24 = 437,
	FN_A2___3 = 438,
	FN_IP1_26 = 439,
	FN_IP1_27 = 440,
	FN_IP1_29_28___2 = 441,
	FN_IP1_31_30 = 442,
	FN_IP2_1_0 = 443,
	FN_IP2_3_2 = 444,
	FN_IP2_5_4 = 445,
	FN_IP2_7_6 = 446,
	FN_IP2_9_8 = 447,
	FN_IP2_11_10 = 448,
	FN_IP2_13_12 = 449,
	FN_IP2_15_14 = 450,
	FN_IP2_17_16 = 451,
	FN_IP2_20_18 = 452,
	FN_IP2_23_21 = 453,
	FN_IP2_26_24 = 454,
	FN_IP2_29_27___2 = 455,
	FN_IP2_31_30 = 456,
	FN_IP3_1_0 = 457,
	FN_IP3_3_2 = 458,
	FN_IP3_5_4 = 459,
	FN_IP3_7_6 = 460,
	FN_IP3_9_8 = 461,
	FN_IP3_10 = 462,
	FN_IP3_11 = 463,
	FN_IP3_12 = 464,
	FN_IP3_14_13 = 465,
	FN_IP3_17_15___2 = 466,
	FN_IP3_20_18 = 467,
	FN_IP3_23_21 = 468,
	FN_IP3_26_24 = 469,
	FN_IP3_29_27 = 470,
	FN_IP3_30 = 471,
	FN_IP3_31 = 472,
	FN_WE0_N___3 = 473,
	FN_WE1_N___3 = 474,
	FN_IP4_1_0___2 = 475,
	FN_IP7_31 = 476,
	FN_DACK0___3 = 477,
	FN_IP4_4_2___2 = 478,
	FN_IP4_7_5___2 = 479,
	FN_IP4_9_8___2 = 480,
	FN_IP4_11_10 = 481,
	FN_IP4_13_12 = 482,
	FN_IP4_15_14 = 483,
	FN_IP4_17_16 = 484,
	FN_IP4_19_18 = 485,
	FN_IP4_22_20 = 486,
	FN_IP4_25_23 = 487,
	FN_IP4_27_26___2 = 488,
	FN_IP4_29_28 = 489,
	FN_IP4_31_30 = 490,
	FN_IP5_1_0 = 491,
	FN_IP5_3_2 = 492,
	FN_IP5_5_4 = 493,
	FN_IP5_8_6___2 = 494,
	FN_IP5_11_9___2 = 495,
	FN_IP5_13_12 = 496,
	FN_IP5_15_14 = 497,
	FN_IP5_17_16 = 498,
	FN_IP5_19_18 = 499,
	FN_IP5_21_20___2 = 500,
	FN_IP5_23_22___2 = 501,
	FN_IP5_25_24___2 = 502,
	FN_IP5_27_26 = 503,
	FN_IP5_29_28 = 504,
	FN_IP5_31_30 = 505,
	FN_IP6_1_0 = 506,
	FN_IP6_3_2 = 507,
	FN_IP6_5_4 = 508,
	FN_IP6_7_6___2 = 509,
	FN_IP6_8 = 510,
	FN_IP6_9 = 511,
	FN_IP6_10 = 512,
	FN_IP6_11 = 513,
	FN_IP6_12 = 514,
	FN_IP6_13 = 515,
	FN_IP6_14 = 516,
	FN_IP6_15 = 517,
	FN_IP6_16 = 518,
	FN_IP6_19_17___2 = 519,
	FN_IP6_22_20___2 = 520,
	FN_IP6_25_23___2 = 521,
	FN_IP6_28_26___2 = 522,
	FN_IP6_31_29___2 = 523,
	FN_IP7_2_0___3 = 524,
	FN_IP7_5_3___3 = 525,
	FN_IP7_8_6___2 = 526,
	FN_IP7_11_9 = 527,
	FN_IP7_14_12 = 528,
	FN_IP7_17_15 = 529,
	FN_IP7_20_18 = 530,
	FN_IP7_23_21___2 = 531,
	FN_IP7_26_24___2 = 532,
	FN_IP7_29_27___2 = 533,
	FN_IP8_2_0___2 = 534,
	FN_IP8_5_3___2 = 535,
	FN_IP8_8_6___2 = 536,
	FN_IP8_11_9___2 = 537,
	FN_IP8_14_12___2 = 538,
	FN_IP8_16_15 = 539,
	FN_IP8_19_17 = 540,
	FN_IP8_22_20 = 541,
	FN_IP8_25_23 = 542,
	FN_IP8_28_26 = 543,
	FN_IP8_31_29 = 544,
	FN_IP9_2_0___2 = 545,
	FN_IP9_5_3___2 = 546,
	FN_IP9_8_6 = 547,
	FN_IP9_11_9 = 548,
	FN_IP9_14_12 = 549,
	FN_IP9_16_15 = 550,
	FN_IP9_18_17___2 = 551,
	FN_IP9_21_19 = 552,
	FN_IP9_24_22 = 553,
	FN_IP9_27_25 = 554,
	FN_IP9_30_28 = 555,
	FN_IP10_2_0___2 = 556,
	FN_IP10_5_3___2 = 557,
	FN_IP10_8_6___2 = 558,
	FN_IP10_11_9___2 = 559,
	FN_IP10_14_12___2 = 560,
	FN_IP10_17_15 = 561,
	FN_IP10_20_18 = 562,
	FN_IP10_23_21 = 563,
	FN_IP10_26_24 = 564,
	FN_IP10_29_27 = 565,
	FN_IP10_31_30 = 566,
	FN_IP11_2_0___2 = 567,
	FN_IP11_5_3___2 = 568,
	FN_IP11_7_6 = 569,
	FN_IP11_10_8 = 570,
	FN_IP11_13_11 = 571,
	FN_IP11_15_14 = 572,
	FN_IP11_17_16 = 573,
	FN_IP11_20_18 = 574,
	FN_IP11_23_21 = 575,
	FN_IP11_26_24___2 = 576,
	FN_IP11_29_27___2 = 577,
	FN_IP12_2_0 = 578,
	FN_IP12_5_3 = 579,
	FN_IP12_8_6 = 580,
	FN_IP12_10_9 = 581,
	FN_IP12_12_11 = 582,
	FN_IP12_14_13 = 583,
	FN_IP12_17_15 = 584,
	FN_IP12_20_18 = 585,
	FN_IP12_23_21 = 586,
	FN_IP12_26_24___2 = 587,
	FN_IP12_29_27___2 = 588,
	FN_IP13_2_0___3 = 589,
	FN_IP13_5_3 = 590,
	FN_IP13_8_6 = 591,
	FN_IP13_11_9 = 592,
	FN_IP13_14_12 = 593,
	FN_IP13_17_15 = 594,
	FN_IP13_20_18 = 595,
	FN_IP13_23_21 = 596,
	FN_IP13_26_24 = 597,
	FN_USB0_PWEN___3 = 598,
	FN_USB0_OVC___2 = 599,
	FN_USB1_PWEN___3 = 600,
	FN_USB1_OVC___3 = 601,
	FN_SD0_CLK___3 = 602,
	FN_SD0_CMD___3 = 603,
	FN_SD0_DATA0___2 = 604,
	FN_SD0_DATA1___2 = 605,
	FN_SD0_DATA2___2 = 606,
	FN_SD0_DATA3___2 = 607,
	FN_SD0_CD___3 = 608,
	FN_SD0_WP___3 = 609,
	FN_SD1_CLK___3 = 610,
	FN_SD1_CMD___3 = 611,
	FN_SD1_DATA0___2 = 612,
	FN_SD1_DATA1___2 = 613,
	FN_SD1_DATA2___2 = 614,
	FN_SD1_DATA3___2 = 615,
	FN_IP0_0___2 = 616,
	FN_IP0_9_8 = 617,
	FN_IP0_10___2 = 618,
	FN_IP0_11___2 = 619,
	FN_IP0_12___2 = 620,
	FN_IP0_13___2 = 621,
	FN_IP0_14___2 = 622,
	FN_IP0_15___2 = 623,
	FN_IP0_16 = 624,
	FN_IP0_17 = 625,
	FN_IP0_19_18 = 626,
	FN_IP0_21_20 = 627,
	FN_SD1_CD___3 = 628,
	FN_CAN0_RX___3 = 629,
	FN_SD1_WP___3 = 630,
	FN_IRQ7___2 = 631,
	FN_CAN0_TX___3 = 632,
	FN_MMC_CLK___2 = 633,
	FN_SD2_CLK___3 = 634,
	FN_MMC_CMD___2 = 635,
	FN_SD2_CMD___3 = 636,
	FN_MMC_D0___2 = 637,
	FN_SD2_DATA0___2 = 638,
	FN_MMC_D1___2 = 639,
	FN_SD2_DATA1___2 = 640,
	FN_MMC_D2___2 = 641,
	FN_SD2_DATA2___2 = 642,
	FN_MMC_D3___2 = 643,
	FN_SD2_DATA3___2 = 644,
	FN_MMC_D4___2 = 645,
	FN_SD2_CD___3 = 646,
	FN_MMC_D5___2 = 647,
	FN_SD2_WP___3 = 648,
	FN_MMC_D6___2 = 649,
	FN_SCIF0_RXD = 650,
	FN_I2C2_SCL_B___3 = 651,
	FN_CAN1_RX___3 = 652,
	FN_MMC_D7___2 = 653,
	FN_SCIF0_TXD = 654,
	FN_I2C2_SDA_B___3 = 655,
	FN_CAN1_TX___3 = 656,
	FN_D0___3 = 657,
	FN_SCIFA3_SCK_B___2 = 658,
	FN_IRQ4___2 = 659,
	FN_D1___3 = 660,
	FN_SCIFA3_RXD_B___2 = 661,
	FN_D2___3 = 662,
	FN_SCIFA3_TXD_B___2 = 663,
	FN_D3___3 = 664,
	FN_I2C3_SCL_B___2 = 665,
	FN_SCIF5_RXD_B = 666,
	FN_D4___3 = 667,
	FN_I2C3_SDA_B___2 = 668,
	FN_SCIF5_TXD_B = 669,
	FN_D5___3 = 670,
	FN_SCIF4_RXD_B = 671,
	FN_I2C0_SCL_D = 672,
	FN_D6___3 = 673,
	FN_SCIF4_TXD_B = 674,
	FN_I2C0_SDA_D = 675,
	FN_D7___3 = 676,
	FN_IRQ3___3 = 677,
	FN_TCLK1___3 = 678,
	FN_PWM6_B = 679,
	FN_D8___3 = 680,
	FN_HSCIF2_HRX = 681,
	FN_I2C1_SCL_B___3 = 682,
	FN_D9___3 = 683,
	FN_HSCIF2_HTX = 684,
	FN_I2C1_SDA_B___3 = 685,
	FN_D10___3 = 686,
	FN_HSCIF2_HSCK = 687,
	FN_SCIF1_SCK_C = 688,
	FN_IRQ6___2 = 689,
	FN_PWM5_C = 690,
	FN_D11___3 = 691,
	FN_HSCIF2_HCTS_N = 692,
	FN_SCIF1_RXD_C = 693,
	FN_I2C1_SCL_D___2 = 694,
	FN_D12___3 = 695,
	FN_HSCIF2_HRTS_N = 696,
	FN_SCIF1_TXD_C = 697,
	FN_I2C1_SDA_D___2 = 698,
	FN_D13___3 = 699,
	FN_SCIFA1_SCK___3 = 700,
	FN_PWM2_C = 701,
	FN_TCLK2_B = 702,
	FN_D14___3 = 703,
	FN_SCIFA1_RXD___3 = 704,
	FN_I2C5_SCL_B = 705,
	FN_D15___3 = 706,
	FN_SCIFA1_TXD___3 = 707,
	FN_I2C5_SDA_B = 708,
	FN_A0___3 = 709,
	FN_SCIFB1_SCK___3 = 710,
	FN_PWM3_B = 711,
	FN_A1___3 = 712,
	FN_SCIFB1_TXD___3 = 713,
	FN_A3___3 = 714,
	FN_SCIFB0_SCK___3 = 715,
	FN_A4___3 = 716,
	FN_SCIFB0_TXD___3 = 717,
	FN_A5___3 = 718,
	FN_SCIFB0_RXD___3 = 719,
	FN_PWM4_B___2 = 720,
	FN_TPUTO3_C = 721,
	FN_A6___3 = 722,
	FN_SCIFB0_CTS_N___3 = 723,
	FN_SCIFA4_RXD_B___2 = 724,
	FN_TPUTO2_C = 725,
	FN_A7___3 = 726,
	FN_SCIFB0_RTS_N___3 = 727,
	FN_SCIFA4_TXD_B___2 = 728,
	FN_A8___3 = 729,
	FN_MSIOF1_RXD___3 = 730,
	FN_SCIFA0_RXD_B___3 = 731,
	FN_A9___3 = 732,
	FN_MSIOF1_TXD___3 = 733,
	FN_SCIFA0_TXD_B___3 = 734,
	FN_A10___3 = 735,
	FN_MSIOF1_SCK___3 = 736,
	FN_IIC0_SCL_B___2 = 737,
	FN_A11___3 = 738,
	FN_MSIOF1_SYNC___3 = 739,
	FN_IIC0_SDA_B___2 = 740,
	FN_A12___3 = 741,
	FN_MSIOF1_SS1___3 = 742,
	FN_SCIFA5_RXD_B___2 = 743,
	FN_A13___3 = 744,
	FN_MSIOF1_SS2___3 = 745,
	FN_SCIFA5_TXD_B___2 = 746,
	FN_A14___3 = 747,
	FN_MSIOF2_RXD___3 = 748,
	FN_HSCIF0_HRX_B = 749,
	FN_DREQ1_N___2 = 750,
	FN_A15___3 = 751,
	FN_MSIOF2_TXD___3 = 752,
	FN_HSCIF0_HTX_B = 753,
	FN_DACK1___3 = 754,
	FN_A16___3 = 755,
	FN_MSIOF2_SCK___3 = 756,
	FN_HSCIF0_HSCK_B = 757,
	FN_SPEEDIN___3 = 758,
	FN_CAN_CLK_C___2 = 759,
	FN_TPUTO2_B = 760,
	FN_A17___3 = 761,
	FN_MSIOF2_SYNC___3 = 762,
	FN_SCIF4_RXD_E = 763,
	FN_CAN1_RX_B___3 = 764,
	FN_A18___3 = 765,
	FN_MSIOF2_SS1___3 = 766,
	FN_SCIF4_TXD_E = 767,
	FN_CAN1_TX_B___3 = 768,
	FN_A19___3 = 769,
	FN_MSIOF2_SS2___3 = 770,
	FN_PWM4___3 = 771,
	FN_TPUTO2 = 772,
	FN_A20___3 = 773,
	FN_SPCLK___3 = 774,
	FN_A21___3 = 775,
	FN_MOSI_IO0___3 = 776,
	FN_A22___3 = 777,
	FN_MISO_IO1___3 = 778,
	FN_ATADIR1_N___3 = 779,
	FN_A23___3 = 780,
	FN_IO2___3 = 781,
	FN_ATAWR1_N___3 = 782,
	FN_A24___3 = 783,
	FN_IO3___3 = 784,
	FN_EX_WAIT2___3 = 785,
	FN_A25___3 = 786,
	FN_SSL___3 = 787,
	FN_ATARD1_N___3 = 788,
	FN_CS0_N___3 = 789,
	FN_VI1_DATA8 = 790,
	FN_CS1_N_A26___3 = 791,
	FN_VI1_DATA9 = 792,
	FN_EX_CS0_N___3 = 793,
	FN_VI1_DATA10 = 794,
	FN_EX_CS1_N___3 = 795,
	FN_TPUTO3_B = 796,
	FN_SCIFB2_RXD___3 = 797,
	FN_VI1_DATA11 = 798,
	FN_EX_CS2_N___3 = 799,
	FN_PWM0___3 = 800,
	FN_SCIF4_RXD_C = 801,
	FN_TS_SDATA_B = 802,
	FN_TPUTO3 = 803,
	FN_SCIFB2_TXD___3 = 804,
	FN_EX_CS3_N___3 = 805,
	FN_SCIFA2_SCK___3 = 806,
	FN_SCIF4_TXD_C = 807,
	FN_TS_SCK_B = 808,
	FN_BPFCLK___3 = 809,
	FN_SCIFB2_SCK___3 = 810,
	FN_EX_CS4_N___3 = 811,
	FN_SCIFA2_RXD___3 = 812,
	FN_I2C2_SCL_E___2 = 813,
	FN_TS_SDEN_B = 814,
	FN_FMCLK___3 = 815,
	FN_SCIFB2_CTS_N___3 = 816,
	FN_EX_CS5_N___3 = 817,
	FN_SCIFA2_TXD___3 = 818,
	FN_I2C2_SDA_E___2 = 819,
	FN_TS_SPSYNC_B = 820,
	FN_FMIN___3 = 821,
	FN_SCIFB2_RTS_N___3 = 822,
	FN_BS_N___3 = 823,
	FN_DRACK0___3 = 824,
	FN_PWM1_C = 825,
	FN_TPUTO0_C = 826,
	FN_ATACS01_N___3 = 827,
	FN_RD_N___3 = 828,
	FN_ATACS11_N___3 = 829,
	FN_RD_WR_N___3 = 830,
	FN_ATAG1_N___3 = 831,
	FN_EX_WAIT0___3 = 832,
	FN_CAN_CLK_B___3 = 833,
	FN_SCIF_CLK___3 = 834,
	FN_DU0_DR0 = 835,
	FN_LCDOUT16___3 = 836,
	FN_SCIF5_RXD_C = 837,
	FN_I2C2_SCL_D___3 = 838,
	FN_DU0_DR1 = 839,
	FN_LCDOUT17___3 = 840,
	FN_SCIF5_TXD_C = 841,
	FN_I2C2_SDA_D___3 = 842,
	FN_DU0_DR2 = 843,
	FN_LCDOUT18___3 = 844,
	FN_DU0_DR3 = 845,
	FN_LCDOUT19___3 = 846,
	FN_DU0_DR4 = 847,
	FN_LCDOUT20___3 = 848,
	FN_DU0_DR5 = 849,
	FN_LCDOUT21___3 = 850,
	FN_DU0_DR6 = 851,
	FN_LCDOUT22___3 = 852,
	FN_DU0_DR7 = 853,
	FN_LCDOUT23___3 = 854,
	FN_DU0_DG0 = 855,
	FN_LCDOUT8___3 = 856,
	FN_SCIFA0_RXD_C = 857,
	FN_I2C3_SCL_D___2 = 858,
	FN_DU0_DG1 = 859,
	FN_LCDOUT9___3 = 860,
	FN_SCIFA0_TXD_C = 861,
	FN_I2C3_SDA_D___2 = 862,
	FN_DU0_DG2 = 863,
	FN_LCDOUT10___3 = 864,
	FN_DU0_DG3 = 865,
	FN_LCDOUT11___3 = 866,
	FN_DU0_DG4 = 867,
	FN_LCDOUT12___3 = 868,
	FN_DU0_DG5 = 869,
	FN_LCDOUT13___3 = 870,
	FN_DU0_DG6 = 871,
	FN_LCDOUT14___3 = 872,
	FN_DU0_DG7 = 873,
	FN_LCDOUT15___3 = 874,
	FN_DU0_DB0 = 875,
	FN_LCDOUT0___3 = 876,
	FN_SCIFA4_RXD_C___2 = 877,
	FN_I2C4_SCL_D = 878,
	FN_CAN0_RX_C___3 = 879,
	FN_DU0_DB1 = 880,
	FN_LCDOUT1___3 = 881,
	FN_SCIFA4_TXD_C___2 = 882,
	FN_I2C4_SDA_D = 883,
	FN_CAN0_TX_C___3 = 884,
	FN_DU0_DB2 = 885,
	FN_LCDOUT2___3 = 886,
	FN_DU0_DB3 = 887,
	FN_LCDOUT3___3 = 888,
	FN_DU0_DB4 = 889,
	FN_LCDOUT4___3 = 890,
	FN_DU0_DB5 = 891,
	FN_LCDOUT5___3 = 892,
	FN_DU0_DB6 = 893,
	FN_LCDOUT6___3 = 894,
	FN_DU0_DB7 = 895,
	FN_LCDOUT7___3 = 896,
	FN_DU0_DOTCLKIN___2 = 897,
	FN_QSTVA_QVS___3 = 898,
	FN_DU0_DOTCLKOUT0 = 899,
	FN_QCLK___3 = 900,
	FN_DU0_DOTCLKOUT1 = 901,
	FN_QSTVB_QVE___3 = 902,
	FN_DU0_EXHSYNC_DU0_HSYNC = 903,
	FN_QSTH_QHS___3 = 904,
	FN_DU0_EXVSYNC_DU0_VSYNC = 905,
	FN_QSTB_QHE___3 = 906,
	FN_DU0_EXODDF_DU0_ODDF_DISP_CDE = 907,
	FN_QCPV_QDE___3 = 908,
	FN_DU0_DISP = 909,
	FN_QPOLA___3 = 910,
	FN_DU0_CDE = 911,
	FN_QPOLB___3 = 912,
	FN_VI0_CLK___3 = 913,
	FN_AVB_RX_CLK___3 = 914,
	FN_VI0_DATA0_VI0_B0___3 = 915,
	FN_AVB_RX_DV___3 = 916,
	FN_VI0_DATA1_VI0_B1___3 = 917,
	FN_AVB_RXD0___3 = 918,
	FN_VI0_DATA2_VI0_B2___3 = 919,
	FN_AVB_RXD1___3 = 920,
	FN_VI0_DATA3_VI0_B3___3 = 921,
	FN_AVB_RXD2___3 = 922,
	FN_VI0_DATA4_VI0_B4___3 = 923,
	FN_AVB_RXD3___3 = 924,
	FN_VI0_DATA5_VI0_B5___3 = 925,
	FN_AVB_RXD4___3 = 926,
	FN_VI0_DATA6_VI0_B6___3 = 927,
	FN_AVB_RXD5___3 = 928,
	FN_VI0_DATA7_VI0_B7___3 = 929,
	FN_AVB_RXD6___3 = 930,
	FN_VI0_CLKENB___3 = 931,
	FN_I2C3_SCL___2 = 932,
	FN_SCIFA5_RXD_C___2 = 933,
	FN_IETX_C___3 = 934,
	FN_AVB_RXD7___3 = 935,
	FN_VI0_FIELD___3 = 936,
	FN_I2C3_SDA___2 = 937,
	FN_SCIFA5_TXD_C___2 = 938,
	FN_IECLK_C___3 = 939,
	FN_AVB_RX_ER___3 = 940,
	FN_VI0_HSYNC_N___3 = 941,
	FN_SCIF0_RXD_B = 942,
	FN_I2C0_SCL_C___2 = 943,
	FN_IERX_C___3 = 944,
	FN_AVB_COL___3 = 945,
	FN_VI0_VSYNC_N___3 = 946,
	FN_SCIF0_TXD_B = 947,
	FN_I2C0_SDA_C___2 = 948,
	FN_AUDIO_CLKOUT_B___2 = 949,
	FN_AVB_TX_EN___3 = 950,
	FN_ETH_MDIO___3 = 951,
	FN_VI0_G0___3 = 952,
	FN_MSIOF2_RXD_B___2 = 953,
	FN_I2C5_SCL_D = 954,
	FN_AVB_TX_CLK___3 = 955,
	FN_ADIDATA___3 = 956,
	FN_ETH_CRS_DV___3 = 957,
	FN_VI0_G1___3 = 958,
	FN_MSIOF2_TXD_B___2 = 959,
	FN_I2C5_SDA_D = 960,
	FN_AVB_TXD0___3 = 961,
	FN_ADICS_SAMP___3 = 962,
	FN_ETH_RX_ER___3 = 963,
	FN_VI0_G2___3 = 964,
	FN_MSIOF2_SCK_B___2 = 965,
	FN_CAN0_RX_B___3 = 966,
	FN_AVB_TXD1___3 = 967,
	FN_ADICLK___3 = 968,
	FN_ETH_RXD0___3 = 969,
	FN_VI0_G3___3 = 970,
	FN_MSIOF2_SYNC_B___2 = 971,
	FN_CAN0_TX_B___3 = 972,
	FN_AVB_TXD2___3 = 973,
	FN_ADICHS0___3 = 974,
	FN_ETH_RXD1___3 = 975,
	FN_VI0_G4___3 = 976,
	FN_MSIOF2_SS1_B___2 = 977,
	FN_SCIF4_RXD_D = 978,
	FN_AVB_TXD3___3 = 979,
	FN_ADICHS1___3 = 980,
	FN_ETH_LINK___3 = 981,
	FN_VI0_G5___3 = 982,
	FN_MSIOF2_SS2_B___2 = 983,
	FN_SCIF4_TXD_D = 984,
	FN_AVB_TXD4___3 = 985,
	FN_ADICHS2___3 = 986,
	FN_ETH_REFCLK___2 = 987,
	FN_VI0_G6___3 = 988,
	FN_SCIF2_SCK_C = 989,
	FN_AVB_TXD5___3 = 990,
	FN_SSI_SCK5_B___2 = 991,
	FN_ETH_TXD1___3 = 992,
	FN_VI0_G7___3 = 993,
	FN_SCIF2_RXD_C = 994,
	FN_IIC0_SCL_D = 995,
	FN_AVB_TXD6___3 = 996,
	FN_SSI_WS5_B___2 = 997,
	FN_ETH_TX_EN___3 = 998,
	FN_VI0_R0___3 = 999,
	FN_SCIF2_TXD_C = 1000,
	FN_IIC0_SDA_D = 1001,
	FN_AVB_TXD7___3 = 1002,
	FN_SSI_SDATA5_B___2 = 1003,
	FN_ETH_MAGIC___3 = 1004,
	FN_VI0_R1___3 = 1005,
	FN_SCIF3_SCK_B___2 = 1006,
	FN_AVB_TX_ER___3 = 1007,
	FN_SSI_SCK6_B___2 = 1008,
	FN_ETH_TXD0___3 = 1009,
	FN_VI0_R2___3 = 1010,
	FN_SCIF3_RXD_B = 1011,
	FN_I2C4_SCL_E = 1012,
	FN_AVB_GTX_CLK___3 = 1013,
	FN_SSI_WS6_B___2 = 1014,
	FN_DREQ0_N___2 = 1015,
	FN_SCIFB1_RXD___3 = 1016,
	FN_ETH_MDC___3 = 1017,
	FN_VI0_R3___3 = 1018,
	FN_SCIF3_TXD_B = 1019,
	FN_I2C4_SDA_E = 1020,
	FN_AVB_MDC___3 = 1021,
	FN_SSI_SDATA6_B___2 = 1022,
	FN_HSCIF0_HRX = 1023,
	FN_VI0_R4___3 = 1024,
	FN_I2C1_SCL_C___3 = 1025,
	FN_AUDIO_CLKA_B = 1026,
	FN_AVB_MDIO___3 = 1027,
	FN_SSI_SCK78_B___3 = 1028,
	FN_HSCIF0_HTX = 1029,
	FN_VI0_R5___3 = 1030,
	FN_I2C1_SDA_C___3 = 1031,
	FN_AUDIO_CLKB_B___2 = 1032,
	FN_AVB_LINK___3 = 1033,
	FN_SSI_WS78_B___3 = 1034,
	FN_HSCIF0_HCTS_N = 1035,
	FN_VI0_R6___3 = 1036,
	FN_SCIF0_RXD_D = 1037,
	FN_I2C0_SCL_E = 1038,
	FN_AVB_MAGIC___3 = 1039,
	FN_SSI_SDATA7_B___3 = 1040,
	FN_HSCIF0_HRTS_N = 1041,
	FN_VI0_R7___3 = 1042,
	FN_SCIF0_TXD_D = 1043,
	FN_I2C0_SDA_E = 1044,
	FN_AVB_PHY_INT___3 = 1045,
	FN_SSI_SDATA8_B___3 = 1046,
	FN_HSCIF0_HSCK = 1047,
	FN_SCIF_CLK_B___3 = 1048,
	FN_AVB_CRS___3 = 1049,
	FN_AUDIO_CLKC_B = 1050,
	FN_I2C0_SCL___2 = 1051,
	FN_SCIF0_RXD_C = 1052,
	FN_PWM5___3 = 1053,
	FN_TCLK1_B___3 = 1054,
	FN_AVB_GTXREFCLK___3 = 1055,
	FN_CAN1_RX_D___2 = 1056,
	FN_TPUTO0_B = 1057,
	FN_I2C0_SDA___2 = 1058,
	FN_SCIF0_TXD_C = 1059,
	FN_TPUTO0 = 1060,
	FN_CAN_CLK___3 = 1061,
	FN_DVC_MUTE___3 = 1062,
	FN_CAN1_TX_D___2 = 1063,
	FN_I2C1_SCL___3 = 1064,
	FN_SCIF4_RXD = 1065,
	FN_PWM5_B___2 = 1066,
	FN_DU1_DR0___2 = 1067,
	FN_TS_SDATA_D = 1068,
	FN_TPUTO1_B = 1069,
	FN_I2C1_SDA___3 = 1070,
	FN_SCIF4_TXD = 1071,
	FN_IRQ5___2 = 1072,
	FN_DU1_DR1___2 = 1073,
	FN_TS_SCK_D = 1074,
	FN_BPFCLK_C___3 = 1075,
	FN_MSIOF0_RXD___3 = 1076,
	FN_SCIF5_RXD = 1077,
	FN_I2C2_SCL_C___3 = 1078,
	FN_DU1_DR2___2 = 1079,
	FN_TS_SDEN_D = 1080,
	FN_FMCLK_C___2 = 1081,
	FN_MSIOF0_TXD___3 = 1082,
	FN_SCIF5_TXD = 1083,
	FN_I2C2_SDA_C___3 = 1084,
	FN_DU1_DR3___2 = 1085,
	FN_TS_SPSYNC_D = 1086,
	FN_FMIN_C___3 = 1087,
	FN_MSIOF0_SCK___3 = 1088,
	FN_IRQ0___3 = 1089,
	FN_TS_SDATA = 1090,
	FN_DU1_DR4___2 = 1091,
	FN_TPUTO1_C = 1092,
	FN_MSIOF0_SYNC___3 = 1093,
	FN_PWM1___3 = 1094,
	FN_TS_SCK = 1095,
	FN_DU1_DR5___2 = 1096,
	FN_BPFCLK_B___3 = 1097,
	FN_MSIOF0_SS1___3 = 1098,
	FN_SCIFA0_RXD___3 = 1099,
	FN_TS_SDEN = 1100,
	FN_DU1_DR6___2 = 1101,
	FN_FMCLK_B___3 = 1102,
	FN_MSIOF0_SS2___3 = 1103,
	FN_SCIFA0_TXD___3 = 1104,
	FN_TS_SPSYNC = 1105,
	FN_DU1_DR7___2 = 1106,
	FN_FMIN_B___3 = 1107,
	FN_HSCIF1_HRX = 1108,
	FN_I2C4_SCL___2 = 1109,
	FN_PWM6___3 = 1110,
	FN_DU1_DG0___2 = 1111,
	FN_HSCIF1_HTX = 1112,
	FN_I2C4_SDA___2 = 1113,
	FN_TPUTO1 = 1114,
	FN_DU1_DG1___2 = 1115,
	FN_HSCIF1_HSCK = 1116,
	FN_PWM2___3 = 1117,
	FN_IETX___3 = 1118,
	FN_DU1_DG2___2 = 1119,
	FN_REMOCON_B___2 = 1120,
	FN_SPEEDIN_B___2 = 1121,
	FN_HSCIF1_HCTS_N = 1122,
	FN_SCIFA4_RXD___2 = 1123,
	FN_IECLK___3 = 1124,
	FN_DU1_DG3___2 = 1125,
	FN_SSI_SCK1_B___2 = 1126,
	FN_HSCIF1_HRTS_N = 1127,
	FN_SCIFA4_TXD___2 = 1128,
	FN_IERX___3 = 1129,
	FN_DU1_DG4___2 = 1130,
	FN_SSI_WS1_B___2 = 1131,
	FN_SCIF1_SCK = 1132,
	FN_PWM3___3 = 1133,
	FN_TCLK2___3 = 1134,
	FN_DU1_DG5___2 = 1135,
	FN_SSI_SDATA1_B___2 = 1136,
	FN_SCIF1_RXD = 1137,
	FN_I2C5_SCL = 1138,
	FN_DU1_DG6___2 = 1139,
	FN_SSI_SCK2_B = 1140,
	FN_SCIF1_TXD = 1141,
	FN_I2C5_SDA = 1142,
	FN_DU1_DG7___2 = 1143,
	FN_SSI_WS2_B = 1144,
	FN_SCIF2_RXD = 1145,
	FN_IIC0_SCL___3 = 1146,
	FN_DU1_DB0___2 = 1147,
	FN_SSI_SDATA2_B = 1148,
	FN_SCIF2_TXD = 1149,
	FN_IIC0_SDA___3 = 1150,
	FN_DU1_DB1___2 = 1151,
	FN_SSI_SCK9_B___2 = 1152,
	FN_SCIF2_SCK = 1153,
	FN_IRQ1___3 = 1154,
	FN_DU1_DB2___2 = 1155,
	FN_SSI_WS9_B___2 = 1156,
	FN_SCIF3_SCK___2 = 1157,
	FN_IRQ2___3 = 1158,
	FN_BPFCLK_D___3 = 1159,
	FN_DU1_DB3___2 = 1160,
	FN_SSI_SDATA9_B___2 = 1161,
	FN_SCIF3_RXD = 1162,
	FN_I2C1_SCL_E___2 = 1163,
	FN_FMCLK_D___2 = 1164,
	FN_DU1_DB4___2 = 1165,
	FN_AUDIO_CLKA_C = 1166,
	FN_SSI_SCK4_B = 1167,
	FN_SCIF3_TXD = 1168,
	FN_I2C1_SDA_E___2 = 1169,
	FN_FMIN_D___3 = 1170,
	FN_DU1_DB5___2 = 1171,
	FN_AUDIO_CLKB_C = 1172,
	FN_SSI_WS4_B = 1173,
	FN_I2C2_SCL___3 = 1174,
	FN_SCIFA5_RXD___2 = 1175,
	FN_DU1_DB6___2 = 1176,
	FN_AUDIO_CLKC_C = 1177,
	FN_SSI_SDATA4_B = 1178,
	FN_I2C2_SDA___3 = 1179,
	FN_SCIFA5_TXD___2 = 1180,
	FN_DU1_DB7___2 = 1181,
	FN_AUDIO_CLKOUT_C___2 = 1182,
	FN_SSI_SCK5___3 = 1183,
	FN_SCIFA3_SCK___2 = 1184,
	FN_DU1_DOTCLKIN___2 = 1185,
	FN_SSI_WS5___3 = 1186,
	FN_SCIFA3_RXD___2 = 1187,
	FN_I2C3_SCL_C___2 = 1188,
	FN_DU1_DOTCLKOUT0___2 = 1189,
	FN_SSI_SDATA5___3 = 1190,
	FN_SCIFA3_TXD___2 = 1191,
	FN_I2C3_SDA_C___2 = 1192,
	FN_DU1_DOTCLKOUT1___2 = 1193,
	FN_SSI_SCK6___3 = 1194,
	FN_SCIFA1_SCK_B___3 = 1195,
	FN_DU1_EXHSYNC_DU1_HSYNC___2 = 1196,
	FN_SSI_WS6___3 = 1197,
	FN_SCIFA1_RXD_B___3 = 1198,
	FN_I2C4_SCL_C___2 = 1199,
	FN_DU1_EXVSYNC_DU1_VSYNC___2 = 1200,
	FN_SSI_SDATA6___3 = 1201,
	FN_SCIFA1_TXD_B___3 = 1202,
	FN_I2C4_SDA_C___2 = 1203,
	FN_DU1_EXODDF_DU1_ODDF_DISP_CDE___2 = 1204,
	FN_SSI_SCK78___3 = 1205,
	FN_SCIFA2_SCK_B = 1206,
	FN_I2C5_SDA_C = 1207,
	FN_DU1_DISP___2 = 1208,
	FN_SSI_WS78___3 = 1209,
	FN_SCIFA2_RXD_B___3 = 1210,
	FN_I2C5_SCL_C = 1211,
	FN_DU1_CDE___2 = 1212,
	FN_SSI_SDATA7___3 = 1213,
	FN_SCIFA2_TXD_B___3 = 1214,
	FN_IRQ8___2 = 1215,
	FN_AUDIO_CLKA_D = 1216,
	FN_CAN_CLK_D___2 = 1217,
	FN_SSI_SCK0129___3 = 1218,
	FN_MSIOF1_RXD_B___3 = 1219,
	FN_SCIF5_RXD_D = 1220,
	FN_ADIDATA_B___2 = 1221,
	FN_SSI_WS0129___3 = 1222,
	FN_MSIOF1_TXD_B___3 = 1223,
	FN_SCIF5_TXD_D = 1224,
	FN_ADICS_SAMP_B___2 = 1225,
	FN_SSI_SDATA0___3 = 1226,
	FN_MSIOF1_SCK_B___3 = 1227,
	FN_PWM0_B___3 = 1228,
	FN_ADICLK_B___2 = 1229,
	FN_SSI_SCK34___3 = 1230,
	FN_MSIOF1_SYNC_B___2 = 1231,
	FN_SCIFA1_SCK_C___2 = 1232,
	FN_ADICHS0_B___2 = 1233,
	FN_DREQ1_N_B = 1234,
	FN_SSI_WS34___3 = 1235,
	FN_MSIOF1_SS1_B___3 = 1236,
	FN_SCIFA1_RXD_C___3 = 1237,
	FN_ADICHS1_B___2 = 1238,
	FN_CAN1_RX_C___2 = 1239,
	FN_DACK1_B = 1240,
	FN_SSI_SDATA3___3 = 1241,
	FN_MSIOF1_SS2_B___3 = 1242,
	FN_SCIFA1_TXD_C___3 = 1243,
	FN_ADICHS2_B___2 = 1244,
	FN_CAN1_TX_C___2 = 1245,
	FN_DREQ2_N___2 = 1246,
	FN_SSI_SCK4___3 = 1247,
	FN_MLB_CLK___3 = 1248,
	FN_IETX_B___3 = 1249,
	FN_SSI_WS4___3 = 1250,
	FN_MLB_SIG___3 = 1251,
	FN_IECLK_B___3 = 1252,
	FN_SSI_SDATA4___3 = 1253,
	FN_MLB_DAT___3 = 1254,
	FN_IERX_B___3 = 1255,
	FN_SSI_SDATA8___3 = 1256,
	FN_SCIF1_SCK_B___2 = 1257,
	FN_PWM1_B___3 = 1258,
	FN_IRQ9___2 = 1259,
	FN_REMOCON___3 = 1260,
	FN_DACK2___3 = 1261,
	FN_ETH_MDIO_B = 1262,
	FN_SSI_SCK1___3 = 1263,
	FN_SCIF1_RXD_B = 1264,
	FN_IIC0_SCL_C___2 = 1265,
	FN_VI1_CLK___3 = 1266,
	FN_CAN0_RX_D___3 = 1267,
	FN_ETH_CRS_DV_B = 1268,
	FN_SSI_WS1___3 = 1269,
	FN_SCIF1_TXD_B = 1270,
	FN_IIC0_SDA_C___2 = 1271,
	FN_VI1_DATA0___2 = 1272,
	FN_CAN0_TX_D___3 = 1273,
	FN_ETH_RX_ER_B = 1274,
	FN_SSI_SDATA1___3 = 1275,
	FN_HSCIF1_HRX_B = 1276,
	FN_VI1_DATA1___2 = 1277,
	FN_ATAWR0_N___3 = 1278,
	FN_ETH_RXD0_B = 1279,
	FN_SSI_SCK2___3 = 1280,
	FN_HSCIF1_HTX_B = 1281,
	FN_VI1_DATA2___2 = 1282,
	FN_ATAG0_N___3 = 1283,
	FN_ETH_RXD1_B = 1284,
	FN_SSI_WS2___3 = 1285,
	FN_HSCIF1_HCTS_N_B = 1286,
	FN_SCIFA0_RXD_D = 1287,
	FN_VI1_DATA3___2 = 1288,
	FN_ATACS00_N___3 = 1289,
	FN_ETH_LINK_B = 1290,
	FN_SSI_SDATA2___3 = 1291,
	FN_HSCIF1_HRTS_N_B = 1292,
	FN_SCIFA0_TXD_D = 1293,
	FN_VI1_DATA4___2 = 1294,
	FN_ATACS10_N___3 = 1295,
	FN_ETH_REFCLK_B = 1296,
	FN_SSI_SCK9___3 = 1297,
	FN_SCIF2_SCK_B___2 = 1298,
	FN_PWM2_B___2 = 1299,
	FN_VI1_DATA5___2 = 1300,
	FN_EX_WAIT1___3 = 1301,
	FN_ETH_TXD1_B = 1302,
	FN_SSI_WS9___3 = 1303,
	FN_SCIF2_RXD_B = 1304,
	FN_I2C3_SCL_E = 1305,
	FN_VI1_DATA6___2 = 1306,
	FN_ATARD0_N___3 = 1307,
	FN_ETH_TX_EN_B = 1308,
	FN_SSI_SDATA9___3 = 1309,
	FN_SCIF2_TXD_B = 1310,
	FN_I2C3_SDA_E = 1311,
	FN_VI1_DATA7___2 = 1312,
	FN_ATADIR0_N___3 = 1313,
	FN_ETH_MAGIC_B = 1314,
	FN_AUDIO_CLKA___3 = 1315,
	FN_I2C0_SCL_B___2 = 1316,
	FN_SCIFA4_RXD_D = 1317,
	FN_VI1_CLKENB___3 = 1318,
	FN_TS_SDATA_C = 1319,
	FN_ETH_TXD0_B = 1320,
	FN_AUDIO_CLKB___3 = 1321,
	FN_I2C0_SDA_B___2 = 1322,
	FN_SCIFA4_TXD_D = 1323,
	FN_VI1_FIELD___3 = 1324,
	FN_TS_SCK_C = 1325,
	FN_BPFCLK_E___3 = 1326,
	FN_ETH_MDC_B = 1327,
	FN_AUDIO_CLKC___3 = 1328,
	FN_I2C4_SCL_B___2 = 1329,
	FN_SCIFA5_RXD_D = 1330,
	FN_VI1_HSYNC_N___3 = 1331,
	FN_TS_SDEN_C = 1332,
	FN_FMCLK_E = 1333,
	FN_AUDIO_CLKOUT___3 = 1334,
	FN_I2C4_SDA_B___2 = 1335,
	FN_SCIFA5_TXD_D = 1336,
	FN_VI1_VSYNC_N___3 = 1337,
	FN_TS_SPSYNC_C = 1338,
	FN_FMIN_E___3 = 1339,
	FN_SEL_ADG_0___2 = 1340,
	FN_SEL_ADG_1___2 = 1341,
	FN_SEL_ADG_2 = 1342,
	FN_SEL_ADG_3 = 1343,
	FN_SEL_CAN_0 = 1344,
	FN_SEL_CAN_1 = 1345,
	FN_SEL_CAN_2 = 1346,
	FN_SEL_CAN_3 = 1347,
	FN_SEL_DARC_0 = 1348,
	FN_SEL_DARC_1 = 1349,
	FN_SEL_DARC_2 = 1350,
	FN_SEL_DARC_3 = 1351,
	FN_SEL_DARC_4 = 1352,
	FN_SEL_ETH_0 = 1353,
	FN_SEL_ETH_1 = 1354,
	FN_SEL_I2C00_0 = 1355,
	FN_SEL_I2C00_1 = 1356,
	FN_SEL_I2C00_2 = 1357,
	FN_SEL_I2C00_3 = 1358,
	FN_SEL_I2C00_4 = 1359,
	FN_SEL_I2C01_0 = 1360,
	FN_SEL_I2C01_1 = 1361,
	FN_SEL_I2C01_2 = 1362,
	FN_SEL_I2C01_3 = 1363,
	FN_SEL_I2C01_4 = 1364,
	FN_SEL_I2C02_0 = 1365,
	FN_SEL_I2C02_1 = 1366,
	FN_SEL_I2C02_2 = 1367,
	FN_SEL_I2C02_3 = 1368,
	FN_SEL_I2C02_4 = 1369,
	FN_SEL_I2C03_0 = 1370,
	FN_SEL_I2C03_1 = 1371,
	FN_SEL_I2C03_2 = 1372,
	FN_SEL_I2C03_3 = 1373,
	FN_SEL_I2C03_4 = 1374,
	FN_SEL_I2C04_0 = 1375,
	FN_SEL_I2C04_1 = 1376,
	FN_SEL_I2C04_2 = 1377,
	FN_SEL_I2C04_3 = 1378,
	FN_SEL_I2C04_4 = 1379,
	FN_SEL_I2C05_0 = 1380,
	FN_SEL_I2C05_1 = 1381,
	FN_SEL_I2C05_2 = 1382,
	FN_SEL_I2C05_3 = 1383,
	FN_SEL_IEB_0___3 = 1384,
	FN_SEL_IEB_1___3 = 1385,
	FN_SEL_IEB_2___3 = 1386,
	FN_SEL_IIC0_0___3 = 1387,
	FN_SEL_IIC0_1___3 = 1388,
	FN_SEL_IIC0_2___2 = 1389,
	FN_SEL_IIC0_3 = 1390,
	FN_SEL_LBS_0___3 = 1391,
	FN_SEL_LBS_1___3 = 1392,
	FN_SEL_MSI1_0 = 1393,
	FN_SEL_MSI1_1 = 1394,
	FN_SEL_MSI2_0 = 1395,
	FN_SEL_MSI2_1 = 1396,
	FN_SEL_RAD_0___2 = 1397,
	FN_SEL_RAD_1___2 = 1398,
	FN_SEL_RCN_0___2 = 1399,
	FN_SEL_RCN_1___2 = 1400,
	FN_SEL_RSP_0___2 = 1401,
	FN_SEL_RSP_1___2 = 1402,
	FN_SEL_SCIFA0_0 = 1403,
	FN_SEL_SCIFA0_1 = 1404,
	FN_SEL_SCIFA0_2 = 1405,
	FN_SEL_SCIFA0_3 = 1406,
	FN_SEL_SCIFA1_0___3 = 1407,
	FN_SEL_SCIFA1_1___3 = 1408,
	FN_SEL_SCIFA1_2___3 = 1409,
	FN_SEL_SCIFA2_0___3 = 1410,
	FN_SEL_SCIFA2_1___3 = 1411,
	FN_SEL_SCIFA3_0___2 = 1412,
	FN_SEL_SCIFA3_1___2 = 1413,
	FN_SEL_SCIFA4_0___2 = 1414,
	FN_SEL_SCIFA4_1___2 = 1415,
	FN_SEL_SCIFA4_2___2 = 1416,
	FN_SEL_SCIFA4_3 = 1417,
	FN_SEL_SCIFA5_0___2 = 1418,
	FN_SEL_SCIFA5_1___2 = 1419,
	FN_SEL_SCIFA5_2___2 = 1420,
	FN_SEL_SCIFA5_3 = 1421,
	FN_SEL_TMU_0 = 1422,
	FN_SEL_TMU_1 = 1423,
	FN_SEL_TSIF0_0___3 = 1424,
	FN_SEL_TSIF0_1___3 = 1425,
	FN_SEL_TSIF0_2___3 = 1426,
	FN_SEL_TSIF0_3___3 = 1427,
	FN_SEL_CAN0_0___3 = 1428,
	FN_SEL_CAN0_1___3 = 1429,
	FN_SEL_CAN0_2___3 = 1430,
	FN_SEL_CAN0_3___3 = 1431,
	FN_SEL_CAN1_0___3 = 1432,
	FN_SEL_CAN1_1___3 = 1433,
	FN_SEL_CAN1_2___2 = 1434,
	FN_SEL_CAN1_3___2 = 1435,
	FN_SEL_HSCIF0_0___3 = 1436,
	FN_SEL_HSCIF0_1___3 = 1437,
	FN_SEL_HSCIF1_0___3 = 1438,
	FN_SEL_HSCIF1_1___3 = 1439,
	FN_SEL_SCIF0_0___3 = 1440,
	FN_SEL_SCIF0_1___3 = 1441,
	FN_SEL_SCIF0_2___2 = 1442,
	FN_SEL_SCIF0_3___2 = 1443,
	FN_SEL_SCIF1_0___3 = 1444,
	FN_SEL_SCIF1_1___3 = 1445,
	FN_SEL_SCIF1_2___3 = 1446,
	FN_SEL_SCIF2_0___3 = 1447,
	FN_SEL_SCIF2_1___3 = 1448,
	FN_SEL_SCIF2_2___2 = 1449,
	FN_SEL_SCIF3_0___2 = 1450,
	FN_SEL_SCIF3_1___2 = 1451,
	FN_SEL_SCIF4_0___2 = 1452,
	FN_SEL_SCIF4_1___2 = 1453,
	FN_SEL_SCIF4_2___2 = 1454,
	FN_SEL_SCIF4_3 = 1455,
	FN_SEL_SCIF4_4 = 1456,
	FN_SEL_SCIF5_0___2 = 1457,
	FN_SEL_SCIF5_1___2 = 1458,
	FN_SEL_SCIF5_2 = 1459,
	FN_SEL_SCIF5_3 = 1460,
	FN_SEL_SSI1_0___2 = 1461,
	FN_SEL_SSI1_1___2 = 1462,
	FN_SEL_SSI2_0 = 1463,
	FN_SEL_SSI2_1 = 1464,
	FN_SEL_SSI4_0 = 1465,
	FN_SEL_SSI4_1 = 1466,
	FN_SEL_SSI5_0___2 = 1467,
	FN_SEL_SSI5_1___2 = 1468,
	FN_SEL_SSI6_0___2 = 1469,
	FN_SEL_SSI6_1___2 = 1470,
	FN_SEL_SSI7_0___3 = 1471,
	FN_SEL_SSI7_1___3 = 1472,
	FN_SEL_SSI8_0___3 = 1473,
	FN_SEL_SSI8_1___3 = 1474,
	FN_SEL_SSI9_0___2 = 1475,
	FN_SEL_SSI9_1___2 = 1476,
	PINMUX_FUNCTION_END___6 = 1477,
	PINMUX_MARK_BEGIN___6 = 1478,
	A2_MARK___5 = 1479,
	WE0_N_MARK___4 = 1480,
	WE1_N_MARK___4 = 1481,
	DACK0_MARK___4 = 1482,
	USB0_PWEN_MARK___3 = 1483,
	USB0_OVC_MARK___2 = 1484,
	USB1_PWEN_MARK___3 = 1485,
	USB1_OVC_MARK___3 = 1486,
	SD0_CLK_MARK___3 = 1487,
	SD0_CMD_MARK___3 = 1488,
	SD0_DATA0_MARK___2 = 1489,
	SD0_DATA1_MARK___2 = 1490,
	SD0_DATA2_MARK___2 = 1491,
	SD0_DATA3_MARK___2 = 1492,
	SD0_CD_MARK___3 = 1493,
	SD0_WP_MARK___3 = 1494,
	SD1_CLK_MARK___3 = 1495,
	SD1_CMD_MARK___3 = 1496,
	SD1_DATA0_MARK___2 = 1497,
	SD1_DATA1_MARK___2 = 1498,
	SD1_DATA2_MARK___2 = 1499,
	SD1_DATA3_MARK___2 = 1500,
	SD1_CD_MARK___3 = 1501,
	CAN0_RX_MARK___3 = 1502,
	SD1_WP_MARK___3 = 1503,
	IRQ7_MARK___3 = 1504,
	CAN0_TX_MARK___3 = 1505,
	MMC_CLK_MARK___2 = 1506,
	SD2_CLK_MARK___3 = 1507,
	MMC_CMD_MARK___2 = 1508,
	SD2_CMD_MARK___3 = 1509,
	MMC_D0_MARK___2 = 1510,
	SD2_DATA0_MARK___2 = 1511,
	MMC_D1_MARK___2 = 1512,
	SD2_DATA1_MARK___2 = 1513,
	MMC_D2_MARK___2 = 1514,
	SD2_DATA2_MARK___2 = 1515,
	MMC_D3_MARK___2 = 1516,
	SD2_DATA3_MARK___2 = 1517,
	MMC_D4_MARK___2 = 1518,
	SD2_CD_MARK___3 = 1519,
	MMC_D5_MARK___2 = 1520,
	SD2_WP_MARK___3 = 1521,
	MMC_D6_MARK___2 = 1522,
	SCIF0_RXD_MARK = 1523,
	I2C2_SCL_B_MARK___3 = 1524,
	CAN1_RX_MARK___3 = 1525,
	MMC_D7_MARK___2 = 1526,
	SCIF0_TXD_MARK = 1527,
	I2C2_SDA_B_MARK___3 = 1528,
	CAN1_TX_MARK___3 = 1529,
	D0_MARK___4 = 1530,
	SCIFA3_SCK_B_MARK___2 = 1531,
	IRQ4_MARK___3 = 1532,
	D1_MARK___4 = 1533,
	SCIFA3_RXD_B_MARK___2 = 1534,
	D2_MARK___4 = 1535,
	SCIFA3_TXD_B_MARK___2 = 1536,
	D3_MARK___4 = 1537,
	I2C3_SCL_B_MARK___2 = 1538,
	SCIF5_RXD_B_MARK = 1539,
	D4_MARK___4 = 1540,
	I2C3_SDA_B_MARK___2 = 1541,
	SCIF5_TXD_B_MARK = 1542,
	D5_MARK___4 = 1543,
	SCIF4_RXD_B_MARK = 1544,
	I2C0_SCL_D_MARK = 1545,
	D6_MARK___4 = 1546,
	SCIF4_TXD_B_MARK = 1547,
	I2C0_SDA_D_MARK = 1548,
	D7_MARK___4 = 1549,
	IRQ3_MARK___4 = 1550,
	TCLK1_MARK___3 = 1551,
	PWM6_B_MARK = 1552,
	D8_MARK___4 = 1553,
	HSCIF2_HRX_MARK = 1554,
	I2C1_SCL_B_MARK___3 = 1555,
	D9_MARK___4 = 1556,
	HSCIF2_HTX_MARK = 1557,
	I2C1_SDA_B_MARK___3 = 1558,
	D10_MARK___4 = 1559,
	HSCIF2_HSCK_MARK = 1560,
	SCIF1_SCK_C_MARK = 1561,
	IRQ6_MARK___3 = 1562,
	PWM5_C_MARK = 1563,
	D11_MARK___4 = 1564,
	HSCIF2_HCTS_N_MARK = 1565,
	SCIF1_RXD_C_MARK = 1566,
	I2C1_SCL_D_MARK___2 = 1567,
	D12_MARK___4 = 1568,
	HSCIF2_HRTS_N_MARK = 1569,
	SCIF1_TXD_C_MARK = 1570,
	I2C1_SDA_D_MARK___2 = 1571,
	D13_MARK___4 = 1572,
	SCIFA1_SCK_MARK___5 = 1573,
	PWM2_C_MARK = 1574,
	TCLK2_B_MARK = 1575,
	D14_MARK___4 = 1576,
	SCIFA1_RXD_MARK___5 = 1577,
	I2C5_SCL_B_MARK = 1578,
	D15_MARK___4 = 1579,
	SCIFA1_TXD_MARK___5 = 1580,
	I2C5_SDA_B_MARK = 1581,
	A0_MARK___5 = 1582,
	SCIFB1_SCK_MARK___3 = 1583,
	PWM3_B_MARK = 1584,
	A1_MARK___5 = 1585,
	SCIFB1_TXD_MARK___3 = 1586,
	A3_MARK___5 = 1587,
	SCIFB0_SCK_MARK___4 = 1588,
	A4_MARK___4 = 1589,
	SCIFB0_TXD_MARK___4 = 1590,
	A5_MARK___4 = 1591,
	SCIFB0_RXD_MARK___4 = 1592,
	PWM4_B_MARK___2 = 1593,
	TPUTO3_C_MARK = 1594,
	A6_MARK___5 = 1595,
	SCIFB0_CTS_N_MARK___3 = 1596,
	SCIFA4_RXD_B_MARK___2 = 1597,
	TPUTO2_C_MARK = 1598,
	A7_MARK___5 = 1599,
	SCIFB0_RTS_N_MARK___3 = 1600,
	SCIFA4_TXD_B_MARK___2 = 1601,
	A8_MARK___5 = 1602,
	MSIOF1_RXD_MARK___4 = 1603,
	SCIFA0_RXD_B_MARK___3 = 1604,
	A9_MARK___5 = 1605,
	MSIOF1_TXD_MARK___4 = 1606,
	SCIFA0_TXD_B_MARK___3 = 1607,
	A10_MARK___5 = 1608,
	MSIOF1_SCK_MARK___4 = 1609,
	IIC0_SCL_B_MARK___2 = 1610,
	A11_MARK___4 = 1611,
	MSIOF1_SYNC_MARK___4 = 1612,
	IIC0_SDA_B_MARK___2 = 1613,
	A12_MARK___4 = 1614,
	MSIOF1_SS1_MARK___4 = 1615,
	SCIFA5_RXD_B_MARK___2 = 1616,
	A13_MARK___4 = 1617,
	MSIOF1_SS2_MARK___4 = 1618,
	SCIFA5_TXD_B_MARK___2 = 1619,
	A14_MARK___4 = 1620,
	MSIOF2_RXD_MARK___5 = 1621,
	HSCIF0_HRX_B_MARK = 1622,
	DREQ1_N_MARK___2 = 1623,
	A15_MARK___4 = 1624,
	MSIOF2_TXD_MARK___5 = 1625,
	HSCIF0_HTX_B_MARK = 1626,
	DACK1_MARK___4 = 1627,
	A16_MARK___4 = 1628,
	MSIOF2_SCK_MARK___4 = 1629,
	HSCIF0_HSCK_B_MARK = 1630,
	SPEEDIN_MARK___3 = 1631,
	CAN_CLK_C_MARK___2 = 1632,
	TPUTO2_B_MARK = 1633,
	A17_MARK___4 = 1634,
	MSIOF2_SYNC_MARK___4 = 1635,
	SCIF4_RXD_E_MARK = 1636,
	CAN1_RX_B_MARK___3 = 1637,
	A18_MARK___4 = 1638,
	MSIOF2_SS1_MARK___5 = 1639,
	SCIF4_TXD_E_MARK = 1640,
	CAN1_TX_B_MARK___3 = 1641,
	A19_MARK___4 = 1642,
	MSIOF2_SS2_MARK___5 = 1643,
	PWM4_MARK___3 = 1644,
	TPUTO2_MARK = 1645,
	A20_MARK___4 = 1646,
	SPCLK_MARK___3 = 1647,
	A21_MARK___4 = 1648,
	MOSI_IO0_MARK___3 = 1649,
	A22_MARK___4 = 1650,
	MISO_IO1_MARK___3 = 1651,
	ATADIR1_N_MARK___3 = 1652,
	A23_MARK___4 = 1653,
	IO2_MARK___3 = 1654,
	ATAWR1_N_MARK___3 = 1655,
	A24_MARK___4 = 1656,
	IO3_MARK___3 = 1657,
	EX_WAIT2_MARK___3 = 1658,
	A25_MARK___4 = 1659,
	SSL_MARK___3 = 1660,
	ATARD1_N_MARK___3 = 1661,
	CS0_N_MARK___4 = 1662,
	VI1_DATA8_MARK = 1663,
	CS1_N_A26_MARK___3 = 1664,
	VI1_DATA9_MARK = 1665,
	EX_CS0_N_MARK___3 = 1666,
	VI1_DATA10_MARK = 1667,
	EX_CS1_N_MARK___3 = 1668,
	TPUTO3_B_MARK = 1669,
	SCIFB2_RXD_MARK___3 = 1670,
	VI1_DATA11_MARK = 1671,
	EX_CS2_N_MARK___3 = 1672,
	PWM0_MARK___4 = 1673,
	SCIF4_RXD_C_MARK = 1674,
	TS_SDATA_B_MARK = 1675,
	TPUTO3_MARK = 1676,
	SCIFB2_TXD_MARK___3 = 1677,
	EX_CS3_N_MARK___3 = 1678,
	SCIFA2_SCK_MARK___3 = 1679,
	SCIF4_TXD_C_MARK = 1680,
	TS_SCK_B_MARK = 1681,
	BPFCLK_MARK___3 = 1682,
	SCIFB2_SCK_MARK___3 = 1683,
	EX_CS4_N_MARK___3 = 1684,
	SCIFA2_RXD_MARK___4 = 1685,
	I2C2_SCL_E_MARK___2 = 1686,
	TS_SDEN_B_MARK = 1687,
	FMCLK_MARK___3 = 1688,
	SCIFB2_CTS_N_MARK___3 = 1689,
	EX_CS5_N_MARK___3 = 1690,
	SCIFA2_TXD_MARK___4 = 1691,
	I2C2_SDA_E_MARK___2 = 1692,
	TS_SPSYNC_B_MARK = 1693,
	FMIN_MARK___3 = 1694,
	SCIFB2_RTS_N_MARK___3 = 1695,
	BS_N_MARK___3 = 1696,
	DRACK0_MARK___3 = 1697,
	PWM1_C_MARK = 1698,
	TPUTO0_C_MARK = 1699,
	ATACS01_N_MARK___3 = 1700,
	RD_N_MARK___4 = 1701,
	ATACS11_N_MARK___3 = 1702,
	RD_WR_N_MARK___3 = 1703,
	ATAG1_N_MARK___3 = 1704,
	EX_WAIT0_MARK___3 = 1705,
	CAN_CLK_B_MARK___3 = 1706,
	SCIF_CLK_MARK___3 = 1707,
	DU0_DR0_MARK___2 = 1708,
	LCDOUT16_MARK___3 = 1709,
	SCIF5_RXD_C_MARK = 1710,
	I2C2_SCL_D_MARK___3 = 1711,
	DU0_DR1_MARK = 1712,
	LCDOUT17_MARK___3 = 1713,
	SCIF5_TXD_C_MARK = 1714,
	I2C2_SDA_D_MARK___3 = 1715,
	DU0_DR2_MARK___2 = 1716,
	LCDOUT18_MARK___3 = 1717,
	DU0_DR3_MARK___2 = 1718,
	LCDOUT19_MARK___3 = 1719,
	DU0_DR4_MARK___2 = 1720,
	LCDOUT20_MARK___3 = 1721,
	DU0_DR5_MARK___2 = 1722,
	LCDOUT21_MARK___3 = 1723,
	DU0_DR6_MARK___2 = 1724,
	LCDOUT22_MARK___3 = 1725,
	DU0_DR7_MARK___2 = 1726,
	LCDOUT23_MARK___3 = 1727,
	DU0_DG0_MARK___2 = 1728,
	LCDOUT8_MARK___3 = 1729,
	SCIFA0_RXD_C_MARK = 1730,
	I2C3_SCL_D_MARK___2 = 1731,
	DU0_DG1_MARK___2 = 1732,
	LCDOUT9_MARK___3 = 1733,
	SCIFA0_TXD_C_MARK = 1734,
	I2C3_SDA_D_MARK___2 = 1735,
	DU0_DG2_MARK___2 = 1736,
	LCDOUT10_MARK___3 = 1737,
	DU0_DG3_MARK___2 = 1738,
	LCDOUT11_MARK___3 = 1739,
	DU0_DG4_MARK___2 = 1740,
	LCDOUT12_MARK___3 = 1741,
	DU0_DG5_MARK___2 = 1742,
	LCDOUT13_MARK___3 = 1743,
	DU0_DG6_MARK___2 = 1744,
	LCDOUT14_MARK___3 = 1745,
	DU0_DG7_MARK___2 = 1746,
	LCDOUT15_MARK___3 = 1747,
	DU0_DB0_MARK___2 = 1748,
	LCDOUT0_MARK___3 = 1749,
	SCIFA4_RXD_C_MARK___2 = 1750,
	I2C4_SCL_D_MARK = 1751,
	CAN0_RX_C_MARK___3 = 1752,
	DU0_DB1_MARK___2 = 1753,
	LCDOUT1_MARK___3 = 1754,
	SCIFA4_TXD_C_MARK___2 = 1755,
	I2C4_SDA_D_MARK = 1756,
	CAN0_TX_C_MARK___3 = 1757,
	DU0_DB2_MARK___2 = 1758,
	LCDOUT2_MARK___3 = 1759,
	DU0_DB3_MARK___2 = 1760,
	LCDOUT3_MARK___3 = 1761,
	DU0_DB4_MARK___2 = 1762,
	LCDOUT4_MARK___3 = 1763,
	DU0_DB5_MARK___2 = 1764,
	LCDOUT5_MARK___3 = 1765,
	DU0_DB6_MARK___2 = 1766,
	LCDOUT6_MARK___3 = 1767,
	DU0_DB7_MARK___2 = 1768,
	LCDOUT7_MARK___3 = 1769,
	DU0_DOTCLKIN_MARK___3 = 1770,
	QSTVA_QVS_MARK___3 = 1771,
	DU0_DOTCLKOUT0_MARK = 1772,
	QCLK_MARK___3 = 1773,
	DU0_DOTCLKOUT1_MARK = 1774,
	QSTVB_QVE_MARK___3 = 1775,
	DU0_EXHSYNC_DU0_HSYNC_MARK = 1776,
	QSTH_QHS_MARK___3 = 1777,
	DU0_EXVSYNC_DU0_VSYNC_MARK = 1778,
	QSTB_QHE_MARK___3 = 1779,
	DU0_EXODDF_DU0_ODDF_DISP_CDE_MARK = 1780,
	QCPV_QDE_MARK___3 = 1781,
	DU0_DISP_MARK = 1782,
	QPOLA_MARK___3 = 1783,
	DU0_CDE_MARK___2 = 1784,
	QPOLB_MARK___3 = 1785,
	VI0_CLK_MARK___3 = 1786,
	AVB_RX_CLK_MARK___3 = 1787,
	VI0_DATA0_VI0_B0_MARK___3 = 1788,
	AVB_RX_DV_MARK___3 = 1789,
	VI0_DATA1_VI0_B1_MARK___3 = 1790,
	AVB_RXD0_MARK___3 = 1791,
	VI0_DATA2_VI0_B2_MARK___3 = 1792,
	AVB_RXD1_MARK___3 = 1793,
	VI0_DATA3_VI0_B3_MARK___3 = 1794,
	AVB_RXD2_MARK___3 = 1795,
	VI0_DATA4_VI0_B4_MARK___3 = 1796,
	AVB_RXD3_MARK___3 = 1797,
	VI0_DATA5_VI0_B5_MARK___3 = 1798,
	AVB_RXD4_MARK___3 = 1799,
	VI0_DATA6_VI0_B6_MARK___3 = 1800,
	AVB_RXD5_MARK___3 = 1801,
	VI0_DATA7_VI0_B7_MARK___3 = 1802,
	AVB_RXD6_MARK___3 = 1803,
	VI0_CLKENB_MARK___3 = 1804,
	I2C3_SCL_MARK___3 = 1805,
	SCIFA5_RXD_C_MARK___2 = 1806,
	IETX_C_MARK___3 = 1807,
	AVB_RXD7_MARK___3 = 1808,
	VI0_FIELD_MARK___3 = 1809,
	I2C3_SDA_MARK___3 = 1810,
	SCIFA5_TXD_C_MARK___2 = 1811,
	IECLK_C_MARK___3 = 1812,
	AVB_RX_ER_MARK___3 = 1813,
	VI0_HSYNC_N_MARK___3 = 1814,
	SCIF0_RXD_B_MARK = 1815,
	I2C0_SCL_C_MARK___2 = 1816,
	IERX_C_MARK___3 = 1817,
	AVB_COL_MARK___3 = 1818,
	VI0_VSYNC_N_MARK___3 = 1819,
	SCIF0_TXD_B_MARK = 1820,
	I2C0_SDA_C_MARK___2 = 1821,
	AUDIO_CLKOUT_B_MARK___2 = 1822,
	AVB_TX_EN_MARK___3 = 1823,
	ETH_MDIO_MARK___3 = 1824,
	VI0_G0_MARK___3 = 1825,
	MSIOF2_RXD_B_MARK___2 = 1826,
	I2C5_SCL_D_MARK = 1827,
	AVB_TX_CLK_MARK___3 = 1828,
	ADIDATA_MARK___3 = 1829,
	ETH_CRS_DV_MARK___3 = 1830,
	VI0_G1_MARK___3 = 1831,
	MSIOF2_TXD_B_MARK___2 = 1832,
	I2C5_SDA_D_MARK = 1833,
	AVB_TXD0_MARK___3 = 1834,
	ADICS_SAMP_MARK___3 = 1835,
	ETH_RX_ER_MARK___3 = 1836,
	VI0_G2_MARK___3 = 1837,
	MSIOF2_SCK_B_MARK___2 = 1838,
	CAN0_RX_B_MARK___3 = 1839,
	AVB_TXD1_MARK___3 = 1840,
	ADICLK_MARK___3 = 1841,
	ETH_RXD0_MARK___3 = 1842,
	VI0_G3_MARK___3 = 1843,
	MSIOF2_SYNC_B_MARK___2 = 1844,
	CAN0_TX_B_MARK___3 = 1845,
	AVB_TXD2_MARK___3 = 1846,
	ADICHS0_MARK___3 = 1847,
	ETH_RXD1_MARK___3 = 1848,
	VI0_G4_MARK___3 = 1849,
	MSIOF2_SS1_B_MARK___2 = 1850,
	SCIF4_RXD_D_MARK = 1851,
	AVB_TXD3_MARK___3 = 1852,
	ADICHS1_MARK___3 = 1853,
	ETH_LINK_MARK___3 = 1854,
	VI0_G5_MARK___3 = 1855,
	MSIOF2_SS2_B_MARK___2 = 1856,
	SCIF4_TXD_D_MARK = 1857,
	AVB_TXD4_MARK___3 = 1858,
	ADICHS2_MARK___3 = 1859,
	ETH_REFCLK_MARK___2 = 1860,
	VI0_G6_MARK___3 = 1861,
	SCIF2_SCK_C_MARK = 1862,
	AVB_TXD5_MARK___3 = 1863,
	SSI_SCK5_B_MARK___2 = 1864,
	ETH_TXD1_MARK___3 = 1865,
	VI0_G7_MARK___3 = 1866,
	SCIF2_RXD_C_MARK = 1867,
	IIC0_SCL_D_MARK = 1868,
	AVB_TXD6_MARK___3 = 1869,
	SSI_WS5_B_MARK___2 = 1870,
	ETH_TX_EN_MARK___3 = 1871,
	VI0_R0_MARK___3 = 1872,
	SCIF2_TXD_C_MARK = 1873,
	IIC0_SDA_D_MARK = 1874,
	AVB_TXD7_MARK___3 = 1875,
	SSI_SDATA5_B_MARK___2 = 1876,
	ETH_MAGIC_MARK___3 = 1877,
	VI0_R1_MARK___3 = 1878,
	SCIF3_SCK_B_MARK___2 = 1879,
	AVB_TX_ER_MARK___3 = 1880,
	SSI_SCK6_B_MARK___2 = 1881,
	ETH_TXD0_MARK___3 = 1882,
	VI0_R2_MARK___3 = 1883,
	SCIF3_RXD_B_MARK = 1884,
	I2C4_SCL_E_MARK = 1885,
	AVB_GTX_CLK_MARK___3 = 1886,
	SSI_WS6_B_MARK___2 = 1887,
	DREQ0_N_MARK___2 = 1888,
	SCIFB1_RXD_MARK___3 = 1889,
	ETH_MDC_MARK___3 = 1890,
	VI0_R3_MARK___3 = 1891,
	SCIF3_TXD_B_MARK = 1892,
	I2C4_SDA_E_MARK = 1893,
	AVB_MDC_MARK___3 = 1894,
	SSI_SDATA6_B_MARK___2 = 1895,
	HSCIF0_HRX_MARK = 1896,
	VI0_R4_MARK___3 = 1897,
	I2C1_SCL_C_MARK___3 = 1898,
	AUDIO_CLKA_B_MARK = 1899,
	AVB_MDIO_MARK___3 = 1900,
	SSI_SCK78_B_MARK___3 = 1901,
	HSCIF0_HTX_MARK = 1902,
	VI0_R5_MARK___3 = 1903,
	I2C1_SDA_C_MARK___3 = 1904,
	AUDIO_CLKB_B_MARK___2 = 1905,
	AVB_LINK_MARK___3 = 1906,
	SSI_WS78_B_MARK___3 = 1907,
	HSCIF0_HCTS_N_MARK = 1908,
	VI0_R6_MARK___3 = 1909,
	SCIF0_RXD_D_MARK = 1910,
	I2C0_SCL_E_MARK = 1911,
	AVB_MAGIC_MARK___3 = 1912,
	SSI_SDATA7_B_MARK___3 = 1913,
	HSCIF0_HRTS_N_MARK = 1914,
	VI0_R7_MARK___3 = 1915,
	SCIF0_TXD_D_MARK = 1916,
	I2C0_SDA_E_MARK = 1917,
	AVB_PHY_INT_MARK___3 = 1918,
	SSI_SDATA8_B_MARK___3 = 1919,
	HSCIF0_HSCK_MARK = 1920,
	SCIF_CLK_B_MARK___3 = 1921,
	AVB_CRS_MARK___3 = 1922,
	AUDIO_CLKC_B_MARK = 1923,
	I2C0_SCL_MARK___3 = 1924,
	SCIF0_RXD_C_MARK = 1925,
	PWM5_MARK___3 = 1926,
	TCLK1_B_MARK___3 = 1927,
	AVB_GTXREFCLK_MARK___3 = 1928,
	CAN1_RX_D_MARK___2 = 1929,
	TPUTO0_B_MARK = 1930,
	I2C0_SDA_MARK___3 = 1931,
	SCIF0_TXD_C_MARK = 1932,
	TPUTO0_MARK = 1933,
	CAN_CLK_MARK___3 = 1934,
	DVC_MUTE_MARK___3 = 1935,
	CAN1_TX_D_MARK___2 = 1936,
	I2C1_SCL_MARK___3 = 1937,
	SCIF4_RXD_MARK = 1938,
	PWM5_B_MARK___2 = 1939,
	DU1_DR0_MARK___2 = 1940,
	TS_SDATA_D_MARK = 1941,
	TPUTO1_B_MARK = 1942,
	I2C1_SDA_MARK___3 = 1943,
	SCIF4_TXD_MARK = 1944,
	IRQ5_MARK___3 = 1945,
	DU1_DR1_MARK___2 = 1946,
	TS_SCK_D_MARK = 1947,
	BPFCLK_C_MARK___3 = 1948,
	MSIOF0_RXD_MARK___5 = 1949,
	SCIF5_RXD_MARK = 1950,
	I2C2_SCL_C_MARK___3 = 1951,
	DU1_DR2_MARK___2 = 1952,
	TS_SDEN_D_MARK = 1953,
	FMCLK_C_MARK___2 = 1954,
	MSIOF0_TXD_MARK___5 = 1955,
	SCIF5_TXD_MARK = 1956,
	I2C2_SDA_C_MARK___3 = 1957,
	DU1_DR3_MARK___2 = 1958,
	TS_SPSYNC_D_MARK = 1959,
	FMIN_C_MARK___3 = 1960,
	MSIOF0_SCK_MARK___4 = 1961,
	IRQ0_MARK___4 = 1962,
	TS_SDATA_MARK = 1963,
	DU1_DR4_MARK___2 = 1964,
	TPUTO1_C_MARK = 1965,
	MSIOF0_SYNC_MARK___4 = 1966,
	PWM1_MARK___4 = 1967,
	TS_SCK_MARK___2 = 1968,
	DU1_DR5_MARK___2 = 1969,
	BPFCLK_B_MARK___3 = 1970,
	MSIOF0_SS1_MARK___5 = 1971,
	SCIFA0_RXD_MARK___5 = 1972,
	TS_SDEN_MARK___2 = 1973,
	DU1_DR6_MARK___2 = 1974,
	FMCLK_B_MARK___3 = 1975,
	MSIOF0_SS2_MARK___5 = 1976,
	SCIFA0_TXD_MARK___5 = 1977,
	TS_SPSYNC_MARK___2 = 1978,
	DU1_DR7_MARK___2 = 1979,
	FMIN_B_MARK___3 = 1980,
	HSCIF1_HRX_MARK = 1981,
	I2C4_SCL_MARK___2 = 1982,
	PWM6_MARK___3 = 1983,
	DU1_DG0_MARK___2 = 1984,
	HSCIF1_HTX_MARK = 1985,
	I2C4_SDA_MARK___2 = 1986,
	TPUTO1_MARK = 1987,
	DU1_DG1_MARK___2 = 1988,
	HSCIF1_HSCK_MARK = 1989,
	PWM2_MARK___3 = 1990,
	IETX_MARK___3 = 1991,
	DU1_DG2_MARK___2 = 1992,
	REMOCON_B_MARK___2 = 1993,
	SPEEDIN_B_MARK___2 = 1994,
	HSCIF1_HCTS_N_MARK = 1995,
	SCIFA4_RXD_MARK___2 = 1996,
	IECLK_MARK___3 = 1997,
	DU1_DG3_MARK___2 = 1998,
	SSI_SCK1_B_MARK___2 = 1999,
	HSCIF1_HRTS_N_MARK = 2000,
	SCIFA4_TXD_MARK___2 = 2001,
	IERX_MARK___3 = 2002,
	DU1_DG4_MARK___2 = 2003,
	SSI_WS1_B_MARK___2 = 2004,
	SCIF1_SCK_MARK = 2005,
	PWM3_MARK___3 = 2006,
	TCLK2_MARK___3 = 2007,
	DU1_DG5_MARK___2 = 2008,
	SSI_SDATA1_B_MARK___2 = 2009,
	CAN_TXCLK_MARK___2 = 2010,
	SCIF1_RXD_MARK = 2011,
	I2C5_SCL_MARK = 2012,
	DU1_DG6_MARK___2 = 2013,
	SSI_SCK2_B_MARK = 2014,
	SCIF1_TXD_MARK = 2015,
	I2C5_SDA_MARK = 2016,
	DU1_DG7_MARK___2 = 2017,
	SSI_WS2_B_MARK = 2018,
	SCIF2_RXD_MARK = 2019,
	IIC0_SCL_MARK___4 = 2020,
	DU1_DB0_MARK___2 = 2021,
	SSI_SDATA2_B_MARK = 2022,
	SCIF2_TXD_MARK = 2023,
	IIC0_SDA_MARK___4 = 2024,
	DU1_DB1_MARK___2 = 2025,
	SSI_SCK9_B_MARK___2 = 2026,
	SCIF2_SCK_MARK = 2027,
	IRQ1_MARK___5 = 2028,
	DU1_DB2_MARK___2 = 2029,
	SSI_WS9_B_MARK___2 = 2030,
	SCIF3_SCK_MARK___2 = 2031,
	IRQ2_MARK___4 = 2032,
	BPFCLK_D_MARK___3 = 2033,
	DU1_DB3_MARK___2 = 2034,
	SSI_SDATA9_B_MARK___2 = 2035,
	SCIF3_RXD_MARK = 2036,
	I2C1_SCL_E_MARK___2 = 2037,
	FMCLK_D_MARK___2 = 2038,
	DU1_DB4_MARK___2 = 2039,
	AUDIO_CLKA_C_MARK = 2040,
	SSI_SCK4_B_MARK = 2041,
	SCIF3_TXD_MARK = 2042,
	I2C1_SDA_E_MARK___2 = 2043,
	FMIN_D_MARK___3 = 2044,
	DU1_DB5_MARK___2 = 2045,
	AUDIO_CLKB_C_MARK = 2046,
	SSI_WS4_B_MARK = 2047,
	I2C2_SCL_MARK___3 = 2048,
	SCIFA5_RXD_MARK___2 = 2049,
	DU1_DB6_MARK___2 = 2050,
	AUDIO_CLKC_C_MARK = 2051,
	SSI_SDATA4_B_MARK = 2052,
	I2C2_SDA_MARK___3 = 2053,
	SCIFA5_TXD_MARK___2 = 2054,
	DU1_DB7_MARK___2 = 2055,
	AUDIO_CLKOUT_C_MARK___2 = 2056,
	SSI_SCK5_MARK___3 = 2057,
	SCIFA3_SCK_MARK___2 = 2058,
	DU1_DOTCLKIN_MARK___2 = 2059,
	SSI_WS5_MARK___3 = 2060,
	SCIFA3_RXD_MARK___2 = 2061,
	I2C3_SCL_C_MARK___2 = 2062,
	DU1_DOTCLKOUT0_MARK___2 = 2063,
	SSI_SDATA5_MARK___3 = 2064,
	SCIFA3_TXD_MARK___2 = 2065,
	I2C3_SDA_C_MARK___2 = 2066,
	DU1_DOTCLKOUT1_MARK___2 = 2067,
	SSI_SCK6_MARK___3 = 2068,
	SCIFA1_SCK_B_MARK___3 = 2069,
	DU1_EXHSYNC_DU1_HSYNC_MARK___2 = 2070,
	SSI_WS6_MARK___3 = 2071,
	SCIFA1_RXD_B_MARK___3 = 2072,
	I2C4_SCL_C_MARK___2 = 2073,
	DU1_EXVSYNC_DU1_VSYNC_MARK___2 = 2074,
	SSI_SDATA6_MARK___3 = 2075,
	SCIFA1_TXD_B_MARK___3 = 2076,
	I2C4_SDA_C_MARK___2 = 2077,
	DU1_EXODDF_DU1_ODDF_DISP_CDE_MARK___2 = 2078,
	SSI_SCK78_MARK___3 = 2079,
	SCIFA2_SCK_B_MARK = 2080,
	I2C5_SDA_C_MARK = 2081,
	DU1_DISP_MARK___2 = 2082,
	SSI_WS78_MARK___3 = 2083,
	SCIFA2_RXD_B_MARK___3 = 2084,
	I2C5_SCL_C_MARK = 2085,
	DU1_CDE_MARK___2 = 2086,
	SSI_SDATA7_MARK___3 = 2087,
	SCIFA2_TXD_B_MARK___3 = 2088,
	IRQ8_MARK___4 = 2089,
	AUDIO_CLKA_D_MARK = 2090,
	CAN_CLK_D_MARK___2 = 2091,
	SSI_SCK0129_MARK___3 = 2092,
	MSIOF1_RXD_B_MARK___3 = 2093,
	SCIF5_RXD_D_MARK = 2094,
	ADIDATA_B_MARK___2 = 2095,
	SSI_WS0129_MARK___3 = 2096,
	MSIOF1_TXD_B_MARK___3 = 2097,
	SCIF5_TXD_D_MARK = 2098,
	ADICS_SAMP_B_MARK___2 = 2099,
	SSI_SDATA0_MARK___3 = 2100,
	MSIOF1_SCK_B_MARK___3 = 2101,
	PWM0_B_MARK___3 = 2102,
	ADICLK_B_MARK___2 = 2103,
	SSI_SCK34_MARK___3 = 2104,
	MSIOF1_SYNC_B_MARK___2 = 2105,
	SCIFA1_SCK_C_MARK___2 = 2106,
	ADICHS0_B_MARK___2 = 2107,
	DREQ1_N_B_MARK = 2108,
	SSI_WS34_MARK___3 = 2109,
	MSIOF1_SS1_B_MARK___3 = 2110,
	SCIFA1_RXD_C_MARK___3 = 2111,
	ADICHS1_B_MARK___2 = 2112,
	CAN1_RX_C_MARK___2 = 2113,
	DACK1_B_MARK = 2114,
	SSI_SDATA3_MARK___3 = 2115,
	MSIOF1_SS2_B_MARK___3 = 2116,
	SCIFA1_TXD_C_MARK___3 = 2117,
	ADICHS2_B_MARK___2 = 2118,
	CAN1_TX_C_MARK___2 = 2119,
	DREQ2_N_MARK___2 = 2120,
	SSI_SCK4_MARK___3 = 2121,
	MLB_CLK_MARK___3 = 2122,
	IETX_B_MARK___3 = 2123,
	SSI_WS4_MARK___3 = 2124,
	MLB_SIG_MARK___3 = 2125,
	IECLK_B_MARK___3 = 2126,
	SSI_SDATA4_MARK___3 = 2127,
	MLB_DAT_MARK___3 = 2128,
	IERX_B_MARK___3 = 2129,
	SSI_SDATA8_MARK___3 = 2130,
	SCIF1_SCK_B_MARK___2 = 2131,
	PWM1_B_MARK___3 = 2132,
	IRQ9_MARK___3 = 2133,
	REMOCON_MARK___3 = 2134,
	DACK2_MARK___3 = 2135,
	ETH_MDIO_B_MARK = 2136,
	SSI_SCK1_MARK___3 = 2137,
	SCIF1_RXD_B_MARK = 2138,
	IIC0_SCL_C_MARK___2 = 2139,
	VI1_CLK_MARK___3 = 2140,
	CAN0_RX_D_MARK___3 = 2141,
	ETH_CRS_DV_B_MARK = 2142,
	SSI_WS1_MARK___3 = 2143,
	SCIF1_TXD_B_MARK = 2144,
	IIC0_SDA_C_MARK___2 = 2145,
	VI1_DATA0_MARK___2 = 2146,
	CAN0_TX_D_MARK___3 = 2147,
	ETH_RX_ER_B_MARK = 2148,
	SSI_SDATA1_MARK___3 = 2149,
	HSCIF1_HRX_B_MARK = 2150,
	VI1_DATA1_MARK___2 = 2151,
	ATAWR0_N_MARK___3 = 2152,
	ETH_RXD0_B_MARK = 2153,
	SSI_SCK2_MARK___3 = 2154,
	HSCIF1_HTX_B_MARK = 2155,
	VI1_DATA2_MARK___2 = 2156,
	ATAG0_N_MARK___3 = 2157,
	ETH_RXD1_B_MARK = 2158,
	SSI_WS2_MARK___3 = 2159,
	HSCIF1_HCTS_N_B_MARK = 2160,
	SCIFA0_RXD_D_MARK = 2161,
	VI1_DATA3_MARK___2 = 2162,
	ATACS00_N_MARK___3 = 2163,
	ETH_LINK_B_MARK = 2164,
	SSI_SDATA2_MARK___3 = 2165,
	HSCIF1_HRTS_N_B_MARK = 2166,
	SCIFA0_TXD_D_MARK = 2167,
	VI1_DATA4_MARK___2 = 2168,
	ATACS10_N_MARK___3 = 2169,
	ETH_REFCLK_B_MARK = 2170,
	SSI_SCK9_MARK___3 = 2171,
	SCIF2_SCK_B_MARK___2 = 2172,
	PWM2_B_MARK___2 = 2173,
	VI1_DATA5_MARK___2 = 2174,
	EX_WAIT1_MARK___3 = 2175,
	ETH_TXD1_B_MARK = 2176,
	SSI_WS9_MARK___3 = 2177,
	SCIF2_RXD_B_MARK = 2178,
	I2C3_SCL_E_MARK = 2179,
	VI1_DATA6_MARK___2 = 2180,
	ATARD0_N_MARK___3 = 2181,
	ETH_TX_EN_B_MARK = 2182,
	SSI_SDATA9_MARK___3 = 2183,
	SCIF2_TXD_B_MARK = 2184,
	I2C3_SDA_E_MARK = 2185,
	VI1_DATA7_MARK___2 = 2186,
	ATADIR0_N_MARK___3 = 2187,
	ETH_MAGIC_B_MARK = 2188,
	AUDIO_CLKA_MARK___3 = 2189,
	I2C0_SCL_B_MARK___2 = 2190,
	SCIFA4_RXD_D_MARK = 2191,
	VI1_CLKENB_MARK___3 = 2192,
	TS_SDATA_C_MARK = 2193,
	ETH_TXD0_B_MARK = 2194,
	AUDIO_CLKB_MARK___3 = 2195,
	I2C0_SDA_B_MARK___2 = 2196,
	SCIFA4_TXD_D_MARK = 2197,
	VI1_FIELD_MARK___3 = 2198,
	TS_SCK_C_MARK = 2199,
	BPFCLK_E_MARK___3 = 2200,
	ETH_MDC_B_MARK = 2201,
	AUDIO_CLKC_MARK___3 = 2202,
	I2C4_SCL_B_MARK___2 = 2203,
	SCIFA5_RXD_D_MARK = 2204,
	VI1_HSYNC_N_MARK___3 = 2205,
	TS_SDEN_C_MARK = 2206,
	FMCLK_E_MARK = 2207,
	AUDIO_CLKOUT_MARK___3 = 2208,
	I2C4_SDA_B_MARK___2 = 2209,
	SCIFA5_TXD_D_MARK = 2210,
	VI1_VSYNC_N_MARK___3 = 2211,
	TS_SPSYNC_C_MARK = 2212,
	FMIN_E_MARK___3 = 2213,
	PINMUX_MARK_END___6 = 2214,
};

enum {
	PINMUX_RESERVED___7 = 0,
	PINMUX_DATA_BEGIN___7 = 1,
	GP_0_0_DATA___4 = 2,
	GP_0_1_DATA___4 = 3,
	GP_0_2_DATA___4 = 4,
	GP_0_3_DATA___4 = 5,
	GP_0_4_DATA___4 = 6,
	GP_0_5_DATA___4 = 7,
	GP_0_6_DATA___4 = 8,
	GP_0_7_DATA___4 = 9,
	GP_0_8_DATA___4 = 10,
	GP_0_9_DATA___4 = 11,
	GP_0_10_DATA___4 = 12,
	GP_0_11_DATA___4 = 13,
	GP_0_12_DATA___4 = 14,
	GP_0_13_DATA___4 = 15,
	GP_0_14_DATA___4 = 16,
	GP_0_15_DATA___4 = 17,
	GP_0_16_DATA___4 = 18,
	GP_0_17_DATA___4 = 19,
	GP_0_18_DATA___4 = 20,
	GP_0_19_DATA___4 = 21,
	GP_0_20_DATA___4 = 22,
	GP_0_21_DATA___4 = 23,
	GP_0_22_DATA___4 = 24,
	GP_1_0_DATA___4 = 25,
	GP_1_1_DATA___4 = 26,
	GP_1_2_DATA___4 = 27,
	GP_1_3_DATA___4 = 28,
	GP_1_4_DATA___4 = 29,
	GP_1_5_DATA___4 = 30,
	GP_1_6_DATA___4 = 31,
	GP_1_7_DATA___4 = 32,
	GP_1_8_DATA___4 = 33,
	GP_1_9_DATA___4 = 34,
	GP_1_10_DATA___4 = 35,
	GP_1_11_DATA___4 = 36,
	GP_1_12_DATA___4 = 37,
	GP_1_13_DATA___4 = 38,
	GP_1_14_DATA___4 = 39,
	GP_1_15_DATA___4 = 40,
	GP_1_16_DATA___4 = 41,
	GP_1_17_DATA___4 = 42,
	GP_1_18_DATA___4 = 43,
	GP_1_19_DATA___4 = 44,
	GP_1_20_DATA___4 = 45,
	GP_1_21_DATA___4 = 46,
	GP_1_22_DATA___4 = 47,
	GP_2_0_DATA___4 = 48,
	GP_2_1_DATA___4 = 49,
	GP_2_2_DATA___4 = 50,
	GP_2_3_DATA___4 = 51,
	GP_2_4_DATA___4 = 52,
	GP_2_5_DATA___4 = 53,
	GP_2_6_DATA___4 = 54,
	GP_2_7_DATA___4 = 55,
	GP_2_8_DATA___4 = 56,
	GP_2_9_DATA___4 = 57,
	GP_2_10_DATA___4 = 58,
	GP_2_11_DATA___4 = 59,
	GP_2_12_DATA___4 = 60,
	GP_2_13_DATA___4 = 61,
	GP_2_14_DATA___4 = 62,
	GP_2_15_DATA___4 = 63,
	GP_2_16_DATA___4 = 64,
	GP_2_17_DATA___4 = 65,
	GP_2_18_DATA___4 = 66,
	GP_2_19_DATA___4 = 67,
	GP_2_20_DATA___4 = 68,
	GP_2_21_DATA___4 = 69,
	GP_2_22_DATA___4 = 70,
	GP_2_23_DATA___4 = 71,
	GP_2_24_DATA___4 = 72,
	GP_2_25_DATA___4 = 73,
	GP_2_26_DATA___4 = 74,
	GP_2_27_DATA___4 = 75,
	GP_2_28_DATA___4 = 76,
	GP_2_29_DATA___4 = 77,
	GP_2_30_DATA___3 = 78,
	GP_2_31_DATA___3 = 79,
	GP_3_0_DATA___4 = 80,
	GP_3_1_DATA___4 = 81,
	GP_3_2_DATA___4 = 82,
	GP_3_3_DATA___4 = 83,
	GP_3_4_DATA___4 = 84,
	GP_3_5_DATA___4 = 85,
	GP_3_6_DATA___4 = 86,
	GP_3_7_DATA___4 = 87,
	GP_3_8_DATA___4 = 88,
	GP_3_9_DATA___4 = 89,
	GP_3_10_DATA___4 = 90,
	GP_3_11_DATA___4 = 91,
	GP_3_12_DATA___4 = 92,
	GP_3_13_DATA___4 = 93,
	GP_3_14_DATA___4 = 94,
	GP_3_15_DATA___4 = 95,
	GP_3_16_DATA___4 = 96,
	GP_3_27_DATA___4 = 97,
	GP_3_28_DATA___4 = 98,
	GP_3_29_DATA___4 = 99,
	GP_4_0_DATA___4 = 100,
	GP_4_1_DATA___4 = 101,
	GP_4_2_DATA___4 = 102,
	GP_4_3_DATA___4 = 103,
	GP_4_4_DATA___4 = 104,
	GP_4_5_DATA___4 = 105,
	GP_4_6_DATA___4 = 106,
	GP_4_7_DATA___4 = 107,
	GP_4_8_DATA___4 = 108,
	GP_4_9_DATA___4 = 109,
	GP_4_10_DATA___4 = 110,
	GP_4_11_DATA___4 = 111,
	GP_4_12_DATA___4 = 112,
	GP_4_13_DATA___4 = 113,
	GP_4_14_DATA___4 = 114,
	GP_4_15_DATA___4 = 115,
	GP_4_16_DATA___4 = 116,
	GP_4_17_DATA___4 = 117,
	GP_4_18_DATA___4 = 118,
	GP_4_19_DATA___4 = 119,
	GP_4_20_DATA___4 = 120,
	GP_4_21_DATA___4 = 121,
	GP_4_22_DATA___4 = 122,
	GP_4_23_DATA___4 = 123,
	GP_4_24_DATA___4 = 124,
	GP_4_25_DATA___4 = 125,
	GP_5_0_DATA___4 = 126,
	GP_5_1_DATA___4 = 127,
	GP_5_2_DATA___4 = 128,
	GP_5_3_DATA___4 = 129,
	GP_5_4_DATA___4 = 130,
	GP_5_5_DATA___4 = 131,
	GP_5_6_DATA___4 = 132,
	GP_5_7_DATA___4 = 133,
	GP_5_8_DATA___4 = 134,
	GP_5_9_DATA___4 = 135,
	GP_5_10_DATA___4 = 136,
	GP_5_11_DATA___4 = 137,
	GP_5_12_DATA___4 = 138,
	GP_5_13_DATA___4 = 139,
	GP_5_14_DATA___4 = 140,
	GP_5_15_DATA___4 = 141,
	GP_5_16_DATA___4 = 142,
	GP_5_17_DATA___4 = 143,
	GP_5_18_DATA___4 = 144,
	GP_5_19_DATA___4 = 145,
	GP_5_20_DATA___4 = 146,
	GP_5_21_DATA___4 = 147,
	GP_5_22_DATA___4 = 148,
	GP_5_23_DATA___4 = 149,
	GP_5_24_DATA___4 = 150,
	GP_5_25_DATA___4 = 151,
	GP_5_26_DATA___4 = 152,
	GP_5_27_DATA___4 = 153,
	GP_5_28_DATA___3 = 154,
	GP_5_29_DATA___3 = 155,
	GP_5_30_DATA___3 = 156,
	GP_5_31_DATA___3 = 157,
	PINMUX_DATA_END___7 = 158,
	PINMUX_FUNCTION_BEGIN___7 = 159,
	GP_0_0_FN___4 = 160,
	GP_0_1_FN___4 = 161,
	GP_0_2_FN___4 = 162,
	GP_0_3_FN___4 = 163,
	GP_0_4_FN___4 = 164,
	GP_0_5_FN___4 = 165,
	GP_0_6_FN___4 = 166,
	GP_0_7_FN___4 = 167,
	GP_0_8_FN___4 = 168,
	GP_0_9_FN___4 = 169,
	GP_0_10_FN___4 = 170,
	GP_0_11_FN___4 = 171,
	GP_0_12_FN___4 = 172,
	GP_0_13_FN___4 = 173,
	GP_0_14_FN___4 = 174,
	GP_0_15_FN___4 = 175,
	GP_0_16_FN___4 = 176,
	GP_0_17_FN___4 = 177,
	GP_0_18_FN___4 = 178,
	GP_0_19_FN___4 = 179,
	GP_0_20_FN___4 = 180,
	GP_0_21_FN___4 = 181,
	GP_0_22_FN___4 = 182,
	GP_1_0_FN___4 = 183,
	GP_1_1_FN___4 = 184,
	GP_1_2_FN___4 = 185,
	GP_1_3_FN___4 = 186,
	GP_1_4_FN___4 = 187,
	GP_1_5_FN___4 = 188,
	GP_1_6_FN___4 = 189,
	GP_1_7_FN___4 = 190,
	GP_1_8_FN___4 = 191,
	GP_1_9_FN___4 = 192,
	GP_1_10_FN___4 = 193,
	GP_1_11_FN___4 = 194,
	GP_1_12_FN___4 = 195,
	GP_1_13_FN___4 = 196,
	GP_1_14_FN___4 = 197,
	GP_1_15_FN___4 = 198,
	GP_1_16_FN___4 = 199,
	GP_1_17_FN___4 = 200,
	GP_1_18_FN___4 = 201,
	GP_1_19_FN___4 = 202,
	GP_1_20_FN___4 = 203,
	GP_1_21_FN___4 = 204,
	GP_1_22_FN___4 = 205,
	GP_2_0_FN___4 = 206,
	GP_2_1_FN___4 = 207,
	GP_2_2_FN___4 = 208,
	GP_2_3_FN___4 = 209,
	GP_2_4_FN___4 = 210,
	GP_2_5_FN___4 = 211,
	GP_2_6_FN___4 = 212,
	GP_2_7_FN___4 = 213,
	GP_2_8_FN___4 = 214,
	GP_2_9_FN___4 = 215,
	GP_2_10_FN___4 = 216,
	GP_2_11_FN___4 = 217,
	GP_2_12_FN___4 = 218,
	GP_2_13_FN___4 = 219,
	GP_2_14_FN___4 = 220,
	GP_2_15_FN___4 = 221,
	GP_2_16_FN___4 = 222,
	GP_2_17_FN___4 = 223,
	GP_2_18_FN___4 = 224,
	GP_2_19_FN___4 = 225,
	GP_2_20_FN___4 = 226,
	GP_2_21_FN___4 = 227,
	GP_2_22_FN___4 = 228,
	GP_2_23_FN___4 = 229,
	GP_2_24_FN___4 = 230,
	GP_2_25_FN___4 = 231,
	GP_2_26_FN___4 = 232,
	GP_2_27_FN___4 = 233,
	GP_2_28_FN___4 = 234,
	GP_2_29_FN___4 = 235,
	GP_2_30_FN___3 = 236,
	GP_2_31_FN___3 = 237,
	GP_3_0_FN___4 = 238,
	GP_3_1_FN___4 = 239,
	GP_3_2_FN___4 = 240,
	GP_3_3_FN___4 = 241,
	GP_3_4_FN___4 = 242,
	GP_3_5_FN___4 = 243,
	GP_3_6_FN___4 = 244,
	GP_3_7_FN___4 = 245,
	GP_3_8_FN___4 = 246,
	GP_3_9_FN___4 = 247,
	GP_3_10_FN___4 = 248,
	GP_3_11_FN___4 = 249,
	GP_3_12_FN___4 = 250,
	GP_3_13_FN___4 = 251,
	GP_3_14_FN___4 = 252,
	GP_3_15_FN___4 = 253,
	GP_3_16_FN___4 = 254,
	GP_3_27_FN___4 = 255,
	GP_3_28_FN___4 = 256,
	GP_3_29_FN___4 = 257,
	GP_4_0_FN___4 = 258,
	GP_4_1_FN___4 = 259,
	GP_4_2_FN___4 = 260,
	GP_4_3_FN___4 = 261,
	GP_4_4_FN___4 = 262,
	GP_4_5_FN___4 = 263,
	GP_4_6_FN___4 = 264,
	GP_4_7_FN___4 = 265,
	GP_4_8_FN___4 = 266,
	GP_4_9_FN___4 = 267,
	GP_4_10_FN___4 = 268,
	GP_4_11_FN___4 = 269,
	GP_4_12_FN___4 = 270,
	GP_4_13_FN___4 = 271,
	GP_4_14_FN___4 = 272,
	GP_4_15_FN___4 = 273,
	GP_4_16_FN___4 = 274,
	GP_4_17_FN___4 = 275,
	GP_4_18_FN___4 = 276,
	GP_4_19_FN___4 = 277,
	GP_4_20_FN___4 = 278,
	GP_4_21_FN___4 = 279,
	GP_4_22_FN___4 = 280,
	GP_4_23_FN___4 = 281,
	GP_4_24_FN___4 = 282,
	GP_4_25_FN___4 = 283,
	GP_5_0_FN___4 = 284,
	GP_5_1_FN___4 = 285,
	GP_5_2_FN___4 = 286,
	GP_5_3_FN___4 = 287,
	GP_5_4_FN___4 = 288,
	GP_5_5_FN___4 = 289,
	GP_5_6_FN___4 = 290,
	GP_5_7_FN___4 = 291,
	GP_5_8_FN___4 = 292,
	GP_5_9_FN___4 = 293,
	GP_5_10_FN___4 = 294,
	GP_5_11_FN___4 = 295,
	GP_5_12_FN___4 = 296,
	GP_5_13_FN___4 = 297,
	GP_5_14_FN___4 = 298,
	GP_5_15_FN___4 = 299,
	GP_5_16_FN___4 = 300,
	GP_5_17_FN___4 = 301,
	GP_5_18_FN___4 = 302,
	GP_5_19_FN___4 = 303,
	GP_5_20_FN___4 = 304,
	GP_5_21_FN___4 = 305,
	GP_5_22_FN___4 = 306,
	GP_5_23_FN___4 = 307,
	GP_5_24_FN___4 = 308,
	GP_5_25_FN___4 = 309,
	GP_5_26_FN___4 = 310,
	GP_5_27_FN___4 = 311,
	GP_5_28_FN___3 = 312,
	GP_5_29_FN___3 = 313,
	GP_5_30_FN___3 = 314,
	GP_5_31_FN___3 = 315,
	FN_USB0_PWEN___4 = 316,
	FN_USB0_OVC___3 = 317,
	FN_USB1_PWEN___4 = 318,
	FN_USB1_OVC___4 = 319,
	FN_CLKOUT = 320,
	FN_IP0_3_0 = 321,
	FN_IP0_7_4 = 322,
	FN_IP0_11_8 = 323,
	FN_IP0_15_12___2 = 324,
	FN_IP0_19_16___2 = 325,
	FN_IP0_23_20 = 326,
	FN_IP0_27_24 = 327,
	FN_IP0_31_28 = 328,
	FN_MMC0_CLK_SDHI1_CLK = 329,
	FN_MMC0_CMD_SDHI1_CMD = 330,
	FN_MMC0_D0_SDHI1_D0 = 331,
	FN_MMC0_D1_SDHI1_D1 = 332,
	FN_MMC0_D2_SDHI1_D2 = 333,
	FN_MMC0_D3_SDHI1_D3 = 334,
	FN_IP1_3_0___2 = 335,
	FN_IP1_7_4___2 = 336,
	FN_MMC0_D6___2 = 337,
	FN_MMC0_D7___2 = 338,
	FN_IP1_11_8___2 = 339,
	FN_IP1_15_12 = 340,
	FN_IP1_19_16 = 341,
	FN_IP1_23_20 = 342,
	FN_IP1_27_24 = 343,
	FN_IP1_31_28 = 344,
	FN_IP2_3_0 = 345,
	FN_IP2_7_4 = 346,
	FN_IP2_11_8 = 347,
	FN_IP2_15_12 = 348,
	FN_IP2_19_16 = 349,
	FN_IP2_23_20 = 350,
	FN_IP2_27_24 = 351,
	FN_IP2_31_28 = 352,
	FN_IP3_3_0___2 = 353,
	FN_IP3_7_4___2 = 354,
	FN_IP3_11_8___2 = 355,
	FN_IP3_15_12 = 356,
	FN_IP3_19_16 = 357,
	FN_IP3_23_20 = 358,
	FN_IP3_27_24 = 359,
	FN_IP3_31_28 = 360,
	FN_IP4_3_0 = 361,
	FN_IP4_7_4 = 362,
	FN_IP4_11_8 = 363,
	FN_IP4_15_12 = 364,
	FN_IP4_19_16 = 365,
	FN_IP4_23_20 = 366,
	FN_IP4_27_24 = 367,
	FN_IP4_31_28 = 368,
	FN_IP5_3_0 = 369,
	FN_IP5_7_4 = 370,
	FN_IP5_11_8 = 371,
	FN_IP5_15_12 = 372,
	FN_IP5_19_16 = 373,
	FN_IP5_23_20 = 374,
	FN_IP5_27_24 = 375,
	FN_IP5_31_28 = 376,
	FN_IP6_3_0 = 377,
	FN_IP6_7_4 = 378,
	FN_IP6_11_8 = 379,
	FN_IP6_15_12 = 380,
	FN_IP6_19_16 = 381,
	FN_IP6_23_20 = 382,
	FN_IP6_27_24 = 383,
	FN_IP6_31_28 = 384,
	FN_IP7_3_0 = 385,
	FN_IP7_7_4 = 386,
	FN_IP7_11_8 = 387,
	FN_IP7_15_12 = 388,
	FN_IP7_19_16 = 389,
	FN_IP7_23_20 = 390,
	FN_IP7_27_24 = 391,
	FN_IP7_31_28 = 392,
	FN_IP8_3_0 = 393,
	FN_IP8_7_4 = 394,
	FN_IP8_11_8 = 395,
	FN_IP8_15_12 = 396,
	FN_IP8_19_16 = 397,
	FN_IP8_23_20 = 398,
	FN_IP8_27_24 = 399,
	FN_IP8_31_28 = 400,
	FN_IP9_3_0 = 401,
	FN_IP9_7_4 = 402,
	FN_IP9_11_8___2 = 403,
	FN_IP9_15_12___2 = 404,
	FN_IP9_19_16 = 405,
	FN_IP9_23_20 = 406,
	FN_IP9_27_24 = 407,
	FN_IP9_31_28___2 = 408,
	FN_IP10_3_0___2 = 409,
	FN_IP10_7_4 = 410,
	FN_IP10_11_8 = 411,
	FN_IP10_15_12 = 412,
	FN_IP10_19_16 = 413,
	FN_IP10_23_20 = 414,
	FN_IP10_27_24 = 415,
	FN_IP10_31_28 = 416,
	FN_IP11_3_0___2 = 417,
	FN_IP11_7_4 = 418,
	FN_IP11_11_8 = 419,
	FN_IP11_15_12 = 420,
	FN_IP11_19_16 = 421,
	FN_IP11_23_20 = 422,
	FN_IP11_27_24 = 423,
	FN_IP11_31_28 = 424,
	FN_IP12_3_0 = 425,
	FN_IP12_7_4 = 426,
	FN_IP12_11_8 = 427,
	FN_IP12_15_12 = 428,
	FN_IP12_19_16 = 429,
	FN_IP12_23_20 = 430,
	FN_IP12_27_24 = 431,
	FN_IP12_31_28 = 432,
	FN_IP13_3_0 = 433,
	FN_IP13_7_4 = 434,
	FN_IP13_11_8 = 435,
	FN_IP13_15_12 = 436,
	FN_IP13_19_16 = 437,
	FN_IP13_23_20 = 438,
	FN_IP13_27_24 = 439,
	FN_IP13_31_28 = 440,
	FN_IP14_3_0 = 441,
	FN_IP14_7_4 = 442,
	FN_IP14_11_8 = 443,
	FN_IP14_15_12___2 = 444,
	FN_IP14_19_16 = 445,
	FN_IP14_23_20 = 446,
	FN_IP14_27_24 = 447,
	FN_IP14_31_28 = 448,
	FN_IP15_3_0 = 449,
	FN_IP15_7_4 = 450,
	FN_IP15_11_8 = 451,
	FN_IP15_15_12 = 452,
	FN_IP15_19_16 = 453,
	FN_IP15_23_20 = 454,
	FN_IP15_27_24 = 455,
	FN_IP15_31_28 = 456,
	FN_IP16_3_0 = 457,
	FN_IP16_7_4 = 458,
	FN_IP16_11_8 = 459,
	FN_IP16_15_12 = 460,
	FN_IP16_19_16 = 461,
	FN_IP16_23_20 = 462,
	FN_IP16_27_24 = 463,
	FN_IP16_31_28 = 464,
	FN_IP17_3_0 = 465,
	FN_IP17_7_4 = 466,
	FN_IP17_11_8 = 467,
	FN_IP17_15_12 = 468,
	FN_IP17_19_16 = 469,
	FN_IP17_23_20 = 470,
	FN_IP17_27_24 = 471,
	FN_SD0_CLK___4 = 472,
	FN_SSI_SCK1_C = 473,
	FN_RX3_C___2 = 474,
	FN_SD0_CMD___4 = 475,
	FN_SSI_WS1_C = 476,
	FN_TX3_C___2 = 477,
	FN_SD0_DAT0___2 = 478,
	FN_SSI_SDATA1_C = 479,
	FN_RX4_E = 480,
	FN_SD0_DAT1___2 = 481,
	FN_SSI_SCK0129_B___2 = 482,
	FN_TX4_E = 483,
	FN_SD0_DAT2___2 = 484,
	FN_SSI_WS0129_B___2 = 485,
	FN_RX5_E = 486,
	FN_SD0_DAT3___2 = 487,
	FN_SSI_SDATA0_B___2 = 488,
	FN_TX5_E = 489,
	FN_SD0_CD___4 = 490,
	FN_CAN0_RX_A = 491,
	FN_SD0_WP___4 = 492,
	FN_IRQ7___3 = 493,
	FN_CAN0_TX_A = 494,
	FN_MMC0_D4___2 = 495,
	FN_SD1_CD___4 = 496,
	FN_MMC0_D5___2 = 497,
	FN_SD1_WP___4 = 498,
	FN_D0___4 = 499,
	FN_SCL3_B = 500,
	FN_RX5_B___2 = 501,
	FN_IRQ4___3 = 502,
	FN_MSIOF2_RXD_C___2 = 503,
	FN_SSI_SDATA5_B___3 = 504,
	FN_D1___4 = 505,
	FN_SDA3_B = 506,
	FN_TX5_B___2 = 507,
	FN_MSIOF2_TXD_C___2 = 508,
	FN_SSI_WS5_B___3 = 509,
	FN_D2___4 = 510,
	FN_RX4_B___2 = 511,
	FN_SCL0_D = 512,
	FN_PWM1_C___2 = 513,
	FN_MSIOF2_SCK_C___2 = 514,
	FN_SSI_SCK5_B___3 = 515,
	FN_D3___4 = 516,
	FN_TX4_B___2 = 517,
	FN_SDA0_D = 518,
	FN_PWM0_A = 519,
	FN_MSIOF2_SYNC_C___2 = 520,
	FN_D4___4 = 521,
	FN_IRQ3___4 = 522,
	FN_TCLK1_A = 523,
	FN_PWM6_C = 524,
	FN_D5___4 = 525,
	FN_HRX2___2 = 526,
	FN_SCL1_B = 527,
	FN_PWM2_C___2 = 528,
	FN_TCLK2_B___2 = 529,
	FN_D6___4 = 530,
	FN_HTX2___2 = 531,
	FN_SDA1_B = 532,
	FN_PWM4_C = 533,
	FN_D7___4 = 534,
	FN_HSCK2___2 = 535,
	FN_SCIF1_SCK_C___2 = 536,
	FN_IRQ6___3 = 537,
	FN_PWM5_C___2 = 538,
	FN_D8___4 = 539,
	FN_HCTS2_N___2 = 540,
	FN_RX1_C___3 = 541,
	FN_SCL1_D = 542,
	FN_PWM3_C = 543,
	FN_D9___4 = 544,
	FN_HRTS2_N___2 = 545,
	FN_TX1_C___3 = 546,
	FN_SDA1_D = 547,
	FN_D10___4 = 548,
	FN_MSIOF2_RXD_A = 549,
	FN_HRX0_B___3 = 550,
	FN_D11___4 = 551,
	FN_MSIOF2_TXD_A = 552,
	FN_HTX0_B___3 = 553,
	FN_D12___4 = 554,
	FN_MSIOF2_SCK_A = 555,
	FN_HSCK0___3 = 556,
	FN_CAN_CLK_C___3 = 557,
	FN_D13___4 = 558,
	FN_MSIOF2_SYNC_A = 559,
	FN_RX4_C___2 = 560,
	FN_D14___4 = 561,
	FN_MSIOF2_SS1___4 = 562,
	FN_TX4_C___2 = 563,
	FN_CAN1_RX_B___4 = 564,
	FN_AVB_AVTP_CAPTURE_A = 565,
	FN_D15___4 = 566,
	FN_MSIOF2_SS2___4 = 567,
	FN_PWM4_A = 568,
	FN_CAN1_TX_B___4 = 569,
	FN_IRQ2___4 = 570,
	FN_AVB_AVTP_MATCH_A = 571,
	FN_QSPI0_SPCLK = 572,
	FN_WE0_N___4 = 573,
	FN_QSPI0_MOSI_QSPI0_IO0 = 574,
	FN_BS_N___4 = 575,
	FN_QSPI0_MISO_QSPI0_IO1 = 576,
	FN_RD_WR_N___4 = 577,
	FN_QSPI0_IO2 = 578,
	FN_CS0_N___4 = 579,
	FN_QSPI0_IO3 = 580,
	FN_RD_N___4 = 581,
	FN_QSPI0_SSL = 582,
	FN_WE1_N___4 = 583,
	FN_EX_WAIT0___4 = 584,
	FN_CAN_CLK_B___4 = 585,
	FN_SCIF_CLK_A = 586,
	FN_DU0_DR0___2 = 587,
	FN_RX5_C = 588,
	FN_SCL2_D = 589,
	FN_A0___4 = 590,
	FN_DU0_DR1___2 = 591,
	FN_TX5_C = 592,
	FN_SDA2_D = 593,
	FN_A1___4 = 594,
	FN_DU0_DR2___2 = 595,
	FN_RX0_D___2 = 596,
	FN_SCL0_E = 597,
	FN_A2___4 = 598,
	FN_DU0_DR3___2 = 599,
	FN_TX0_D___2 = 600,
	FN_SDA0_E = 601,
	FN_PWM0_B___4 = 602,
	FN_A3___4 = 603,
	FN_DU0_DR4___2 = 604,
	FN_RX1_D___3 = 605,
	FN_A4___4 = 606,
	FN_DU0_DR5___2 = 607,
	FN_TX1_D___3 = 608,
	FN_PWM1_B___4 = 609,
	FN_A5___4 = 610,
	FN_DU0_DR6___2 = 611,
	FN_RX2_C___2 = 612,
	FN_A6___4 = 613,
	FN_DU0_DR7___2 = 614,
	FN_TX2_C___2 = 615,
	FN_PWM2_B___3 = 616,
	FN_A7___4 = 617,
	FN_DU0_DG0___2 = 618,
	FN_RX3_B___2 = 619,
	FN_SCL3_D = 620,
	FN_A8___4 = 621,
	FN_DU0_DG1___2 = 622,
	FN_TX3_B___2 = 623,
	FN_SDA3_D = 624,
	FN_PWM3_B___2 = 625,
	FN_A9___4 = 626,
	FN_DU0_DG2___2 = 627,
	FN_RX4_D = 628,
	FN_A10___4 = 629,
	FN_DU0_DG3___2 = 630,
	FN_TX4_D = 631,
	FN_PWM4_B___3 = 632,
	FN_A11___4 = 633,
	FN_DU0_DG4___2 = 634,
	FN_HRX0_A = 635,
	FN_A12___4 = 636,
	FN_DU0_DG5___2 = 637,
	FN_HTX0_A = 638,
	FN_PWM5_B___3 = 639,
	FN_A13___4 = 640,
	FN_DU0_DG6___2 = 641,
	FN_HRX1_C___2 = 642,
	FN_A14___4 = 643,
	FN_DU0_DG7___2 = 644,
	FN_HTX1_C___2 = 645,
	FN_PWM6_B___2 = 646,
	FN_A15___4 = 647,
	FN_DU0_DB0___2 = 648,
	FN_SCL4_D = 649,
	FN_CAN0_RX_C___4 = 650,
	FN_A16___4 = 651,
	FN_DU0_DB1___2 = 652,
	FN_SDA4_D = 653,
	FN_CAN0_TX_C___4 = 654,
	FN_A17___4 = 655,
	FN_DU0_DB2___2 = 656,
	FN_HCTS0_N___3 = 657,
	FN_A18___4 = 658,
	FN_DU0_DB3___2 = 659,
	FN_HRTS0_N___3 = 660,
	FN_A19___4 = 661,
	FN_DU0_DB4___2 = 662,
	FN_HCTS1_N_C___2 = 663,
	FN_A20___4 = 664,
	FN_DU0_DB5___2 = 665,
	FN_HRTS1_N_C___2 = 666,
	FN_A21___4 = 667,
	FN_DU0_DB6___2 = 668,
	FN_A22___4 = 669,
	FN_DU0_DB7___2 = 670,
	FN_A23___4 = 671,
	FN_DU0_DOTCLKIN___3 = 672,
	FN_A24___4 = 673,
	FN_DU0_DOTCLKOUT0___2 = 674,
	FN_A25___4 = 675,
	FN_DU0_DOTCLKOUT1___2 = 676,
	FN_MSIOF2_RXD_B___3 = 677,
	FN_CS1_N_A26___4 = 678,
	FN_DU0_EXHSYNC_DU0_HSYNC___2 = 679,
	FN_MSIOF2_TXD_B___3 = 680,
	FN_DREQ0_N___3 = 681,
	FN_DU0_EXVSYNC_DU0_VSYNC___2 = 682,
	FN_MSIOF2_SYNC_B___3 = 683,
	FN_DACK0___4 = 684,
	FN_DU0_EXODDF_DU0_ODDF_DISP_CDE___2 = 685,
	FN_MSIOF2_SCK_B___3 = 686,
	FN_DRACK0___4 = 687,
	FN_DU0_DISP___2 = 688,
	FN_CAN1_RX_C___3 = 689,
	FN_DU0_CDE___2 = 690,
	FN_CAN1_TX_C___3 = 691,
	FN_VI1_CLK___4 = 692,
	FN_AVB_RX_CLK___4 = 693,
	FN_ETH_REF_CLK___2 = 694,
	FN_VI1_DATA0___3 = 695,
	FN_AVB_RX_DV___4 = 696,
	FN_ETH_CRS_DV___4 = 697,
	FN_VI1_DATA1___3 = 698,
	FN_AVB_RXD0___4 = 699,
	FN_ETH_RXD0___4 = 700,
	FN_VI1_DATA2___3 = 701,
	FN_AVB_RXD1___4 = 702,
	FN_ETH_RXD1___4 = 703,
	FN_VI1_DATA3___3 = 704,
	FN_AVB_RXD2___4 = 705,
	FN_ETH_MDIO___4 = 706,
	FN_VI1_DATA4___3 = 707,
	FN_AVB_RXD3___4 = 708,
	FN_ETH_RX_ER___4 = 709,
	FN_VI1_DATA5___3 = 710,
	FN_AVB_RXD4___4 = 711,
	FN_ETH_LINK___4 = 712,
	FN_VI1_DATA6___3 = 713,
	FN_AVB_RXD5___4 = 714,
	FN_ETH_TXD1___4 = 715,
	FN_VI1_DATA7___3 = 716,
	FN_AVB_RXD6___4 = 717,
	FN_ETH_TX_EN___4 = 718,
	FN_VI1_CLKENB___4 = 719,
	FN_SCL3_A = 720,
	FN_AVB_RXD7___4 = 721,
	FN_ETH_MAGIC___4 = 722,
	FN_VI1_FIELD___4 = 723,
	FN_SDA3_A = 724,
	FN_AVB_RX_ER___4 = 725,
	FN_ETH_TXD0___4 = 726,
	FN_VI1_HSYNC_N___4 = 727,
	FN_RX0_B___3 = 728,
	FN_SCL0_C = 729,
	FN_AVB_GTXREFCLK___4 = 730,
	FN_ETH_MDC___4 = 731,
	FN_VI1_VSYNC_N___4 = 732,
	FN_TX0_B___3 = 733,
	FN_SDA0_C = 734,
	FN_AUDIO_CLKOUT_B___3 = 735,
	FN_AVB_TX_CLK___4 = 736,
	FN_VI1_DATA8___2 = 737,
	FN_SCL2_B = 738,
	FN_AVB_TX_EN___4 = 739,
	FN_VI1_DATA9___2 = 740,
	FN_SDA2_B = 741,
	FN_AVB_TXD0___4 = 742,
	FN_VI1_DATA10___2 = 743,
	FN_CAN0_RX_B___4 = 744,
	FN_AVB_TXD1___4 = 745,
	FN_VI1_DATA11___2 = 746,
	FN_CAN0_TX_B___4 = 747,
	FN_AVB_TXD2___4 = 748,
	FN_AVB_TXD3___4 = 749,
	FN_AUDIO_CLKA_B___2 = 750,
	FN_SSI_SCK1_D = 751,
	FN_RX5_F = 752,
	FN_MSIOF0_RXD_B___3 = 753,
	FN_AVB_TXD4___4 = 754,
	FN_AUDIO_CLKB_B___3 = 755,
	FN_SSI_WS1_D = 756,
	FN_TX5_F = 757,
	FN_MSIOF0_TXD_B___3 = 758,
	FN_AVB_TXD5___4 = 759,
	FN_SCIF_CLK_B___4 = 760,
	FN_AUDIO_CLKC_B___2 = 761,
	FN_SSI_SDATA1_D = 762,
	FN_MSIOF0_SCK_B___3 = 763,
	FN_SCL0_A = 764,
	FN_RX0_C___2 = 765,
	FN_PWM5_A = 766,
	FN_TCLK1_B___4 = 767,
	FN_AVB_TXD6___4 = 768,
	FN_CAN1_RX_D___3 = 769,
	FN_MSIOF0_SYNC_B___2 = 770,
	FN_SDA0_A = 771,
	FN_TX0_C___2 = 772,
	FN_IRQ5___3 = 773,
	FN_CAN_CLK_A = 774,
	FN_AVB_GTX_CLK___4 = 775,
	FN_CAN1_TX_D___3 = 776,
	FN_DVC_MUTE___4 = 777,
	FN_SCL1_A = 778,
	FN_RX4_A = 779,
	FN_PWM5_D = 780,
	FN_DU1_DR0___3 = 781,
	FN_SSI_SCK6_B___3 = 782,
	FN_VI0_G0___4 = 783,
	FN_SDA1_A = 784,
	FN_TX4_A = 785,
	FN_DU1_DR1___3 = 786,
	FN_SSI_WS6_B___3 = 787,
	FN_VI0_G1___4 = 788,
	FN_MSIOF0_RXD_A = 789,
	FN_RX5_A = 790,
	FN_SCL2_C = 791,
	FN_DU1_DR2___3 = 792,
	FN_QSPI1_MOSI_QSPI1_IO0 = 793,
	FN_SSI_SDATA6_B___3 = 794,
	FN_VI0_G2___4 = 795,
	FN_MSIOF0_TXD_A = 796,
	FN_TX5_A = 797,
	FN_SDA2_C = 798,
	FN_DU1_DR3___3 = 799,
	FN_QSPI1_MISO_QSPI1_IO1 = 800,
	FN_SSI_WS78_B___4 = 801,
	FN_VI0_G3___4 = 802,
	FN_MSIOF0_SCK_A = 803,
	FN_IRQ0___4 = 804,
	FN_DU1_DR4___3 = 805,
	FN_QSPI1_SPCLK = 806,
	FN_SSI_SCK78_B___4 = 807,
	FN_VI0_G4___4 = 808,
	FN_MSIOF0_SYNC_A = 809,
	FN_PWM1_A = 810,
	FN_DU1_DR5___3 = 811,
	FN_QSPI1_IO2 = 812,
	FN_SSI_SDATA7_B___4 = 813,
	FN_MSIOF0_SS1_A = 814,
	FN_DU1_DR6___3 = 815,
	FN_QSPI1_IO3 = 816,
	FN_SSI_SDATA8_B___4 = 817,
	FN_MSIOF0_SS2_A = 818,
	FN_DU1_DR7___3 = 819,
	FN_QSPI1_SSL = 820,
	FN_HRX1_A = 821,
	FN_SCL4_A = 822,
	FN_PWM6_A = 823,
	FN_DU1_DG0___3 = 824,
	FN_RX0_A = 825,
	FN_HTX1_A = 826,
	FN_SDA4_A = 827,
	FN_DU1_DG1___3 = 828,
	FN_TX0_A = 829,
	FN_HCTS1_N_A = 830,
	FN_PWM2_A = 831,
	FN_DU1_DG2___3 = 832,
	FN_REMOCON_B___3 = 833,
	FN_HRTS1_N_A = 834,
	FN_DU1_DG3___3 = 835,
	FN_SSI_WS1_B___3 = 836,
	FN_IRQ1___4 = 837,
	FN_SD2_CLK___4 = 838,
	FN_HSCK1___3 = 839,
	FN_DU1_DG4___3 = 840,
	FN_SSI_SCK1_B___3 = 841,
	FN_SD2_CMD___4 = 842,
	FN_SCIF1_SCK_A = 843,
	FN_TCLK2_A = 844,
	FN_DU1_DG5___3 = 845,
	FN_SSI_SCK2_B___2 = 846,
	FN_PWM3_A = 847,
	FN_SD2_DAT0___2 = 848,
	FN_RX1_A = 849,
	FN_SCL1_E = 850,
	FN_DU1_DG6___3 = 851,
	FN_SSI_SDATA1_B___3 = 852,
	FN_SD2_DAT1___2 = 853,
	FN_TX1_A = 854,
	FN_SDA1_E = 855,
	FN_DU1_DG7___3 = 856,
	FN_SSI_WS2_B___2 = 857,
	FN_SD2_DAT2___2 = 858,
	FN_RX2_A = 859,
	FN_DU1_DB0___3 = 860,
	FN_SSI_SDATA2_B___2 = 861,
	FN_SD2_DAT3___2 = 862,
	FN_TX2_A = 863,
	FN_DU1_DB1___3 = 864,
	FN_SSI_WS9_B___3 = 865,
	FN_SD2_CD___4 = 866,
	FN_SCIF2_SCK_A = 867,
	FN_DU1_DB2___3 = 868,
	FN_SSI_SCK9_B___3 = 869,
	FN_SD2_WP___4 = 870,
	FN_SCIF3_SCK___3 = 871,
	FN_DU1_DB3___3 = 872,
	FN_SSI_SDATA9_B___3 = 873,
	FN_RX3_A = 874,
	FN_SCL1_C = 875,
	FN_MSIOF1_RXD_B___4 = 876,
	FN_DU1_DB4___3 = 877,
	FN_AUDIO_CLKA_C___2 = 878,
	FN_SSI_SDATA4_B___2 = 879,
	FN_TX3_A = 880,
	FN_SDA1_C = 881,
	FN_MSIOF1_TXD_B___4 = 882,
	FN_DU1_DB5___3 = 883,
	FN_AUDIO_CLKB_C___2 = 884,
	FN_SSI_WS4_B___2 = 885,
	FN_SCL2_A = 886,
	FN_MSIOF1_SCK_B___4 = 887,
	FN_DU1_DB6___3 = 888,
	FN_AUDIO_CLKC_C___2 = 889,
	FN_SSI_SCK4_B___2 = 890,
	FN_SDA2_A = 891,
	FN_MSIOF1_SYNC_B___3 = 892,
	FN_DU1_DB7___3 = 893,
	FN_AUDIO_CLKOUT_C___3 = 894,
	FN_SSI_SCK5_A = 895,
	FN_DU1_DOTCLKOUT1___3 = 896,
	FN_SSI_WS5_A = 897,
	FN_SCL3_C = 898,
	FN_DU1_DOTCLKIN___3 = 899,
	FN_SSI_SDATA5_A = 900,
	FN_SDA3_C = 901,
	FN_DU1_DOTCLKOUT0___3 = 902,
	FN_SSI_SCK6_A = 903,
	FN_DU1_EXODDF_DU1_ODDF_DISP_CDE___3 = 904,
	FN_SSI_WS6_A = 905,
	FN_SCL4_C = 906,
	FN_DU1_EXHSYNC_DU1_HSYNC___3 = 907,
	FN_SSI_SDATA6_A = 908,
	FN_SDA4_C = 909,
	FN_DU1_EXVSYNC_DU1_VSYNC___3 = 910,
	FN_SSI_SCK78_A = 911,
	FN_SDA4_E = 912,
	FN_DU1_DISP___3 = 913,
	FN_SSI_WS78_A = 914,
	FN_SCL4_E = 915,
	FN_DU1_CDE___3 = 916,
	FN_SSI_SDATA7_A = 917,
	FN_IRQ8___3 = 918,
	FN_AUDIO_CLKA_D___2 = 919,
	FN_CAN_CLK_D___3 = 920,
	FN_VI0_G5___4 = 921,
	FN_SSI_SCK0129_A = 922,
	FN_MSIOF1_RXD_A = 923,
	FN_RX5_D = 924,
	FN_VI0_G6___4 = 925,
	FN_SSI_WS0129_A = 926,
	FN_MSIOF1_TXD_A = 927,
	FN_TX5_D = 928,
	FN_VI0_G7___4 = 929,
	FN_SSI_SDATA0_A = 930,
	FN_MSIOF1_SYNC_A = 931,
	FN_PWM0_C = 932,
	FN_VI0_R0___4 = 933,
	FN_SSI_SCK34___4 = 934,
	FN_MSIOF1_SCK_A = 935,
	FN_AVB_MDC___4 = 936,
	FN_DACK1___4 = 937,
	FN_VI0_R1___4 = 938,
	FN_SSI_WS34___4 = 939,
	FN_MSIOF1_SS1_A = 940,
	FN_AVB_MDIO___4 = 941,
	FN_CAN1_RX_A = 942,
	FN_DREQ1_N___3 = 943,
	FN_VI0_R2___4 = 944,
	FN_SSI_SDATA3___4 = 945,
	FN_MSIOF1_SS2_A = 946,
	FN_AVB_LINK___4 = 947,
	FN_CAN1_TX_A = 948,
	FN_DREQ2_N___3 = 949,
	FN_VI0_R3___4 = 950,
	FN_SSI_SCK4_A = 951,
	FN_AVB_MAGIC___4 = 952,
	FN_VI0_R4___4 = 953,
	FN_SSI_WS4_A = 954,
	FN_AVB_PHY_INT___4 = 955,
	FN_VI0_R5___4 = 956,
	FN_SSI_SDATA4_A = 957,
	FN_AVB_CRS___4 = 958,
	FN_VI0_R6___4 = 959,
	FN_SSI_SCK1_A = 960,
	FN_SCIF1_SCK_B___3 = 961,
	FN_PWM1_D = 962,
	FN_IRQ9___3 = 963,
	FN_REMOCON_A = 964,
	FN_DACK2___4 = 965,
	FN_VI0_CLK___4 = 966,
	FN_AVB_COL___4 = 967,
	FN_SSI_SDATA8_A = 968,
	FN_RX1_B___3 = 969,
	FN_CAN0_RX_D___4 = 970,
	FN_AVB_AVTP_CAPTURE_B = 971,
	FN_VI0_R7___4 = 972,
	FN_SSI_WS1_A = 973,
	FN_TX1_B___3 = 974,
	FN_CAN0_TX_D___4 = 975,
	FN_AVB_AVTP_MATCH_B = 976,
	FN_VI0_DATA0_VI0_B0___4 = 977,
	FN_SSI_SDATA1_A = 978,
	FN_HRX1_B___3 = 979,
	FN_VI0_DATA1_VI0_B1___4 = 980,
	FN_SSI_SCK2_A = 981,
	FN_HTX1_B___3 = 982,
	FN_AVB_TXD7___4 = 983,
	FN_VI0_DATA2_VI0_B2___4 = 984,
	FN_SSI_WS2_A = 985,
	FN_HCTS1_N_B___2 = 986,
	FN_AVB_TX_ER___4 = 987,
	FN_VI0_DATA3_VI0_B3___4 = 988,
	FN_SSI_SDATA2_A = 989,
	FN_HRTS1_N_B___2 = 990,
	FN_VI0_DATA4_VI0_B4___4 = 991,
	FN_SSI_SCK9_A = 992,
	FN_RX2_B___3 = 993,
	FN_SCL3_E = 994,
	FN_EX_WAIT1___4 = 995,
	FN_VI0_DATA5_VI0_B5___4 = 996,
	FN_SSI_WS9_A = 997,
	FN_TX2_B___3 = 998,
	FN_SDA3_E = 999,
	FN_VI0_DATA6_VI0_B6___4 = 1000,
	FN_SSI_SDATA9_A = 1001,
	FN_SCIF2_SCK_B___3 = 1002,
	FN_PWM2_D = 1003,
	FN_VI0_DATA7_VI0_B7___4 = 1004,
	FN_AUDIO_CLKA_A = 1005,
	FN_SCL0_B = 1006,
	FN_VI0_CLKENB___4 = 1007,
	FN_AUDIO_CLKB_A = 1008,
	FN_SDA0_B = 1009,
	FN_VI0_FIELD___4 = 1010,
	FN_AUDIO_CLKC_A = 1011,
	FN_SCL4_B = 1012,
	FN_VI0_HSYNC_N___4 = 1013,
	FN_AUDIO_CLKOUT_A = 1014,
	FN_SDA4_B = 1015,
	FN_VI0_VSYNC_N___4 = 1016,
	FN_SEL_ADGA_0 = 1017,
	FN_SEL_ADGA_1 = 1018,
	FN_SEL_ADGA_2 = 1019,
	FN_SEL_ADGA_3 = 1020,
	FN_SEL_CANCLK_0___3 = 1021,
	FN_SEL_CANCLK_1___3 = 1022,
	FN_SEL_CANCLK_2___2 = 1023,
	FN_SEL_CANCLK_3___2 = 1024,
	FN_SEL_CAN1_0___4 = 1025,
	FN_SEL_CAN1_1___4 = 1026,
	FN_SEL_CAN1_2___3 = 1027,
	FN_SEL_CAN1_3___3 = 1028,
	FN_SEL_CAN0_0___4 = 1029,
	FN_SEL_CAN0_1___4 = 1030,
	FN_SEL_CAN0_2___4 = 1031,
	FN_SEL_CAN0_3___4 = 1032,
	FN_SEL_I2C04_0___2 = 1033,
	FN_SEL_I2C04_1___2 = 1034,
	FN_SEL_I2C04_2___2 = 1035,
	FN_SEL_I2C04_3___2 = 1036,
	FN_SEL_I2C04_4___2 = 1037,
	FN_SEL_I2C03_0___2 = 1038,
	FN_SEL_I2C03_1___2 = 1039,
	FN_SEL_I2C03_2___2 = 1040,
	FN_SEL_I2C03_3___2 = 1041,
	FN_SEL_I2C03_4___2 = 1042,
	FN_SEL_I2C02_0___2 = 1043,
	FN_SEL_I2C02_1___2 = 1044,
	FN_SEL_I2C02_2___2 = 1045,
	FN_SEL_I2C02_3___2 = 1046,
	FN_SEL_I2C01_0___2 = 1047,
	FN_SEL_I2C01_1___2 = 1048,
	FN_SEL_I2C01_2___2 = 1049,
	FN_SEL_I2C01_3___2 = 1050,
	FN_SEL_I2C01_4___2 = 1051,
	FN_SEL_I2C00_0___2 = 1052,
	FN_SEL_I2C00_1___2 = 1053,
	FN_SEL_I2C00_2___2 = 1054,
	FN_SEL_I2C00_3___2 = 1055,
	FN_SEL_I2C00_4___2 = 1056,
	FN_SEL_AVB_0 = 1057,
	FN_SEL_AVB_1 = 1058,
	FN_SEL_SCIFCLK_0___2 = 1059,
	FN_SEL_SCIFCLK_1___2 = 1060,
	FN_SEL_SCIF5_0___3 = 1061,
	FN_SEL_SCIF5_1___3 = 1062,
	FN_SEL_SCIF5_2___2 = 1063,
	FN_SEL_SCIF5_3___2 = 1064,
	FN_SEL_SCIF5_4 = 1065,
	FN_SEL_SCIF5_5 = 1066,
	FN_SEL_SCIF4_0___3 = 1067,
	FN_SEL_SCIF4_1___3 = 1068,
	FN_SEL_SCIF4_2___3 = 1069,
	FN_SEL_SCIF4_3___2 = 1070,
	FN_SEL_SCIF4_4___2 = 1071,
	FN_SEL_SCIF3_0___3 = 1072,
	FN_SEL_SCIF3_1___3 = 1073,
	FN_SEL_SCIF3_2___2 = 1074,
	FN_SEL_SCIF2_0___4 = 1075,
	FN_SEL_SCIF2_1___4 = 1076,
	FN_SEL_SCIF2_2___3 = 1077,
	FN_SEL_SCIF2_CLK_0 = 1078,
	FN_SEL_SCIF2_CLK_1 = 1079,
	FN_SEL_SCIF1_0___4 = 1080,
	FN_SEL_SCIF1_1___4 = 1081,
	FN_SEL_SCIF1_2___4 = 1082,
	FN_SEL_SCIF1_3___3 = 1083,
	FN_SEL_SCIF0_0___4 = 1084,
	FN_SEL_SCIF0_1___4 = 1085,
	FN_SEL_SCIF0_2___3 = 1086,
	FN_SEL_SCIF0_3___3 = 1087,
	FN_SEL_MSIOF2_0 = 1088,
	FN_SEL_MSIOF2_1 = 1089,
	FN_SEL_MSIOF2_2 = 1090,
	FN_SEL_MSIOF1_0 = 1091,
	FN_SEL_MSIOF1_1 = 1092,
	FN_SEL_MSIOF0_0 = 1093,
	FN_SEL_MSIOF0_1 = 1094,
	FN_SEL_RCN_0___3 = 1095,
	FN_SEL_RCN_1___3 = 1096,
	FN_SEL_TMU2_0 = 1097,
	FN_SEL_TMU2_1 = 1098,
	FN_SEL_TMU1_0___3 = 1099,
	FN_SEL_TMU1_1___3 = 1100,
	FN_SEL_HSCIF1_0___4 = 1101,
	FN_SEL_HSCIF1_1___4 = 1102,
	FN_SEL_HSCIF1_2___2 = 1103,
	FN_SEL_HSCIF0_0___4 = 1104,
	FN_SEL_HSCIF0_1___4 = 1105,
	FN_SEL_ADGB_0 = 1106,
	FN_SEL_ADGB_1 = 1107,
	FN_SEL_ADGB_2 = 1108,
	FN_SEL_ADGC_0 = 1109,
	FN_SEL_ADGC_1 = 1110,
	FN_SEL_ADGC_2 = 1111,
	FN_SEL_SSI9_0___3 = 1112,
	FN_SEL_SSI9_1___3 = 1113,
	FN_SEL_SSI8_0___4 = 1114,
	FN_SEL_SSI8_1___4 = 1115,
	FN_SEL_SSI7_0___4 = 1116,
	FN_SEL_SSI7_1___4 = 1117,
	FN_SEL_SSI6_0___3 = 1118,
	FN_SEL_SSI6_1___3 = 1119,
	FN_SEL_SSI5_0___3 = 1120,
	FN_SEL_SSI5_1___3 = 1121,
	FN_SEL_SSI4_0___2 = 1122,
	FN_SEL_SSI4_1___2 = 1123,
	FN_SEL_SSI2_0___2 = 1124,
	FN_SEL_SSI2_1___2 = 1125,
	FN_SEL_SSI1_0___3 = 1126,
	FN_SEL_SSI1_1___3 = 1127,
	FN_SEL_SSI1_2 = 1128,
	FN_SEL_SSI1_3 = 1129,
	FN_SEL_SSI0_0___2 = 1130,
	FN_SEL_SSI0_1___2 = 1131,
	PINMUX_FUNCTION_END___7 = 1132,
	PINMUX_MARK_BEGIN___7 = 1133,
	USB0_PWEN_MARK___4 = 1134,
	USB0_OVC_MARK___3 = 1135,
	USB1_PWEN_MARK___4 = 1136,
	USB1_OVC_MARK___4 = 1137,
	CLKOUT_MARK = 1138,
	MMC0_CLK_SDHI1_CLK_MARK = 1139,
	MMC0_CMD_SDHI1_CMD_MARK = 1140,
	MMC0_D0_SDHI1_D0_MARK = 1141,
	MMC0_D1_SDHI1_D1_MARK = 1142,
	MMC0_D2_SDHI1_D2_MARK = 1143,
	MMC0_D3_SDHI1_D3_MARK = 1144,
	MMC0_D6_MARK___2 = 1145,
	MMC0_D7_MARK___2 = 1146,
	SD0_CLK_MARK___4 = 1147,
	SSI_SCK1_C_MARK = 1148,
	RX3_C_MARK___2 = 1149,
	SD0_CMD_MARK___4 = 1150,
	SSI_WS1_C_MARK = 1151,
	TX3_C_MARK___2 = 1152,
	SD0_DAT0_MARK___2 = 1153,
	SSI_SDATA1_C_MARK = 1154,
	RX4_E_MARK = 1155,
	SD0_DAT1_MARK___2 = 1156,
	SSI_SCK0129_B_MARK___2 = 1157,
	TX4_E_MARK = 1158,
	SD0_DAT2_MARK___2 = 1159,
	SSI_WS0129_B_MARK___2 = 1160,
	RX5_E_MARK = 1161,
	SD0_DAT3_MARK___2 = 1162,
	SSI_SDATA0_B_MARK___2 = 1163,
	TX5_E_MARK = 1164,
	SD0_CD_MARK___4 = 1165,
	CAN0_RX_A_MARK = 1166,
	SD0_WP_MARK___4 = 1167,
	IRQ7_MARK___4 = 1168,
	CAN0_TX_A_MARK = 1169,
	MMC0_D4_MARK___2 = 1170,
	SD1_CD_MARK___4 = 1171,
	MMC0_D5_MARK___2 = 1172,
	SD1_WP_MARK___4 = 1173,
	D0_MARK___5 = 1174,
	SCL3_B_MARK = 1175,
	RX5_B_MARK___2 = 1176,
	IRQ4_MARK___4 = 1177,
	MSIOF2_RXD_C_MARK___2 = 1178,
	SSI_SDATA5_B_MARK___3 = 1179,
	D1_MARK___5 = 1180,
	SDA3_B_MARK = 1181,
	TX5_B_MARK___2 = 1182,
	MSIOF2_TXD_C_MARK___2 = 1183,
	SSI_WS5_B_MARK___3 = 1184,
	D2_MARK___5 = 1185,
	RX4_B_MARK___2 = 1186,
	SCL0_D_MARK = 1187,
	PWM1_C_MARK___2 = 1188,
	MSIOF2_SCK_C_MARK___2 = 1189,
	SSI_SCK5_B_MARK___3 = 1190,
	D3_MARK___5 = 1191,
	TX4_B_MARK___2 = 1192,
	SDA0_D_MARK = 1193,
	PWM0_A_MARK = 1194,
	MSIOF2_SYNC_C_MARK___2 = 1195,
	D4_MARK___5 = 1196,
	IRQ3_MARK___5 = 1197,
	TCLK1_A_MARK = 1198,
	PWM6_C_MARK = 1199,
	D5_MARK___5 = 1200,
	HRX2_MARK___2 = 1201,
	SCL1_B_MARK = 1202,
	PWM2_C_MARK___2 = 1203,
	TCLK2_B_MARK___2 = 1204,
	D6_MARK___5 = 1205,
	HTX2_MARK___2 = 1206,
	SDA1_B_MARK = 1207,
	PWM4_C_MARK = 1208,
	D7_MARK___5 = 1209,
	HSCK2_MARK___2 = 1210,
	SCIF1_SCK_C_MARK___2 = 1211,
	IRQ6_MARK___4 = 1212,
	PWM5_C_MARK___2 = 1213,
	D8_MARK___5 = 1214,
	HCTS2_N_MARK___2 = 1215,
	RX1_C_MARK___3 = 1216,
	SCL1_D_MARK = 1217,
	PWM3_C_MARK = 1218,
	D9_MARK___5 = 1219,
	HRTS2_N_MARK___2 = 1220,
	TX1_C_MARK___3 = 1221,
	SDA1_D_MARK = 1222,
	D10_MARK___5 = 1223,
	MSIOF2_RXD_A_MARK = 1224,
	HRX0_B_MARK___3 = 1225,
	D11_MARK___5 = 1226,
	MSIOF2_TXD_A_MARK = 1227,
	HTX0_B_MARK___3 = 1228,
	D12_MARK___5 = 1229,
	MSIOF2_SCK_A_MARK = 1230,
	HSCK0_MARK___3 = 1231,
	CAN_CLK_C_MARK___3 = 1232,
	D13_MARK___5 = 1233,
	MSIOF2_SYNC_A_MARK = 1234,
	RX4_C_MARK___2 = 1235,
	D14_MARK___5 = 1236,
	MSIOF2_SS1_MARK___6 = 1237,
	TX4_C_MARK___2 = 1238,
	CAN1_RX_B_MARK___4 = 1239,
	AVB_AVTP_CAPTURE_A_MARK = 1240,
	D15_MARK___5 = 1241,
	MSIOF2_SS2_MARK___6 = 1242,
	PWM4_A_MARK = 1243,
	CAN1_TX_B_MARK___4 = 1244,
	IRQ2_MARK___5 = 1245,
	AVB_AVTP_MATCH_A_MARK = 1246,
	QSPI0_SPCLK_MARK = 1247,
	WE0_N_MARK___5 = 1248,
	QSPI0_MOSI_QSPI0_IO0_MARK = 1249,
	BS_N_MARK___4 = 1250,
	QSPI0_MISO_QSPI0_IO1_MARK = 1251,
	RD_WR_N_MARK___4 = 1252,
	QSPI0_IO2_MARK = 1253,
	CS0_N_MARK___5 = 1254,
	QSPI0_IO3_MARK = 1255,
	RD_N_MARK___5 = 1256,
	QSPI0_SSL_MARK = 1257,
	WE1_N_MARK___5 = 1258,
	EX_WAIT0_MARK___4 = 1259,
	CAN_CLK_B_MARK___4 = 1260,
	SCIF_CLK_A_MARK = 1261,
	DU0_DR0_MARK___3 = 1262,
	RX5_C_MARK = 1263,
	SCL2_D_MARK = 1264,
	A0_MARK___6 = 1265,
	DU0_DR1_MARK___2 = 1266,
	TX5_C_MARK = 1267,
	SDA2_D_MARK = 1268,
	A1_MARK___6 = 1269,
	DU0_DR2_MARK___3 = 1270,
	RX0_D_MARK___2 = 1271,
	SCL0_E_MARK = 1272,
	A2_MARK___6 = 1273,
	DU0_DR3_MARK___3 = 1274,
	TX0_D_MARK___2 = 1275,
	SDA0_E_MARK = 1276,
	PWM0_B_MARK___4 = 1277,
	A3_MARK___6 = 1278,
	DU0_DR4_MARK___3 = 1279,
	RX1_D_MARK___3 = 1280,
	A4_MARK___5 = 1281,
	DU0_DR5_MARK___3 = 1282,
	TX1_D_MARK___3 = 1283,
	PWM1_B_MARK___4 = 1284,
	A5_MARK___5 = 1285,
	DU0_DR6_MARK___3 = 1286,
	RX2_C_MARK___2 = 1287,
	A6_MARK___6 = 1288,
	DU0_DR7_MARK___3 = 1289,
	TX2_C_MARK___2 = 1290,
	PWM2_B_MARK___3 = 1291,
	A7_MARK___6 = 1292,
	DU0_DG0_MARK___3 = 1293,
	RX3_B_MARK___2 = 1294,
	SCL3_D_MARK = 1295,
	A8_MARK___6 = 1296,
	DU0_DG1_MARK___3 = 1297,
	TX3_B_MARK___2 = 1298,
	SDA3_D_MARK = 1299,
	PWM3_B_MARK___2 = 1300,
	A9_MARK___6 = 1301,
	DU0_DG2_MARK___3 = 1302,
	RX4_D_MARK = 1303,
	A10_MARK___6 = 1304,
	DU0_DG3_MARK___3 = 1305,
	TX4_D_MARK = 1306,
	PWM4_B_MARK___3 = 1307,
	A11_MARK___5 = 1308,
	DU0_DG4_MARK___3 = 1309,
	HRX0_A_MARK = 1310,
	A12_MARK___5 = 1311,
	DU0_DG5_MARK___3 = 1312,
	HTX0_A_MARK = 1313,
	PWM5_B_MARK___3 = 1314,
	A13_MARK___5 = 1315,
	DU0_DG6_MARK___3 = 1316,
	HRX1_C_MARK___2 = 1317,
	A14_MARK___5 = 1318,
	DU0_DG7_MARK___3 = 1319,
	HTX1_C_MARK___2 = 1320,
	PWM6_B_MARK___2 = 1321,
	A15_MARK___5 = 1322,
	DU0_DB0_MARK___3 = 1323,
	SCL4_D_MARK = 1324,
	CAN0_RX_C_MARK___4 = 1325,
	A16_MARK___5 = 1326,
	DU0_DB1_MARK___3 = 1327,
	SDA4_D_MARK = 1328,
	CAN0_TX_C_MARK___4 = 1329,
	A17_MARK___5 = 1330,
	DU0_DB2_MARK___3 = 1331,
	HCTS0_N_MARK___3 = 1332,
	A18_MARK___5 = 1333,
	DU0_DB3_MARK___3 = 1334,
	HRTS0_N_MARK___3 = 1335,
	A19_MARK___5 = 1336,
	DU0_DB4_MARK___3 = 1337,
	HCTS1_N_C_MARK___2 = 1338,
	A20_MARK___5 = 1339,
	DU0_DB5_MARK___3 = 1340,
	HRTS1_N_C_MARK___2 = 1341,
	A21_MARK___5 = 1342,
	DU0_DB6_MARK___3 = 1343,
	A22_MARK___5 = 1344,
	DU0_DB7_MARK___3 = 1345,
	A23_MARK___5 = 1346,
	DU0_DOTCLKIN_MARK___4 = 1347,
	A24_MARK___5 = 1348,
	DU0_DOTCLKOUT0_MARK___2 = 1349,
	A25_MARK___5 = 1350,
	DU0_DOTCLKOUT1_MARK___2 = 1351,
	MSIOF2_RXD_B_MARK___3 = 1352,
	CS1_N_A26_MARK___4 = 1353,
	DU0_EXHSYNC_DU0_HSYNC_MARK___2 = 1354,
	MSIOF2_TXD_B_MARK___3 = 1355,
	DREQ0_N_MARK___3 = 1356,
	DU0_EXVSYNC_DU0_VSYNC_MARK___2 = 1357,
	MSIOF2_SYNC_B_MARK___3 = 1358,
	DACK0_MARK___5 = 1359,
	DU0_EXODDF_DU0_ODDF_DISP_CDE_MARK___2 = 1360,
	MSIOF2_SCK_B_MARK___3 = 1361,
	DRACK0_MARK___4 = 1362,
	DU0_DISP_MARK___2 = 1363,
	CAN1_RX_C_MARK___3 = 1364,
	DU0_CDE_MARK___3 = 1365,
	CAN1_TX_C_MARK___3 = 1366,
	VI1_CLK_MARK___4 = 1367,
	AVB_RX_CLK_MARK___4 = 1368,
	ETH_REF_CLK_MARK___2 = 1369,
	VI1_DATA0_MARK___3 = 1370,
	AVB_RX_DV_MARK___4 = 1371,
	ETH_CRS_DV_MARK___4 = 1372,
	VI1_DATA1_MARK___3 = 1373,
	AVB_RXD0_MARK___4 = 1374,
	ETH_RXD0_MARK___4 = 1375,
	VI1_DATA2_MARK___3 = 1376,
	AVB_RXD1_MARK___4 = 1377,
	ETH_RXD1_MARK___4 = 1378,
	VI1_DATA3_MARK___3 = 1379,
	AVB_RXD2_MARK___4 = 1380,
	ETH_MDIO_MARK___4 = 1381,
	VI1_DATA4_MARK___3 = 1382,
	AVB_RXD3_MARK___4 = 1383,
	ETH_RX_ER_MARK___4 = 1384,
	VI1_DATA5_MARK___3 = 1385,
	AVB_RXD4_MARK___4 = 1386,
	ETH_LINK_MARK___4 = 1387,
	VI1_DATA6_MARK___3 = 1388,
	AVB_RXD5_MARK___4 = 1389,
	ETH_TXD1_MARK___4 = 1390,
	VI1_DATA7_MARK___3 = 1391,
	AVB_RXD6_MARK___4 = 1392,
	ETH_TX_EN_MARK___4 = 1393,
	VI1_CLKENB_MARK___4 = 1394,
	SCL3_A_MARK = 1395,
	AVB_RXD7_MARK___4 = 1396,
	ETH_MAGIC_MARK___4 = 1397,
	VI1_FIELD_MARK___4 = 1398,
	SDA3_A_MARK = 1399,
	AVB_RX_ER_MARK___4 = 1400,
	ETH_TXD0_MARK___4 = 1401,
	VI1_HSYNC_N_MARK___4 = 1402,
	RX0_B_MARK___3 = 1403,
	SCL0_C_MARK = 1404,
	AVB_GTXREFCLK_MARK___4 = 1405,
	ETH_MDC_MARK___4 = 1406,
	VI1_VSYNC_N_MARK___4 = 1407,
	TX0_B_MARK___3 = 1408,
	SDA0_C_MARK = 1409,
	AUDIO_CLKOUT_B_MARK___3 = 1410,
	AVB_TX_CLK_MARK___4 = 1411,
	VI1_DATA8_MARK___2 = 1412,
	SCL2_B_MARK = 1413,
	AVB_TX_EN_MARK___4 = 1414,
	VI1_DATA9_MARK___2 = 1415,
	SDA2_B_MARK = 1416,
	AVB_TXD0_MARK___4 = 1417,
	VI1_DATA10_MARK___2 = 1418,
	CAN0_RX_B_MARK___4 = 1419,
	AVB_TXD1_MARK___4 = 1420,
	VI1_DATA11_MARK___2 = 1421,
	CAN0_TX_B_MARK___4 = 1422,
	AVB_TXD2_MARK___4 = 1423,
	AVB_TXD3_MARK___4 = 1424,
	AUDIO_CLKA_B_MARK___2 = 1425,
	SSI_SCK1_D_MARK = 1426,
	RX5_F_MARK = 1427,
	MSIOF0_RXD_B_MARK___3 = 1428,
	AVB_TXD4_MARK___4 = 1429,
	AUDIO_CLKB_B_MARK___3 = 1430,
	SSI_WS1_D_MARK = 1431,
	TX5_F_MARK = 1432,
	MSIOF0_TXD_B_MARK___3 = 1433,
	AVB_TXD5_MARK___4 = 1434,
	SCIF_CLK_B_MARK___4 = 1435,
	AUDIO_CLKC_B_MARK___2 = 1436,
	SSI_SDATA1_D_MARK = 1437,
	MSIOF0_SCK_B_MARK___3 = 1438,
	SCL0_A_MARK = 1439,
	RX0_C_MARK___2 = 1440,
	PWM5_A_MARK = 1441,
	TCLK1_B_MARK___4 = 1442,
	AVB_TXD6_MARK___4 = 1443,
	CAN1_RX_D_MARK___3 = 1444,
	MSIOF0_SYNC_B_MARK___2 = 1445,
	SDA0_A_MARK = 1446,
	TX0_C_MARK___2 = 1447,
	IRQ5_MARK___4 = 1448,
	CAN_CLK_A_MARK = 1449,
	AVB_GTX_CLK_MARK___4 = 1450,
	CAN1_TX_D_MARK___3 = 1451,
	DVC_MUTE_MARK___4 = 1452,
	SCL1_A_MARK = 1453,
	RX4_A_MARK = 1454,
	PWM5_D_MARK = 1455,
	DU1_DR0_MARK___3 = 1456,
	SSI_SCK6_B_MARK___3 = 1457,
	VI0_G0_MARK___4 = 1458,
	SDA1_A_MARK = 1459,
	TX4_A_MARK = 1460,
	DU1_DR1_MARK___3 = 1461,
	SSI_WS6_B_MARK___3 = 1462,
	VI0_G1_MARK___4 = 1463,
	MSIOF0_RXD_A_MARK = 1464,
	RX5_A_MARK = 1465,
	SCL2_C_MARK = 1466,
	DU1_DR2_MARK___3 = 1467,
	QSPI1_MOSI_QSPI1_IO0_MARK = 1468,
	SSI_SDATA6_B_MARK___3 = 1469,
	VI0_G2_MARK___4 = 1470,
	MSIOF0_TXD_A_MARK = 1471,
	TX5_A_MARK = 1472,
	SDA2_C_MARK = 1473,
	DU1_DR3_MARK___3 = 1474,
	QSPI1_MISO_QSPI1_IO1_MARK = 1475,
	SSI_WS78_B_MARK___4 = 1476,
	VI0_G3_MARK___4 = 1477,
	MSIOF0_SCK_A_MARK = 1478,
	IRQ0_MARK___5 = 1479,
	DU1_DR4_MARK___3 = 1480,
	QSPI1_SPCLK_MARK = 1481,
	SSI_SCK78_B_MARK___4 = 1482,
	VI0_G4_MARK___4 = 1483,
	MSIOF0_SYNC_A_MARK = 1484,
	PWM1_A_MARK = 1485,
	DU1_DR5_MARK___3 = 1486,
	QSPI1_IO2_MARK = 1487,
	SSI_SDATA7_B_MARK___4 = 1488,
	MSIOF0_SS1_A_MARK = 1489,
	DU1_DR6_MARK___3 = 1490,
	QSPI1_IO3_MARK = 1491,
	SSI_SDATA8_B_MARK___4 = 1492,
	MSIOF0_SS2_A_MARK = 1493,
	DU1_DR7_MARK___3 = 1494,
	QSPI1_SSL_MARK = 1495,
	HRX1_A_MARK = 1496,
	SCL4_A_MARK = 1497,
	PWM6_A_MARK = 1498,
	DU1_DG0_MARK___3 = 1499,
	RX0_A_MARK = 1500,
	HTX1_A_MARK = 1501,
	SDA4_A_MARK = 1502,
	DU1_DG1_MARK___3 = 1503,
	TX0_A_MARK = 1504,
	HCTS1_N_A_MARK = 1505,
	PWM2_A_MARK = 1506,
	DU1_DG2_MARK___3 = 1507,
	REMOCON_B_MARK___3 = 1508,
	HRTS1_N_A_MARK = 1509,
	DU1_DG3_MARK___3 = 1510,
	SSI_WS1_B_MARK___3 = 1511,
	IRQ1_MARK___6 = 1512,
	SD2_CLK_MARK___4 = 1513,
	HSCK1_MARK___3 = 1514,
	DU1_DG4_MARK___3 = 1515,
	SSI_SCK1_B_MARK___3 = 1516,
	SD2_CMD_MARK___4 = 1517,
	SCIF1_SCK_A_MARK = 1518,
	TCLK2_A_MARK = 1519,
	DU1_DG5_MARK___3 = 1520,
	SSI_SCK2_B_MARK___2 = 1521,
	PWM3_A_MARK = 1522,
	SD2_DAT0_MARK___2 = 1523,
	RX1_A_MARK = 1524,
	SCL1_E_MARK = 1525,
	DU1_DG6_MARK___3 = 1526,
	SSI_SDATA1_B_MARK___3 = 1527,
	SD2_DAT1_MARK___2 = 1528,
	TX1_A_MARK = 1529,
	SDA1_E_MARK = 1530,
	DU1_DG7_MARK___3 = 1531,
	SSI_WS2_B_MARK___2 = 1532,
	SD2_DAT2_MARK___2 = 1533,
	RX2_A_MARK = 1534,
	DU1_DB0_MARK___3 = 1535,
	SSI_SDATA2_B_MARK___2 = 1536,
	SD2_DAT3_MARK___2 = 1537,
	TX2_A_MARK = 1538,
	DU1_DB1_MARK___3 = 1539,
	SSI_WS9_B_MARK___3 = 1540,
	SD2_CD_MARK___4 = 1541,
	SCIF2_SCK_A_MARK = 1542,
	DU1_DB2_MARK___3 = 1543,
	SSI_SCK9_B_MARK___3 = 1544,
	SD2_WP_MARK___4 = 1545,
	SCIF3_SCK_MARK___3 = 1546,
	DU1_DB3_MARK___3 = 1547,
	SSI_SDATA9_B_MARK___3 = 1548,
	RX3_A_MARK = 1549,
	SCL1_C_MARK = 1550,
	MSIOF1_RXD_B_MARK___4 = 1551,
	DU1_DB4_MARK___3 = 1552,
	AUDIO_CLKA_C_MARK___2 = 1553,
	SSI_SDATA4_B_MARK___2 = 1554,
	TX3_A_MARK = 1555,
	SDA1_C_MARK = 1556,
	MSIOF1_TXD_B_MARK___4 = 1557,
	DU1_DB5_MARK___3 = 1558,
	AUDIO_CLKB_C_MARK___2 = 1559,
	SSI_WS4_B_MARK___2 = 1560,
	SCL2_A_MARK = 1561,
	MSIOF1_SCK_B_MARK___4 = 1562,
	DU1_DB6_MARK___3 = 1563,
	AUDIO_CLKC_C_MARK___2 = 1564,
	SSI_SCK4_B_MARK___2 = 1565,
	SDA2_A_MARK = 1566,
	MSIOF1_SYNC_B_MARK___3 = 1567,
	DU1_DB7_MARK___3 = 1568,
	AUDIO_CLKOUT_C_MARK___3 = 1569,
	SSI_SCK5_A_MARK = 1570,
	DU1_DOTCLKOUT1_MARK___3 = 1571,
	SSI_WS5_A_MARK = 1572,
	SCL3_C_MARK = 1573,
	DU1_DOTCLKIN_MARK___3 = 1574,
	SSI_SDATA5_A_MARK = 1575,
	SDA3_C_MARK = 1576,
	DU1_DOTCLKOUT0_MARK___3 = 1577,
	SSI_SCK6_A_MARK = 1578,
	DU1_EXODDF_DU1_ODDF_DISP_CDE_MARK___3 = 1579,
	SSI_WS6_A_MARK = 1580,
	SCL4_C_MARK = 1581,
	DU1_EXHSYNC_DU1_HSYNC_MARK___3 = 1582,
	SSI_SDATA6_A_MARK = 1583,
	SDA4_C_MARK = 1584,
	DU1_EXVSYNC_DU1_VSYNC_MARK___3 = 1585,
	SSI_SCK78_A_MARK = 1586,
	SDA4_E_MARK = 1587,
	DU1_DISP_MARK___3 = 1588,
	SSI_WS78_A_MARK = 1589,
	SCL4_E_MARK = 1590,
	DU1_CDE_MARK___3 = 1591,
	SSI_SDATA7_A_MARK = 1592,
	IRQ8_MARK___5 = 1593,
	AUDIO_CLKA_D_MARK___2 = 1594,
	CAN_CLK_D_MARK___3 = 1595,
	VI0_G5_MARK___4 = 1596,
	SSI_SCK0129_A_MARK = 1597,
	MSIOF1_RXD_A_MARK = 1598,
	RX5_D_MARK = 1599,
	VI0_G6_MARK___4 = 1600,
	SSI_WS0129_A_MARK = 1601,
	MSIOF1_TXD_A_MARK = 1602,
	TX5_D_MARK = 1603,
	VI0_G7_MARK___4 = 1604,
	SSI_SDATA0_A_MARK = 1605,
	MSIOF1_SYNC_A_MARK = 1606,
	PWM0_C_MARK = 1607,
	VI0_R0_MARK___4 = 1608,
	SSI_SCK34_MARK___4 = 1609,
	MSIOF1_SCK_A_MARK = 1610,
	AVB_MDC_MARK___4 = 1611,
	DACK1_MARK___5 = 1612,
	VI0_R1_MARK___4 = 1613,
	SSI_WS34_MARK___4 = 1614,
	MSIOF1_SS1_A_MARK = 1615,
	AVB_MDIO_MARK___4 = 1616,
	CAN1_RX_A_MARK = 1617,
	DREQ1_N_MARK___3 = 1618,
	VI0_R2_MARK___4 = 1619,
	SSI_SDATA3_MARK___4 = 1620,
	MSIOF1_SS2_A_MARK = 1621,
	AVB_LINK_MARK___4 = 1622,
	CAN1_TX_A_MARK = 1623,
	DREQ2_N_MARK___3 = 1624,
	VI0_R3_MARK___4 = 1625,
	SSI_SCK4_A_MARK = 1626,
	AVB_MAGIC_MARK___4 = 1627,
	VI0_R4_MARK___4 = 1628,
	SSI_WS4_A_MARK = 1629,
	AVB_PHY_INT_MARK___4 = 1630,
	VI0_R5_MARK___4 = 1631,
	SSI_SDATA4_A_MARK = 1632,
	AVB_CRS_MARK___4 = 1633,
	VI0_R6_MARK___4 = 1634,
	SSI_SCK1_A_MARK = 1635,
	SCIF1_SCK_B_MARK___3 = 1636,
	PWM1_D_MARK = 1637,
	IRQ9_MARK___4 = 1638,
	REMOCON_A_MARK = 1639,
	DACK2_MARK___4 = 1640,
	VI0_CLK_MARK___4 = 1641,
	AVB_COL_MARK___4 = 1642,
	SSI_SDATA8_A_MARK = 1643,
	RX1_B_MARK___3 = 1644,
	CAN0_RX_D_MARK___4 = 1645,
	AVB_AVTP_CAPTURE_B_MARK = 1646,
	VI0_R7_MARK___4 = 1647,
	SSI_WS1_A_MARK = 1648,
	TX1_B_MARK___3 = 1649,
	CAN0_TX_D_MARK___4 = 1650,
	AVB_AVTP_MATCH_B_MARK = 1651,
	VI0_DATA0_VI0_B0_MARK___4 = 1652,
	SSI_SDATA1_A_MARK = 1653,
	HRX1_B_MARK___3 = 1654,
	VI0_DATA1_VI0_B1_MARK___4 = 1655,
	SSI_SCK2_A_MARK = 1656,
	HTX1_B_MARK___3 = 1657,
	AVB_TXD7_MARK___4 = 1658,
	VI0_DATA2_VI0_B2_MARK___4 = 1659,
	SSI_WS2_A_MARK = 1660,
	HCTS1_N_B_MARK___2 = 1661,
	AVB_TX_ER_MARK___4 = 1662,
	VI0_DATA3_VI0_B3_MARK___4 = 1663,
	SSI_SDATA2_A_MARK = 1664,
	HRTS1_N_B_MARK___2 = 1665,
	VI0_DATA4_VI0_B4_MARK___4 = 1666,
	SSI_SCK9_A_MARK = 1667,
	RX2_B_MARK___3 = 1668,
	SCL3_E_MARK = 1669,
	EX_WAIT1_MARK___4 = 1670,
	VI0_DATA5_VI0_B5_MARK___4 = 1671,
	SSI_WS9_A_MARK = 1672,
	TX2_B_MARK___3 = 1673,
	SDA3_E_MARK = 1674,
	VI0_DATA6_VI0_B6_MARK___4 = 1675,
	SSI_SDATA9_A_MARK = 1676,
	SCIF2_SCK_B_MARK___3 = 1677,
	PWM2_D_MARK = 1678,
	VI0_DATA7_VI0_B7_MARK___4 = 1679,
	AUDIO_CLKA_A_MARK = 1680,
	SCL0_B_MARK = 1681,
	VI0_CLKENB_MARK___4 = 1682,
	AUDIO_CLKB_A_MARK = 1683,
	SDA0_B_MARK = 1684,
	VI0_FIELD_MARK___4 = 1685,
	AUDIO_CLKC_A_MARK = 1686,
	SCL4_B_MARK = 1687,
	VI0_HSYNC_N_MARK___4 = 1688,
	AUDIO_CLKOUT_A_MARK = 1689,
	SDA4_B_MARK = 1690,
	VI0_VSYNC_N_MARK___4 = 1691,
	PINMUX_MARK_END___7 = 1692,
};

enum {
	PINMUX_RESERVED___8 = 0,
	PINMUX_DATA_BEGIN___8 = 1,
	GP_0_0_DATA___5 = 2,
	GP_0_1_DATA___5 = 3,
	GP_0_2_DATA___5 = 4,
	GP_0_3_DATA___5 = 5,
	GP_0_4_DATA___5 = 6,
	GP_0_5_DATA___5 = 7,
	GP_0_6_DATA___5 = 8,
	GP_0_7_DATA___5 = 9,
	GP_0_8_DATA___5 = 10,
	GP_0_9_DATA___5 = 11,
	GP_0_10_DATA___5 = 12,
	GP_0_11_DATA___5 = 13,
	GP_0_12_DATA___5 = 14,
	GP_0_13_DATA___5 = 15,
	GP_0_14_DATA___5 = 16,
	GP_0_15_DATA___5 = 17,
	GP_0_16_DATA___5 = 18,
	GP_0_17_DATA___5 = 19,
	GP_0_18_DATA___5 = 20,
	GP_0_19_DATA___5 = 21,
	GP_0_20_DATA___5 = 22,
	GP_0_21_DATA___5 = 23,
	GP_0_22_DATA___5 = 24,
	GP_0_23_DATA___4 = 25,
	GP_0_24_DATA___4 = 26,
	GP_0_25_DATA___4 = 27,
	GP_0_26_DATA___4 = 28,
	GP_0_27_DATA___4 = 29,
	GP_0_28_DATA___4 = 30,
	GP_0_29_DATA___4 = 31,
	GP_0_30_DATA___4 = 32,
	GP_0_31_DATA___4 = 33,
	GP_1_0_DATA___5 = 34,
	GP_1_1_DATA___5 = 35,
	GP_1_2_DATA___5 = 36,
	GP_1_3_DATA___5 = 37,
	GP_1_4_DATA___5 = 38,
	GP_1_5_DATA___5 = 39,
	GP_1_6_DATA___5 = 40,
	GP_1_7_DATA___5 = 41,
	GP_1_8_DATA___5 = 42,
	GP_1_9_DATA___5 = 43,
	GP_1_10_DATA___5 = 44,
	GP_1_11_DATA___5 = 45,
	GP_1_12_DATA___5 = 46,
	GP_1_13_DATA___5 = 47,
	GP_1_14_DATA___5 = 48,
	GP_1_15_DATA___5 = 49,
	GP_1_16_DATA___5 = 50,
	GP_1_17_DATA___5 = 51,
	GP_1_18_DATA___5 = 52,
	GP_1_19_DATA___5 = 53,
	GP_1_20_DATA___5 = 54,
	GP_1_21_DATA___5 = 55,
	GP_1_22_DATA___5 = 56,
	GP_1_23_DATA___4 = 57,
	GP_1_24_DATA___4 = 58,
	GP_1_25_DATA___4 = 59,
	GP_1_26_DATA___2 = 60,
	GP_1_27_DATA___2 = 61,
	GP_1_28_DATA___2 = 62,
	GP_1_29_DATA___2 = 63,
	GP_1_30_DATA = 64,
	GP_1_31_DATA = 65,
	GP_2_0_DATA___5 = 66,
	GP_2_1_DATA___5 = 67,
	GP_2_2_DATA___5 = 68,
	GP_2_3_DATA___5 = 69,
	GP_2_4_DATA___5 = 70,
	GP_2_5_DATA___5 = 71,
	GP_2_6_DATA___5 = 72,
	GP_2_7_DATA___5 = 73,
	GP_2_8_DATA___5 = 74,
	GP_2_9_DATA___5 = 75,
	GP_2_10_DATA___5 = 76,
	GP_2_11_DATA___5 = 77,
	GP_2_12_DATA___5 = 78,
	GP_2_13_DATA___5 = 79,
	GP_2_14_DATA___5 = 80,
	GP_2_15_DATA___5 = 81,
	GP_2_16_DATA___5 = 82,
	GP_2_17_DATA___5 = 83,
	GP_2_18_DATA___5 = 84,
	GP_2_19_DATA___5 = 85,
	GP_2_20_DATA___5 = 86,
	GP_2_21_DATA___5 = 87,
	GP_2_22_DATA___5 = 88,
	GP_2_23_DATA___5 = 89,
	GP_2_24_DATA___5 = 90,
	GP_2_25_DATA___5 = 91,
	GP_2_26_DATA___5 = 92,
	GP_2_27_DATA___5 = 93,
	GP_2_28_DATA___5 = 94,
	GP_2_29_DATA___5 = 95,
	GP_2_30_DATA___4 = 96,
	GP_2_31_DATA___4 = 97,
	GP_3_0_DATA___5 = 98,
	GP_3_1_DATA___5 = 99,
	GP_3_2_DATA___5 = 100,
	GP_3_3_DATA___5 = 101,
	GP_3_4_DATA___5 = 102,
	GP_3_5_DATA___5 = 103,
	GP_3_6_DATA___5 = 104,
	GP_3_7_DATA___5 = 105,
	GP_3_8_DATA___5 = 106,
	GP_3_9_DATA___5 = 107,
	GP_3_10_DATA___5 = 108,
	GP_3_11_DATA___5 = 109,
	GP_3_12_DATA___5 = 110,
	GP_3_13_DATA___5 = 111,
	GP_3_14_DATA___5 = 112,
	GP_3_15_DATA___5 = 113,
	GP_3_16_DATA___5 = 114,
	GP_3_17_DATA___4 = 115,
	GP_3_18_DATA___4 = 116,
	GP_3_19_DATA___4 = 117,
	GP_3_20_DATA___4 = 118,
	GP_3_21_DATA___4 = 119,
	GP_3_22_DATA___4 = 120,
	GP_3_23_DATA___4 = 121,
	GP_3_24_DATA___4 = 122,
	GP_3_25_DATA___4 = 123,
	GP_3_26_DATA___4 = 124,
	GP_3_27_DATA___5 = 125,
	GP_3_28_DATA___5 = 126,
	GP_3_29_DATA___5 = 127,
	GP_3_30_DATA___4 = 128,
	GP_3_31_DATA___4 = 129,
	GP_4_0_DATA___5 = 130,
	GP_4_1_DATA___5 = 131,
	GP_4_2_DATA___5 = 132,
	GP_4_3_DATA___5 = 133,
	GP_4_4_DATA___5 = 134,
	GP_4_5_DATA___5 = 135,
	GP_4_6_DATA___5 = 136,
	GP_4_7_DATA___5 = 137,
	GP_4_8_DATA___5 = 138,
	GP_4_9_DATA___5 = 139,
	GP_4_10_DATA___5 = 140,
	GP_4_11_DATA___5 = 141,
	GP_4_12_DATA___5 = 142,
	GP_4_13_DATA___5 = 143,
	GP_4_14_DATA___5 = 144,
	GP_4_15_DATA___5 = 145,
	GP_4_16_DATA___5 = 146,
	GP_4_17_DATA___5 = 147,
	GP_4_18_DATA___5 = 148,
	GP_4_19_DATA___5 = 149,
	GP_4_20_DATA___5 = 150,
	GP_4_21_DATA___5 = 151,
	GP_4_22_DATA___5 = 152,
	GP_4_23_DATA___5 = 153,
	GP_4_24_DATA___5 = 154,
	GP_4_25_DATA___5 = 155,
	GP_4_26_DATA___4 = 156,
	PINMUX_DATA_END___8 = 157,
	PINMUX_FUNCTION_BEGIN___8 = 158,
	GP_0_0_FN___5 = 159,
	GP_0_1_FN___5 = 160,
	GP_0_2_FN___5 = 161,
	GP_0_3_FN___5 = 162,
	GP_0_4_FN___5 = 163,
	GP_0_5_FN___5 = 164,
	GP_0_6_FN___5 = 165,
	GP_0_7_FN___5 = 166,
	GP_0_8_FN___5 = 167,
	GP_0_9_FN___5 = 168,
	GP_0_10_FN___5 = 169,
	GP_0_11_FN___5 = 170,
	GP_0_12_FN___5 = 171,
	GP_0_13_FN___5 = 172,
	GP_0_14_FN___5 = 173,
	GP_0_15_FN___5 = 174,
	GP_0_16_FN___5 = 175,
	GP_0_17_FN___5 = 176,
	GP_0_18_FN___5 = 177,
	GP_0_19_FN___5 = 178,
	GP_0_20_FN___5 = 179,
	GP_0_21_FN___5 = 180,
	GP_0_22_FN___5 = 181,
	GP_0_23_FN___4 = 182,
	GP_0_24_FN___4 = 183,
	GP_0_25_FN___4 = 184,
	GP_0_26_FN___4 = 185,
	GP_0_27_FN___4 = 186,
	GP_0_28_FN___4 = 187,
	GP_0_29_FN___4 = 188,
	GP_0_30_FN___4 = 189,
	GP_0_31_FN___4 = 190,
	GP_1_0_FN___5 = 191,
	GP_1_1_FN___5 = 192,
	GP_1_2_FN___5 = 193,
	GP_1_3_FN___5 = 194,
	GP_1_4_FN___5 = 195,
	GP_1_5_FN___5 = 196,
	GP_1_6_FN___5 = 197,
	GP_1_7_FN___5 = 198,
	GP_1_8_FN___5 = 199,
	GP_1_9_FN___5 = 200,
	GP_1_10_FN___5 = 201,
	GP_1_11_FN___5 = 202,
	GP_1_12_FN___5 = 203,
	GP_1_13_FN___5 = 204,
	GP_1_14_FN___5 = 205,
	GP_1_15_FN___5 = 206,
	GP_1_16_FN___5 = 207,
	GP_1_17_FN___5 = 208,
	GP_1_18_FN___5 = 209,
	GP_1_19_FN___5 = 210,
	GP_1_20_FN___5 = 211,
	GP_1_21_FN___5 = 212,
	GP_1_22_FN___5 = 213,
	GP_1_23_FN___4 = 214,
	GP_1_24_FN___4 = 215,
	GP_1_25_FN___4 = 216,
	GP_1_26_FN___2 = 217,
	GP_1_27_FN___2 = 218,
	GP_1_28_FN___2 = 219,
	GP_1_29_FN___2 = 220,
	GP_1_30_FN = 221,
	GP_1_31_FN = 222,
	GP_2_0_FN___5 = 223,
	GP_2_1_FN___5 = 224,
	GP_2_2_FN___5 = 225,
	GP_2_3_FN___5 = 226,
	GP_2_4_FN___5 = 227,
	GP_2_5_FN___5 = 228,
	GP_2_6_FN___5 = 229,
	GP_2_7_FN___5 = 230,
	GP_2_8_FN___5 = 231,
	GP_2_9_FN___5 = 232,
	GP_2_10_FN___5 = 233,
	GP_2_11_FN___5 = 234,
	GP_2_12_FN___5 = 235,
	GP_2_13_FN___5 = 236,
	GP_2_14_FN___5 = 237,
	GP_2_15_FN___5 = 238,
	GP_2_16_FN___5 = 239,
	GP_2_17_FN___5 = 240,
	GP_2_18_FN___5 = 241,
	GP_2_19_FN___5 = 242,
	GP_2_20_FN___5 = 243,
	GP_2_21_FN___5 = 244,
	GP_2_22_FN___5 = 245,
	GP_2_23_FN___5 = 246,
	GP_2_24_FN___5 = 247,
	GP_2_25_FN___5 = 248,
	GP_2_26_FN___5 = 249,
	GP_2_27_FN___5 = 250,
	GP_2_28_FN___5 = 251,
	GP_2_29_FN___5 = 252,
	GP_2_30_FN___4 = 253,
	GP_2_31_FN___4 = 254,
	GP_3_0_FN___5 = 255,
	GP_3_1_FN___5 = 256,
	GP_3_2_FN___5 = 257,
	GP_3_3_FN___5 = 258,
	GP_3_4_FN___5 = 259,
	GP_3_5_FN___5 = 260,
	GP_3_6_FN___5 = 261,
	GP_3_7_FN___5 = 262,
	GP_3_8_FN___5 = 263,
	GP_3_9_FN___5 = 264,
	GP_3_10_FN___5 = 265,
	GP_3_11_FN___5 = 266,
	GP_3_12_FN___5 = 267,
	GP_3_13_FN___5 = 268,
	GP_3_14_FN___5 = 269,
	GP_3_15_FN___5 = 270,
	GP_3_16_FN___5 = 271,
	GP_3_17_FN___4 = 272,
	GP_3_18_FN___4 = 273,
	GP_3_19_FN___4 = 274,
	GP_3_20_FN___4 = 275,
	GP_3_21_FN___4 = 276,
	GP_3_22_FN___4 = 277,
	GP_3_23_FN___4 = 278,
	GP_3_24_FN___4 = 279,
	GP_3_25_FN___4 = 280,
	GP_3_26_FN___4 = 281,
	GP_3_27_FN___5 = 282,
	GP_3_28_FN___5 = 283,
	GP_3_29_FN___5 = 284,
	GP_3_30_FN___4 = 285,
	GP_3_31_FN___4 = 286,
	GP_4_0_FN___5 = 287,
	GP_4_1_FN___5 = 288,
	GP_4_2_FN___5 = 289,
	GP_4_3_FN___5 = 290,
	GP_4_4_FN___5 = 291,
	GP_4_5_FN___5 = 292,
	GP_4_6_FN___5 = 293,
	GP_4_7_FN___5 = 294,
	GP_4_8_FN___5 = 295,
	GP_4_9_FN___5 = 296,
	GP_4_10_FN___5 = 297,
	GP_4_11_FN___5 = 298,
	GP_4_12_FN___5 = 299,
	GP_4_13_FN___5 = 300,
	GP_4_14_FN___5 = 301,
	GP_4_15_FN___5 = 302,
	GP_4_16_FN___5 = 303,
	GP_4_17_FN___5 = 304,
	GP_4_18_FN___5 = 305,
	GP_4_19_FN___5 = 306,
	GP_4_20_FN___5 = 307,
	GP_4_21_FN___5 = 308,
	GP_4_22_FN___5 = 309,
	GP_4_23_FN___5 = 310,
	GP_4_24_FN___5 = 311,
	GP_4_25_FN___5 = 312,
	GP_4_26_FN___4 = 313,
	FN_IP0_1_0 = 314,
	FN_PENC0 = 315,
	FN_PENC1 = 316,
	FN_IP0_4_2 = 317,
	FN_IP0_7_5 = 318,
	FN_IP0_11_8___2 = 319,
	FN_IP0_14_12 = 320,
	FN_A1___5 = 321,
	FN_A2___5 = 322,
	FN_A3___5 = 323,
	FN_IP0_15___3 = 324,
	FN_IP0_16___2 = 325,
	FN_IP0_17___2 = 326,
	FN_IP0_18 = 327,
	FN_IP0_19 = 328,
	FN_IP0_20 = 329,
	FN_IP0_21 = 330,
	FN_IP0_22 = 331,
	FN_IP0_23 = 332,
	FN_IP0_24___2 = 333,
	FN_IP0_25___2 = 334,
	FN_IP0_26 = 335,
	FN_IP0_27 = 336,
	FN_IP0_28 = 337,
	FN_IP0_29 = 338,
	FN_IP0_30 = 339,
	FN_IP1_0 = 340,
	FN_IP1_1 = 341,
	FN_IP1_4_2 = 342,
	FN_IP1_7_5 = 343,
	FN_IP1_10_8___3 = 344,
	FN_IP1_14_11 = 345,
	FN_IP1_23_21 = 346,
	FN_WE0 = 347,
	FN_IP1_24___2 = 348,
	FN_IP1_27_25 = 349,
	FN_IP1_29_28___3 = 350,
	FN_IP2_2_0___3 = 351,
	FN_IP2_5_3___2 = 352,
	FN_IP2_8_6___2 = 353,
	FN_IP2_11_9___2 = 354,
	FN_IP2_13_12___2 = 355,
	FN_IP2_16_14 = 356,
	FN_IP2_17 = 357,
	FN_IP2_30 = 358,
	FN_IP2_31 = 359,
	FN_IP3_1_0___2 = 360,
	FN_IP3_4_2 = 361,
	FN_IP3_7_5 = 362,
	FN_IP3_9_8___2 = 363,
	FN_IP3_12_10 = 364,
	FN_IP3_15_13 = 365,
	FN_IP3_18_16 = 366,
	FN_IP3_20_19 = 367,
	FN_IP3_23_21___2 = 368,
	FN_IP3_26_24___2 = 369,
	FN_IP3_27 = 370,
	FN_IP3_28 = 371,
	FN_IP3_29 = 372,
	FN_IP3_30___2 = 373,
	FN_IP3_31___2 = 374,
	FN_IP4_0 = 375,
	FN_IP4_3_1 = 376,
	FN_IP4_6_4 = 377,
	FN_IP4_7 = 378,
	FN_IP4_8 = 379,
	FN_IP4_10_9 = 380,
	FN_IP4_12_11 = 381,
	FN_IP4_14_13 = 382,
	FN_IP4_16_15 = 383,
	FN_IP4_20_17 = 384,
	FN_IP4_24_21 = 385,
	FN_IP4_26_25 = 386,
	FN_IP4_28_27 = 387,
	FN_IP4_30_29 = 388,
	FN_IP5_1_0___2 = 389,
	FN_IP5_3_2___2 = 390,
	FN_IP5_5_4___2 = 391,
	FN_IP5_6 = 392,
	FN_IP5_7 = 393,
	FN_IP5_9_8 = 394,
	FN_IP5_11_10 = 395,
	FN_IP5_12 = 396,
	FN_IP5_14_13___2 = 397,
	FN_IP5_17_15___2 = 398,
	FN_IP5_20_18___2 = 399,
	FN_AUDIO_CLKA___4 = 400,
	FN_AUDIO_CLKB___4 = 401,
	FN_IP5_22_21 = 402,
	FN_IP5_25_23 = 403,
	FN_IP5_28_26___2 = 404,
	FN_IP5_30_29 = 405,
	FN_IP6_1_0___2 = 406,
	FN_IP6_4_2 = 407,
	FN_IP6_6_5 = 408,
	FN_IP6_7 = 409,
	FN_IP6_8___2 = 410,
	FN_IP6_9___2 = 411,
	FN_SSI_SCK34___5 = 412,
	FN_IP6_10___2 = 413,
	FN_IP6_12_11 = 414,
	FN_IP6_13___2 = 415,
	FN_IP6_15_14___2 = 416,
	FN_IP6_16___2 = 417,
	FN_IP6_18_17 = 418,
	FN_IP6_20_19___2 = 419,
	FN_IP6_21 = 420,
	FN_IP6_23_22 = 421,
	FN_IP6_25_24 = 422,
	FN_IP6_27_26 = 423,
	FN_IP6_29_28 = 424,
	FN_IP6_31_30 = 425,
	FN_IP7_1_0 = 426,
	FN_IP7_3_2 = 427,
	FN_IP7_5_4 = 428,
	FN_IP7_8_6___3 = 429,
	FN_IP7_11_9___2 = 430,
	FN_IP7_14_12___2 = 431,
	FN_IP7_17_15___2 = 432,
	FN_IP7_20_18___2 = 433,
	FN_IP7_21 = 434,
	FN_IP7_24_22___2 = 435,
	FN_IP7_28_25 = 436,
	FN_IP7_31_29 = 437,
	FN_IP8_2_0___3 = 438,
	FN_IP8_5_3___3 = 439,
	FN_IP8_8_6___3 = 440,
	FN_IP8_10_9 = 441,
	FN_IP8_13_11 = 442,
	FN_IP8_15_14___2 = 443,
	FN_IP8_18_16 = 444,
	FN_IP8_21_19 = 445,
	FN_IP8_23_22___2 = 446,
	FN_IP8_26_24 = 447,
	FN_IP8_29_27 = 448,
	FN_IP9_2_0___3 = 449,
	FN_IP9_5_3___3 = 450,
	FN_IP9_8_6___2 = 451,
	FN_IP9_11_9___2 = 452,
	FN_IP9_14_12___2 = 453,
	FN_IP9_17_15 = 454,
	FN_IP9_20_18 = 455,
	FN_IP9_23_21 = 456,
	FN_IP9_26_24 = 457,
	FN_IP9_29_27 = 458,
	FN_IP10_2_0___3 = 459,
	FN_IP10_5_3___3 = 460,
	FN_IP10_8_6___3 = 461,
	FN_IP10_12_9 = 462,
	FN_IP10_15_13 = 463,
	FN_IP10_18_16 = 464,
	FN_IP10_21_19___2 = 465,
	FN_IP10_24_22___2 = 466,
	FN_AVS1___2 = 467,
	FN_AVS2___2 = 468,
	FN_PRESETOUT = 469,
	FN_PWM1___4 = 470,
	FN_AUDATA0 = 471,
	FN_ARM_TRACEDATA_0 = 472,
	FN_GPSCLK_C = 473,
	FN_USB_OVC0 = 474,
	FN_TX2_E___2 = 475,
	FN_SDA2_B___2 = 476,
	FN_AUDATA1 = 477,
	FN_ARM_TRACEDATA_1 = 478,
	FN_GPSIN_C = 479,
	FN_USB_OVC1 = 480,
	FN_RX2_E___2 = 481,
	FN_SCL2_B___2 = 482,
	FN_SD1_DAT2_A = 483,
	FN_MMC_D2___3 = 484,
	FN_BS = 485,
	FN_ATADIR0_A = 486,
	FN_SDSELF_A = 487,
	FN_PWM4_B___4 = 488,
	FN_SD1_DAT3_A = 489,
	FN_MMC_D3___3 = 490,
	FN_A0___5 = 491,
	FN_ATAG0_A = 492,
	FN_REMOCON_B___4 = 493,
	FN_A4___5 = 494,
	FN_A5___5 = 495,
	FN_A6___5 = 496,
	FN_A7___5 = 497,
	FN_A8___5 = 498,
	FN_A9___5 = 499,
	FN_A10___5 = 500,
	FN_A11___5 = 501,
	FN_A12___5 = 502,
	FN_A13___5 = 503,
	FN_A14___5 = 504,
	FN_A15___5 = 505,
	FN_A16___5 = 506,
	FN_A17___5 = 507,
	FN_A18___5 = 508,
	FN_A19___5 = 509,
	FN_A20___5 = 510,
	FN_HSPI_CS1_B = 511,
	FN_A21___5 = 512,
	FN_HSPI_CLK1_B = 513,
	FN_A22___5 = 514,
	FN_HRTS0_B = 515,
	FN_RX2_B___4 = 516,
	FN_DREQ2_A = 517,
	FN_A23___5 = 518,
	FN_HTX0_B___4 = 519,
	FN_TX2_B___4 = 520,
	FN_DACK2_A = 521,
	FN_TS_SDEN0_A = 522,
	FN_SD1_CD_A = 523,
	FN_MMC_D6___3 = 524,
	FN_A24___5 = 525,
	FN_DREQ1_A = 526,
	FN_HRX0_B___4 = 527,
	FN_TS_SPSYNC0_A = 528,
	FN_SD1_WP_A = 529,
	FN_MMC_D7___3 = 530,
	FN_A25___5 = 531,
	FN_DACK1_A = 532,
	FN_HCTS0_B = 533,
	FN_RX3_C___3 = 534,
	FN_TS_SDAT0_A = 535,
	FN_CLKOUT___2 = 536,
	FN_HSPI_TX1_B = 537,
	FN_PWM0_B___5 = 538,
	FN_CS0 = 539,
	FN_HSPI_RX1_B = 540,
	FN_SSI_SCK1_B___4 = 541,
	FN_ATAG0_B = 542,
	FN_CS1_A26 = 543,
	FN_SDA2_A___2 = 544,
	FN_SCK2_B = 545,
	FN_MMC_D5___3 = 546,
	FN_ATADIR0_B = 547,
	FN_RD_WR = 548,
	FN_WE1 = 549,
	FN_ATAWR0_B = 550,
	FN_SSI_WS1_B___4 = 551,
	FN_EX_CS0 = 552,
	FN_SCL2_A___2 = 553,
	FN_TX3_C___3 = 554,
	FN_TS_SCK0_A = 555,
	FN_EX_CS1 = 556,
	FN_MMC_D4___3 = 557,
	FN_SD1_CLK_A = 558,
	FN_MMC_CLK___3 = 559,
	FN_ATACS00 = 560,
	FN_EX_CS2 = 561,
	FN_SD1_CMD_A = 562,
	FN_MMC_CMD___3 = 563,
	FN_ATACS10 = 564,
	FN_EX_CS3 = 565,
	FN_SD1_DAT0_A = 566,
	FN_MMC_D0___3 = 567,
	FN_ATARD0 = 568,
	FN_EX_CS4 = 569,
	FN_EX_WAIT1_A = 570,
	FN_SD1_DAT1_A = 571,
	FN_MMC_D1___3 = 572,
	FN_ATAWR0_A = 573,
	FN_EX_CS5 = 574,
	FN_EX_WAIT2_A = 575,
	FN_DREQ0_A = 576,
	FN_RX3_A___2 = 577,
	FN_DACK0___5 = 578,
	FN_TX3_A___2 = 579,
	FN_DRACK0___5 = 580,
	FN_EX_WAIT0___5 = 581,
	FN_PWM0_C___2 = 582,
	FN_D0___5 = 583,
	FN_D1___5 = 584,
	FN_D2___5 = 585,
	FN_D3___5 = 586,
	FN_D4___5 = 587,
	FN_D5___5 = 588,
	FN_D6___5 = 589,
	FN_D7___5 = 590,
	FN_D8___5 = 591,
	FN_D9___5 = 592,
	FN_D10___5 = 593,
	FN_D11___5 = 594,
	FN_RD_WR_B = 595,
	FN_IRQ0___5 = 596,
	FN_MLB_CLK___4 = 597,
	FN_IRQ1_A = 598,
	FN_MLB_SIG___4 = 599,
	FN_RX5_B___3 = 600,
	FN_SDA3_A___2 = 601,
	FN_IRQ2_A = 602,
	FN_MLB_DAT___4 = 603,
	FN_TX5_B___3 = 604,
	FN_SCL3_A___2 = 605,
	FN_IRQ3_A = 606,
	FN_SDSELF_B = 607,
	FN_SD1_CMD_B = 608,
	FN_SCIF_CLK___4 = 609,
	FN_AUDIO_CLKOUT_B___4 = 610,
	FN_CAN_CLK_B___5 = 611,
	FN_SDA3_B___2 = 612,
	FN_SD1_CLK_B = 613,
	FN_HTX0_A___2 = 614,
	FN_TX0_A___2 = 615,
	FN_SD1_DAT0_B = 616,
	FN_HRX0_A___2 = 617,
	FN_RX0_A___2 = 618,
	FN_SD1_DAT1_B = 619,
	FN_HSCK0___4 = 620,
	FN_SCK0___2 = 621,
	FN_SCL3_B___2 = 622,
	FN_SD1_DAT2_B = 623,
	FN_HCTS0_A = 624,
	FN_CTS0 = 625,
	FN_SD1_DAT3_B = 626,
	FN_HRTS0_A = 627,
	FN_RTS0 = 628,
	FN_SSI_SCK4___4 = 629,
	FN_DU0_DR0___3 = 630,
	FN_LCDOUT0___4 = 631,
	FN_AUDATA2 = 632,
	FN_ARM_TRACEDATA_2 = 633,
	FN_SDA3_C___2 = 634,
	FN_ADICHS1___4 = 635,
	FN_TS_SDEN0_B___3 = 636,
	FN_SSI_WS4___4 = 637,
	FN_DU0_DR1___3 = 638,
	FN_LCDOUT1___4 = 639,
	FN_AUDATA3 = 640,
	FN_ARM_TRACEDATA_3 = 641,
	FN_SCL3_C___2 = 642,
	FN_ADICHS2___4 = 643,
	FN_TS_SPSYNC0_B___3 = 644,
	FN_DU0_DR2___3 = 645,
	FN_LCDOUT2___4 = 646,
	FN_DU0_DR3___3 = 647,
	FN_LCDOUT3___4 = 648,
	FN_DU0_DR4___3 = 649,
	FN_LCDOUT4___4 = 650,
	FN_DU0_DR5___3 = 651,
	FN_LCDOUT5___4 = 652,
	FN_DU0_DR6___3 = 653,
	FN_LCDOUT6___4 = 654,
	FN_DU0_DR7___3 = 655,
	FN_LCDOUT7___4 = 656,
	FN_DU0_DG0___3 = 657,
	FN_LCDOUT8___4 = 658,
	FN_AUDATA4 = 659,
	FN_ARM_TRACEDATA_4 = 660,
	FN_TX1_D___4 = 661,
	FN_CAN0_TX_A___2 = 662,
	FN_ADICHS0___4 = 663,
	FN_DU0_DG1___3 = 664,
	FN_LCDOUT9___4 = 665,
	FN_AUDATA5 = 666,
	FN_ARM_TRACEDATA_5 = 667,
	FN_RX1_D___4 = 668,
	FN_CAN0_RX_A___2 = 669,
	FN_ADIDATA___4 = 670,
	FN_DU0_DG2___3 = 671,
	FN_LCDOUT10___4 = 672,
	FN_DU0_DG3___3 = 673,
	FN_LCDOUT11___4 = 674,
	FN_DU0_DG4___3 = 675,
	FN_LCDOUT12___4 = 676,
	FN_RX0_B___4 = 677,
	FN_DU0_DG5___3 = 678,
	FN_LCDOUT13___4 = 679,
	FN_TX0_B___4 = 680,
	FN_DU0_DG6___3 = 681,
	FN_LCDOUT14___4 = 682,
	FN_RX4_A___2 = 683,
	FN_DU0_DG7___3 = 684,
	FN_LCDOUT15___4 = 685,
	FN_TX4_A___2 = 686,
	FN_SSI_SCK2_B___3 = 687,
	FN_VI0_R0_B___2 = 688,
	FN_DU0_DB0___3 = 689,
	FN_LCDOUT16___4 = 690,
	FN_AUDATA6 = 691,
	FN_ARM_TRACEDATA_6 = 692,
	FN_GPSCLK_A = 693,
	FN_PWM0_A___2 = 694,
	FN_ADICLK___4 = 695,
	FN_TS_SDAT0_B___2 = 696,
	FN_AUDIO_CLKC___4 = 697,
	FN_VI0_R1_B___2 = 698,
	FN_DU0_DB1___3 = 699,
	FN_LCDOUT17___4 = 700,
	FN_AUDATA7 = 701,
	FN_ARM_TRACEDATA_7 = 702,
	FN_GPSIN_A = 703,
	FN_ADICS_SAMP___4 = 704,
	FN_TS_SCK0_B___3 = 705,
	FN_VI0_R2_B___2 = 706,
	FN_DU0_DB2___3 = 707,
	FN_LCDOUT18___4 = 708,
	FN_VI0_R3_B___2 = 709,
	FN_DU0_DB3___3 = 710,
	FN_LCDOUT19___4 = 711,
	FN_VI0_R4_B___2 = 712,
	FN_DU0_DB4___3 = 713,
	FN_LCDOUT20___4 = 714,
	FN_VI0_R5_B___2 = 715,
	FN_DU0_DB5___3 = 716,
	FN_LCDOUT21___4 = 717,
	FN_VI1_DATA10_B = 718,
	FN_DU0_DB6___3 = 719,
	FN_LCDOUT22___4 = 720,
	FN_VI1_DATA11_B = 721,
	FN_DU0_DB7___3 = 722,
	FN_LCDOUT23___4 = 723,
	FN_DU0_DOTCLKIN___4 = 724,
	FN_QSTVA_QVS___4 = 725,
	FN_DU0_DOTCLKO_UT0 = 726,
	FN_QCLK___4 = 727,
	FN_DU0_DOTCLKO_UT1 = 728,
	FN_QSTVB_QVE___4 = 729,
	FN_AUDIO_CLKOUT_A___2 = 730,
	FN_REMOCON_C = 731,
	FN_SSI_WS2_B___3 = 732,
	FN_DU0_EXHSYNC_DU0_HSYNC___3 = 733,
	FN_QSTH_QHS___4 = 734,
	FN_DU0_EXVSYNC_DU0_VSYNC___3 = 735,
	FN_QSTB_QHE___4 = 736,
	FN_DU0_EXODDF_DU0_ODDF_DISP_CDE___3 = 737,
	FN_QCPV_QDE___4 = 738,
	FN_FMCLK_D___3 = 739,
	FN_SSI_SCK1_A___2 = 740,
	FN_DU0_DISP___3 = 741,
	FN_QPOLA___4 = 742,
	FN_AUDCK = 743,
	FN_ARM_TRACECLK = 744,
	FN_BPFCLK_D___4 = 745,
	FN_SSI_WS1_A___2 = 746,
	FN_DU0_CDE___3 = 747,
	FN_QPOLB___4 = 748,
	FN_AUDSYNC = 749,
	FN_ARM_TRACECTL = 750,
	FN_FMIN_D___4 = 751,
	FN_SD1_CD_B = 752,
	FN_SSI_SCK78___4 = 753,
	FN_HSPI_RX0_B = 754,
	FN_TX1_B___4 = 755,
	FN_SD1_WP_B = 756,
	FN_SSI_WS78___4 = 757,
	FN_HSPI_CLK0_B = 758,
	FN_RX1_B___4 = 759,
	FN_CAN_CLK_D___4 = 760,
	FN_SSI_SDATA8___4 = 761,
	FN_SSI_SCK2_A___2 = 762,
	FN_HSPI_CS0_B = 763,
	FN_TX2_A___2 = 764,
	FN_CAN0_TX_B___5 = 765,
	FN_SSI_SDATA7___4 = 766,
	FN_HSPI_TX0_B = 767,
	FN_RX2_A___2 = 768,
	FN_CAN0_RX_B___5 = 769,
	FN_SSI_SCK6___4 = 770,
	FN_HSPI_RX2_A = 771,
	FN_FMCLK_B___4 = 772,
	FN_CAN1_TX_B___5 = 773,
	FN_SSI_WS6___4 = 774,
	FN_HSPI_CLK2_A = 775,
	FN_BPFCLK_B___4 = 776,
	FN_CAN1_RX_B___5 = 777,
	FN_SSI_SDATA6___4 = 778,
	FN_HSPI_TX2_A = 779,
	FN_FMIN_B___4 = 780,
	FN_SSI_SCK5___4 = 781,
	FN_RX4_C___3 = 782,
	FN_SSI_WS5___4 = 783,
	FN_TX4_C___3 = 784,
	FN_SSI_SDATA5___4 = 785,
	FN_RX0_D___3 = 786,
	FN_SSI_WS34___5 = 787,
	FN_ARM_TRACEDATA_8 = 788,
	FN_SSI_SDATA4___4 = 789,
	FN_SSI_WS2_A___2 = 790,
	FN_ARM_TRACEDATA_9 = 791,
	FN_SSI_SDATA3___5 = 792,
	FN_ARM_TRACEDATA_10 = 793,
	FN_SSI_SCK012 = 794,
	FN_ARM_TRACEDATA_11 = 795,
	FN_TX0_D___3 = 796,
	FN_SSI_WS012 = 797,
	FN_ARM_TRACEDATA_12 = 798,
	FN_SSI_SDATA2___4 = 799,
	FN_HSPI_CS2_A = 800,
	FN_ARM_TRACEDATA_13 = 801,
	FN_SDA1_A___2 = 802,
	FN_SSI_SDATA1___4 = 803,
	FN_ARM_TRACEDATA_14 = 804,
	FN_SCL1_A___2 = 805,
	FN_SCK2_A = 806,
	FN_SSI_SDATA0___4 = 807,
	FN_ARM_TRACEDATA_15 = 808,
	FN_SD0_CLK___5 = 809,
	FN_SUB_TDO = 810,
	FN_SD0_CMD___5 = 811,
	FN_SUB_TRST = 812,
	FN_SD0_DAT0___3 = 813,
	FN_SUB_TMS = 814,
	FN_SD0_DAT1___3 = 815,
	FN_SUB_TCK = 816,
	FN_SD0_DAT2___3 = 817,
	FN_SUB_TDI = 818,
	FN_SD0_DAT3___3 = 819,
	FN_IRQ1_B = 820,
	FN_SD0_CD___5 = 821,
	FN_TX5_A___2 = 822,
	FN_SD0_WP___5 = 823,
	FN_RX5_A___2 = 824,
	FN_VI1_CLKENB___5 = 825,
	FN_HSPI_CLK0_A = 826,
	FN_HTX1_A___2 = 827,
	FN_RTS1_C = 828,
	FN_VI1_FIELD___5 = 829,
	FN_HSPI_CS0_A = 830,
	FN_HRX1_A___2 = 831,
	FN_SCK1_C = 832,
	FN_VI1_HSYNC = 833,
	FN_HSPI_RX0_A = 834,
	FN_HRTS1_A = 835,
	FN_FMCLK_A = 836,
	FN_RX1_C___4 = 837,
	FN_VI1_VSYNC = 838,
	FN_HSPI_TX0 = 839,
	FN_HCTS1_A = 840,
	FN_BPFCLK_A = 841,
	FN_TX1_C___4 = 842,
	FN_TCLK0 = 843,
	FN_HSCK1_A = 844,
	FN_FMIN_A = 845,
	FN_IRQ2_C = 846,
	FN_CTS1_C = 847,
	FN_SPEEDIN___4 = 848,
	FN_VI0_CLK___5 = 849,
	FN_CAN_CLK_A___2 = 850,
	FN_VI0_CLKENB___5 = 851,
	FN_SD2_DAT2_B = 852,
	FN_VI1_DATA0___4 = 853,
	FN_DU1_DG6___4 = 854,
	FN_HSPI_RX1_A = 855,
	FN_RX4_B___3 = 856,
	FN_VI0_FIELD___5 = 857,
	FN_SD2_DAT3_B = 858,
	FN_VI0_R3_C = 859,
	FN_VI1_DATA1___4 = 860,
	FN_DU1_DG7___4 = 861,
	FN_HSPI_CLK1_A = 862,
	FN_TX4_B___3 = 863,
	FN_VI0_HSYNC = 864,
	FN_SD2_CD_B = 865,
	FN_VI1_DATA2___4 = 866,
	FN_DU1_DR2___4 = 867,
	FN_HSPI_CS1_A = 868,
	FN_RX3_B___3 = 869,
	FN_VI0_VSYNC = 870,
	FN_SD2_WP_B = 871,
	FN_VI1_DATA3___4 = 872,
	FN_DU1_DR3___4 = 873,
	FN_HSPI_TX1_A = 874,
	FN_TX3_B___3 = 875,
	FN_VI0_DATA0_VI0_B0___5 = 876,
	FN_DU1_DG2___4 = 877,
	FN_IRQ2_B = 878,
	FN_RX3_D___2 = 879,
	FN_VI0_DATA1_VI0_B1___5 = 880,
	FN_DU1_DG3___4 = 881,
	FN_IRQ3_B = 882,
	FN_TX3_D___2 = 883,
	FN_VI0_DATA2_VI0_B2___5 = 884,
	FN_DU1_DG4___4 = 885,
	FN_RX0_C___3 = 886,
	FN_VI0_DATA3_VI0_B3___5 = 887,
	FN_DU1_DG5___4 = 888,
	FN_TX1_A___2 = 889,
	FN_TX0_C___3 = 890,
	FN_VI0_DATA4_VI0_B4___5 = 891,
	FN_DU1_DB2___4 = 892,
	FN_RX1_A___2 = 893,
	FN_VI0_DATA5_VI0_B5___5 = 894,
	FN_DU1_DB3___4 = 895,
	FN_SCK1_A = 896,
	FN_PWM4___4 = 897,
	FN_HSCK1_B___2 = 898,
	FN_VI0_DATA6_VI0_G0 = 899,
	FN_DU1_DB4___4 = 900,
	FN_CTS1_A = 901,
	FN_PWM5___4 = 902,
	FN_VI0_DATA7_VI0_G1 = 903,
	FN_DU1_DB5___4 = 904,
	FN_RTS1_A = 905,
	FN_VI0_G2___5 = 906,
	FN_SD2_CLK_B = 907,
	FN_VI1_DATA4___4 = 908,
	FN_DU1_DR4___4 = 909,
	FN_HTX1_B___4 = 910,
	FN_VI0_G3___5 = 911,
	FN_SD2_CMD_B = 912,
	FN_VI1_DATA5___4 = 913,
	FN_DU1_DR5___4 = 914,
	FN_HRX1_B___4 = 915,
	FN_VI0_G4___5 = 916,
	FN_SD2_DAT0_B = 917,
	FN_VI1_DATA6___4 = 918,
	FN_DU1_DR6___4 = 919,
	FN_HRTS1_B = 920,
	FN_VI0_G5___5 = 921,
	FN_SD2_DAT1_B = 922,
	FN_VI1_DATA7___4 = 923,
	FN_DU1_DR7___4 = 924,
	FN_HCTS1_B = 925,
	FN_VI0_R0_A = 926,
	FN_VI1_CLK___5 = 927,
	FN_ETH_REF_CLK___3 = 928,
	FN_DU1_DOTCLKIN___4 = 929,
	FN_VI0_R1_A = 930,
	FN_VI1_DATA8___3 = 931,
	FN_DU1_DB6___4 = 932,
	FN_ETH_TXD0___5 = 933,
	FN_PWM2___4 = 934,
	FN_TCLK1___4 = 935,
	FN_VI0_R2_A = 936,
	FN_VI1_DATA9___3 = 937,
	FN_DU1_DB7___4 = 938,
	FN_ETH_TXD1___5 = 939,
	FN_PWM3___4 = 940,
	FN_VI0_R3_A = 941,
	FN_ETH_CRS_DV___5 = 942,
	FN_IECLK___4 = 943,
	FN_SCK2_C = 944,
	FN_VI0_R4_A = 945,
	FN_ETH_TX_EN___5 = 946,
	FN_IETX___4 = 947,
	FN_TX2_C___3 = 948,
	FN_VI0_R5_A = 949,
	FN_ETH_RX_ER___5 = 950,
	FN_FMCLK_C___3 = 951,
	FN_IERX___4 = 952,
	FN_RX2_C___3 = 953,
	FN_VI1_DATA10_A = 954,
	FN_DU1_DOTCLKOUT___2 = 955,
	FN_ETH_RXD0___5 = 956,
	FN_BPFCLK_C___4 = 957,
	FN_TX2_D = 958,
	FN_SDA2_C___2 = 959,
	FN_VI1_DATA11_A = 960,
	FN_DU1_EXHSYNC_DU1_HSYNC___4 = 961,
	FN_ETH_RXD1___5 = 962,
	FN_FMIN_C___4 = 963,
	FN_RX2_D = 964,
	FN_SCL2_C___2 = 965,
	FN_SD2_CLK_A = 966,
	FN_DU1_EXVSYNC_DU1_VSYNC___4 = 967,
	FN_ATARD1 = 968,
	FN_ETH_MDC___5 = 969,
	FN_SDA1_B___2 = 970,
	FN_SD2_CMD_A = 971,
	FN_DU1_EXODDF_DU1_ODDF_DISP_CDE___4 = 972,
	FN_ATAWR1 = 973,
	FN_ETH_MDIO___5 = 974,
	FN_SCL1_B___2 = 975,
	FN_SD2_DAT0_A = 976,
	FN_DU1_DISP___4 = 977,
	FN_ATACS01 = 978,
	FN_DREQ1_B = 979,
	FN_ETH_LINK___5 = 980,
	FN_CAN1_RX_A___2 = 981,
	FN_SD2_DAT1_A = 982,
	FN_DU1_CDE___4 = 983,
	FN_ATACS11 = 984,
	FN_DACK1_B___2 = 985,
	FN_ETH_MAGIC___5 = 986,
	FN_CAN1_TX_A___2 = 987,
	FN_PWM6___4 = 988,
	FN_SD2_DAT2_A = 989,
	FN_VI1_DATA12 = 990,
	FN_DREQ2_B___2 = 991,
	FN_ATADIR1 = 992,
	FN_HSPI_CLK2_B = 993,
	FN_GPSCLK_B = 994,
	FN_SD2_DAT3_A = 995,
	FN_VI1_DATA13 = 996,
	FN_DACK2_B___2 = 997,
	FN_ATAG1 = 998,
	FN_HSPI_CS2_B = 999,
	FN_GPSIN_B = 1000,
	FN_SD2_CD_A = 1001,
	FN_VI1_DATA14 = 1002,
	FN_EX_WAIT1_B = 1003,
	FN_DREQ0_B = 1004,
	FN_HSPI_RX2_B = 1005,
	FN_REMOCON_A___2 = 1006,
	FN_SD2_WP_A = 1007,
	FN_VI1_DATA15 = 1008,
	FN_EX_WAIT2_B = 1009,
	FN_DACK0_B = 1010,
	FN_HSPI_TX2_B = 1011,
	FN_CAN_CLK_C___4 = 1012,
	FN_SEL_SCIF5_A = 1013,
	FN_SEL_SCIF5_B = 1014,
	FN_SEL_SCIF4_A = 1015,
	FN_SEL_SCIF4_B = 1016,
	FN_SEL_SCIF4_C = 1017,
	FN_SEL_SCIF3_A = 1018,
	FN_SEL_SCIF3_B = 1019,
	FN_SEL_SCIF3_C = 1020,
	FN_SEL_SCIF3_D = 1021,
	FN_SEL_SCIF2_A = 1022,
	FN_SEL_SCIF2_B = 1023,
	FN_SEL_SCIF2_C = 1024,
	FN_SEL_SCIF2_D = 1025,
	FN_SEL_SCIF2_E = 1026,
	FN_SEL_SCIF1_A = 1027,
	FN_SEL_SCIF1_B = 1028,
	FN_SEL_SCIF1_C = 1029,
	FN_SEL_SCIF1_D = 1030,
	FN_SEL_SCIF0_A = 1031,
	FN_SEL_SCIF0_B = 1032,
	FN_SEL_SCIF0_C = 1033,
	FN_SEL_SCIF0_D = 1034,
	FN_SEL_SSI2_A = 1035,
	FN_SEL_SSI2_B = 1036,
	FN_SEL_SSI1_A = 1037,
	FN_SEL_SSI1_B = 1038,
	FN_SEL_VI1_A = 1039,
	FN_SEL_VI1_B = 1040,
	FN_SEL_VI0_A = 1041,
	FN_SEL_VI0_B = 1042,
	FN_SEL_VI0_C = 1043,
	FN_SEL_VI0_D = 1044,
	FN_SEL_SD2_A = 1045,
	FN_SEL_SD2_B = 1046,
	FN_SEL_SD1_A = 1047,
	FN_SEL_SD1_B = 1048,
	FN_SEL_IRQ3_A = 1049,
	FN_SEL_IRQ3_B = 1050,
	FN_SEL_IRQ2_A = 1051,
	FN_SEL_IRQ2_B = 1052,
	FN_SEL_IRQ2_C = 1053,
	FN_SEL_IRQ1_A = 1054,
	FN_SEL_IRQ1_B = 1055,
	FN_SEL_DREQ2_A = 1056,
	FN_SEL_DREQ2_B = 1057,
	FN_SEL_DREQ1_A = 1058,
	FN_SEL_DREQ1_B = 1059,
	FN_SEL_DREQ0_A = 1060,
	FN_SEL_DREQ0_B = 1061,
	FN_SEL_WAIT2_A = 1062,
	FN_SEL_WAIT2_B = 1063,
	FN_SEL_WAIT1_A = 1064,
	FN_SEL_WAIT1_B = 1065,
	FN_SEL_CAN1_A = 1066,
	FN_SEL_CAN1_B = 1067,
	FN_SEL_CAN0_A = 1068,
	FN_SEL_CAN0_B = 1069,
	FN_SEL_CANCLK_A = 1070,
	FN_SEL_CANCLK_B = 1071,
	FN_SEL_CANCLK_C = 1072,
	FN_SEL_CANCLK_D = 1073,
	FN_SEL_HSCIF1_A = 1074,
	FN_SEL_HSCIF1_B = 1075,
	FN_SEL_HSCIF0_A = 1076,
	FN_SEL_HSCIF0_B = 1077,
	FN_SEL_REMOCON_A = 1078,
	FN_SEL_REMOCON_B = 1079,
	FN_SEL_REMOCON_C = 1080,
	FN_SEL_FM_A = 1081,
	FN_SEL_FM_B = 1082,
	FN_SEL_FM_C = 1083,
	FN_SEL_FM_D = 1084,
	FN_SEL_GPS_A = 1085,
	FN_SEL_GPS_B = 1086,
	FN_SEL_GPS_C = 1087,
	FN_SEL_TSIF0_A = 1088,
	FN_SEL_TSIF0_B = 1089,
	FN_SEL_HSPI2_A = 1090,
	FN_SEL_HSPI2_B = 1091,
	FN_SEL_HSPI1_A = 1092,
	FN_SEL_HSPI1_B = 1093,
	FN_SEL_HSPI0_A = 1094,
	FN_SEL_HSPI0_B = 1095,
	FN_SEL_I2C3_A = 1096,
	FN_SEL_I2C3_B = 1097,
	FN_SEL_I2C3_C = 1098,
	FN_SEL_I2C2_A = 1099,
	FN_SEL_I2C2_B = 1100,
	FN_SEL_I2C2_C = 1101,
	FN_SEL_I2C1_A = 1102,
	FN_SEL_I2C1_B = 1103,
	PINMUX_FUNCTION_END___8 = 1104,
	PINMUX_MARK_BEGIN___8 = 1105,
	PENC0_MARK = 1106,
	PENC1_MARK = 1107,
	A1_MARK___7 = 1108,
	A2_MARK___7 = 1109,
	A3_MARK___7 = 1110,
	WE0_MARK = 1111,
	AUDIO_CLKA_MARK___4 = 1112,
	AUDIO_CLKB_MARK___4 = 1113,
	SSI_SCK34_MARK___5 = 1114,
	AVS1_MARK___2 = 1115,
	AVS2_MARK___2 = 1116,
	VI0_R0_C_MARK = 1117,
	VI0_R1_C_MARK = 1118,
	VI0_R2_C_MARK = 1119,
	VI0_R4_C_MARK = 1120,
	VI0_R5_C_MARK = 1121,
	VI0_R0_D_MARK = 1122,
	VI0_R1_D_MARK = 1123,
	VI0_R2_D_MARK = 1124,
	VI0_R3_D_MARK = 1125,
	VI0_R4_D_MARK = 1126,
	VI0_R5_D_MARK = 1127,
	PRESETOUT_MARK = 1128,
	PWM1_MARK___5 = 1129,
	AUDATA0_MARK = 1130,
	ARM_TRACEDATA_0_MARK = 1131,
	GPSCLK_C_MARK = 1132,
	USB_OVC0_MARK = 1133,
	TX2_E_MARK___2 = 1134,
	SDA2_B_MARK___2 = 1135,
	AUDATA1_MARK = 1136,
	ARM_TRACEDATA_1_MARK = 1137,
	GPSIN_C_MARK = 1138,
	USB_OVC1_MARK = 1139,
	RX2_E_MARK___2 = 1140,
	SCL2_B_MARK___2 = 1141,
	SD1_DAT2_A_MARK = 1142,
	MMC_D2_MARK___3 = 1143,
	BS_MARK___3 = 1144,
	ATADIR0_A_MARK = 1145,
	SDSELF_A_MARK = 1146,
	PWM4_B_MARK___4 = 1147,
	SD1_DAT3_A_MARK = 1148,
	MMC_D3_MARK___3 = 1149,
	A0_MARK___7 = 1150,
	ATAG0_A_MARK = 1151,
	REMOCON_B_MARK___4 = 1152,
	A4_MARK___6 = 1153,
	A5_MARK___6 = 1154,
	A6_MARK___7 = 1155,
	A7_MARK___7 = 1156,
	A8_MARK___7 = 1157,
	A9_MARK___7 = 1158,
	A10_MARK___7 = 1159,
	A11_MARK___6 = 1160,
	A12_MARK___6 = 1161,
	A13_MARK___6 = 1162,
	A14_MARK___6 = 1163,
	A15_MARK___6 = 1164,
	A16_MARK___6 = 1165,
	A17_MARK___6 = 1166,
	A18_MARK___6 = 1167,
	A19_MARK___6 = 1168,
	A20_MARK___6 = 1169,
	HSPI_CS1_B_MARK = 1170,
	A21_MARK___6 = 1171,
	HSPI_CLK1_B_MARK = 1172,
	A22_MARK___6 = 1173,
	HRTS0_B_MARK = 1174,
	RX2_B_MARK___4 = 1175,
	DREQ2_A_MARK = 1176,
	A23_MARK___6 = 1177,
	HTX0_B_MARK___4 = 1178,
	TX2_B_MARK___4 = 1179,
	DACK2_A_MARK = 1180,
	TS_SDEN0_A_MARK = 1181,
	SD1_CD_A_MARK = 1182,
	MMC_D6_MARK___3 = 1183,
	A24_MARK___6 = 1184,
	DREQ1_A_MARK = 1185,
	HRX0_B_MARK___4 = 1186,
	TS_SPSYNC0_A_MARK = 1187,
	SD1_WP_A_MARK = 1188,
	MMC_D7_MARK___3 = 1189,
	A25_MARK___6 = 1190,
	DACK1_A_MARK = 1191,
	HCTS0_B_MARK = 1192,
	RX3_C_MARK___3 = 1193,
	TS_SDAT0_A_MARK = 1194,
	CLKOUT_MARK___2 = 1195,
	HSPI_TX1_B_MARK = 1196,
	PWM0_B_MARK___5 = 1197,
	CS0_MARK___2 = 1198,
	HSPI_RX1_B_MARK = 1199,
	SSI_SCK1_B_MARK___4 = 1200,
	ATAG0_B_MARK = 1201,
	CS1_A26_MARK = 1202,
	SDA2_A_MARK___2 = 1203,
	SCK2_B_MARK = 1204,
	MMC_D5_MARK___3 = 1205,
	ATADIR0_B_MARK = 1206,
	RD_WR_MARK = 1207,
	WE1_MARK___2 = 1208,
	ATAWR0_B_MARK = 1209,
	SSI_WS1_B_MARK___4 = 1210,
	EX_CS0_MARK = 1211,
	SCL2_A_MARK___2 = 1212,
	TX3_C_MARK___3 = 1213,
	TS_SCK0_A_MARK = 1214,
	EX_CS1_MARK = 1215,
	MMC_D4_MARK___3 = 1216,
	SD1_CLK_A_MARK = 1217,
	MMC_CLK_MARK___3 = 1218,
	ATACS00_MARK = 1219,
	EX_CS2_MARK = 1220,
	SD1_CMD_A_MARK = 1221,
	MMC_CMD_MARK___3 = 1222,
	ATACS10_MARK = 1223,
	EX_CS3_MARK = 1224,
	SD1_DAT0_A_MARK = 1225,
	MMC_D0_MARK___3 = 1226,
	ATARD0_MARK = 1227,
	EX_CS4_MARK = 1228,
	EX_WAIT1_A_MARK = 1229,
	SD1_DAT1_A_MARK = 1230,
	MMC_D1_MARK___3 = 1231,
	ATAWR0_A_MARK = 1232,
	EX_CS5_MARK = 1233,
	EX_WAIT2_A_MARK = 1234,
	DREQ0_A_MARK = 1235,
	RX3_A_MARK___2 = 1236,
	DACK0_MARK___6 = 1237,
	TX3_A_MARK___2 = 1238,
	DRACK0_MARK___5 = 1239,
	EX_WAIT0_MARK___5 = 1240,
	PWM0_C_MARK___2 = 1241,
	D0_MARK___6 = 1242,
	D1_MARK___6 = 1243,
	D2_MARK___6 = 1244,
	D3_MARK___6 = 1245,
	D4_MARK___6 = 1246,
	D5_MARK___6 = 1247,
	D6_MARK___6 = 1248,
	D7_MARK___6 = 1249,
	D8_MARK___6 = 1250,
	D9_MARK___6 = 1251,
	D10_MARK___6 = 1252,
	D11_MARK___6 = 1253,
	RD_WR_B_MARK = 1254,
	IRQ0_MARK___6 = 1255,
	MLB_CLK_MARK___4 = 1256,
	IRQ1_A_MARK = 1257,
	MLB_SIG_MARK___4 = 1258,
	RX5_B_MARK___3 = 1259,
	SDA3_A_MARK___2 = 1260,
	IRQ2_A_MARK = 1261,
	MLB_DAT_MARK___4 = 1262,
	TX5_B_MARK___3 = 1263,
	SCL3_A_MARK___2 = 1264,
	IRQ3_A_MARK = 1265,
	SDSELF_B_MARK = 1266,
	SD1_CMD_B_MARK = 1267,
	SCIF_CLK_MARK___4 = 1268,
	AUDIO_CLKOUT_B_MARK___4 = 1269,
	CAN_CLK_B_MARK___5 = 1270,
	SDA3_B_MARK___2 = 1271,
	SD1_CLK_B_MARK = 1272,
	HTX0_A_MARK___2 = 1273,
	TX0_A_MARK___2 = 1274,
	SD1_DAT0_B_MARK = 1275,
	HRX0_A_MARK___2 = 1276,
	RX0_A_MARK___2 = 1277,
	SD1_DAT1_B_MARK = 1278,
	HSCK0_MARK___4 = 1279,
	SCK0_MARK___2 = 1280,
	SCL3_B_MARK___2 = 1281,
	SD1_DAT2_B_MARK = 1282,
	HCTS0_A_MARK = 1283,
	CTS0_MARK = 1284,
	SD1_DAT3_B_MARK = 1285,
	HRTS0_A_MARK = 1286,
	RTS0_MARK = 1287,
	SSI_SCK4_MARK___4 = 1288,
	DU0_DR0_MARK___4 = 1289,
	LCDOUT0_MARK___4 = 1290,
	AUDATA2_MARK = 1291,
	ARM_TRACEDATA_2_MARK = 1292,
	SDA3_C_MARK___2 = 1293,
	ADICHS1_MARK___4 = 1294,
	TS_SDEN0_B_MARK___3 = 1295,
	SSI_WS4_MARK___4 = 1296,
	DU0_DR1_MARK___3 = 1297,
	LCDOUT1_MARK___4 = 1298,
	AUDATA3_MARK = 1299,
	ARM_TRACEDATA_3_MARK = 1300,
	SCL3_C_MARK___2 = 1301,
	ADICHS2_MARK___4 = 1302,
	TS_SPSYNC0_B_MARK___3 = 1303,
	DU0_DR2_MARK___4 = 1304,
	LCDOUT2_MARK___4 = 1305,
	DU0_DR3_MARK___4 = 1306,
	LCDOUT3_MARK___4 = 1307,
	DU0_DR4_MARK___4 = 1308,
	LCDOUT4_MARK___4 = 1309,
	DU0_DR5_MARK___4 = 1310,
	LCDOUT5_MARK___4 = 1311,
	DU0_DR6_MARK___4 = 1312,
	LCDOUT6_MARK___4 = 1313,
	DU0_DR7_MARK___4 = 1314,
	LCDOUT7_MARK___4 = 1315,
	DU0_DG0_MARK___4 = 1316,
	LCDOUT8_MARK___4 = 1317,
	AUDATA4_MARK = 1318,
	ARM_TRACEDATA_4_MARK = 1319,
	TX1_D_MARK___4 = 1320,
	CAN0_TX_A_MARK___2 = 1321,
	ADICHS0_MARK___4 = 1322,
	DU0_DG1_MARK___4 = 1323,
	LCDOUT9_MARK___4 = 1324,
	AUDATA5_MARK = 1325,
	ARM_TRACEDATA_5_MARK = 1326,
	RX1_D_MARK___4 = 1327,
	CAN0_RX_A_MARK___2 = 1328,
	ADIDATA_MARK___4 = 1329,
	DU0_DG2_MARK___4 = 1330,
	LCDOUT10_MARK___4 = 1331,
	DU0_DG3_MARK___4 = 1332,
	LCDOUT11_MARK___4 = 1333,
	DU0_DG4_MARK___4 = 1334,
	LCDOUT12_MARK___4 = 1335,
	RX0_B_MARK___4 = 1336,
	DU0_DG5_MARK___4 = 1337,
	LCDOUT13_MARK___4 = 1338,
	TX0_B_MARK___4 = 1339,
	DU0_DG6_MARK___4 = 1340,
	LCDOUT14_MARK___4 = 1341,
	RX4_A_MARK___2 = 1342,
	DU0_DG7_MARK___4 = 1343,
	LCDOUT15_MARK___4 = 1344,
	TX4_A_MARK___2 = 1345,
	SSI_SCK2_B_MARK___3 = 1346,
	VI0_R0_B_MARK___2 = 1347,
	DU0_DB0_MARK___4 = 1348,
	LCDOUT16_MARK___4 = 1349,
	AUDATA6_MARK = 1350,
	ARM_TRACEDATA_6_MARK = 1351,
	GPSCLK_A_MARK = 1352,
	PWM0_A_MARK___2 = 1353,
	ADICLK_MARK___4 = 1354,
	TS_SDAT0_B_MARK___2 = 1355,
	AUDIO_CLKC_MARK___4 = 1356,
	VI0_R1_B_MARK___2 = 1357,
	DU0_DB1_MARK___4 = 1358,
	LCDOUT17_MARK___4 = 1359,
	AUDATA7_MARK = 1360,
	ARM_TRACEDATA_7_MARK = 1361,
	GPSIN_A_MARK = 1362,
	ADICS_SAMP_MARK___4 = 1363,
	TS_SCK0_B_MARK___3 = 1364,
	VI0_R2_B_MARK___2 = 1365,
	DU0_DB2_MARK___4 = 1366,
	LCDOUT18_MARK___4 = 1367,
	VI0_R3_B_MARK___2 = 1368,
	DU0_DB3_MARK___4 = 1369,
	LCDOUT19_MARK___4 = 1370,
	VI0_R4_B_MARK___2 = 1371,
	DU0_DB4_MARK___4 = 1372,
	LCDOUT20_MARK___4 = 1373,
	VI0_R5_B_MARK___2 = 1374,
	DU0_DB5_MARK___4 = 1375,
	LCDOUT21_MARK___4 = 1376,
	VI1_DATA10_B_MARK = 1377,
	DU0_DB6_MARK___4 = 1378,
	LCDOUT22_MARK___4 = 1379,
	VI1_DATA11_B_MARK = 1380,
	DU0_DB7_MARK___4 = 1381,
	LCDOUT23_MARK___4 = 1382,
	DU0_DOTCLKIN_MARK___5 = 1383,
	QSTVA_QVS_MARK___4 = 1384,
	DU0_DOTCLKO_UT0_MARK = 1385,
	QCLK_MARK___4 = 1386,
	DU0_DOTCLKO_UT1_MARK = 1387,
	QSTVB_QVE_MARK___4 = 1388,
	AUDIO_CLKOUT_A_MARK___2 = 1389,
	REMOCON_C_MARK = 1390,
	SSI_WS2_B_MARK___3 = 1391,
	DU0_EXHSYNC_DU0_HSYNC_MARK___3 = 1392,
	QSTH_QHS_MARK___4 = 1393,
	DU0_EXVSYNC_DU0_VSYNC_MARK___3 = 1394,
	QSTB_QHE_MARK___4 = 1395,
	DU0_EXODDF_DU0_ODDF_DISP_CDE_MARK___3 = 1396,
	QCPV_QDE_MARK___4 = 1397,
	FMCLK_D_MARK___3 = 1398,
	SSI_SCK1_A_MARK___2 = 1399,
	DU0_DISP_MARK___3 = 1400,
	QPOLA_MARK___4 = 1401,
	AUDCK_MARK = 1402,
	ARM_TRACECLK_MARK = 1403,
	BPFCLK_D_MARK___4 = 1404,
	SSI_WS1_A_MARK___2 = 1405,
	DU0_CDE_MARK___4 = 1406,
	QPOLB_MARK___4 = 1407,
	AUDSYNC_MARK = 1408,
	ARM_TRACECTL_MARK = 1409,
	FMIN_D_MARK___4 = 1410,
	SD1_CD_B_MARK = 1411,
	SSI_SCK78_MARK___4 = 1412,
	HSPI_RX0_B_MARK = 1413,
	TX1_B_MARK___4 = 1414,
	SD1_WP_B_MARK = 1415,
	SSI_WS78_MARK___4 = 1416,
	HSPI_CLK0_B_MARK = 1417,
	RX1_B_MARK___4 = 1418,
	CAN_CLK_D_MARK___4 = 1419,
	SSI_SDATA8_MARK___4 = 1420,
	SSI_SCK2_A_MARK___2 = 1421,
	HSPI_CS0_B_MARK = 1422,
	TX2_A_MARK___2 = 1423,
	CAN0_TX_B_MARK___5 = 1424,
	SSI_SDATA7_MARK___4 = 1425,
	HSPI_TX0_B_MARK = 1426,
	RX2_A_MARK___2 = 1427,
	CAN0_RX_B_MARK___5 = 1428,
	SSI_SCK6_MARK___4 = 1429,
	HSPI_RX2_A_MARK = 1430,
	FMCLK_B_MARK___4 = 1431,
	CAN1_TX_B_MARK___5 = 1432,
	SSI_WS6_MARK___4 = 1433,
	HSPI_CLK2_A_MARK = 1434,
	BPFCLK_B_MARK___4 = 1435,
	CAN1_RX_B_MARK___5 = 1436,
	SSI_SDATA6_MARK___4 = 1437,
	HSPI_TX2_A_MARK = 1438,
	FMIN_B_MARK___4 = 1439,
	SSI_SCK5_MARK___4 = 1440,
	RX4_C_MARK___3 = 1441,
	SSI_WS5_MARK___4 = 1442,
	TX4_C_MARK___3 = 1443,
	SSI_SDATA5_MARK___4 = 1444,
	RX0_D_MARK___3 = 1445,
	SSI_WS34_MARK___5 = 1446,
	ARM_TRACEDATA_8_MARK = 1447,
	SSI_SDATA4_MARK___4 = 1448,
	SSI_WS2_A_MARK___2 = 1449,
	ARM_TRACEDATA_9_MARK = 1450,
	SSI_SDATA3_MARK___5 = 1451,
	ARM_TRACEDATA_10_MARK = 1452,
	SSI_SCK012_MARK = 1453,
	ARM_TRACEDATA_11_MARK = 1454,
	TX0_D_MARK___3 = 1455,
	SSI_WS012_MARK = 1456,
	ARM_TRACEDATA_12_MARK = 1457,
	SSI_SDATA2_MARK___4 = 1458,
	HSPI_CS2_A_MARK = 1459,
	ARM_TRACEDATA_13_MARK = 1460,
	SDA1_A_MARK___2 = 1461,
	SSI_SDATA1_MARK___4 = 1462,
	ARM_TRACEDATA_14_MARK = 1463,
	SCL1_A_MARK___2 = 1464,
	SCK2_A_MARK = 1465,
	SSI_SDATA0_MARK___4 = 1466,
	ARM_TRACEDATA_15_MARK = 1467,
	SD0_CLK_MARK___5 = 1468,
	SUB_TDO_MARK = 1469,
	SD0_CMD_MARK___5 = 1470,
	SUB_TRST_MARK = 1471,
	SD0_DAT0_MARK___3 = 1472,
	SUB_TMS_MARK = 1473,
	SD0_DAT1_MARK___3 = 1474,
	SUB_TCK_MARK = 1475,
	SD0_DAT2_MARK___3 = 1476,
	SUB_TDI_MARK = 1477,
	SD0_DAT3_MARK___3 = 1478,
	IRQ1_B_MARK = 1479,
	SD0_CD_MARK___5 = 1480,
	TX5_A_MARK___2 = 1481,
	SD0_WP_MARK___5 = 1482,
	RX5_A_MARK___2 = 1483,
	VI1_CLKENB_MARK___5 = 1484,
	HSPI_CLK0_A_MARK = 1485,
	HTX1_A_MARK___2 = 1486,
	RTS1_C_MARK = 1487,
	VI1_FIELD_MARK___5 = 1488,
	HSPI_CS0_A_MARK = 1489,
	HRX1_A_MARK___2 = 1490,
	SCK1_C_MARK = 1491,
	VI1_HSYNC_MARK = 1492,
	HSPI_RX0_A_MARK = 1493,
	HRTS1_A_MARK = 1494,
	FMCLK_A_MARK = 1495,
	RX1_C_MARK___4 = 1496,
	VI1_VSYNC_MARK = 1497,
	HSPI_TX0_MARK = 1498,
	HCTS1_A_MARK = 1499,
	BPFCLK_A_MARK = 1500,
	TX1_C_MARK___4 = 1501,
	TCLK0_MARK = 1502,
	HSCK1_A_MARK = 1503,
	FMIN_A_MARK = 1504,
	IRQ2_C_MARK = 1505,
	CTS1_C_MARK = 1506,
	SPEEDIN_MARK___4 = 1507,
	VI0_CLK_MARK___5 = 1508,
	CAN_CLK_A_MARK___2 = 1509,
	VI0_CLKENB_MARK___5 = 1510,
	SD2_DAT2_B_MARK = 1511,
	VI1_DATA0_MARK___4 = 1512,
	DU1_DG6_MARK___4 = 1513,
	HSPI_RX1_A_MARK = 1514,
	RX4_B_MARK___3 = 1515,
	VI0_FIELD_MARK___5 = 1516,
	SD2_DAT3_B_MARK = 1517,
	VI0_R3_C_MARK = 1518,
	VI1_DATA1_MARK___4 = 1519,
	DU1_DG7_MARK___4 = 1520,
	HSPI_CLK1_A_MARK = 1521,
	TX4_B_MARK___3 = 1522,
	VI0_HSYNC_MARK = 1523,
	SD2_CD_B_MARK = 1524,
	VI1_DATA2_MARK___4 = 1525,
	DU1_DR2_MARK___4 = 1526,
	HSPI_CS1_A_MARK = 1527,
	RX3_B_MARK___3 = 1528,
	VI0_VSYNC_MARK = 1529,
	SD2_WP_B_MARK = 1530,
	VI1_DATA3_MARK___4 = 1531,
	DU1_DR3_MARK___4 = 1532,
	HSPI_TX1_A_MARK = 1533,
	TX3_B_MARK___3 = 1534,
	VI0_DATA0_VI0_B0_MARK___5 = 1535,
	DU1_DG2_MARK___4 = 1536,
	IRQ2_B_MARK = 1537,
	RX3_D_MARK___2 = 1538,
	VI0_DATA1_VI0_B1_MARK___5 = 1539,
	DU1_DG3_MARK___4 = 1540,
	IRQ3_B_MARK = 1541,
	TX3_D_MARK___2 = 1542,
	VI0_DATA2_VI0_B2_MARK___5 = 1543,
	DU1_DG4_MARK___4 = 1544,
	RX0_C_MARK___3 = 1545,
	VI0_DATA3_VI0_B3_MARK___5 = 1546,
	DU1_DG5_MARK___4 = 1547,
	TX1_A_MARK___2 = 1548,
	TX0_C_MARK___3 = 1549,
	VI0_DATA4_VI0_B4_MARK___5 = 1550,
	DU1_DB2_MARK___4 = 1551,
	RX1_A_MARK___2 = 1552,
	VI0_DATA5_VI0_B5_MARK___5 = 1553,
	DU1_DB3_MARK___4 = 1554,
	SCK1_A_MARK = 1555,
	PWM4_MARK___4 = 1556,
	HSCK1_B_MARK___2 = 1557,
	VI0_DATA6_VI0_G0_MARK = 1558,
	DU1_DB4_MARK___4 = 1559,
	CTS1_A_MARK = 1560,
	PWM5_MARK___4 = 1561,
	VI0_DATA7_VI0_G1_MARK = 1562,
	DU1_DB5_MARK___4 = 1563,
	RTS1_A_MARK = 1564,
	VI0_G2_MARK___5 = 1565,
	SD2_CLK_B_MARK = 1566,
	VI1_DATA4_MARK___4 = 1567,
	DU1_DR4_MARK___4 = 1568,
	HTX1_B_MARK___4 = 1569,
	VI0_G3_MARK___5 = 1570,
	SD2_CMD_B_MARK = 1571,
	VI1_DATA5_MARK___4 = 1572,
	DU1_DR5_MARK___4 = 1573,
	HRX1_B_MARK___4 = 1574,
	VI0_G4_MARK___5 = 1575,
	SD2_DAT0_B_MARK = 1576,
	VI1_DATA6_MARK___4 = 1577,
	DU1_DR6_MARK___4 = 1578,
	HRTS1_B_MARK = 1579,
	VI0_G5_MARK___5 = 1580,
	SD2_DAT1_B_MARK = 1581,
	VI1_DATA7_MARK___4 = 1582,
	DU1_DR7_MARK___4 = 1583,
	HCTS1_B_MARK = 1584,
	VI0_R0_A_MARK = 1585,
	VI1_CLK_MARK___5 = 1586,
	ETH_REF_CLK_MARK___3 = 1587,
	DU1_DOTCLKIN_MARK___4 = 1588,
	VI0_R1_A_MARK = 1589,
	VI1_DATA8_MARK___3 = 1590,
	DU1_DB6_MARK___4 = 1591,
	ETH_TXD0_MARK___5 = 1592,
	PWM2_MARK___4 = 1593,
	TCLK1_MARK___4 = 1594,
	VI0_R2_A_MARK = 1595,
	VI1_DATA9_MARK___3 = 1596,
	DU1_DB7_MARK___4 = 1597,
	ETH_TXD1_MARK___5 = 1598,
	PWM3_MARK___4 = 1599,
	VI0_R3_A_MARK = 1600,
	ETH_CRS_DV_MARK___5 = 1601,
	IECLK_MARK___4 = 1602,
	SCK2_C_MARK = 1603,
	VI0_R4_A_MARK = 1604,
	ETH_TX_EN_MARK___5 = 1605,
	IETX_MARK___4 = 1606,
	TX2_C_MARK___3 = 1607,
	VI0_R5_A_MARK = 1608,
	ETH_RX_ER_MARK___5 = 1609,
	FMCLK_C_MARK___3 = 1610,
	IERX_MARK___4 = 1611,
	RX2_C_MARK___3 = 1612,
	VI1_DATA10_A_MARK = 1613,
	DU1_DOTCLKOUT_MARK___2 = 1614,
	ETH_RXD0_MARK___5 = 1615,
	BPFCLK_C_MARK___4 = 1616,
	TX2_D_MARK = 1617,
	SDA2_C_MARK___2 = 1618,
	VI1_DATA11_A_MARK = 1619,
	DU1_EXHSYNC_DU1_HSYNC_MARK___4 = 1620,
	ETH_RXD1_MARK___5 = 1621,
	FMIN_C_MARK___4 = 1622,
	RX2_D_MARK = 1623,
	SCL2_C_MARK___2 = 1624,
	SD2_CLK_A_MARK = 1625,
	DU1_EXVSYNC_DU1_VSYNC_MARK___4 = 1626,
	ATARD1_MARK = 1627,
	ETH_MDC_MARK___5 = 1628,
	SDA1_B_MARK___2 = 1629,
	SD2_CMD_A_MARK = 1630,
	DU1_EXODDF_DU1_ODDF_DISP_CDE_MARK___4 = 1631,
	ATAWR1_MARK = 1632,
	ETH_MDIO_MARK___5 = 1633,
	SCL1_B_MARK___2 = 1634,
	SD2_DAT0_A_MARK = 1635,
	DU1_DISP_MARK___4 = 1636,
	ATACS01_MARK = 1637,
	DREQ1_B_MARK = 1638,
	ETH_LINK_MARK___5 = 1639,
	CAN1_RX_A_MARK___2 = 1640,
	SD2_DAT1_A_MARK = 1641,
	DU1_CDE_MARK___4 = 1642,
	ATACS11_MARK = 1643,
	DACK1_B_MARK___2 = 1644,
	ETH_MAGIC_MARK___5 = 1645,
	CAN1_TX_A_MARK___2 = 1646,
	PWM6_MARK___4 = 1647,
	SD2_DAT2_A_MARK = 1648,
	VI1_DATA12_MARK = 1649,
	DREQ2_B_MARK___2 = 1650,
	ATADIR1_MARK = 1651,
	HSPI_CLK2_B_MARK = 1652,
	GPSCLK_B_MARK = 1653,
	SD2_DAT3_A_MARK = 1654,
	VI1_DATA13_MARK = 1655,
	DACK2_B_MARK___2 = 1656,
	ATAG1_MARK = 1657,
	HSPI_CS2_B_MARK = 1658,
	GPSIN_B_MARK = 1659,
	SD2_CD_A_MARK = 1660,
	VI1_DATA14_MARK = 1661,
	EX_WAIT1_B_MARK = 1662,
	DREQ0_B_MARK = 1663,
	HSPI_RX2_B_MARK = 1664,
	REMOCON_A_MARK___2 = 1665,
	SD2_WP_A_MARK = 1666,
	VI1_DATA15_MARK = 1667,
	EX_WAIT2_B_MARK = 1668,
	DACK0_B_MARK = 1669,
	HSPI_TX2_B_MARK = 1670,
	CAN_CLK_C_MARK___4 = 1671,
	PINMUX_MARK_END___8 = 1672,
};

enum {
	GP_LAST___2 = 154,
	PIN_CLKOUT = 155,
	PIN_CS0 = 156,
	PIN_CS1_A26 = 157,
};

enum {
	PINMUX_RESERVED___9 = 0,
	PINMUX_DATA_BEGIN___9 = 1,
	GP_0_0_DATA___6 = 2,
	GP_0_1_DATA___6 = 3,
	GP_0_2_DATA___6 = 4,
	GP_0_3_DATA___6 = 5,
	GP_0_4_DATA___6 = 6,
	GP_0_5_DATA___6 = 7,
	GP_0_6_DATA___6 = 8,
	GP_0_7_DATA___6 = 9,
	GP_0_8_DATA___6 = 10,
	GP_0_9_DATA___6 = 11,
	GP_0_10_DATA___6 = 12,
	GP_0_11_DATA___6 = 13,
	GP_0_12_DATA___6 = 14,
	GP_0_13_DATA___6 = 15,
	GP_0_14_DATA___6 = 16,
	GP_0_15_DATA___6 = 17,
	GP_0_16_DATA___6 = 18,
	GP_0_17_DATA___6 = 19,
	GP_0_18_DATA___6 = 20,
	GP_0_19_DATA___6 = 21,
	GP_0_20_DATA___6 = 22,
	GP_0_21_DATA___6 = 23,
	GP_0_22_DATA___6 = 24,
	GP_0_23_DATA___5 = 25,
	GP_0_24_DATA___5 = 26,
	GP_0_25_DATA___5 = 27,
	GP_0_26_DATA___5 = 28,
	GP_0_27_DATA___5 = 29,
	GP_0_28_DATA___5 = 30,
	GP_0_29_DATA___5 = 31,
	GP_0_30_DATA___5 = 32,
	GP_0_31_DATA___5 = 33,
	GP_1_0_DATA___6 = 34,
	GP_1_1_DATA___6 = 35,
	GP_1_2_DATA___6 = 36,
	GP_1_3_DATA___6 = 37,
	GP_1_4_DATA___6 = 38,
	GP_1_5_DATA___6 = 39,
	GP_1_6_DATA___6 = 40,
	GP_1_7_DATA___6 = 41,
	GP_1_8_DATA___6 = 42,
	GP_1_9_DATA___6 = 43,
	GP_1_10_DATA___6 = 44,
	GP_1_11_DATA___6 = 45,
	GP_1_12_DATA___6 = 46,
	GP_1_13_DATA___6 = 47,
	GP_1_14_DATA___6 = 48,
	GP_1_15_DATA___6 = 49,
	GP_1_16_DATA___6 = 50,
	GP_1_17_DATA___6 = 51,
	GP_1_18_DATA___6 = 52,
	GP_1_19_DATA___6 = 53,
	GP_1_20_DATA___6 = 54,
	GP_1_21_DATA___6 = 55,
	GP_1_22_DATA___6 = 56,
	GP_1_23_DATA___5 = 57,
	GP_1_24_DATA___5 = 58,
	GP_1_25_DATA___5 = 59,
	GP_1_26_DATA___3 = 60,
	GP_1_27_DATA___3 = 61,
	GP_1_28_DATA___3 = 62,
	GP_1_29_DATA___3 = 63,
	GP_1_30_DATA___2 = 64,
	GP_1_31_DATA___2 = 65,
	GP_2_0_DATA___6 = 66,
	GP_2_1_DATA___6 = 67,
	GP_2_2_DATA___6 = 68,
	GP_2_3_DATA___6 = 69,
	GP_2_4_DATA___6 = 70,
	GP_2_5_DATA___6 = 71,
	GP_2_6_DATA___6 = 72,
	GP_2_7_DATA___6 = 73,
	GP_2_8_DATA___6 = 74,
	GP_2_9_DATA___6 = 75,
	GP_2_10_DATA___6 = 76,
	GP_2_11_DATA___6 = 77,
	GP_2_12_DATA___6 = 78,
	GP_2_13_DATA___6 = 79,
	GP_2_14_DATA___6 = 80,
	GP_2_15_DATA___6 = 81,
	GP_2_16_DATA___6 = 82,
	GP_2_17_DATA___6 = 83,
	GP_2_18_DATA___6 = 84,
	GP_2_19_DATA___6 = 85,
	GP_2_20_DATA___6 = 86,
	GP_2_21_DATA___6 = 87,
	GP_2_22_DATA___6 = 88,
	GP_2_23_DATA___6 = 89,
	GP_2_24_DATA___6 = 90,
	GP_2_25_DATA___6 = 91,
	GP_2_26_DATA___6 = 92,
	GP_2_27_DATA___6 = 93,
	GP_2_28_DATA___6 = 94,
	GP_2_29_DATA___6 = 95,
	GP_2_30_DATA___5 = 96,
	GP_2_31_DATA___5 = 97,
	GP_3_0_DATA___6 = 98,
	GP_3_1_DATA___6 = 99,
	GP_3_2_DATA___6 = 100,
	GP_3_3_DATA___6 = 101,
	GP_3_4_DATA___6 = 102,
	GP_3_5_DATA___6 = 103,
	GP_3_6_DATA___6 = 104,
	GP_3_7_DATA___6 = 105,
	GP_3_8_DATA___6 = 106,
	GP_3_9_DATA___6 = 107,
	GP_3_10_DATA___6 = 108,
	GP_3_11_DATA___6 = 109,
	GP_3_12_DATA___6 = 110,
	GP_3_13_DATA___6 = 111,
	GP_3_14_DATA___6 = 112,
	GP_3_15_DATA___6 = 113,
	GP_3_16_DATA___6 = 114,
	GP_3_17_DATA___5 = 115,
	GP_3_18_DATA___5 = 116,
	GP_3_19_DATA___5 = 117,
	GP_3_20_DATA___5 = 118,
	GP_3_21_DATA___5 = 119,
	GP_3_22_DATA___5 = 120,
	GP_3_23_DATA___5 = 121,
	GP_3_24_DATA___5 = 122,
	GP_3_25_DATA___5 = 123,
	GP_3_26_DATA___5 = 124,
	GP_3_27_DATA___6 = 125,
	GP_3_28_DATA___6 = 126,
	GP_3_29_DATA___6 = 127,
	GP_3_30_DATA___5 = 128,
	GP_3_31_DATA___5 = 129,
	GP_4_0_DATA___6 = 130,
	GP_4_1_DATA___6 = 131,
	GP_4_2_DATA___6 = 132,
	GP_4_3_DATA___6 = 133,
	GP_4_4_DATA___6 = 134,
	GP_4_5_DATA___6 = 135,
	GP_4_6_DATA___6 = 136,
	GP_4_7_DATA___6 = 137,
	GP_4_8_DATA___6 = 138,
	GP_4_9_DATA___6 = 139,
	GP_4_10_DATA___6 = 140,
	GP_4_11_DATA___6 = 141,
	GP_4_12_DATA___6 = 142,
	GP_4_13_DATA___6 = 143,
	GP_4_14_DATA___6 = 144,
	GP_4_15_DATA___6 = 145,
	GP_4_16_DATA___6 = 146,
	GP_4_17_DATA___6 = 147,
	GP_4_18_DATA___6 = 148,
	GP_4_19_DATA___6 = 149,
	GP_4_20_DATA___6 = 150,
	GP_4_21_DATA___6 = 151,
	GP_4_22_DATA___6 = 152,
	GP_4_23_DATA___6 = 153,
	GP_4_24_DATA___6 = 154,
	GP_4_25_DATA___6 = 155,
	GP_4_26_DATA___5 = 156,
	GP_4_27_DATA___4 = 157,
	GP_4_28_DATA___4 = 158,
	GP_4_29_DATA___4 = 159,
	GP_4_30_DATA___4 = 160,
	GP_4_31_DATA___4 = 161,
	GP_5_0_DATA___5 = 162,
	GP_5_1_DATA___5 = 163,
	GP_5_2_DATA___5 = 164,
	GP_5_3_DATA___5 = 165,
	GP_5_4_DATA___5 = 166,
	GP_5_5_DATA___5 = 167,
	GP_5_6_DATA___5 = 168,
	GP_5_7_DATA___5 = 169,
	GP_5_8_DATA___5 = 170,
	GP_5_9_DATA___5 = 171,
	GP_5_10_DATA___5 = 172,
	GP_5_11_DATA___5 = 173,
	GP_5_12_DATA___5 = 174,
	GP_5_13_DATA___5 = 175,
	GP_5_14_DATA___5 = 176,
	GP_5_15_DATA___5 = 177,
	GP_5_16_DATA___5 = 178,
	GP_5_17_DATA___5 = 179,
	GP_5_18_DATA___5 = 180,
	GP_5_19_DATA___5 = 181,
	GP_5_20_DATA___5 = 182,
	GP_5_21_DATA___5 = 183,
	GP_5_22_DATA___5 = 184,
	GP_5_23_DATA___5 = 185,
	GP_5_24_DATA___5 = 186,
	GP_5_25_DATA___5 = 187,
	GP_5_26_DATA___5 = 188,
	GP_5_27_DATA___5 = 189,
	GP_5_28_DATA___4 = 190,
	GP_5_29_DATA___4 = 191,
	GP_5_30_DATA___4 = 192,
	GP_5_31_DATA___4 = 193,
	GP_6_0_DATA___3 = 194,
	GP_6_1_DATA___3 = 195,
	GP_6_2_DATA___3 = 196,
	GP_6_3_DATA___3 = 197,
	GP_6_4_DATA___3 = 198,
	GP_6_5_DATA___3 = 199,
	GP_6_6_DATA___3 = 200,
	GP_6_7_DATA___3 = 201,
	GP_6_8_DATA___3 = 202,
	PINMUX_DATA_END___9 = 203,
	PINMUX_FUNCTION_BEGIN___9 = 204,
	GP_0_0_FN___6 = 205,
	GP_0_1_FN___6 = 206,
	GP_0_2_FN___6 = 207,
	GP_0_3_FN___6 = 208,
	GP_0_4_FN___6 = 209,
	GP_0_5_FN___6 = 210,
	GP_0_6_FN___6 = 211,
	GP_0_7_FN___6 = 212,
	GP_0_8_FN___6 = 213,
	GP_0_9_FN___6 = 214,
	GP_0_10_FN___6 = 215,
	GP_0_11_FN___6 = 216,
	GP_0_12_FN___6 = 217,
	GP_0_13_FN___6 = 218,
	GP_0_14_FN___6 = 219,
	GP_0_15_FN___6 = 220,
	GP_0_16_FN___6 = 221,
	GP_0_17_FN___6 = 222,
	GP_0_18_FN___6 = 223,
	GP_0_19_FN___6 = 224,
	GP_0_20_FN___6 = 225,
	GP_0_21_FN___6 = 226,
	GP_0_22_FN___6 = 227,
	GP_0_23_FN___5 = 228,
	GP_0_24_FN___5 = 229,
	GP_0_25_FN___5 = 230,
	GP_0_26_FN___5 = 231,
	GP_0_27_FN___5 = 232,
	GP_0_28_FN___5 = 233,
	GP_0_29_FN___5 = 234,
	GP_0_30_FN___5 = 235,
	GP_0_31_FN___5 = 236,
	GP_1_0_FN___6 = 237,
	GP_1_1_FN___6 = 238,
	GP_1_2_FN___6 = 239,
	GP_1_3_FN___6 = 240,
	GP_1_4_FN___6 = 241,
	GP_1_5_FN___6 = 242,
	GP_1_6_FN___6 = 243,
	GP_1_7_FN___6 = 244,
	GP_1_8_FN___6 = 245,
	GP_1_9_FN___6 = 246,
	GP_1_10_FN___6 = 247,
	GP_1_11_FN___6 = 248,
	GP_1_12_FN___6 = 249,
	GP_1_13_FN___6 = 250,
	GP_1_14_FN___6 = 251,
	GP_1_15_FN___6 = 252,
	GP_1_16_FN___6 = 253,
	GP_1_17_FN___6 = 254,
	GP_1_18_FN___6 = 255,
	GP_1_19_FN___6 = 256,
	GP_1_20_FN___6 = 257,
	GP_1_21_FN___6 = 258,
	GP_1_22_FN___6 = 259,
	GP_1_23_FN___5 = 260,
	GP_1_24_FN___5 = 261,
	GP_1_25_FN___5 = 262,
	GP_1_26_FN___3 = 263,
	GP_1_27_FN___3 = 264,
	GP_1_28_FN___3 = 265,
	GP_1_29_FN___3 = 266,
	GP_1_30_FN___2 = 267,
	GP_1_31_FN___2 = 268,
	GP_2_0_FN___6 = 269,
	GP_2_1_FN___6 = 270,
	GP_2_2_FN___6 = 271,
	GP_2_3_FN___6 = 272,
	GP_2_4_FN___6 = 273,
	GP_2_5_FN___6 = 274,
	GP_2_6_FN___6 = 275,
	GP_2_7_FN___6 = 276,
	GP_2_8_FN___6 = 277,
	GP_2_9_FN___6 = 278,
	GP_2_10_FN___6 = 279,
	GP_2_11_FN___6 = 280,
	GP_2_12_FN___6 = 281,
	GP_2_13_FN___6 = 282,
	GP_2_14_FN___6 = 283,
	GP_2_15_FN___6 = 284,
	GP_2_16_FN___6 = 285,
	GP_2_17_FN___6 = 286,
	GP_2_18_FN___6 = 287,
	GP_2_19_FN___6 = 288,
	GP_2_20_FN___6 = 289,
	GP_2_21_FN___6 = 290,
	GP_2_22_FN___6 = 291,
	GP_2_23_FN___6 = 292,
	GP_2_24_FN___6 = 293,
	GP_2_25_FN___6 = 294,
	GP_2_26_FN___6 = 295,
	GP_2_27_FN___6 = 296,
	GP_2_28_FN___6 = 297,
	GP_2_29_FN___6 = 298,
	GP_2_30_FN___5 = 299,
	GP_2_31_FN___5 = 300,
	GP_3_0_FN___6 = 301,
	GP_3_1_FN___6 = 302,
	GP_3_2_FN___6 = 303,
	GP_3_3_FN___6 = 304,
	GP_3_4_FN___6 = 305,
	GP_3_5_FN___6 = 306,
	GP_3_6_FN___6 = 307,
	GP_3_7_FN___6 = 308,
	GP_3_8_FN___6 = 309,
	GP_3_9_FN___6 = 310,
	GP_3_10_FN___6 = 311,
	GP_3_11_FN___6 = 312,
	GP_3_12_FN___6 = 313,
	GP_3_13_FN___6 = 314,
	GP_3_14_FN___6 = 315,
	GP_3_15_FN___6 = 316,
	GP_3_16_FN___6 = 317,
	GP_3_17_FN___5 = 318,
	GP_3_18_FN___5 = 319,
	GP_3_19_FN___5 = 320,
	GP_3_20_FN___5 = 321,
	GP_3_21_FN___5 = 322,
	GP_3_22_FN___5 = 323,
	GP_3_23_FN___5 = 324,
	GP_3_24_FN___5 = 325,
	GP_3_25_FN___5 = 326,
	GP_3_26_FN___5 = 327,
	GP_3_27_FN___6 = 328,
	GP_3_28_FN___6 = 329,
	GP_3_29_FN___6 = 330,
	GP_3_30_FN___5 = 331,
	GP_3_31_FN___5 = 332,
	GP_4_0_FN___6 = 333,
	GP_4_1_FN___6 = 334,
	GP_4_2_FN___6 = 335,
	GP_4_3_FN___6 = 336,
	GP_4_4_FN___6 = 337,
	GP_4_5_FN___6 = 338,
	GP_4_6_FN___6 = 339,
	GP_4_7_FN___6 = 340,
	GP_4_8_FN___6 = 341,
	GP_4_9_FN___6 = 342,
	GP_4_10_FN___6 = 343,
	GP_4_11_FN___6 = 344,
	GP_4_12_FN___6 = 345,
	GP_4_13_FN___6 = 346,
	GP_4_14_FN___6 = 347,
	GP_4_15_FN___6 = 348,
	GP_4_16_FN___6 = 349,
	GP_4_17_FN___6 = 350,
	GP_4_18_FN___6 = 351,
	GP_4_19_FN___6 = 352,
	GP_4_20_FN___6 = 353,
	GP_4_21_FN___6 = 354,
	GP_4_22_FN___6 = 355,
	GP_4_23_FN___6 = 356,
	GP_4_24_FN___6 = 357,
	GP_4_25_FN___6 = 358,
	GP_4_26_FN___5 = 359,
	GP_4_27_FN___4 = 360,
	GP_4_28_FN___4 = 361,
	GP_4_29_FN___4 = 362,
	GP_4_30_FN___4 = 363,
	GP_4_31_FN___4 = 364,
	GP_5_0_FN___5 = 365,
	GP_5_1_FN___5 = 366,
	GP_5_2_FN___5 = 367,
	GP_5_3_FN___5 = 368,
	GP_5_4_FN___5 = 369,
	GP_5_5_FN___5 = 370,
	GP_5_6_FN___5 = 371,
	GP_5_7_FN___5 = 372,
	GP_5_8_FN___5 = 373,
	GP_5_9_FN___5 = 374,
	GP_5_10_FN___5 = 375,
	GP_5_11_FN___5 = 376,
	GP_5_12_FN___5 = 377,
	GP_5_13_FN___5 = 378,
	GP_5_14_FN___5 = 379,
	GP_5_15_FN___5 = 380,
	GP_5_16_FN___5 = 381,
	GP_5_17_FN___5 = 382,
	GP_5_18_FN___5 = 383,
	GP_5_19_FN___5 = 384,
	GP_5_20_FN___5 = 385,
	GP_5_21_FN___5 = 386,
	GP_5_22_FN___5 = 387,
	GP_5_23_FN___5 = 388,
	GP_5_24_FN___5 = 389,
	GP_5_25_FN___5 = 390,
	GP_5_26_FN___5 = 391,
	GP_5_27_FN___5 = 392,
	GP_5_28_FN___4 = 393,
	GP_5_29_FN___4 = 394,
	GP_5_30_FN___4 = 395,
	GP_5_31_FN___4 = 396,
	GP_6_0_FN___3 = 397,
	GP_6_1_FN___3 = 398,
	GP_6_2_FN___3 = 399,
	GP_6_3_FN___3 = 400,
	GP_6_4_FN___3 = 401,
	GP_6_5_FN___3 = 402,
	GP_6_6_FN___3 = 403,
	GP_6_7_FN___3 = 404,
	GP_6_8_FN___3 = 405,
	FN_AVS1___3 = 406,
	FN_AVS2___3 = 407,
	FN_IP0_7_6 = 408,
	FN_A17___6 = 409,
	FN_A18___6 = 410,
	FN_A19___6 = 411,
	FN_IP0_9_8___2 = 412,
	FN_IP0_11_10 = 413,
	FN_IP0_13_12 = 414,
	FN_IP0_15_14 = 415,
	FN_IP0_18_16___2 = 416,
	FN_IP0_22_19 = 417,
	FN_IP0_24_23___2 = 418,
	FN_IP0_25___3 = 419,
	FN_IP0_27_26___2 = 420,
	FN_IP1_1_0___3 = 421,
	FN_IP1_3_2___3 = 422,
	FN_IP1_6_4 = 423,
	FN_IP1_10_7 = 424,
	FN_IP1_14_11___2 = 425,
	FN_IP1_18_15 = 426,
	FN_IP0_5_3___2 = 427,
	FN_IP0_30_28 = 428,
	FN_IP2_18_16___2 = 429,
	FN_IP2_21_19 = 430,
	FN_IP2_30_28 = 431,
	FN_IP3_2_0___2 = 432,
	FN_IP3_11_9___2 = 433,
	FN_IP3_14_12___2 = 434,
	FN_IP3_22_21 = 435,
	FN_IP3_26_24___3 = 436,
	FN_IP3_31_29___2 = 437,
	FN_IP4_1_0___3 = 438,
	FN_IP4_4_2___3 = 439,
	FN_IP4_7_5___3 = 440,
	FN_IP4_10_8 = 441,
	FN_IP4_11 = 442,
	FN_IP4_12 = 443,
	FN_IP4_13 = 444,
	FN_IP4_14 = 445,
	FN_IP4_15 = 446,
	FN_IP4_16 = 447,
	FN_IP4_19_17 = 448,
	FN_IP4_22_20___2 = 449,
	FN_IP4_23 = 450,
	FN_IP4_24 = 451,
	FN_IP4_25 = 452,
	FN_IP4_26 = 453,
	FN_IP4_27 = 454,
	FN_IP4_28 = 455,
	FN_IP4_31_29 = 456,
	FN_IP5_2_0___3 = 457,
	FN_IP5_3 = 458,
	FN_IP5_4 = 459,
	FN_IP5_5 = 460,
	FN_IP5_6___2 = 461,
	FN_IP5_7___2 = 462,
	FN_IP5_8 = 463,
	FN_IP5_10_9 = 464,
	FN_IP5_12_11 = 465,
	FN_IP5_14_13___3 = 466,
	FN_IP5_16_15___2 = 467,
	FN_IP5_20_17 = 468,
	FN_IP5_23_21___2 = 469,
	FN_IP5_27_24___2 = 470,
	FN_IP8_20 = 471,
	FN_IP8_22_21 = 472,
	FN_IP8_24_23 = 473,
	FN_IP8_27_25 = 474,
	FN_IP8_30_28___2 = 475,
	FN_IP9_1_0___2 = 476,
	FN_IP9_3_2___2 = 477,
	FN_IP9_4 = 478,
	FN_IP9_5 = 479,
	FN_IP9_6___2 = 480,
	FN_IP9_7___2 = 481,
	FN_IP9_9_8 = 482,
	FN_IP9_11_10 = 483,
	FN_IP9_13_12 = 484,
	FN_IP9_15_14 = 485,
	FN_IP9_18_16 = 486,
	FN_IP9_21_19___2 = 487,
	FN_IP9_23_22___2 = 488,
	FN_IP9_25_24___2 = 489,
	FN_IP9_27_26___2 = 490,
	FN_IP9_29_28 = 491,
	FN_IP10_2_0___4 = 492,
	FN_IP10_5_3___4 = 493,
	FN_IP10_8_6___4 = 494,
	FN_IP10_11_9___3 = 495,
	FN_IP10_14_12___3 = 496,
	FN_IP10_17_15___2 = 497,
	FN_IP10_20_18___2 = 498,
	FN_IP10_23_21___2 = 499,
	FN_IP10_25_24 = 500,
	FN_IP10_28_26 = 501,
	FN_IP10_31_29___2 = 502,
	FN_IP11_2_0___3 = 503,
	FN_IP11_5_3___3 = 504,
	FN_IP11_8_6___2 = 505,
	FN_IP11_11_9___2 = 506,
	FN_IP11_14_12___2 = 507,
	FN_IP11_17_15___2 = 508,
	FN_IP11_20_18___2 = 509,
	FN_IP11_23_21___2 = 510,
	FN_IP11_26_24___3 = 511,
	FN_IP11_29_27___3 = 512,
	FN_IP12_2_0___2 = 513,
	FN_IP12_5_3___2 = 514,
	FN_IP12_8_6___2 = 515,
	FN_IP12_11_9 = 516,
	FN_IP12_14_12 = 517,
	FN_IP12_17_15___2 = 518,
	FN_IP7_16_15___2 = 519,
	FN_IP7_18_17___2 = 520,
	FN_IP7_28_27___2 = 521,
	FN_IP7_30_29___2 = 522,
	FN_IP7_20_19___2 = 523,
	FN_IP7_22_21 = 524,
	FN_IP7_24_23 = 525,
	FN_IP7_26_25___2 = 526,
	FN_IP1_20_19 = 527,
	FN_IP1_22_21 = 528,
	FN_IP1_24_23 = 529,
	FN_IP5_28 = 530,
	FN_IP5_30_29___2 = 531,
	FN_IP6_1_0___3 = 532,
	FN_IP6_3_2___2 = 533,
	FN_IP6_5_4___2 = 534,
	FN_IP6_7_6___3 = 535,
	FN_IP6_8___3 = 536,
	FN_IP6_11_9 = 537,
	FN_IP6_14_12 = 538,
	FN_IP6_17_15 = 539,
	FN_IP6_19_18 = 540,
	FN_IP6_22_20___3 = 541,
	FN_IP6_24_23 = 542,
	FN_IP6_26_25 = 543,
	FN_IP6_30_29 = 544,
	FN_IP7_1_0___2 = 545,
	FN_IP7_3_2___2 = 546,
	FN_IP7_6_4 = 547,
	FN_IP7_9_7 = 548,
	FN_IP7_12_10___2 = 549,
	FN_IP7_14_13___2 = 550,
	FN_IP2_7_4___2 = 551,
	FN_IP2_11_8___2 = 552,
	FN_IP2_15_12___2 = 553,
	FN_IP1_28_25 = 554,
	FN_IP2_3_0___2 = 555,
	FN_IP8_3_0___2 = 556,
	FN_IP8_7_4___2 = 557,
	FN_IP8_11_8___2 = 558,
	FN_IP8_15_12___2 = 559,
	FN_USB_PENC0 = 560,
	FN_USB_PENC1 = 561,
	FN_IP0_2_0___2 = 562,
	FN_IP8_17_16___2 = 563,
	FN_IP8_18 = 564,
	FN_IP8_19 = 565,
	FN_A1___6 = 566,
	FN_A2___6 = 567,
	FN_A3___6 = 568,
	FN_A4___6 = 569,
	FN_A5___6 = 570,
	FN_A6___6 = 571,
	FN_A7___6 = 572,
	FN_A8___6 = 573,
	FN_A9___6 = 574,
	FN_A10___6 = 575,
	FN_A11___6 = 576,
	FN_A12___6 = 577,
	FN_A13___6 = 578,
	FN_A14___6 = 579,
	FN_A15___6 = 580,
	FN_A16___6 = 581,
	FN_RD = 582,
	FN_WE0___2 = 583,
	FN_WE1___2 = 584,
	FN_EX_WAIT0___6 = 585,
	FN_IP3_23 = 586,
	FN_IP3_27___2 = 587,
	FN_IP3_28___2 = 588,
	FN_IP2_22 = 589,
	FN_IP2_23 = 590,
	FN_IP2_24 = 591,
	FN_IP2_25 = 592,
	FN_IP2_26 = 593,
	FN_IP2_27 = 594,
	FN_IP3_3 = 595,
	FN_IP3_4 = 596,
	FN_IP3_5 = 597,
	FN_IP3_6 = 598,
	FN_IP3_7 = 599,
	FN_IP3_8 = 600,
	FN_IP3_15 = 601,
	FN_IP3_16 = 602,
	FN_IP3_17 = 603,
	FN_IP3_18 = 604,
	FN_IP3_19 = 605,
	FN_IP3_20 = 606,
	FN_RD_WR___2 = 607,
	FN_FWE = 608,
	FN_ATAG0 = 609,
	FN_VI1_R7___2 = 610,
	FN_HRTS1 = 611,
	FN_RX4_C___4 = 612,
	FN_CS1_A26___2 = 613,
	FN_HSPI_TX2 = 614,
	FN_SDSELF_B___2 = 615,
	FN_CS0___2 = 616,
	FN_HSPI_CS2_B___2 = 617,
	FN_CLKOUT___3 = 618,
	FN_TX3C_IRDA_TX_C = 619,
	FN_PWM0_B___6 = 620,
	FN_A25___6 = 621,
	FN_SD1_WP___5 = 622,
	FN_MMC0_D5___3 = 623,
	FN_FD5 = 624,
	FN_HSPI_RX2 = 625,
	FN_VI1_R3___2 = 626,
	FN_TX5_B___4 = 627,
	FN_SSI_SDATA7_B___5 = 628,
	FN_CTS0_B = 629,
	FN_A24___6 = 630,
	FN_SD1_CD___5 = 631,
	FN_MMC0_D4___3 = 632,
	FN_FD4 = 633,
	FN_HSPI_CS2 = 634,
	FN_VI1_R2___2 = 635,
	FN_SSI_WS78_B___5 = 636,
	FN_A23___6 = 637,
	FN_FCLE = 638,
	FN_HSPI_CLK2 = 639,
	FN_VI1_R1___2 = 640,
	FN_A22___6 = 641,
	FN_RX5_D___2 = 642,
	FN_HSPI_RX2_B___2 = 643,
	FN_VI1_R0___2 = 644,
	FN_A21___6 = 645,
	FN_SCK5_D = 646,
	FN_HSPI_CLK2_B___2 = 647,
	FN_A20___6 = 648,
	FN_TX5_D___2 = 649,
	FN_HSPI_TX2_B___2 = 650,
	FN_A0___6 = 651,
	FN_SD1_DAT3___2 = 652,
	FN_MMC0_D3___2 = 653,
	FN_FD3 = 654,
	FN_BS___2 = 655,
	FN_SD1_DAT2___2 = 656,
	FN_MMC0_D2___2 = 657,
	FN_FD2 = 658,
	FN_ATADIR0 = 659,
	FN_SDSELF = 660,
	FN_HCTS1 = 661,
	FN_TX4_C___4 = 662,
	FN_USB_PENC2 = 663,
	FN_SCK0___3 = 664,
	FN_PWM1___5 = 665,
	FN_PWMFSW0___2 = 666,
	FN_SCIF_CLK___5 = 667,
	FN_TCLK0_C = 668,
	FN_EX_CS0___2 = 669,
	FN_RX3_C_IRDA_RX_C = 670,
	FN_MMC0_D6___3 = 671,
	FN_FD6 = 672,
	FN_EX_CS1___2 = 673,
	FN_MMC0_D7___3 = 674,
	FN_FD7 = 675,
	FN_EX_CS2___2 = 676,
	FN_SD1_CLK___4 = 677,
	FN_MMC0_CLK___2 = 678,
	FN_FALE = 679,
	FN_ATACS00___2 = 680,
	FN_EX_CS3___2 = 681,
	FN_SD1_CMD___4 = 682,
	FN_MMC0_CMD___2 = 683,
	FN_FRE = 684,
	FN_ATACS10___2 = 685,
	FN_VI1_R4___2 = 686,
	FN_RX5_B___4 = 687,
	FN_HSCK1___4 = 688,
	FN_SSI_SDATA8_B___5 = 689,
	FN_RTS0_B_TANS_B = 690,
	FN_SSI_SDATA9___4 = 691,
	FN_EX_CS4___2 = 692,
	FN_SD1_DAT0___2 = 693,
	FN_MMC0_D0___2 = 694,
	FN_FD0 = 695,
	FN_ATARD0___2 = 696,
	FN_VI1_R5___2 = 697,
	FN_SCK5_B = 698,
	FN_HTX1___3 = 699,
	FN_TX2_E___3 = 700,
	FN_TX0_B___5 = 701,
	FN_SSI_SCK9___4 = 702,
	FN_EX_CS5___2 = 703,
	FN_SD1_DAT1___2 = 704,
	FN_MMC0_D1___2 = 705,
	FN_FD1 = 706,
	FN_ATAWR0 = 707,
	FN_VI1_R6___2 = 708,
	FN_HRX1___3 = 709,
	FN_RX2_E___3 = 710,
	FN_RX0_B___5 = 711,
	FN_SSI_WS9___4 = 712,
	FN_MLB_CLK___5 = 713,
	FN_PWM2___5 = 714,
	FN_SCK4 = 715,
	FN_MLB_SIG___5 = 716,
	FN_PWM3___5 = 717,
	FN_TX4___2 = 718,
	FN_MLB_DAT___5 = 719,
	FN_PWM4___5 = 720,
	FN_RX4___2 = 721,
	FN_HTX0___3 = 722,
	FN_TX1___3 = 723,
	FN_SDATA___2 = 724,
	FN_CTS0_C = 725,
	FN_SUB_TCK___2 = 726,
	FN_CC5_STATE2 = 727,
	FN_CC5_STATE10 = 728,
	FN_CC5_STATE18 = 729,
	FN_CC5_STATE26 = 730,
	FN_CC5_STATE34 = 731,
	FN_HRX0___3 = 732,
	FN_RX1___3 = 733,
	FN_SCKZ___2 = 734,
	FN_RTS0_C_TANS_C = 735,
	FN_SUB_TDI___2 = 736,
	FN_CC5_STATE3 = 737,
	FN_CC5_STATE11 = 738,
	FN_CC5_STATE19 = 739,
	FN_CC5_STATE27 = 740,
	FN_CC5_STATE35 = 741,
	FN_HSCK0___5 = 742,
	FN_SCK1___2 = 743,
	FN_MTS = 744,
	FN_PWM5___5 = 745,
	FN_SCK0_C = 746,
	FN_SSI_SDATA9_B___4 = 747,
	FN_SUB_TDO___2 = 748,
	FN_CC5_STATE0 = 749,
	FN_CC5_STATE8 = 750,
	FN_CC5_STATE16 = 751,
	FN_CC5_STATE24 = 752,
	FN_CC5_STATE32 = 753,
	FN_HCTS0 = 754,
	FN_CTS1 = 755,
	FN_STM = 756,
	FN_PWM0_D = 757,
	FN_RX0_C___4 = 758,
	FN_SCIF_CLK_C = 759,
	FN_SUB_TRST___2 = 760,
	FN_TCLK1_B___5 = 761,
	FN_CC5_OSCOUT = 762,
	FN_HRTS0 = 763,
	FN_RTS1_TANS = 764,
	FN_MDATA___2 = 765,
	FN_TX0_C___4 = 766,
	FN_SUB_TMS___2 = 767,
	FN_CC5_STATE1 = 768,
	FN_CC5_STATE9 = 769,
	FN_CC5_STATE17 = 770,
	FN_CC5_STATE25 = 771,
	FN_CC5_STATE33 = 772,
	FN_DU0_DR0___4 = 773,
	FN_LCDOUT0___5 = 774,
	FN_DREQ0___2 = 775,
	FN_GPS_CLK_B___2 = 776,
	FN_AUDATA0___2 = 777,
	FN_TX5_C___2 = 778,
	FN_DU0_DR1___4 = 779,
	FN_LCDOUT1___5 = 780,
	FN_DACK0___6 = 781,
	FN_DRACK0___6 = 782,
	FN_GPS_SIGN_B___2 = 783,
	FN_AUDATA1___2 = 784,
	FN_RX5_C___2 = 785,
	FN_DU0_DR2___4 = 786,
	FN_LCDOUT2___5 = 787,
	FN_DU0_DR3___4 = 788,
	FN_LCDOUT3___5 = 789,
	FN_DU0_DR4___4 = 790,
	FN_LCDOUT4___5 = 791,
	FN_DU0_DR5___4 = 792,
	FN_LCDOUT5___5 = 793,
	FN_DU0_DR6___4 = 794,
	FN_LCDOUT6___5 = 795,
	FN_DU0_DR7___4 = 796,
	FN_LCDOUT7___5 = 797,
	FN_DU0_DG0___4 = 798,
	FN_LCDOUT8___5 = 799,
	FN_DREQ1___2 = 800,
	FN_SCL2 = 801,
	FN_AUDATA2___2 = 802,
	FN_DU0_DG1___4 = 803,
	FN_LCDOUT9___5 = 804,
	FN_DACK1___5 = 805,
	FN_SDA2 = 806,
	FN_AUDATA3___2 = 807,
	FN_DU0_DG2___4 = 808,
	FN_LCDOUT10___5 = 809,
	FN_DU0_DG3___4 = 810,
	FN_LCDOUT11___5 = 811,
	FN_DU0_DG4___4 = 812,
	FN_LCDOUT12___5 = 813,
	FN_DU0_DG5___4 = 814,
	FN_LCDOUT13___5 = 815,
	FN_DU0_DG6___4 = 816,
	FN_LCDOUT14___5 = 817,
	FN_DU0_DG7___4 = 818,
	FN_LCDOUT15___5 = 819,
	FN_DU0_DB0___4 = 820,
	FN_LCDOUT16___5 = 821,
	FN_EX_WAIT1___5 = 822,
	FN_SCL1 = 823,
	FN_TCLK1___5 = 824,
	FN_AUDATA4___2 = 825,
	FN_DU0_DB1___4 = 826,
	FN_LCDOUT17___5 = 827,
	FN_EX_WAIT2___4 = 828,
	FN_SDA1 = 829,
	FN_GPS_MAG_B___2 = 830,
	FN_AUDATA5___2 = 831,
	FN_SCK5_C = 832,
	FN_DU0_DB2___4 = 833,
	FN_LCDOUT18___5 = 834,
	FN_DU0_DB3___4 = 835,
	FN_LCDOUT19___5 = 836,
	FN_DU0_DB4___4 = 837,
	FN_LCDOUT20___5 = 838,
	FN_DU0_DB5___4 = 839,
	FN_LCDOUT21___5 = 840,
	FN_DU0_DB6___4 = 841,
	FN_LCDOUT22___5 = 842,
	FN_DU0_DB7___4 = 843,
	FN_LCDOUT23___5 = 844,
	FN_DU0_DOTCLKIN___5 = 845,
	FN_QSTVA_QVS___5 = 846,
	FN_TX3_D_IRDA_TX_D = 847,
	FN_SCL3_B___3 = 848,
	FN_DU0_DOTCLKOUT0___3 = 849,
	FN_QCLK___5 = 850,
	FN_DU0_DOTCLKOUT1___3 = 851,
	FN_QSTVB_QVE___5 = 852,
	FN_RX3_D_IRDA_RX_D = 853,
	FN_SDA3_B___3 = 854,
	FN_SDA2_C___3 = 855,
	FN_DACK0_B___2 = 856,
	FN_DRACK0_B = 857,
	FN_DU0_EXHSYNC_DU0_HSYNC___4 = 858,
	FN_QSTH_QHS___5 = 859,
	FN_DU0_EXVSYNC_DU0_VSYNC___4 = 860,
	FN_QSTB_QHE___5 = 861,
	FN_DU0_EXODDF_DU0_ODDF_DISP_CDE___4 = 862,
	FN_QCPV_QDE___5 = 863,
	FN_CAN1_TX___4 = 864,
	FN_TX2_C___4 = 865,
	FN_SCL2_C___3 = 866,
	FN_REMOCON___4 = 867,
	FN_DU0_DISP___4 = 868,
	FN_QPOLA___5 = 869,
	FN_CAN_CLK_C___5 = 870,
	FN_SCK2_C___2 = 871,
	FN_DU0_CDE___4 = 872,
	FN_QPOLB___5 = 873,
	FN_CAN1_RX___4 = 874,
	FN_RX2_C___4 = 875,
	FN_DREQ0_B___2 = 876,
	FN_SSI_SCK78_B___5 = 877,
	FN_SCK0_B = 878,
	FN_DU1_DR0___4 = 879,
	FN_VI2_DATA0_VI2_B0___2 = 880,
	FN_PWM6___5 = 881,
	FN_SD3_CLK___2 = 882,
	FN_TX3_E_IRDA_TX_E = 883,
	FN_AUDCK___2 = 884,
	FN_PWMFSW0_B = 885,
	FN_DU1_DR1___4 = 886,
	FN_VI2_DATA1_VI2_B1___2 = 887,
	FN_PWM0___4 = 888,
	FN_SD3_CMD___2 = 889,
	FN_RX3_E_IRDA_RX_E = 890,
	FN_AUDSYNC___2 = 891,
	FN_CTS0_D = 892,
	FN_DU1_DR2___5 = 893,
	FN_VI2_G0___2 = 894,
	FN_DU1_DR3___5 = 895,
	FN_VI2_G1___2 = 896,
	FN_DU1_DR4___5 = 897,
	FN_VI2_G2___2 = 898,
	FN_DU1_DR5___5 = 899,
	FN_VI2_G3___2 = 900,
	FN_DU1_DR6___5 = 901,
	FN_VI2_G4___2 = 902,
	FN_DU1_DR7___5 = 903,
	FN_VI2_G5___2 = 904,
	FN_DU1_DG0___4 = 905,
	FN_VI2_DATA2_VI2_B2___2 = 906,
	FN_SCL1_B___3 = 907,
	FN_SD3_DAT2___2 = 908,
	FN_SCK3_E = 909,
	FN_AUDATA6___2 = 910,
	FN_TX0_D___4 = 911,
	FN_DU1_DG1___4 = 912,
	FN_VI2_DATA3_VI2_B3___2 = 913,
	FN_SDA1_B___3 = 914,
	FN_SD3_DAT3___2 = 915,
	FN_SCK5 = 916,
	FN_AUDATA7___2 = 917,
	FN_RX0_D___4 = 918,
	FN_DU1_DG2___5 = 919,
	FN_VI2_G6___2 = 920,
	FN_DU1_DG3___5 = 921,
	FN_VI2_G7___2 = 922,
	FN_DU1_DG4___5 = 923,
	FN_VI2_R0___2 = 924,
	FN_DU1_DG5___5 = 925,
	FN_VI2_R1___2 = 926,
	FN_DU1_DG6___5 = 927,
	FN_VI2_R2___2 = 928,
	FN_DU1_DG7___5 = 929,
	FN_VI2_R3___2 = 930,
	FN_DU1_DB0___4 = 931,
	FN_VI2_DATA4_VI2_B4___2 = 932,
	FN_SCL2_B___3 = 933,
	FN_SD3_DAT0___2 = 934,
	FN_TX5___2 = 935,
	FN_SCK0_D = 936,
	FN_DU1_DB1___4 = 937,
	FN_VI2_DATA5_VI2_B5___2 = 938,
	FN_SDA2_B___3 = 939,
	FN_SD3_DAT1___2 = 940,
	FN_RX5___2 = 941,
	FN_RTS0_D_TANS_D = 942,
	FN_DU1_DB2___5 = 943,
	FN_VI2_R4___2 = 944,
	FN_DU1_DB3___5 = 945,
	FN_VI2_R5___2 = 946,
	FN_DU1_DB4___5 = 947,
	FN_VI2_R6___2 = 948,
	FN_DU1_DB5___5 = 949,
	FN_VI2_R7___2 = 950,
	FN_DU1_DB6___5 = 951,
	FN_SCL2_D___2 = 952,
	FN_DU1_DB7___5 = 953,
	FN_SDA2_D___2 = 954,
	FN_DU1_DOTCLKIN___5 = 955,
	FN_VI2_CLKENB___3 = 956,
	FN_HSPI_CS1 = 957,
	FN_SCL1_D___2 = 958,
	FN_DU1_DOTCLKOUT___3 = 959,
	FN_VI2_FIELD___3 = 960,
	FN_SDA1_D___2 = 961,
	FN_DU1_EXHSYNC_DU1_HSYNC___5 = 962,
	FN_VI2_HSYNC = 963,
	FN_VI3_HSYNC = 964,
	FN_DU1_EXVSYNC_DU1_VSYNC___5 = 965,
	FN_VI2_VSYNC = 966,
	FN_VI3_VSYNC = 967,
	FN_DU1_EXODDF_DU1_ODDF_DISP_CDE___5 = 968,
	FN_VI2_CLK___3 = 969,
	FN_TX3_B_IRDA_TX_B = 970,
	FN_SD3_CD___2 = 971,
	FN_HSPI_TX1 = 972,
	FN_VI1_CLKENB___6 = 973,
	FN_VI3_CLKENB___2 = 974,
	FN_AUDIO_CLKC___5 = 975,
	FN_TX2_D___2 = 976,
	FN_SPEEDIN___5 = 977,
	FN_GPS_SIGN_D___2 = 978,
	FN_DU1_DISP___5 = 979,
	FN_VI2_DATA6_VI2_B6___2 = 980,
	FN_TCLK0___2 = 981,
	FN_QSTVA_B_QVS_B = 982,
	FN_HSPI_CLK1 = 983,
	FN_SCK2_D = 984,
	FN_AUDIO_CLKOUT_B___5 = 985,
	FN_GPS_MAG_D___2 = 986,
	FN_DU1_CDE___5 = 987,
	FN_VI2_DATA7_VI2_B7___2 = 988,
	FN_RX3_B_IRDA_RX_B = 989,
	FN_SD3_WP___2 = 990,
	FN_HSPI_RX1 = 991,
	FN_VI1_FIELD___6 = 992,
	FN_VI3_FIELD___2 = 993,
	FN_AUDIO_CLKOUT___4 = 994,
	FN_RX2_D___2 = 995,
	FN_GPS_CLK_C___2 = 996,
	FN_GPS_CLK_D___2 = 997,
	FN_AUDIO_CLKA___5 = 998,
	FN_CAN_TXCLK___2 = 999,
	FN_AUDIO_CLKB___5 = 1000,
	FN_USB_OVC2 = 1001,
	FN_CAN_DEBUGOUT0___2 = 1002,
	FN_MOUT0___2 = 1003,
	FN_SSI_SCK0129___4 = 1004,
	FN_CAN_DEBUGOUT1___2 = 1005,
	FN_MOUT1___2 = 1006,
	FN_SSI_WS0129___4 = 1007,
	FN_CAN_DEBUGOUT2___2 = 1008,
	FN_MOUT2___2 = 1009,
	FN_SSI_SDATA0___5 = 1010,
	FN_CAN_DEBUGOUT3___2 = 1011,
	FN_MOUT5___2 = 1012,
	FN_SSI_SDATA1___5 = 1013,
	FN_CAN_DEBUGOUT4___2 = 1014,
	FN_MOUT6___2 = 1015,
	FN_SSI_SDATA2___5 = 1016,
	FN_CAN_DEBUGOUT5___2 = 1017,
	FN_SSI_SCK34___6 = 1018,
	FN_CAN_DEBUGOUT6___2 = 1019,
	FN_CAN0_TX_B___6 = 1020,
	FN_IERX___5 = 1021,
	FN_SSI_SCK9_C = 1022,
	FN_SSI_WS34___6 = 1023,
	FN_CAN_DEBUGOUT7___2 = 1024,
	FN_CAN0_RX_B___6 = 1025,
	FN_IETX___5 = 1026,
	FN_SSI_WS9_C = 1027,
	FN_SSI_SDATA3___6 = 1028,
	FN_PWM0_C___3 = 1029,
	FN_CAN_DEBUGOUT8___2 = 1030,
	FN_CAN_CLK_B___6 = 1031,
	FN_IECLK___5 = 1032,
	FN_SCIF_CLK_B___5 = 1033,
	FN_TCLK0_B = 1034,
	FN_SSI_SDATA4___5 = 1035,
	FN_CAN_DEBUGOUT9___2 = 1036,
	FN_SSI_SDATA9_C = 1037,
	FN_SSI_SCK5___5 = 1038,
	FN_ADICLK___5 = 1039,
	FN_CAN_DEBUGOUT10___2 = 1040,
	FN_SCK3 = 1041,
	FN_TCLK0_D = 1042,
	FN_SSI_WS5___5 = 1043,
	FN_ADICS_SAMP___5 = 1044,
	FN_CAN_DEBUGOUT11___2 = 1045,
	FN_TX3_IRDA_TX = 1046,
	FN_SSI_SDATA5___5 = 1047,
	FN_ADIDATA___5 = 1048,
	FN_CAN_DEBUGOUT12___2 = 1049,
	FN_RX3_IRDA_RX = 1050,
	FN_SSI_SCK6___5 = 1051,
	FN_ADICHS0___5 = 1052,
	FN_CAN0_TX___4 = 1053,
	FN_IERX_B___4 = 1054,
	FN_SSI_WS6___5 = 1055,
	FN_ADICHS1___5 = 1056,
	FN_CAN0_RX___4 = 1057,
	FN_IETX_B___4 = 1058,
	FN_SSI_SDATA6___5 = 1059,
	FN_ADICHS2___5 = 1060,
	FN_CAN_CLK___4 = 1061,
	FN_IECLK_B___4 = 1062,
	FN_SSI_SCK78___5 = 1063,
	FN_CAN_DEBUGOUT13___2 = 1064,
	FN_IRQ0_B = 1065,
	FN_SSI_SCK9_B___4 = 1066,
	FN_HSPI_CLK1_C = 1067,
	FN_SSI_WS78___5 = 1068,
	FN_CAN_DEBUGOUT14___2 = 1069,
	FN_IRQ1_B___2 = 1070,
	FN_SSI_WS9_B___4 = 1071,
	FN_HSPI_CS1_C = 1072,
	FN_SSI_SDATA7___5 = 1073,
	FN_CAN_DEBUGOUT15___2 = 1074,
	FN_IRQ2_B___2 = 1075,
	FN_TCLK1_C = 1076,
	FN_HSPI_TX1_C = 1077,
	FN_SSI_SDATA8___5 = 1078,
	FN_VSP___2 = 1079,
	FN_IRQ3_B___2 = 1080,
	FN_HSPI_RX1_C = 1081,
	FN_SD0_CLK___6 = 1082,
	FN_ATACS01___2 = 1083,
	FN_SCK1_B = 1084,
	FN_SD0_CMD___6 = 1085,
	FN_ATACS11___2 = 1086,
	FN_TX1_B___5 = 1087,
	FN_CC5_TDO = 1088,
	FN_SD0_DAT0___4 = 1089,
	FN_ATADIR1___2 = 1090,
	FN_RX1_B___5 = 1091,
	FN_CC5_TRST = 1092,
	FN_SD0_DAT1___4 = 1093,
	FN_ATAG1___2 = 1094,
	FN_SCK2_B___2 = 1095,
	FN_CC5_TMS = 1096,
	FN_SD0_DAT2___4 = 1097,
	FN_ATARD1___2 = 1098,
	FN_TX2_B___5 = 1099,
	FN_CC5_TCK = 1100,
	FN_SD0_DAT3___4 = 1101,
	FN_ATAWR1___2 = 1102,
	FN_RX2_B___5 = 1103,
	FN_CC5_TDI = 1104,
	FN_SD0_CD___6 = 1105,
	FN_DREQ2___2 = 1106,
	FN_RTS1_B_TANS_B = 1107,
	FN_SD0_WP___6 = 1108,
	FN_DACK2___5 = 1109,
	FN_CTS1_B = 1110,
	FN_HSPI_CLK0 = 1111,
	FN_CTS0___2 = 1112,
	FN_USB_OVC0___2 = 1113,
	FN_AD_CLK___2 = 1114,
	FN_CC5_STATE4 = 1115,
	FN_CC5_STATE12 = 1116,
	FN_CC5_STATE20 = 1117,
	FN_CC5_STATE28 = 1118,
	FN_CC5_STATE36 = 1119,
	FN_HSPI_CS0 = 1120,
	FN_RTS0_TANS = 1121,
	FN_USB_OVC1___2 = 1122,
	FN_AD_DI___2 = 1123,
	FN_CC5_STATE5 = 1124,
	FN_CC5_STATE13 = 1125,
	FN_CC5_STATE21 = 1126,
	FN_CC5_STATE29 = 1127,
	FN_CC5_STATE37 = 1128,
	FN_HSPI_TX0___2 = 1129,
	FN_TX0___3 = 1130,
	FN_CAN_DEBUG_HW_TRIGGER___2 = 1131,
	FN_AD_DO___2 = 1132,
	FN_CC5_STATE6 = 1133,
	FN_CC5_STATE14 = 1134,
	FN_CC5_STATE22 = 1135,
	FN_CC5_STATE30 = 1136,
	FN_CC5_STATE38 = 1137,
	FN_HSPI_RX0 = 1138,
	FN_RX0___3 = 1139,
	FN_CAN_STEP0___2 = 1140,
	FN_AD_NCS = 1141,
	FN_CC5_STATE7 = 1142,
	FN_CC5_STATE15 = 1143,
	FN_CC5_STATE23 = 1144,
	FN_CC5_STATE31 = 1145,
	FN_CC5_STATE39 = 1146,
	FN_FMCLK___4 = 1147,
	FN_RDS_CLK = 1148,
	FN_PCMOE = 1149,
	FN_BPFCLK___4 = 1150,
	FN_PCMWE = 1151,
	FN_FMIN___4 = 1152,
	FN_RDS_DATA = 1153,
	FN_VI0_CLK___6 = 1154,
	FN_MMC1_CLK___2 = 1155,
	FN_VI0_CLKENB___6 = 1156,
	FN_TX1_C___5 = 1157,
	FN_HTX1_B___5 = 1158,
	FN_MT1_SYNC = 1159,
	FN_VI0_FIELD___6 = 1160,
	FN_RX1_C___5 = 1161,
	FN_HRX1_B___5 = 1162,
	FN_VI0_HSYNC___2 = 1163,
	FN_VI0_DATA0_B_VI0_B0_B = 1164,
	FN_CTS1_C___2 = 1165,
	FN_TX4_D___2 = 1166,
	FN_MMC1_CMD___2 = 1167,
	FN_HSCK1_B___3 = 1168,
	FN_VI0_VSYNC___2 = 1169,
	FN_VI0_DATA1_B_VI0_B1_B = 1170,
	FN_RTS1_C_TANS_C = 1171,
	FN_RX4_D___2 = 1172,
	FN_PWMFSW0_C = 1173,
	FN_VI0_DATA0_VI0_B0___6 = 1174,
	FN_HRTS1_B___2 = 1175,
	FN_MT1_VCXO = 1176,
	FN_VI0_DATA1_VI0_B1___6 = 1177,
	FN_HCTS1_B___2 = 1178,
	FN_MT1_PWM = 1179,
	FN_VI0_DATA2_VI0_B2___6 = 1180,
	FN_MMC1_D0___2 = 1181,
	FN_VI0_DATA3_VI0_B3___6 = 1182,
	FN_MMC1_D1___2 = 1183,
	FN_VI0_DATA4_VI0_B4___6 = 1184,
	FN_MMC1_D2___2 = 1185,
	FN_VI0_DATA5_VI0_B5___6 = 1186,
	FN_MMC1_D3___2 = 1187,
	FN_VI0_DATA6_VI0_B6___5 = 1188,
	FN_MMC1_D4___2 = 1189,
	FN_ARM_TRACEDATA_0___2 = 1190,
	FN_VI0_DATA7_VI0_B7___5 = 1191,
	FN_MMC1_D5___2 = 1192,
	FN_ARM_TRACEDATA_1___2 = 1193,
	FN_VI0_G0___5 = 1194,
	FN_SSI_SCK78_C___2 = 1195,
	FN_IRQ0___6 = 1196,
	FN_ARM_TRACEDATA_2___2 = 1197,
	FN_VI0_G1___5 = 1198,
	FN_SSI_WS78_C___2 = 1199,
	FN_IRQ1___5 = 1200,
	FN_ARM_TRACEDATA_3___2 = 1201,
	FN_VI0_G2___6 = 1202,
	FN_ETH_TXD1___6 = 1203,
	FN_MMC1_D6___2 = 1204,
	FN_ARM_TRACEDATA_4___2 = 1205,
	FN_TS_SPSYNC0___3 = 1206,
	FN_VI0_G3___6 = 1207,
	FN_ETH_CRS_DV___6 = 1208,
	FN_MMC1_D7___2 = 1209,
	FN_ARM_TRACEDATA_5___2 = 1210,
	FN_TS_SDAT0___2 = 1211,
	FN_VI0_G4___6 = 1212,
	FN_ETH_TX_EN___6 = 1213,
	FN_SD2_DAT0_B___2 = 1214,
	FN_ARM_TRACEDATA_6___2 = 1215,
	FN_VI0_G5___6 = 1216,
	FN_ETH_RX_ER___6 = 1217,
	FN_SD2_DAT1_B___2 = 1218,
	FN_ARM_TRACEDATA_7___2 = 1219,
	FN_VI0_G6___5 = 1220,
	FN_ETH_RXD0___6 = 1221,
	FN_SD2_DAT2_B___2 = 1222,
	FN_ARM_TRACEDATA_8___2 = 1223,
	FN_VI0_G7___5 = 1224,
	FN_ETH_RXD1___6 = 1225,
	FN_SD2_DAT3_B___2 = 1226,
	FN_ARM_TRACEDATA_9___2 = 1227,
	FN_VI0_R0___5 = 1228,
	FN_SSI_SDATA7_C___2 = 1229,
	FN_SCK1_C___2 = 1230,
	FN_DREQ1_B___2 = 1231,
	FN_ARM_TRACEDATA_10___2 = 1232,
	FN_DREQ0_C = 1233,
	FN_VI0_R1___5 = 1234,
	FN_SSI_SDATA8_C___2 = 1235,
	FN_DACK1_B___3 = 1236,
	FN_ARM_TRACEDATA_11___2 = 1237,
	FN_DACK0_C = 1238,
	FN_DRACK0_C = 1239,
	FN_VI0_R2___5 = 1240,
	FN_ETH_LINK___6 = 1241,
	FN_SD2_CLK_B___2 = 1242,
	FN_IRQ2___5 = 1243,
	FN_ARM_TRACEDATA_12___2 = 1244,
	FN_VI0_R3___5 = 1245,
	FN_ETH_MAGIC___6 = 1246,
	FN_SD2_CMD_B___2 = 1247,
	FN_IRQ3___5 = 1248,
	FN_ARM_TRACEDATA_13___2 = 1249,
	FN_VI0_R4___5 = 1250,
	FN_ETH_REFCLK___3 = 1251,
	FN_SD2_CD_B___2 = 1252,
	FN_HSPI_CLK1_B___2 = 1253,
	FN_ARM_TRACEDATA_14___2 = 1254,
	FN_MT1_CLK = 1255,
	FN_TS_SCK0___3 = 1256,
	FN_VI0_R5___5 = 1257,
	FN_ETH_TXD0___6 = 1258,
	FN_SD2_WP_B___2 = 1259,
	FN_HSPI_CS1_B___2 = 1260,
	FN_ARM_TRACEDATA_15___2 = 1261,
	FN_MT1_D = 1262,
	FN_TS_SDEN0___3 = 1263,
	FN_VI0_R6___5 = 1264,
	FN_ETH_MDC___6 = 1265,
	FN_DREQ2_C___2 = 1266,
	FN_HSPI_TX1_B___2 = 1267,
	FN_TRACECLK = 1268,
	FN_MT1_BEN = 1269,
	FN_PWMFSW0_D = 1270,
	FN_VI0_R7___5 = 1271,
	FN_ETH_MDIO___6 = 1272,
	FN_DACK2_C = 1273,
	FN_HSPI_RX1_B___2 = 1274,
	FN_SCIF_CLK_D = 1275,
	FN_TRACECTL = 1276,
	FN_MT1_PEN = 1277,
	FN_VI1_CLK___6 = 1278,
	FN_SIM_D = 1279,
	FN_SDA3 = 1280,
	FN_VI1_HSYNC___2 = 1281,
	FN_VI3_CLK___2 = 1282,
	FN_SSI_SCK4___5 = 1283,
	FN_GPS_SIGN_C___2 = 1284,
	FN_PWMFSW0_E = 1285,
	FN_VI1_VSYNC___2 = 1286,
	FN_AUDIO_CLKOUT_C___4 = 1287,
	FN_SSI_WS4___5 = 1288,
	FN_SIM_CLK = 1289,
	FN_GPS_MAG_C___2 = 1290,
	FN_SPV_TRST = 1291,
	FN_SCL3 = 1292,
	FN_VI1_DATA0_VI1_B0___2 = 1293,
	FN_SD2_DAT0___3 = 1294,
	FN_SIM_RST = 1295,
	FN_SPV_TCK = 1296,
	FN_ADICLK_B___3 = 1297,
	FN_VI1_DATA1_VI1_B1___2 = 1298,
	FN_SD2_DAT1___3 = 1299,
	FN_MT0_CLK = 1300,
	FN_SPV_TMS = 1301,
	FN_ADICS_B_SAMP_B = 1302,
	FN_VI1_DATA2_VI1_B2___2 = 1303,
	FN_SD2_DAT2___3 = 1304,
	FN_MT0_D = 1305,
	FN_SPVTDI = 1306,
	FN_ADIDATA_B___3 = 1307,
	FN_VI1_DATA3_VI1_B3___2 = 1308,
	FN_SD2_DAT3___3 = 1309,
	FN_MT0_BEN = 1310,
	FN_SPV_TDO = 1311,
	FN_ADICHS0_B___3 = 1312,
	FN_VI1_DATA4_VI1_B4___2 = 1313,
	FN_SD2_CLK___5 = 1314,
	FN_MT0_PEN = 1315,
	FN_SPA_TRST = 1316,
	FN_HSPI_CLK1_D = 1317,
	FN_ADICHS1_B___3 = 1318,
	FN_VI1_DATA5_VI1_B5___2 = 1319,
	FN_SD2_CMD___5 = 1320,
	FN_MT0_SYNC = 1321,
	FN_SPA_TCK = 1322,
	FN_HSPI_CS1_D = 1323,
	FN_ADICHS2_B___3 = 1324,
	FN_VI1_DATA6_VI1_B6___2 = 1325,
	FN_SD2_CD___5 = 1326,
	FN_MT0_VCXO = 1327,
	FN_SPA_TMS = 1328,
	FN_HSPI_TX1_D = 1329,
	FN_VI1_DATA7_VI1_B7___2 = 1330,
	FN_SD2_WP___5 = 1331,
	FN_MT0_PWM = 1332,
	FN_SPA_TDI = 1333,
	FN_HSPI_RX1_D = 1334,
	FN_VI1_G0___2 = 1335,
	FN_VI3_DATA0___2 = 1336,
	FN_TS_SCK1___2 = 1337,
	FN_DREQ2_B___3 = 1338,
	FN_TX2___3 = 1339,
	FN_SPA_TDO = 1340,
	FN_HCTS0_B___2 = 1341,
	FN_VI1_G1___2 = 1342,
	FN_VI3_DATA1___2 = 1343,
	FN_SSI_SCK1___4 = 1344,
	FN_TS_SDEN1___2 = 1345,
	FN_DACK2_B___3 = 1346,
	FN_RX2___3 = 1347,
	FN_HRTS0_B___2 = 1348,
	FN_VI1_G2___2 = 1349,
	FN_VI3_DATA2___2 = 1350,
	FN_SSI_WS1___4 = 1351,
	FN_TS_SPSYNC1___2 = 1352,
	FN_SCK2___2 = 1353,
	FN_HSCK0_B = 1354,
	FN_VI1_G3___2 = 1355,
	FN_VI3_DATA3___2 = 1356,
	FN_SSI_SCK2___4 = 1357,
	FN_TS_SDAT1___2 = 1358,
	FN_SCL1_C___2 = 1359,
	FN_HTX0_B___5 = 1360,
	FN_VI1_G4___2 = 1361,
	FN_VI3_DATA4___2 = 1362,
	FN_SSI_WS2___4 = 1363,
	FN_SDA1_C___2 = 1364,
	FN_SIM_RST_B = 1365,
	FN_HRX0_B___5 = 1366,
	FN_VI1_G5___2 = 1367,
	FN_VI3_DATA5___2 = 1368,
	FN_GPS_CLK___3 = 1369,
	FN_FSE = 1370,
	FN_TX4_B___4 = 1371,
	FN_SIM_D_B = 1372,
	FN_VI1_G6___2 = 1373,
	FN_VI3_DATA6___2 = 1374,
	FN_GPS_SIGN___3 = 1375,
	FN_FRB = 1376,
	FN_RX4_B___4 = 1377,
	FN_SIM_CLK_B = 1378,
	FN_VI1_G7___2 = 1379,
	FN_VI3_DATA7___2 = 1380,
	FN_GPS_MAG___3 = 1381,
	FN_FCE = 1382,
	FN_SCK4_B = 1383,
	FN_SEL_SCIF5_0___4 = 1384,
	FN_SEL_SCIF5_1___4 = 1385,
	FN_SEL_SCIF5_2___3 = 1386,
	FN_SEL_SCIF5_3___3 = 1387,
	FN_SEL_SCIF4_0___4 = 1388,
	FN_SEL_SCIF4_1___4 = 1389,
	FN_SEL_SCIF4_2___4 = 1390,
	FN_SEL_SCIF4_3___3 = 1391,
	FN_SEL_SCIF3_0___4 = 1392,
	FN_SEL_SCIF3_1___4 = 1393,
	FN_SEL_SCIF3_2___3 = 1394,
	FN_SEL_SCIF3_3___2 = 1395,
	FN_SEL_SCIF3_4 = 1396,
	FN_SEL_SCIF2_0___5 = 1397,
	FN_SEL_SCIF2_1___5 = 1398,
	FN_SEL_SCIF2_2___4 = 1399,
	FN_SEL_SCIF2_3___2 = 1400,
	FN_SEL_SCIF2_4___2 = 1401,
	FN_SEL_SCIF1_0___5 = 1402,
	FN_SEL_SCIF1_1___5 = 1403,
	FN_SEL_SCIF1_2___5 = 1404,
	FN_SEL_SCIF0_0___5 = 1405,
	FN_SEL_SCIF0_1___5 = 1406,
	FN_SEL_SCIF0_2___4 = 1407,
	FN_SEL_SCIF0_3___4 = 1408,
	FN_SEL_SSI9_0___4 = 1409,
	FN_SEL_SSI9_1___4 = 1410,
	FN_SEL_SSI9_2 = 1411,
	FN_SEL_SSI8_0___5 = 1412,
	FN_SEL_SSI8_1___5 = 1413,
	FN_SEL_SSI8_2___2 = 1414,
	FN_SEL_SSI7_0___5 = 1415,
	FN_SEL_SSI7_1___5 = 1416,
	FN_SEL_SSI7_2___2 = 1417,
	FN_SEL_VI0_0___2 = 1418,
	FN_SEL_VI0_1___2 = 1419,
	FN_SEL_SD2_0 = 1420,
	FN_SEL_SD2_1 = 1421,
	FN_SEL_INT3_0 = 1422,
	FN_SEL_INT3_1 = 1423,
	FN_SEL_INT2_0 = 1424,
	FN_SEL_INT2_1 = 1425,
	FN_SEL_INT1_0 = 1426,
	FN_SEL_INT1_1 = 1427,
	FN_SEL_INT0_0 = 1428,
	FN_SEL_INT0_1 = 1429,
	FN_SEL_IE_0 = 1430,
	FN_SEL_IE_1 = 1431,
	FN_SEL_EXBUS2_0 = 1432,
	FN_SEL_EXBUS2_1 = 1433,
	FN_SEL_EXBUS2_2 = 1434,
	FN_SEL_EXBUS1_0 = 1435,
	FN_SEL_EXBUS1_1 = 1436,
	FN_SEL_EXBUS0_0 = 1437,
	FN_SEL_EXBUS0_1 = 1438,
	FN_SEL_EXBUS0_2 = 1439,
	FN_SEL_TMU1_0___4 = 1440,
	FN_SEL_TMU1_1___4 = 1441,
	FN_SEL_TMU1_2 = 1442,
	FN_SEL_TMU0_0 = 1443,
	FN_SEL_TMU0_1 = 1444,
	FN_SEL_TMU0_2 = 1445,
	FN_SEL_TMU0_3 = 1446,
	FN_SEL_SCIF_0___2 = 1447,
	FN_SEL_SCIF_1___2 = 1448,
	FN_SEL_SCIF_2 = 1449,
	FN_SEL_SCIF_3 = 1450,
	FN_SEL_CANCLK_0___4 = 1451,
	FN_SEL_CANCLK_1___4 = 1452,
	FN_SEL_CANCLK_2___3 = 1453,
	FN_SEL_CAN0_0___5 = 1454,
	FN_SEL_CAN0_1___5 = 1455,
	FN_SEL_HSCIF1_0___5 = 1456,
	FN_SEL_HSCIF1_1___5 = 1457,
	FN_SEL_HSCIF0_0___5 = 1458,
	FN_SEL_HSCIF0_1___5 = 1459,
	FN_SEL_PWMFSW_0 = 1460,
	FN_SEL_PWMFSW_1 = 1461,
	FN_SEL_PWMFSW_2 = 1462,
	FN_SEL_PWMFSW_3 = 1463,
	FN_SEL_PWMFSW_4 = 1464,
	FN_SEL_ADI_0___2 = 1465,
	FN_SEL_ADI_1___2 = 1466,
	FN_SEL_GPS_0___3 = 1467,
	FN_SEL_GPS_1___3 = 1468,
	FN_SEL_GPS_2___3 = 1469,
	FN_SEL_GPS_3___2 = 1470,
	FN_SEL_SIM_0___3 = 1471,
	FN_SEL_SIM_1___3 = 1472,
	FN_SEL_HSPI2_0 = 1473,
	FN_SEL_HSPI2_1 = 1474,
	FN_SEL_HSPI1_0 = 1475,
	FN_SEL_HSPI1_1 = 1476,
	FN_SEL_HSPI1_2 = 1477,
	FN_SEL_HSPI1_3 = 1478,
	FN_SEL_I2C3_0___2 = 1479,
	FN_SEL_I2C3_1___2 = 1480,
	FN_SEL_I2C2_0___3 = 1481,
	FN_SEL_I2C2_1___3 = 1482,
	FN_SEL_I2C2_2___3 = 1483,
	FN_SEL_I2C2_3___3 = 1484,
	FN_SEL_I2C1_0___3 = 1485,
	FN_SEL_I2C1_1___3 = 1486,
	FN_SEL_I2C1_2___3 = 1487,
	FN_SEL_I2C1_3___2 = 1488,
	PINMUX_FUNCTION_END___9 = 1489,
	PINMUX_MARK_BEGIN___9 = 1490,
	AVS1_MARK___3 = 1491,
	AVS2_MARK___3 = 1492,
	A17_MARK___7 = 1493,
	A18_MARK___7 = 1494,
	A19_MARK___7 = 1495,
	RD_WR_MARK___2 = 1496,
	FWE_MARK = 1497,
	ATAG0_MARK = 1498,
	VI1_R7_MARK___2 = 1499,
	HRTS1_MARK = 1500,
	RX4_C_MARK___4 = 1501,
	CS1_A26_MARK___2 = 1502,
	HSPI_TX2_MARK = 1503,
	SDSELF_B_MARK___2 = 1504,
	CS0_MARK___3 = 1505,
	HSPI_CS2_B_MARK___2 = 1506,
	CLKOUT_MARK___3 = 1507,
	TX3C_IRDA_TX_C_MARK = 1508,
	PWM0_B_MARK___6 = 1509,
	A25_MARK___7 = 1510,
	SD1_WP_MARK___5 = 1511,
	MMC0_D5_MARK___3 = 1512,
	FD5_MARK = 1513,
	HSPI_RX2_MARK = 1514,
	VI1_R3_MARK___2 = 1515,
	TX5_B_MARK___4 = 1516,
	SSI_SDATA7_B_MARK___5 = 1517,
	CTS0_B_MARK = 1518,
	A24_MARK___7 = 1519,
	SD1_CD_MARK___5 = 1520,
	MMC0_D4_MARK___3 = 1521,
	FD4_MARK = 1522,
	HSPI_CS2_MARK = 1523,
	VI1_R2_MARK___2 = 1524,
	SSI_WS78_B_MARK___5 = 1525,
	A23_MARK___7 = 1526,
	FCLE_MARK = 1527,
	HSPI_CLK2_MARK = 1528,
	VI1_R1_MARK___2 = 1529,
	A22_MARK___7 = 1530,
	RX5_D_MARK___2 = 1531,
	HSPI_RX2_B_MARK___2 = 1532,
	VI1_R0_MARK___2 = 1533,
	A21_MARK___7 = 1534,
	SCK5_D_MARK = 1535,
	HSPI_CLK2_B_MARK___2 = 1536,
	A20_MARK___7 = 1537,
	TX5_D_MARK___2 = 1538,
	HSPI_TX2_B_MARK___2 = 1539,
	A0_MARK___8 = 1540,
	SD1_DAT3_MARK___2 = 1541,
	MMC0_D3_MARK___2 = 1542,
	FD3_MARK = 1543,
	BS_MARK___4 = 1544,
	SD1_DAT2_MARK___2 = 1545,
	MMC0_D2_MARK___2 = 1546,
	FD2_MARK = 1547,
	ATADIR0_MARK = 1548,
	SDSELF_MARK = 1549,
	HCTS1_MARK = 1550,
	TX4_C_MARK___4 = 1551,
	USB_PENC0_MARK = 1552,
	USB_PENC1_MARK = 1553,
	USB_PENC2_MARK = 1554,
	SCK0_MARK___3 = 1555,
	PWM1_MARK___6 = 1556,
	PWMFSW0_MARK___2 = 1557,
	SCIF_CLK_MARK___5 = 1558,
	TCLK0_C_MARK = 1559,
	EX_CS0_MARK___2 = 1560,
	RX3_C_IRDA_RX_C_MARK = 1561,
	MMC0_D6_MARK___3 = 1562,
	FD6_MARK = 1563,
	EX_CS1_MARK___2 = 1564,
	MMC0_D7_MARK___3 = 1565,
	FD7_MARK = 1566,
	EX_CS2_MARK___2 = 1567,
	SD1_CLK_MARK___4 = 1568,
	MMC0_CLK_MARK___2 = 1569,
	FALE_MARK = 1570,
	ATACS00_MARK___2 = 1571,
	EX_CS3_MARK___2 = 1572,
	SD1_CMD_MARK___4 = 1573,
	MMC0_CMD_MARK___2 = 1574,
	FRE_MARK = 1575,
	ATACS10_MARK___2 = 1576,
	VI1_R4_MARK___2 = 1577,
	RX5_B_MARK___4 = 1578,
	HSCK1_MARK___4 = 1579,
	SSI_SDATA8_B_MARK___5 = 1580,
	RTS0_B_TANS_B_MARK = 1581,
	SSI_SDATA9_MARK___4 = 1582,
	EX_CS4_MARK___2 = 1583,
	SD1_DAT0_MARK___2 = 1584,
	MMC0_D0_MARK___2 = 1585,
	FD0_MARK = 1586,
	ATARD0_MARK___2 = 1587,
	VI1_R5_MARK___2 = 1588,
	SCK5_B_MARK = 1589,
	HTX1_MARK___3 = 1590,
	TX2_E_MARK___3 = 1591,
	TX0_B_MARK___5 = 1592,
	SSI_SCK9_MARK___4 = 1593,
	EX_CS5_MARK___2 = 1594,
	SD1_DAT1_MARK___2 = 1595,
	MMC0_D1_MARK___2 = 1596,
	FD1_MARK = 1597,
	ATAWR0_MARK = 1598,
	VI1_R6_MARK___2 = 1599,
	HRX1_MARK___3 = 1600,
	RX2_E_MARK___3 = 1601,
	RX0_B_MARK___5 = 1602,
	SSI_WS9_MARK___4 = 1603,
	MLB_CLK_MARK___5 = 1604,
	PWM2_MARK___5 = 1605,
	SCK4_MARK = 1606,
	MLB_SIG_MARK___5 = 1607,
	PWM3_MARK___5 = 1608,
	TX4_MARK___2 = 1609,
	MLB_DAT_MARK___5 = 1610,
	PWM4_MARK___5 = 1611,
	RX4_MARK___2 = 1612,
	HTX0_MARK___3 = 1613,
	TX1_MARK___3 = 1614,
	SDATA_MARK___2 = 1615,
	CTS0_C_MARK = 1616,
	SUB_TCK_MARK___2 = 1617,
	CC5_STATE2_MARK = 1618,
	CC5_STATE10_MARK = 1619,
	CC5_STATE18_MARK = 1620,
	CC5_STATE26_MARK = 1621,
	CC5_STATE34_MARK = 1622,
	HRX0_MARK___3 = 1623,
	RX1_MARK___3 = 1624,
	SCKZ_MARK___2 = 1625,
	RTS0_C_TANS_C_MARK = 1626,
	SUB_TDI_MARK___2 = 1627,
	CC5_STATE3_MARK = 1628,
	CC5_STATE11_MARK = 1629,
	CC5_STATE19_MARK = 1630,
	CC5_STATE27_MARK = 1631,
	CC5_STATE35_MARK = 1632,
	HSCK0_MARK___5 = 1633,
	SCK1_MARK___2 = 1634,
	MTS_MARK = 1635,
	PWM5_MARK___5 = 1636,
	SCK0_C_MARK = 1637,
	SSI_SDATA9_B_MARK___4 = 1638,
	SUB_TDO_MARK___2 = 1639,
	CC5_STATE0_MARK = 1640,
	CC5_STATE8_MARK = 1641,
	CC5_STATE16_MARK = 1642,
	CC5_STATE24_MARK = 1643,
	CC5_STATE32_MARK = 1644,
	HCTS0_MARK = 1645,
	CTS1_MARK = 1646,
	STM_MARK = 1647,
	PWM0_D_MARK = 1648,
	RX0_C_MARK___4 = 1649,
	SCIF_CLK_C_MARK = 1650,
	SUB_TRST_MARK___2 = 1651,
	TCLK1_B_MARK___5 = 1652,
	CC5_OSCOUT_MARK = 1653,
	HRTS0_MARK = 1654,
	RTS1_TANS_MARK = 1655,
	MDATA_MARK___2 = 1656,
	TX0_C_MARK___4 = 1657,
	SUB_TMS_MARK___2 = 1658,
	CC5_STATE1_MARK = 1659,
	CC5_STATE9_MARK = 1660,
	CC5_STATE17_MARK = 1661,
	CC5_STATE25_MARK = 1662,
	CC5_STATE33_MARK = 1663,
	DU0_DR0_MARK___5 = 1664,
	LCDOUT0_MARK___5 = 1665,
	DREQ0_MARK___3 = 1666,
	GPS_CLK_B_MARK___2 = 1667,
	AUDATA0_MARK___2 = 1668,
	TX5_C_MARK___2 = 1669,
	DU0_DR1_MARK___4 = 1670,
	LCDOUT1_MARK___5 = 1671,
	DACK0_MARK___7 = 1672,
	DRACK0_MARK___6 = 1673,
	GPS_SIGN_B_MARK___2 = 1674,
	AUDATA1_MARK___2 = 1675,
	RX5_C_MARK___2 = 1676,
	DU0_DR2_MARK___5 = 1677,
	LCDOUT2_MARK___5 = 1678,
	DU0_DR3_MARK___5 = 1679,
	LCDOUT3_MARK___5 = 1680,
	DU0_DR4_MARK___5 = 1681,
	LCDOUT4_MARK___5 = 1682,
	DU0_DR5_MARK___5 = 1683,
	LCDOUT5_MARK___5 = 1684,
	DU0_DR6_MARK___5 = 1685,
	LCDOUT6_MARK___5 = 1686,
	DU0_DR7_MARK___5 = 1687,
	LCDOUT7_MARK___5 = 1688,
	DU0_DG0_MARK___5 = 1689,
	LCDOUT8_MARK___5 = 1690,
	DREQ1_MARK___3 = 1691,
	SCL2_MARK = 1692,
	AUDATA2_MARK___2 = 1693,
	DU0_DG1_MARK___5 = 1694,
	LCDOUT9_MARK___5 = 1695,
	DACK1_MARK___6 = 1696,
	SDA2_MARK = 1697,
	AUDATA3_MARK___2 = 1698,
	DU0_DG2_MARK___5 = 1699,
	LCDOUT10_MARK___5 = 1700,
	DU0_DG3_MARK___5 = 1701,
	LCDOUT11_MARK___5 = 1702,
	DU0_DG4_MARK___5 = 1703,
	LCDOUT12_MARK___5 = 1704,
	DU0_DG5_MARK___5 = 1705,
	LCDOUT13_MARK___5 = 1706,
	DU0_DG6_MARK___5 = 1707,
	LCDOUT14_MARK___5 = 1708,
	DU0_DG7_MARK___5 = 1709,
	LCDOUT15_MARK___5 = 1710,
	DU0_DB0_MARK___5 = 1711,
	LCDOUT16_MARK___5 = 1712,
	EX_WAIT1_MARK___5 = 1713,
	SCL1_MARK = 1714,
	TCLK1_MARK___5 = 1715,
	AUDATA4_MARK___2 = 1716,
	DU0_DB1_MARK___5 = 1717,
	LCDOUT17_MARK___5 = 1718,
	EX_WAIT2_MARK___4 = 1719,
	SDA1_MARK = 1720,
	GPS_MAG_B_MARK___2 = 1721,
	AUDATA5_MARK___2 = 1722,
	SCK5_C_MARK = 1723,
	DU0_DB2_MARK___5 = 1724,
	LCDOUT18_MARK___5 = 1725,
	DU0_DB3_MARK___5 = 1726,
	LCDOUT19_MARK___5 = 1727,
	DU0_DB4_MARK___5 = 1728,
	LCDOUT20_MARK___5 = 1729,
	DU0_DB5_MARK___5 = 1730,
	LCDOUT21_MARK___5 = 1731,
	DU0_DB6_MARK___5 = 1732,
	LCDOUT22_MARK___5 = 1733,
	DU0_DB7_MARK___5 = 1734,
	LCDOUT23_MARK___5 = 1735,
	DU0_DOTCLKIN_MARK___6 = 1736,
	QSTVA_QVS_MARK___5 = 1737,
	TX3_D_IRDA_TX_D_MARK = 1738,
	SCL3_B_MARK___3 = 1739,
	DU0_DOTCLKOUT0_MARK___3 = 1740,
	QCLK_MARK___5 = 1741,
	DU0_DOTCLKOUT1_MARK___3 = 1742,
	QSTVB_QVE_MARK___5 = 1743,
	RX3_D_IRDA_RX_D_MARK = 1744,
	SDA3_B_MARK___3 = 1745,
	SDA2_C_MARK___3 = 1746,
	DACK0_B_MARK___2 = 1747,
	DRACK0_B_MARK = 1748,
	DU0_EXHSYNC_DU0_HSYNC_MARK___4 = 1749,
	QSTH_QHS_MARK___5 = 1750,
	DU0_EXVSYNC_DU0_VSYNC_MARK___4 = 1751,
	QSTB_QHE_MARK___5 = 1752,
	DU0_EXODDF_DU0_ODDF_DISP_CDE_MARK___4 = 1753,
	QCPV_QDE_MARK___5 = 1754,
	CAN1_TX_MARK___4 = 1755,
	TX2_C_MARK___4 = 1756,
	SCL2_C_MARK___3 = 1757,
	REMOCON_MARK___4 = 1758,
	DU0_DISP_MARK___4 = 1759,
	QPOLA_MARK___5 = 1760,
	CAN_CLK_C_MARK___5 = 1761,
	SCK2_C_MARK___2 = 1762,
	DU0_CDE_MARK___5 = 1763,
	QPOLB_MARK___5 = 1764,
	CAN1_RX_MARK___4 = 1765,
	RX2_C_MARK___4 = 1766,
	DREQ0_B_MARK___2 = 1767,
	SSI_SCK78_B_MARK___5 = 1768,
	SCK0_B_MARK = 1769,
	DU1_DR0_MARK___4 = 1770,
	VI2_DATA0_VI2_B0_MARK___2 = 1771,
	PWM6_MARK___5 = 1772,
	SD3_CLK_MARK___2 = 1773,
	TX3_E_IRDA_TX_E_MARK = 1774,
	AUDCK_MARK___2 = 1775,
	PWMFSW0_B_MARK = 1776,
	DU1_DR1_MARK___4 = 1777,
	VI2_DATA1_VI2_B1_MARK___2 = 1778,
	PWM0_MARK___5 = 1779,
	SD3_CMD_MARK___2 = 1780,
	RX3_E_IRDA_RX_E_MARK = 1781,
	AUDSYNC_MARK___2 = 1782,
	CTS0_D_MARK = 1783,
	DU1_DR2_MARK___5 = 1784,
	VI2_G0_MARK___2 = 1785,
	DU1_DR3_MARK___5 = 1786,
	VI2_G1_MARK___2 = 1787,
	DU1_DR4_MARK___5 = 1788,
	VI2_G2_MARK___2 = 1789,
	DU1_DR5_MARK___5 = 1790,
	VI2_G3_MARK___2 = 1791,
	DU1_DR6_MARK___5 = 1792,
	VI2_G4_MARK___2 = 1793,
	DU1_DR7_MARK___5 = 1794,
	VI2_G5_MARK___2 = 1795,
	DU1_DG0_MARK___4 = 1796,
	VI2_DATA2_VI2_B2_MARK___2 = 1797,
	SCL1_B_MARK___3 = 1798,
	SD3_DAT2_MARK___2 = 1799,
	SCK3_E_MARK = 1800,
	AUDATA6_MARK___2 = 1801,
	TX0_D_MARK___4 = 1802,
	DU1_DG1_MARK___4 = 1803,
	VI2_DATA3_VI2_B3_MARK___2 = 1804,
	SDA1_B_MARK___3 = 1805,
	SD3_DAT3_MARK___2 = 1806,
	SCK5_MARK = 1807,
	AUDATA7_MARK___2 = 1808,
	RX0_D_MARK___4 = 1809,
	DU1_DG2_MARK___5 = 1810,
	VI2_G6_MARK___2 = 1811,
	DU1_DG3_MARK___5 = 1812,
	VI2_G7_MARK___2 = 1813,
	DU1_DG4_MARK___5 = 1814,
	VI2_R0_MARK___2 = 1815,
	DU1_DG5_MARK___5 = 1816,
	VI2_R1_MARK___2 = 1817,
	DU1_DG6_MARK___5 = 1818,
	VI2_R2_MARK___2 = 1819,
	DU1_DG7_MARK___5 = 1820,
	VI2_R3_MARK___2 = 1821,
	DU1_DB0_MARK___4 = 1822,
	VI2_DATA4_VI2_B4_MARK___2 = 1823,
	SCL2_B_MARK___3 = 1824,
	SD3_DAT0_MARK___2 = 1825,
	TX5_MARK___2 = 1826,
	SCK0_D_MARK = 1827,
	DU1_DB1_MARK___4 = 1828,
	VI2_DATA5_VI2_B5_MARK___2 = 1829,
	SDA2_B_MARK___3 = 1830,
	SD3_DAT1_MARK___2 = 1831,
	RX5_MARK___2 = 1832,
	RTS0_D_TANS_D_MARK = 1833,
	DU1_DB2_MARK___5 = 1834,
	VI2_R4_MARK___2 = 1835,
	DU1_DB3_MARK___5 = 1836,
	VI2_R5_MARK___2 = 1837,
	DU1_DB4_MARK___5 = 1838,
	VI2_R6_MARK___2 = 1839,
	DU1_DB5_MARK___5 = 1840,
	VI2_R7_MARK___2 = 1841,
	DU1_DB6_MARK___5 = 1842,
	SCL2_D_MARK___2 = 1843,
	DU1_DB7_MARK___5 = 1844,
	SDA2_D_MARK___2 = 1845,
	DU1_DOTCLKIN_MARK___5 = 1846,
	VI2_CLKENB_MARK___3 = 1847,
	HSPI_CS1_MARK = 1848,
	SCL1_D_MARK___2 = 1849,
	DU1_DOTCLKOUT_MARK___3 = 1850,
	VI2_FIELD_MARK___3 = 1851,
	SDA1_D_MARK___2 = 1852,
	DU1_EXHSYNC_DU1_HSYNC_MARK___5 = 1853,
	VI2_HSYNC_MARK = 1854,
	VI3_HSYNC_MARK = 1855,
	DU1_EXVSYNC_DU1_VSYNC_MARK___5 = 1856,
	VI2_VSYNC_MARK = 1857,
	VI3_VSYNC_MARK = 1858,
	DU1_EXODDF_DU1_ODDF_DISP_CDE_MARK___5 = 1859,
	VI2_CLK_MARK___3 = 1860,
	TX3_B_IRDA_TX_B_MARK = 1861,
	SD3_CD_MARK___2 = 1862,
	HSPI_TX1_MARK = 1863,
	VI1_CLKENB_MARK___6 = 1864,
	VI3_CLKENB_MARK___2 = 1865,
	AUDIO_CLKC_MARK___5 = 1866,
	TX2_D_MARK___2 = 1867,
	SPEEDIN_MARK___5 = 1868,
	GPS_SIGN_D_MARK___2 = 1869,
	DU1_DISP_MARK___5 = 1870,
	VI2_DATA6_VI2_B6_MARK___2 = 1871,
	TCLK0_MARK___2 = 1872,
	QSTVA_B_QVS_B_MARK = 1873,
	HSPI_CLK1_MARK = 1874,
	SCK2_D_MARK = 1875,
	AUDIO_CLKOUT_B_MARK___5 = 1876,
	GPS_MAG_D_MARK___2 = 1877,
	DU1_CDE_MARK___5 = 1878,
	VI2_DATA7_VI2_B7_MARK___2 = 1879,
	RX3_B_IRDA_RX_B_MARK = 1880,
	SD3_WP_MARK___2 = 1881,
	HSPI_RX1_MARK = 1882,
	VI1_FIELD_MARK___6 = 1883,
	VI3_FIELD_MARK___2 = 1884,
	AUDIO_CLKOUT_MARK___4 = 1885,
	RX2_D_MARK___2 = 1886,
	GPS_CLK_C_MARK___2 = 1887,
	GPS_CLK_D_MARK___2 = 1888,
	AUDIO_CLKA_MARK___5 = 1889,
	CAN_TXCLK_MARK___3 = 1890,
	AUDIO_CLKB_MARK___5 = 1891,
	USB_OVC2_MARK = 1892,
	CAN_DEBUGOUT0_MARK___2 = 1893,
	MOUT0_MARK___2 = 1894,
	SSI_SCK0129_MARK___4 = 1895,
	CAN_DEBUGOUT1_MARK___2 = 1896,
	MOUT1_MARK___2 = 1897,
	SSI_WS0129_MARK___4 = 1898,
	CAN_DEBUGOUT2_MARK___2 = 1899,
	MOUT2_MARK___2 = 1900,
	SSI_SDATA0_MARK___5 = 1901,
	CAN_DEBUGOUT3_MARK___2 = 1902,
	MOUT5_MARK___2 = 1903,
	SSI_SDATA1_MARK___5 = 1904,
	CAN_DEBUGOUT4_MARK___2 = 1905,
	MOUT6_MARK___2 = 1906,
	SSI_SDATA2_MARK___5 = 1907,
	CAN_DEBUGOUT5_MARK___2 = 1908,
	SSI_SCK34_MARK___6 = 1909,
	CAN_DEBUGOUT6_MARK___2 = 1910,
	CAN0_TX_B_MARK___6 = 1911,
	IERX_MARK___5 = 1912,
	SSI_SCK9_C_MARK = 1913,
	SSI_WS34_MARK___6 = 1914,
	CAN_DEBUGOUT7_MARK___2 = 1915,
	CAN0_RX_B_MARK___6 = 1916,
	IETX_MARK___5 = 1917,
	SSI_WS9_C_MARK = 1918,
	SSI_SDATA3_MARK___6 = 1919,
	PWM0_C_MARK___3 = 1920,
	CAN_DEBUGOUT8_MARK___2 = 1921,
	CAN_CLK_B_MARK___6 = 1922,
	IECLK_MARK___5 = 1923,
	SCIF_CLK_B_MARK___5 = 1924,
	TCLK0_B_MARK = 1925,
	SSI_SDATA4_MARK___5 = 1926,
	CAN_DEBUGOUT9_MARK___2 = 1927,
	SSI_SDATA9_C_MARK = 1928,
	SSI_SCK5_MARK___5 = 1929,
	ADICLK_MARK___5 = 1930,
	CAN_DEBUGOUT10_MARK___2 = 1931,
	SCK3_MARK = 1932,
	TCLK0_D_MARK = 1933,
	SSI_WS5_MARK___5 = 1934,
	ADICS_SAMP_MARK___5 = 1935,
	CAN_DEBUGOUT11_MARK___2 = 1936,
	TX3_IRDA_TX_MARK = 1937,
	SSI_SDATA5_MARK___5 = 1938,
	ADIDATA_MARK___5 = 1939,
	CAN_DEBUGOUT12_MARK___2 = 1940,
	RX3_IRDA_RX_MARK = 1941,
	SSI_SCK6_MARK___5 = 1942,
	ADICHS0_MARK___5 = 1943,
	CAN0_TX_MARK___4 = 1944,
	IERX_B_MARK___4 = 1945,
	SSI_WS6_MARK___5 = 1946,
	ADICHS1_MARK___5 = 1947,
	CAN0_RX_MARK___4 = 1948,
	IETX_B_MARK___4 = 1949,
	SSI_SDATA6_MARK___5 = 1950,
	ADICHS2_MARK___5 = 1951,
	CAN_CLK_MARK___4 = 1952,
	IECLK_B_MARK___4 = 1953,
	SSI_SCK78_MARK___5 = 1954,
	CAN_DEBUGOUT13_MARK___2 = 1955,
	IRQ0_B_MARK = 1956,
	SSI_SCK9_B_MARK___4 = 1957,
	HSPI_CLK1_C_MARK = 1958,
	SSI_WS78_MARK___5 = 1959,
	CAN_DEBUGOUT14_MARK___2 = 1960,
	IRQ1_B_MARK___2 = 1961,
	SSI_WS9_B_MARK___4 = 1962,
	HSPI_CS1_C_MARK = 1963,
	SSI_SDATA7_MARK___5 = 1964,
	CAN_DEBUGOUT15_MARK___2 = 1965,
	IRQ2_B_MARK___2 = 1966,
	TCLK1_C_MARK = 1967,
	HSPI_TX1_C_MARK = 1968,
	SSI_SDATA8_MARK___5 = 1969,
	VSP_MARK___2 = 1970,
	IRQ3_B_MARK___2 = 1971,
	HSPI_RX1_C_MARK = 1972,
	SD0_CLK_MARK___6 = 1973,
	ATACS01_MARK___2 = 1974,
	SCK1_B_MARK = 1975,
	SD0_CMD_MARK___6 = 1976,
	ATACS11_MARK___2 = 1977,
	TX1_B_MARK___5 = 1978,
	CC5_TDO_MARK = 1979,
	SD0_DAT0_MARK___4 = 1980,
	ATADIR1_MARK___2 = 1981,
	RX1_B_MARK___5 = 1982,
	CC5_TRST_MARK = 1983,
	SD0_DAT1_MARK___4 = 1984,
	ATAG1_MARK___2 = 1985,
	SCK2_B_MARK___2 = 1986,
	CC5_TMS_MARK = 1987,
	SD0_DAT2_MARK___4 = 1988,
	ATARD1_MARK___2 = 1989,
	TX2_B_MARK___5 = 1990,
	CC5_TCK_MARK = 1991,
	SD0_DAT3_MARK___4 = 1992,
	ATAWR1_MARK___2 = 1993,
	RX2_B_MARK___5 = 1994,
	CC5_TDI_MARK = 1995,
	SD0_CD_MARK___6 = 1996,
	DREQ2_MARK___2 = 1997,
	RTS1_B_TANS_B_MARK = 1998,
	SD0_WP_MARK___6 = 1999,
	DACK2_MARK___5 = 2000,
	CTS1_B_MARK = 2001,
	HSPI_CLK0_MARK = 2002,
	CTS0_MARK___2 = 2003,
	USB_OVC0_MARK___2 = 2004,
	AD_CLK_MARK___2 = 2005,
	CC5_STATE4_MARK = 2006,
	CC5_STATE12_MARK = 2007,
	CC5_STATE20_MARK = 2008,
	CC5_STATE28_MARK = 2009,
	CC5_STATE36_MARK = 2010,
	HSPI_CS0_MARK = 2011,
	RTS0_TANS_MARK = 2012,
	USB_OVC1_MARK___2 = 2013,
	AD_DI_MARK___2 = 2014,
	CC5_STATE5_MARK = 2015,
	CC5_STATE13_MARK = 2016,
	CC5_STATE21_MARK = 2017,
	CC5_STATE29_MARK = 2018,
	CC5_STATE37_MARK = 2019,
	HSPI_TX0_MARK___2 = 2020,
	TX0_MARK___3 = 2021,
	CAN_DEBUG_HW_TRIGGER_MARK___2 = 2022,
	AD_DO_MARK___2 = 2023,
	CC5_STATE6_MARK = 2024,
	CC5_STATE14_MARK = 2025,
	CC5_STATE22_MARK = 2026,
	CC5_STATE30_MARK = 2027,
	CC5_STATE38_MARK = 2028,
	HSPI_RX0_MARK = 2029,
	RX0_MARK___3 = 2030,
	CAN_STEP0_MARK___2 = 2031,
	AD_NCS_MARK = 2032,
	CC5_STATE7_MARK = 2033,
	CC5_STATE15_MARK = 2034,
	CC5_STATE23_MARK = 2035,
	CC5_STATE31_MARK = 2036,
	CC5_STATE39_MARK = 2037,
	FMCLK_MARK___4 = 2038,
	RDS_CLK_MARK = 2039,
	PCMOE_MARK = 2040,
	BPFCLK_MARK___4 = 2041,
	PCMWE_MARK = 2042,
	FMIN_MARK___4 = 2043,
	RDS_DATA_MARK = 2044,
	VI0_CLK_MARK___6 = 2045,
	MMC1_CLK_MARK___2 = 2046,
	VI0_CLKENB_MARK___6 = 2047,
	TX1_C_MARK___5 = 2048,
	HTX1_B_MARK___5 = 2049,
	MT1_SYNC_MARK = 2050,
	VI0_FIELD_MARK___6 = 2051,
	RX1_C_MARK___5 = 2052,
	HRX1_B_MARK___5 = 2053,
	VI0_HSYNC_MARK___2 = 2054,
	VI0_DATA0_B_VI0_B0_B_MARK = 2055,
	CTS1_C_MARK___2 = 2056,
	TX4_D_MARK___2 = 2057,
	MMC1_CMD_MARK___2 = 2058,
	HSCK1_B_MARK___3 = 2059,
	VI0_VSYNC_MARK___2 = 2060,
	VI0_DATA1_B_VI0_B1_B_MARK = 2061,
	RTS1_C_TANS_C_MARK = 2062,
	RX4_D_MARK___2 = 2063,
	PWMFSW0_C_MARK = 2064,
	VI0_DATA0_VI0_B0_MARK___6 = 2065,
	HRTS1_B_MARK___2 = 2066,
	MT1_VCXO_MARK = 2067,
	VI0_DATA1_VI0_B1_MARK___6 = 2068,
	HCTS1_B_MARK___2 = 2069,
	MT1_PWM_MARK = 2070,
	VI0_DATA2_VI0_B2_MARK___6 = 2071,
	MMC1_D0_MARK___2 = 2072,
	VI0_DATA3_VI0_B3_MARK___6 = 2073,
	MMC1_D1_MARK___2 = 2074,
	VI0_DATA4_VI0_B4_MARK___6 = 2075,
	MMC1_D2_MARK___2 = 2076,
	VI0_DATA5_VI0_B5_MARK___6 = 2077,
	MMC1_D3_MARK___2 = 2078,
	VI0_DATA6_VI0_B6_MARK___5 = 2079,
	MMC1_D4_MARK___2 = 2080,
	ARM_TRACEDATA_0_MARK___2 = 2081,
	VI0_DATA7_VI0_B7_MARK___5 = 2082,
	MMC1_D5_MARK___2 = 2083,
	ARM_TRACEDATA_1_MARK___2 = 2084,
	VI0_G0_MARK___5 = 2085,
	SSI_SCK78_C_MARK___2 = 2086,
	IRQ0_MARK___7 = 2087,
	ARM_TRACEDATA_2_MARK___2 = 2088,
	VI0_G1_MARK___5 = 2089,
	SSI_WS78_C_MARK___2 = 2090,
	IRQ1_MARK___7 = 2091,
	ARM_TRACEDATA_3_MARK___2 = 2092,
	VI0_G2_MARK___6 = 2093,
	ETH_TXD1_MARK___6 = 2094,
	MMC1_D6_MARK___2 = 2095,
	ARM_TRACEDATA_4_MARK___2 = 2096,
	TS_SPSYNC0_MARK___3 = 2097,
	VI0_G3_MARK___6 = 2098,
	ETH_CRS_DV_MARK___6 = 2099,
	MMC1_D7_MARK___2 = 2100,
	ARM_TRACEDATA_5_MARK___2 = 2101,
	TS_SDAT0_MARK___2 = 2102,
	VI0_G4_MARK___6 = 2103,
	ETH_TX_EN_MARK___6 = 2104,
	SD2_DAT0_B_MARK___2 = 2105,
	ARM_TRACEDATA_6_MARK___2 = 2106,
	VI0_G5_MARK___6 = 2107,
	ETH_RX_ER_MARK___6 = 2108,
	SD2_DAT1_B_MARK___2 = 2109,
	ARM_TRACEDATA_7_MARK___2 = 2110,
	VI0_G6_MARK___5 = 2111,
	ETH_RXD0_MARK___6 = 2112,
	SD2_DAT2_B_MARK___2 = 2113,
	ARM_TRACEDATA_8_MARK___2 = 2114,
	VI0_G7_MARK___5 = 2115,
	ETH_RXD1_MARK___6 = 2116,
	SD2_DAT3_B_MARK___2 = 2117,
	ARM_TRACEDATA_9_MARK___2 = 2118,
	VI0_R0_MARK___5 = 2119,
	SSI_SDATA7_C_MARK___2 = 2120,
	SCK1_C_MARK___2 = 2121,
	DREQ1_B_MARK___2 = 2122,
	ARM_TRACEDATA_10_MARK___2 = 2123,
	DREQ0_C_MARK = 2124,
	VI0_R1_MARK___5 = 2125,
	SSI_SDATA8_C_MARK___2 = 2126,
	DACK1_B_MARK___3 = 2127,
	ARM_TRACEDATA_11_MARK___2 = 2128,
	DACK0_C_MARK = 2129,
	DRACK0_C_MARK = 2130,
	VI0_R2_MARK___5 = 2131,
	ETH_LINK_MARK___6 = 2132,
	SD2_CLK_B_MARK___2 = 2133,
	IRQ2_MARK___6 = 2134,
	ARM_TRACEDATA_12_MARK___2 = 2135,
	VI0_R3_MARK___5 = 2136,
	ETH_MAGIC_MARK___6 = 2137,
	SD2_CMD_B_MARK___2 = 2138,
	IRQ3_MARK___6 = 2139,
	ARM_TRACEDATA_13_MARK___2 = 2140,
	VI0_R4_MARK___5 = 2141,
	ETH_REFCLK_MARK___3 = 2142,
	SD2_CD_B_MARK___2 = 2143,
	HSPI_CLK1_B_MARK___2 = 2144,
	ARM_TRACEDATA_14_MARK___2 = 2145,
	MT1_CLK_MARK = 2146,
	TS_SCK0_MARK___3 = 2147,
	VI0_R5_MARK___5 = 2148,
	ETH_TXD0_MARK___6 = 2149,
	SD2_WP_B_MARK___2 = 2150,
	HSPI_CS1_B_MARK___2 = 2151,
	ARM_TRACEDATA_15_MARK___2 = 2152,
	MT1_D_MARK = 2153,
	TS_SDEN0_MARK___3 = 2154,
	VI0_R6_MARK___5 = 2155,
	ETH_MDC_MARK___6 = 2156,
	DREQ2_C_MARK___2 = 2157,
	HSPI_TX1_B_MARK___2 = 2158,
	TRACECLK_MARK = 2159,
	MT1_BEN_MARK = 2160,
	PWMFSW0_D_MARK = 2161,
	VI0_R7_MARK___5 = 2162,
	ETH_MDIO_MARK___6 = 2163,
	DACK2_C_MARK = 2164,
	HSPI_RX1_B_MARK___2 = 2165,
	SCIF_CLK_D_MARK = 2166,
	TRACECTL_MARK = 2167,
	MT1_PEN_MARK = 2168,
	VI1_CLK_MARK___6 = 2169,
	SIM_D_MARK = 2170,
	SDA3_MARK = 2171,
	VI1_HSYNC_MARK___2 = 2172,
	VI3_CLK_MARK___2 = 2173,
	SSI_SCK4_MARK___5 = 2174,
	GPS_SIGN_C_MARK___2 = 2175,
	PWMFSW0_E_MARK = 2176,
	VI1_VSYNC_MARK___2 = 2177,
	AUDIO_CLKOUT_C_MARK___4 = 2178,
	SSI_WS4_MARK___5 = 2179,
	SIM_CLK_MARK___2 = 2180,
	GPS_MAG_C_MARK___2 = 2181,
	SPV_TRST_MARK = 2182,
	SCL3_MARK = 2183,
	VI1_DATA0_VI1_B0_MARK___2 = 2184,
	SD2_DAT0_MARK___3 = 2185,
	SIM_RST_MARK___2 = 2186,
	SPV_TCK_MARK = 2187,
	ADICLK_B_MARK___3 = 2188,
	VI1_DATA1_VI1_B1_MARK___2 = 2189,
	SD2_DAT1_MARK___3 = 2190,
	MT0_CLK_MARK = 2191,
	SPV_TMS_MARK = 2192,
	ADICS_B_SAMP_B_MARK = 2193,
	VI1_DATA2_VI1_B2_MARK___2 = 2194,
	SD2_DAT2_MARK___3 = 2195,
	MT0_D_MARK = 2196,
	SPVTDI_MARK = 2197,
	ADIDATA_B_MARK___3 = 2198,
	VI1_DATA3_VI1_B3_MARK___2 = 2199,
	SD2_DAT3_MARK___3 = 2200,
	MT0_BEN_MARK = 2201,
	SPV_TDO_MARK = 2202,
	ADICHS0_B_MARK___3 = 2203,
	VI1_DATA4_VI1_B4_MARK___2 = 2204,
	SD2_CLK_MARK___5 = 2205,
	MT0_PEN_MARK = 2206,
	SPA_TRST_MARK = 2207,
	HSPI_CLK1_D_MARK = 2208,
	ADICHS1_B_MARK___3 = 2209,
	VI1_DATA5_VI1_B5_MARK___2 = 2210,
	SD2_CMD_MARK___5 = 2211,
	MT0_SYNC_MARK = 2212,
	SPA_TCK_MARK = 2213,
	HSPI_CS1_D_MARK = 2214,
	ADICHS2_B_MARK___3 = 2215,
	VI1_DATA6_VI1_B6_MARK___2 = 2216,
	SD2_CD_MARK___5 = 2217,
	MT0_VCXO_MARK = 2218,
	SPA_TMS_MARK = 2219,
	HSPI_TX1_D_MARK = 2220,
	VI1_DATA7_VI1_B7_MARK___2 = 2221,
	SD2_WP_MARK___5 = 2222,
	MT0_PWM_MARK = 2223,
	SPA_TDI_MARK = 2224,
	HSPI_RX1_D_MARK = 2225,
	VI1_G0_MARK___2 = 2226,
	VI3_DATA0_MARK___2 = 2227,
	TS_SCK1_MARK___2 = 2228,
	DREQ2_B_MARK___3 = 2229,
	TX2_MARK___3 = 2230,
	SPA_TDO_MARK = 2231,
	HCTS0_B_MARK___2 = 2232,
	VI1_G1_MARK___2 = 2233,
	VI3_DATA1_MARK___2 = 2234,
	SSI_SCK1_MARK___4 = 2235,
	TS_SDEN1_MARK___2 = 2236,
	DACK2_B_MARK___3 = 2237,
	RX2_MARK___3 = 2238,
	HRTS0_B_MARK___2 = 2239,
	VI1_G2_MARK___2 = 2240,
	VI3_DATA2_MARK___2 = 2241,
	SSI_WS1_MARK___4 = 2242,
	TS_SPSYNC1_MARK___2 = 2243,
	SCK2_MARK___2 = 2244,
	HSCK0_B_MARK = 2245,
	VI1_G3_MARK___2 = 2246,
	VI3_DATA3_MARK___2 = 2247,
	SSI_SCK2_MARK___4 = 2248,
	TS_SDAT1_MARK___2 = 2249,
	SCL1_C_MARK___2 = 2250,
	HTX0_B_MARK___5 = 2251,
	VI1_G4_MARK___2 = 2252,
	VI3_DATA4_MARK___2 = 2253,
	SSI_WS2_MARK___4 = 2254,
	SDA1_C_MARK___2 = 2255,
	SIM_RST_B_MARK = 2256,
	HRX0_B_MARK___5 = 2257,
	VI1_G5_MARK___2 = 2258,
	VI3_DATA5_MARK___2 = 2259,
	GPS_CLK_MARK___3 = 2260,
	FSE_MARK = 2261,
	TX4_B_MARK___4 = 2262,
	SIM_D_B_MARK = 2263,
	VI1_G6_MARK___2 = 2264,
	VI3_DATA6_MARK___2 = 2265,
	GPS_SIGN_MARK___3 = 2266,
	FRB_MARK___2 = 2267,
	RX4_B_MARK___4 = 2268,
	SIM_CLK_B_MARK = 2269,
	VI1_G7_MARK___2 = 2270,
	VI3_DATA7_MARK___2 = 2271,
	GPS_MAG_MARK___3 = 2272,
	FCE_MARK = 2273,
	SCK4_B_MARK = 2274,
	PINMUX_MARK_END___9 = 2275,
};

union vin_data16 {
	unsigned int data16[16];
	unsigned int data12[12];
	unsigned int data10[10];
	unsigned int data8[8];
};

enum {
	PINMUX_RESERVED___10 = 0,
	PINMUX_DATA_BEGIN___10 = 1,
	GP_0_0_DATA___7 = 2,
	GP_0_1_DATA___7 = 3,
	GP_0_2_DATA___7 = 4,
	GP_0_3_DATA___7 = 5,
	GP_0_4_DATA___7 = 6,
	GP_0_5_DATA___7 = 7,
	GP_0_6_DATA___7 = 8,
	GP_0_7_DATA___7 = 9,
	GP_0_8_DATA___7 = 10,
	GP_0_9_DATA___7 = 11,
	GP_0_10_DATA___7 = 12,
	GP_0_11_DATA___7 = 13,
	GP_0_12_DATA___7 = 14,
	GP_0_13_DATA___7 = 15,
	GP_0_14_DATA___7 = 16,
	GP_0_15_DATA___7 = 17,
	GP_0_16_DATA___7 = 18,
	GP_0_17_DATA___7 = 19,
	GP_0_18_DATA___7 = 20,
	GP_0_19_DATA___7 = 21,
	GP_0_20_DATA___7 = 22,
	GP_0_21_DATA___7 = 23,
	GP_0_22_DATA___7 = 24,
	GP_0_23_DATA___6 = 25,
	GP_0_24_DATA___6 = 26,
	GP_0_25_DATA___6 = 27,
	GP_0_26_DATA___6 = 28,
	GP_0_27_DATA___6 = 29,
	GP_0_28_DATA___6 = 30,
	GP_1_0_DATA___7 = 31,
	GP_1_1_DATA___7 = 32,
	GP_1_2_DATA___7 = 33,
	GP_1_3_DATA___7 = 34,
	GP_1_4_DATA___7 = 35,
	GP_1_5_DATA___7 = 36,
	GP_1_6_DATA___7 = 37,
	GP_1_7_DATA___7 = 38,
	GP_1_8_DATA___7 = 39,
	GP_1_9_DATA___7 = 40,
	GP_1_10_DATA___7 = 41,
	GP_1_11_DATA___7 = 42,
	GP_1_12_DATA___7 = 43,
	GP_1_13_DATA___7 = 44,
	GP_1_14_DATA___7 = 45,
	GP_1_15_DATA___7 = 46,
	GP_1_16_DATA___7 = 47,
	GP_1_17_DATA___7 = 48,
	GP_1_18_DATA___7 = 49,
	GP_1_19_DATA___7 = 50,
	GP_1_20_DATA___7 = 51,
	GP_1_21_DATA___7 = 52,
	GP_1_22_DATA___7 = 53,
	GP_2_0_DATA___7 = 54,
	GP_2_1_DATA___7 = 55,
	GP_2_2_DATA___7 = 56,
	GP_2_3_DATA___7 = 57,
	GP_2_4_DATA___7 = 58,
	GP_2_5_DATA___7 = 59,
	GP_2_6_DATA___7 = 60,
	GP_2_7_DATA___7 = 61,
	GP_2_8_DATA___7 = 62,
	GP_2_9_DATA___7 = 63,
	GP_2_10_DATA___7 = 64,
	GP_2_11_DATA___7 = 65,
	GP_2_12_DATA___7 = 66,
	GP_2_13_DATA___7 = 67,
	GP_2_14_DATA___7 = 68,
	GP_2_15_DATA___7 = 69,
	GP_2_16_DATA___7 = 70,
	GP_2_17_DATA___7 = 71,
	GP_2_18_DATA___7 = 72,
	GP_2_19_DATA___7 = 73,
	GP_2_20_DATA___7 = 74,
	GP_2_21_DATA___7 = 75,
	GP_2_22_DATA___7 = 76,
	GP_2_23_DATA___7 = 77,
	GP_2_24_DATA___7 = 78,
	GP_2_25_DATA___7 = 79,
	GP_2_26_DATA___7 = 80,
	GP_2_27_DATA___7 = 81,
	GP_2_28_DATA___7 = 82,
	GP_2_29_DATA___7 = 83,
	GP_2_30_DATA___6 = 84,
	GP_2_31_DATA___6 = 85,
	GP_3_0_DATA___7 = 86,
	GP_3_1_DATA___7 = 87,
	GP_3_2_DATA___7 = 88,
	GP_3_3_DATA___7 = 89,
	GP_3_4_DATA___7 = 90,
	GP_3_5_DATA___7 = 91,
	GP_3_6_DATA___7 = 92,
	GP_3_7_DATA___7 = 93,
	GP_3_8_DATA___7 = 94,
	GP_3_9_DATA___7 = 95,
	GP_3_10_DATA___7 = 96,
	GP_3_11_DATA___7 = 97,
	GP_3_12_DATA___7 = 98,
	GP_3_13_DATA___7 = 99,
	GP_3_14_DATA___7 = 100,
	GP_3_15_DATA___7 = 101,
	GP_3_16_DATA___7 = 102,
	GP_3_17_DATA___6 = 103,
	GP_3_18_DATA___6 = 104,
	GP_3_19_DATA___6 = 105,
	GP_3_20_DATA___6 = 106,
	GP_3_21_DATA___6 = 107,
	GP_3_22_DATA___6 = 108,
	GP_3_23_DATA___6 = 109,
	GP_3_24_DATA___6 = 110,
	GP_3_25_DATA___6 = 111,
	GP_3_26_DATA___6 = 112,
	GP_3_27_DATA___7 = 113,
	GP_4_0_DATA___7 = 114,
	GP_4_1_DATA___7 = 115,
	GP_4_2_DATA___7 = 116,
	GP_4_3_DATA___7 = 117,
	GP_4_4_DATA___7 = 118,
	GP_4_5_DATA___7 = 119,
	GP_4_6_DATA___7 = 120,
	GP_4_7_DATA___7 = 121,
	GP_4_8_DATA___7 = 122,
	GP_4_9_DATA___7 = 123,
	GP_4_10_DATA___7 = 124,
	GP_4_11_DATA___7 = 125,
	GP_4_12_DATA___7 = 126,
	GP_4_13_DATA___7 = 127,
	GP_4_14_DATA___7 = 128,
	GP_4_15_DATA___7 = 129,
	GP_4_16_DATA___7 = 130,
	GP_5_0_DATA___6 = 131,
	GP_5_1_DATA___6 = 132,
	GP_5_2_DATA___6 = 133,
	GP_5_3_DATA___6 = 134,
	GP_5_4_DATA___6 = 135,
	GP_5_5_DATA___6 = 136,
	GP_5_6_DATA___6 = 137,
	GP_5_7_DATA___6 = 138,
	GP_5_8_DATA___6 = 139,
	GP_5_9_DATA___6 = 140,
	GP_5_10_DATA___6 = 141,
	GP_5_11_DATA___6 = 142,
	GP_5_12_DATA___6 = 143,
	GP_5_13_DATA___6 = 144,
	GP_5_14_DATA___6 = 145,
	GP_5_15_DATA___6 = 146,
	GP_5_16_DATA___6 = 147,
	GP_6_0_DATA___4 = 148,
	GP_6_1_DATA___4 = 149,
	GP_6_2_DATA___4 = 150,
	GP_6_3_DATA___4 = 151,
	GP_6_4_DATA___4 = 152,
	GP_6_5_DATA___4 = 153,
	GP_6_6_DATA___4 = 154,
	GP_6_7_DATA___4 = 155,
	GP_6_8_DATA___4 = 156,
	GP_6_9_DATA___3 = 157,
	GP_6_10_DATA___3 = 158,
	GP_6_11_DATA___3 = 159,
	GP_6_12_DATA___3 = 160,
	GP_6_13_DATA___3 = 161,
	GP_6_14_DATA___3 = 162,
	GP_6_15_DATA___3 = 163,
	GP_6_16_DATA___3 = 164,
	GP_7_0_DATA___2 = 165,
	GP_7_1_DATA___2 = 166,
	GP_7_2_DATA___2 = 167,
	GP_7_3_DATA___2 = 168,
	GP_7_4_DATA___2 = 169,
	GP_7_5_DATA___2 = 170,
	GP_7_6_DATA___2 = 171,
	GP_7_7_DATA___2 = 172,
	GP_7_8_DATA___2 = 173,
	GP_7_9_DATA___2 = 174,
	GP_7_10_DATA___2 = 175,
	GP_7_11_DATA___2 = 176,
	GP_7_12_DATA___2 = 177,
	GP_7_13_DATA___2 = 178,
	GP_7_14_DATA___2 = 179,
	GP_7_15_DATA___2 = 180,
	GP_7_16_DATA___2 = 181,
	GP_8_0_DATA = 182,
	GP_8_1_DATA = 183,
	GP_8_2_DATA = 184,
	GP_8_3_DATA = 185,
	GP_8_4_DATA = 186,
	GP_8_5_DATA = 187,
	GP_8_6_DATA = 188,
	GP_8_7_DATA = 189,
	GP_8_8_DATA = 190,
	GP_8_9_DATA = 191,
	GP_8_10_DATA = 192,
	GP_8_11_DATA = 193,
	GP_8_12_DATA = 194,
	GP_8_13_DATA = 195,
	GP_8_14_DATA = 196,
	GP_8_15_DATA = 197,
	GP_8_16_DATA = 198,
	GP_9_0_DATA = 199,
	GP_9_1_DATA = 200,
	GP_9_2_DATA = 201,
	GP_9_3_DATA = 202,
	GP_9_4_DATA = 203,
	GP_9_5_DATA = 204,
	GP_9_6_DATA = 205,
	GP_9_7_DATA = 206,
	GP_9_8_DATA = 207,
	GP_9_9_DATA = 208,
	GP_9_10_DATA = 209,
	GP_9_11_DATA = 210,
	GP_9_12_DATA = 211,
	GP_9_13_DATA = 212,
	GP_9_14_DATA = 213,
	GP_9_15_DATA = 214,
	GP_9_16_DATA = 215,
	GP_10_0_DATA = 216,
	GP_10_1_DATA = 217,
	GP_10_2_DATA = 218,
	GP_10_3_DATA = 219,
	GP_10_4_DATA = 220,
	GP_10_5_DATA = 221,
	GP_10_6_DATA = 222,
	GP_10_7_DATA = 223,
	GP_10_8_DATA = 224,
	GP_10_9_DATA = 225,
	GP_10_10_DATA = 226,
	GP_10_11_DATA = 227,
	GP_10_12_DATA = 228,
	GP_10_13_DATA = 229,
	GP_10_14_DATA = 230,
	GP_10_15_DATA = 231,
	GP_10_16_DATA = 232,
	GP_10_17_DATA = 233,
	GP_10_18_DATA = 234,
	GP_10_19_DATA = 235,
	GP_10_20_DATA = 236,
	GP_10_21_DATA = 237,
	GP_10_22_DATA = 238,
	GP_10_23_DATA = 239,
	GP_10_24_DATA = 240,
	GP_10_25_DATA = 241,
	GP_10_26_DATA = 242,
	GP_10_27_DATA = 243,
	GP_10_28_DATA = 244,
	GP_10_29_DATA = 245,
	GP_10_30_DATA = 246,
	GP_10_31_DATA = 247,
	GP_11_0_DATA = 248,
	GP_11_1_DATA = 249,
	GP_11_2_DATA = 250,
	GP_11_3_DATA = 251,
	GP_11_4_DATA = 252,
	GP_11_5_DATA = 253,
	GP_11_6_DATA = 254,
	GP_11_7_DATA = 255,
	GP_11_8_DATA = 256,
	GP_11_9_DATA = 257,
	GP_11_10_DATA = 258,
	GP_11_11_DATA = 259,
	GP_11_12_DATA = 260,
	GP_11_13_DATA = 261,
	GP_11_14_DATA = 262,
	GP_11_15_DATA = 263,
	GP_11_16_DATA = 264,
	GP_11_17_DATA = 265,
	GP_11_18_DATA = 266,
	GP_11_19_DATA = 267,
	GP_11_20_DATA = 268,
	GP_11_21_DATA = 269,
	GP_11_22_DATA = 270,
	GP_11_23_DATA = 271,
	GP_11_24_DATA = 272,
	GP_11_25_DATA = 273,
	GP_11_26_DATA = 274,
	GP_11_27_DATA = 275,
	GP_11_28_DATA = 276,
	GP_11_29_DATA = 277,
	PINMUX_DATA_END___10 = 278,
	PINMUX_FUNCTION_BEGIN___10 = 279,
	GP_0_0_FN___7 = 280,
	GP_0_1_FN___7 = 281,
	GP_0_2_FN___7 = 282,
	GP_0_3_FN___7 = 283,
	GP_0_4_FN___7 = 284,
	GP_0_5_FN___7 = 285,
	GP_0_6_FN___7 = 286,
	GP_0_7_FN___7 = 287,
	GP_0_8_FN___7 = 288,
	GP_0_9_FN___7 = 289,
	GP_0_10_FN___7 = 290,
	GP_0_11_FN___7 = 291,
	GP_0_12_FN___7 = 292,
	GP_0_13_FN___7 = 293,
	GP_0_14_FN___7 = 294,
	GP_0_15_FN___7 = 295,
	GP_0_16_FN___7 = 296,
	GP_0_17_FN___7 = 297,
	GP_0_18_FN___7 = 298,
	GP_0_19_FN___7 = 299,
	GP_0_20_FN___7 = 300,
	GP_0_21_FN___7 = 301,
	GP_0_22_FN___7 = 302,
	GP_0_23_FN___6 = 303,
	GP_0_24_FN___6 = 304,
	GP_0_25_FN___6 = 305,
	GP_0_26_FN___6 = 306,
	GP_0_27_FN___6 = 307,
	GP_0_28_FN___6 = 308,
	GP_1_0_FN___7 = 309,
	GP_1_1_FN___7 = 310,
	GP_1_2_FN___7 = 311,
	GP_1_3_FN___7 = 312,
	GP_1_4_FN___7 = 313,
	GP_1_5_FN___7 = 314,
	GP_1_6_FN___7 = 315,
	GP_1_7_FN___7 = 316,
	GP_1_8_FN___7 = 317,
	GP_1_9_FN___7 = 318,
	GP_1_10_FN___7 = 319,
	GP_1_11_FN___7 = 320,
	GP_1_12_FN___7 = 321,
	GP_1_13_FN___7 = 322,
	GP_1_14_FN___7 = 323,
	GP_1_15_FN___7 = 324,
	GP_1_16_FN___7 = 325,
	GP_1_17_FN___7 = 326,
	GP_1_18_FN___7 = 327,
	GP_1_19_FN___7 = 328,
	GP_1_20_FN___7 = 329,
	GP_1_21_FN___7 = 330,
	GP_1_22_FN___7 = 331,
	GP_2_0_FN___7 = 332,
	GP_2_1_FN___7 = 333,
	GP_2_2_FN___7 = 334,
	GP_2_3_FN___7 = 335,
	GP_2_4_FN___7 = 336,
	GP_2_5_FN___7 = 337,
	GP_2_6_FN___7 = 338,
	GP_2_7_FN___7 = 339,
	GP_2_8_FN___7 = 340,
	GP_2_9_FN___7 = 341,
	GP_2_10_FN___7 = 342,
	GP_2_11_FN___7 = 343,
	GP_2_12_FN___7 = 344,
	GP_2_13_FN___7 = 345,
	GP_2_14_FN___7 = 346,
	GP_2_15_FN___7 = 347,
	GP_2_16_FN___7 = 348,
	GP_2_17_FN___7 = 349,
	GP_2_18_FN___7 = 350,
	GP_2_19_FN___7 = 351,
	GP_2_20_FN___7 = 352,
	GP_2_21_FN___7 = 353,
	GP_2_22_FN___7 = 354,
	GP_2_23_FN___7 = 355,
	GP_2_24_FN___7 = 356,
	GP_2_25_FN___7 = 357,
	GP_2_26_FN___7 = 358,
	GP_2_27_FN___7 = 359,
	GP_2_28_FN___7 = 360,
	GP_2_29_FN___7 = 361,
	GP_2_30_FN___6 = 362,
	GP_2_31_FN___6 = 363,
	GP_3_0_FN___7 = 364,
	GP_3_1_FN___7 = 365,
	GP_3_2_FN___7 = 366,
	GP_3_3_FN___7 = 367,
	GP_3_4_FN___7 = 368,
	GP_3_5_FN___7 = 369,
	GP_3_6_FN___7 = 370,
	GP_3_7_FN___7 = 371,
	GP_3_8_FN___7 = 372,
	GP_3_9_FN___7 = 373,
	GP_3_10_FN___7 = 374,
	GP_3_11_FN___7 = 375,
	GP_3_12_FN___7 = 376,
	GP_3_13_FN___7 = 377,
	GP_3_14_FN___7 = 378,
	GP_3_15_FN___7 = 379,
	GP_3_16_FN___7 = 380,
	GP_3_17_FN___6 = 381,
	GP_3_18_FN___6 = 382,
	GP_3_19_FN___6 = 383,
	GP_3_20_FN___6 = 384,
	GP_3_21_FN___6 = 385,
	GP_3_22_FN___6 = 386,
	GP_3_23_FN___6 = 387,
	GP_3_24_FN___6 = 388,
	GP_3_25_FN___6 = 389,
	GP_3_26_FN___6 = 390,
	GP_3_27_FN___7 = 391,
	GP_4_0_FN___7 = 392,
	GP_4_1_FN___7 = 393,
	GP_4_2_FN___7 = 394,
	GP_4_3_FN___7 = 395,
	GP_4_4_FN___7 = 396,
	GP_4_5_FN___7 = 397,
	GP_4_6_FN___7 = 398,
	GP_4_7_FN___7 = 399,
	GP_4_8_FN___7 = 400,
	GP_4_9_FN___7 = 401,
	GP_4_10_FN___7 = 402,
	GP_4_11_FN___7 = 403,
	GP_4_12_FN___7 = 404,
	GP_4_13_FN___7 = 405,
	GP_4_14_FN___7 = 406,
	GP_4_15_FN___7 = 407,
	GP_4_16_FN___7 = 408,
	GP_5_0_FN___6 = 409,
	GP_5_1_FN___6 = 410,
	GP_5_2_FN___6 = 411,
	GP_5_3_FN___6 = 412,
	GP_5_4_FN___6 = 413,
	GP_5_5_FN___6 = 414,
	GP_5_6_FN___6 = 415,
	GP_5_7_FN___6 = 416,
	GP_5_8_FN___6 = 417,
	GP_5_9_FN___6 = 418,
	GP_5_10_FN___6 = 419,
	GP_5_11_FN___6 = 420,
	GP_5_12_FN___6 = 421,
	GP_5_13_FN___6 = 422,
	GP_5_14_FN___6 = 423,
	GP_5_15_FN___6 = 424,
	GP_5_16_FN___6 = 425,
	GP_6_0_FN___4 = 426,
	GP_6_1_FN___4 = 427,
	GP_6_2_FN___4 = 428,
	GP_6_3_FN___4 = 429,
	GP_6_4_FN___4 = 430,
	GP_6_5_FN___4 = 431,
	GP_6_6_FN___4 = 432,
	GP_6_7_FN___4 = 433,
	GP_6_8_FN___4 = 434,
	GP_6_9_FN___3 = 435,
	GP_6_10_FN___3 = 436,
	GP_6_11_FN___3 = 437,
	GP_6_12_FN___3 = 438,
	GP_6_13_FN___3 = 439,
	GP_6_14_FN___3 = 440,
	GP_6_15_FN___3 = 441,
	GP_6_16_FN___3 = 442,
	GP_7_0_FN___2 = 443,
	GP_7_1_FN___2 = 444,
	GP_7_2_FN___2 = 445,
	GP_7_3_FN___2 = 446,
	GP_7_4_FN___2 = 447,
	GP_7_5_FN___2 = 448,
	GP_7_6_FN___2 = 449,
	GP_7_7_FN___2 = 450,
	GP_7_8_FN___2 = 451,
	GP_7_9_FN___2 = 452,
	GP_7_10_FN___2 = 453,
	GP_7_11_FN___2 = 454,
	GP_7_12_FN___2 = 455,
	GP_7_13_FN___2 = 456,
	GP_7_14_FN___2 = 457,
	GP_7_15_FN___2 = 458,
	GP_7_16_FN___2 = 459,
	GP_8_0_FN = 460,
	GP_8_1_FN = 461,
	GP_8_2_FN = 462,
	GP_8_3_FN = 463,
	GP_8_4_FN = 464,
	GP_8_5_FN = 465,
	GP_8_6_FN = 466,
	GP_8_7_FN = 467,
	GP_8_8_FN = 468,
	GP_8_9_FN = 469,
	GP_8_10_FN = 470,
	GP_8_11_FN = 471,
	GP_8_12_FN = 472,
	GP_8_13_FN = 473,
	GP_8_14_FN = 474,
	GP_8_15_FN = 475,
	GP_8_16_FN = 476,
	GP_9_0_FN = 477,
	GP_9_1_FN = 478,
	GP_9_2_FN = 479,
	GP_9_3_FN = 480,
	GP_9_4_FN = 481,
	GP_9_5_FN = 482,
	GP_9_6_FN = 483,
	GP_9_7_FN = 484,
	GP_9_8_FN = 485,
	GP_9_9_FN = 486,
	GP_9_10_FN = 487,
	GP_9_11_FN = 488,
	GP_9_12_FN = 489,
	GP_9_13_FN = 490,
	GP_9_14_FN = 491,
	GP_9_15_FN = 492,
	GP_9_16_FN = 493,
	GP_10_0_FN = 494,
	GP_10_1_FN = 495,
	GP_10_2_FN = 496,
	GP_10_3_FN = 497,
	GP_10_4_FN = 498,
	GP_10_5_FN = 499,
	GP_10_6_FN = 500,
	GP_10_7_FN = 501,
	GP_10_8_FN = 502,
	GP_10_9_FN = 503,
	GP_10_10_FN = 504,
	GP_10_11_FN = 505,
	GP_10_12_FN = 506,
	GP_10_13_FN = 507,
	GP_10_14_FN = 508,
	GP_10_15_FN = 509,
	GP_10_16_FN = 510,
	GP_10_17_FN = 511,
	GP_10_18_FN = 512,
	GP_10_19_FN = 513,
	GP_10_20_FN = 514,
	GP_10_21_FN = 515,
	GP_10_22_FN = 516,
	GP_10_23_FN = 517,
	GP_10_24_FN = 518,
	GP_10_25_FN = 519,
	GP_10_26_FN = 520,
	GP_10_27_FN = 521,
	GP_10_28_FN = 522,
	GP_10_29_FN = 523,
	GP_10_30_FN = 524,
	GP_10_31_FN = 525,
	GP_11_0_FN = 526,
	GP_11_1_FN = 527,
	GP_11_2_FN = 528,
	GP_11_3_FN = 529,
	GP_11_4_FN = 530,
	GP_11_5_FN = 531,
	GP_11_6_FN = 532,
	GP_11_7_FN = 533,
	GP_11_8_FN = 534,
	GP_11_9_FN = 535,
	GP_11_10_FN = 536,
	GP_11_11_FN = 537,
	GP_11_12_FN = 538,
	GP_11_13_FN = 539,
	GP_11_14_FN = 540,
	GP_11_15_FN = 541,
	GP_11_16_FN = 542,
	GP_11_17_FN = 543,
	GP_11_18_FN = 544,
	GP_11_19_FN = 545,
	GP_11_20_FN = 546,
	GP_11_21_FN = 547,
	GP_11_22_FN = 548,
	GP_11_23_FN = 549,
	GP_11_24_FN = 550,
	GP_11_25_FN = 551,
	GP_11_26_FN = 552,
	GP_11_27_FN = 553,
	GP_11_28_FN = 554,
	GP_11_29_FN = 555,
	FN_IP0_0___3 = 556,
	FN_IP0_1___2 = 557,
	FN_IP0_2___2 = 558,
	FN_IP0_3___2 = 559,
	FN_IP0_4___2 = 560,
	FN_IP0_5___2 = 561,
	FN_IP0_6___2 = 562,
	FN_IP0_7___2 = 563,
	FN_IP0_8___2 = 564,
	FN_IP0_9___2 = 565,
	FN_IP0_10___3 = 566,
	FN_IP0_11___3 = 567,
	FN_IP0_12___3 = 568,
	FN_IP0_13___3 = 569,
	FN_IP0_14___3 = 570,
	FN_IP0_15___4 = 571,
	FN_IP0_16___3 = 572,
	FN_IP0_17___3 = 573,
	FN_IP0_18___2 = 574,
	FN_IP0_19___2 = 575,
	FN_IP0_20___2 = 576,
	FN_IP0_21___2 = 577,
	FN_IP0_22___2 = 578,
	FN_IP0_23___2 = 579,
	FN_IP1_0___2 = 580,
	FN_IP1_1___2 = 581,
	FN_IP1_2 = 582,
	FN_IP1_3 = 583,
	FN_IP1_4 = 584,
	FN_IP1_5 = 585,
	FN_IP1_6 = 586,
	FN_IP1_7 = 587,
	FN_IP1_8 = 588,
	FN_IP1_9 = 589,
	FN_IP1_10 = 590,
	FN_IP1_11 = 591,
	FN_IP1_12 = 592,
	FN_IP1_13 = 593,
	FN_IP1_14 = 594,
	FN_IP1_15 = 595,
	FN_IP1_16 = 596,
	FN_DU1_DB2_C0_DATA12 = 597,
	FN_DU1_DB3_C1_DATA13 = 598,
	FN_DU1_DB4_C2_DATA14 = 599,
	FN_DU1_DB5_C3_DATA15 = 600,
	FN_DU1_DB6_C4 = 601,
	FN_DU1_DB7_C5 = 602,
	FN_DU1_EXHSYNC_DU1_HSYNC___6 = 603,
	FN_DU1_EXVSYNC_DU1_VSYNC___6 = 604,
	FN_DU1_EXODDF_DU1_ODDF_DISP_CDE___6 = 605,
	FN_DU1_DISP___6 = 606,
	FN_DU1_CDE___6 = 607,
	FN_D0___6 = 608,
	FN_D1___6 = 609,
	FN_D2___6 = 610,
	FN_D3___6 = 611,
	FN_D4___6 = 612,
	FN_D5___6 = 613,
	FN_D6___6 = 614,
	FN_D7___6 = 615,
	FN_D8___6 = 616,
	FN_D9___6 = 617,
	FN_D10___6 = 618,
	FN_D11___6 = 619,
	FN_D12___5 = 620,
	FN_D13___5 = 621,
	FN_D14___5 = 622,
	FN_D15___5 = 623,
	FN_A0___7 = 624,
	FN_A1___7 = 625,
	FN_A2___7 = 626,
	FN_A3___7 = 627,
	FN_A4___7 = 628,
	FN_A5___7 = 629,
	FN_A6___7 = 630,
	FN_A7___7 = 631,
	FN_A8___7 = 632,
	FN_A9___7 = 633,
	FN_A10___7 = 634,
	FN_A11___7 = 635,
	FN_A12___7 = 636,
	FN_A13___7 = 637,
	FN_A14___7 = 638,
	FN_A15___7 = 639,
	FN_A16___7 = 640,
	FN_A17___7 = 641,
	FN_A18___7 = 642,
	FN_A19___7 = 643,
	FN_IP1_17 = 644,
	FN_IP1_18 = 645,
	FN_CS1_N_A26___5 = 646,
	FN_EX_CS0_N___4 = 647,
	FN_EX_CS1_N___4 = 648,
	FN_EX_CS2_N___4 = 649,
	FN_EX_CS3_N___4 = 650,
	FN_EX_CS4_N___4 = 651,
	FN_EX_CS5_N___4 = 652,
	FN_BS_N___5 = 653,
	FN_RD_N___5 = 654,
	FN_RD_WR_N___5 = 655,
	FN_WE0_N___5 = 656,
	FN_WE1_N___5 = 657,
	FN_EX_WAIT0___7 = 658,
	FN_IRQ0___7 = 659,
	FN_IRQ1___6 = 660,
	FN_IRQ2___6 = 661,
	FN_IRQ3___6 = 662,
	FN_IP1_19 = 663,
	FN_IP1_20 = 664,
	FN_IP1_21 = 665,
	FN_IP1_22 = 666,
	FN_CS0_N___5 = 667,
	FN_VI0_CLK___7 = 668,
	FN_VI0_CLKENB___7 = 669,
	FN_VI0_HSYNC_N___5 = 670,
	FN_VI0_VSYNC_N___5 = 671,
	FN_VI0_D0_B0_C0 = 672,
	FN_VI0_D1_B1_C1 = 673,
	FN_VI0_D2_B2_C2 = 674,
	FN_VI0_D3_B3_C3 = 675,
	FN_VI0_D4_B4_C4 = 676,
	FN_VI0_D5_B5_C5 = 677,
	FN_VI0_D6_B6_C6 = 678,
	FN_VI0_D7_B7_C7 = 679,
	FN_VI0_D8_G0_Y0 = 680,
	FN_VI0_D9_G1_Y1 = 681,
	FN_VI0_D10_G2_Y2 = 682,
	FN_VI0_D11_G3_Y3 = 683,
	FN_VI0_FIELD___7 = 684,
	FN_VI1_CLK___7 = 685,
	FN_VI1_CLKENB___7 = 686,
	FN_VI1_HSYNC_N___5 = 687,
	FN_VI1_VSYNC_N___5 = 688,
	FN_VI1_D0_B0_C0 = 689,
	FN_VI1_D1_B1_C1 = 690,
	FN_VI1_D2_B2_C2 = 691,
	FN_VI1_D3_B3_C3 = 692,
	FN_VI1_D4_B4_C4 = 693,
	FN_VI1_D5_B5_C5 = 694,
	FN_VI1_D6_B6_C6 = 695,
	FN_VI1_D7_B7_C7 = 696,
	FN_VI1_D8_G0_Y0 = 697,
	FN_VI1_D9_G1_Y1 = 698,
	FN_VI1_D10_G2_Y2 = 699,
	FN_VI1_D11_G3_Y3 = 700,
	FN_VI1_FIELD___7 = 701,
	FN_IP2_0 = 702,
	FN_IP2_1 = 703,
	FN_IP2_2 = 704,
	FN_IP2_3 = 705,
	FN_IP2_4 = 706,
	FN_IP2_5 = 707,
	FN_IP2_6 = 708,
	FN_IP2_7 = 709,
	FN_IP2_8 = 710,
	FN_IP2_9 = 711,
	FN_IP2_10 = 712,
	FN_IP2_11 = 713,
	FN_IP2_12 = 714,
	FN_IP2_13 = 715,
	FN_IP2_14 = 716,
	FN_IP2_15 = 717,
	FN_IP2_16 = 718,
	FN_IP3_0 = 719,
	FN_IP3_1 = 720,
	FN_IP3_2 = 721,
	FN_IP3_3___2 = 722,
	FN_IP3_4___2 = 723,
	FN_IP3_5___2 = 724,
	FN_IP3_6___2 = 725,
	FN_IP3_7___2 = 726,
	FN_IP3_8___2 = 727,
	FN_IP3_9 = 728,
	FN_IP3_10___2 = 729,
	FN_IP3_11___2 = 730,
	FN_IP3_12___2 = 731,
	FN_IP3_13 = 732,
	FN_VI3_D10_Y2 = 733,
	FN_IP3_14 = 734,
	FN_VI3_FIELD___3 = 735,
	FN_VI4_CLK = 736,
	FN_IP4_0___2 = 737,
	FN_IP4_1 = 738,
	FN_IP4_3_2 = 739,
	FN_IP4_4 = 740,
	FN_IP4_6_5 = 741,
	FN_IP4_8_7 = 742,
	FN_IP4_10_9___2 = 743,
	FN_IP4_12_11___2 = 744,
	FN_IP4_14_13___2 = 745,
	FN_IP4_16_15___2 = 746,
	FN_IP4_18_17 = 747,
	FN_IP4_20_19 = 748,
	FN_IP4_21___2 = 749,
	FN_IP4_22 = 750,
	FN_IP4_23___2 = 751,
	FN_IP4_24___2 = 752,
	FN_VI5_CLK = 753,
	FN_IP5_0 = 754,
	FN_IP5_1 = 755,
	FN_IP5_2 = 756,
	FN_IP5_3___2 = 757,
	FN_IP5_4___2 = 758,
	FN_IP5_5___2 = 759,
	FN_IP5_6___3 = 760,
	FN_IP5_7___3 = 761,
	FN_IP5_8___2 = 762,
	FN_IP5_9 = 763,
	FN_IP5_10 = 764,
	FN_IP5_11 = 765,
	FN_VI5_D9_Y1 = 766,
	FN_VI5_D10_Y2 = 767,
	FN_VI5_D11_Y3 = 768,
	FN_VI5_FIELD = 769,
	FN_IP6_0 = 770,
	FN_IP6_1 = 771,
	FN_HRTS0_N___4 = 772,
	FN_IP6_2 = 773,
	FN_IP6_3 = 774,
	FN_IP6_4 = 775,
	FN_IP6_5 = 776,
	FN_HCTS1_N___3 = 777,
	FN_IP6_6 = 778,
	FN_IP6_7___2 = 779,
	FN_SCK0___4 = 780,
	FN_CTS0_N___2 = 781,
	FN_RTS0_N___2 = 782,
	FN_TX0___4 = 783,
	FN_RX0___4 = 784,
	FN_SCK1___3 = 785,
	FN_CTS1_N___2 = 786,
	FN_RTS1_N___2 = 787,
	FN_TX1___4 = 788,
	FN_RX1___4 = 789,
	FN_IP6_9_8___2 = 790,
	FN_IP6_11_10___2 = 791,
	FN_IP6_13_12___2 = 792,
	FN_IP6_15_14___3 = 793,
	FN_IP6_16___3 = 794,
	FN_IP6_18_17___2 = 795,
	FN_SCIF_CLK___6 = 796,
	FN_CAN0_TX___5 = 797,
	FN_CAN0_RX___5 = 798,
	FN_CAN_CLK___5 = 799,
	FN_CAN1_TX___5 = 800,
	FN_CAN1_RX___5 = 801,
	FN_IP7_1_0___3 = 802,
	FN_IP7_3_2___3 = 803,
	FN_IP7_5_4___2 = 804,
	FN_IP7_6 = 805,
	FN_IP7_7 = 806,
	FN_SD0_CLK___7 = 807,
	FN_SD0_CMD___7 = 808,
	FN_SD0_DAT0___5 = 809,
	FN_SD0_DAT1___5 = 810,
	FN_SD0_DAT2___5 = 811,
	FN_SD0_DAT3___5 = 812,
	FN_SD0_CD___7 = 813,
	FN_SD0_WP___7 = 814,
	FN_IP7_9_8___2 = 815,
	FN_IP7_11_10 = 816,
	FN_IP7_13_12 = 817,
	FN_IP7_15_14 = 818,
	FN_IP7_16 = 819,
	FN_IP7_17 = 820,
	FN_IP7_18 = 821,
	FN_IP7_19 = 822,
	FN_IP7_20 = 823,
	FN_ADICLK___6 = 824,
	FN_ADICS_SAMP___6 = 825,
	FN_ADIDATA___6 = 826,
	FN_ADICHS0___6 = 827,
	FN_ADICHS1___6 = 828,
	FN_ADICHS2___6 = 829,
	FN_AVS1___4 = 830,
	FN_AVS2___4 = 831,
	FN_DU0_DR0_DATA0 = 832,
	FN_DU0_DR1_DATA1 = 833,
	FN_DU0_DR2_Y4_DATA2 = 834,
	FN_DU0_DR3_Y5_DATA3 = 835,
	FN_DU0_DR4_Y6_DATA4 = 836,
	FN_DU0_DR5_Y7_DATA5 = 837,
	FN_DU0_DR6_Y8_DATA6 = 838,
	FN_DU0_DR7_Y9_DATA7 = 839,
	FN_DU0_DG0_DATA8 = 840,
	FN_DU0_DG1_DATA9 = 841,
	FN_DU0_DG2_C6_DATA10 = 842,
	FN_DU0_DG3_C7_DATA11 = 843,
	FN_DU0_DG4_Y0_DATA12 = 844,
	FN_DU0_DG5_Y1_DATA13 = 845,
	FN_DU0_DG6_Y2_DATA14 = 846,
	FN_DU0_DG7_Y3_DATA15 = 847,
	FN_DU0_DB0___5 = 848,
	FN_DU0_DB1___5 = 849,
	FN_DU0_DB2_C0 = 850,
	FN_DU0_DB3_C1 = 851,
	FN_DU0_DB4_C2 = 852,
	FN_DU0_DB5_C3 = 853,
	FN_DU0_DB6_C4 = 854,
	FN_DU0_DB7_C5 = 855,
	FN_DU0_EXHSYNC_DU0_HSYNC___5 = 856,
	FN_DU0_EXVSYNC_DU0_VSYNC___5 = 857,
	FN_DU0_EXODDF_DU0_ODDF_DISP_CDE___5 = 858,
	FN_DU0_DISP___5 = 859,
	FN_DU0_CDE___5 = 860,
	FN_DU1_DR2_Y4_DATA0 = 861,
	FN_DU1_DR3_Y5_DATA1 = 862,
	FN_DU1_DR4_Y6_DATA2 = 863,
	FN_DU1_DR5_Y7_DATA3 = 864,
	FN_DU1_DR6_DATA4 = 865,
	FN_DU1_DR7_DATA5 = 866,
	FN_DU1_DG2_C6_DATA6 = 867,
	FN_DU1_DG3_C7_DATA7 = 868,
	FN_DU1_DG4_Y0_DATA8 = 869,
	FN_DU1_DG5_Y1_DATA9 = 870,
	FN_DU1_DG6_Y2_DATA10 = 871,
	FN_DU1_DG7_Y3_DATA11 = 872,
	FN_A20___7 = 873,
	FN_MOSI_IO0___4 = 874,
	FN_A21___7 = 875,
	FN_MISO_IO1___4 = 876,
	FN_A22___7 = 877,
	FN_IO2___4 = 878,
	FN_A23___7 = 879,
	FN_IO3___4 = 880,
	FN_A24___7 = 881,
	FN_SPCLK___4 = 882,
	FN_A25___7 = 883,
	FN_SSL___4 = 884,
	FN_VI2_CLK___4 = 885,
	FN_AVB_RX_CLK___5 = 886,
	FN_VI2_CLKENB___4 = 887,
	FN_AVB_RX_DV___5 = 888,
	FN_VI2_HSYNC_N___3 = 889,
	FN_AVB_RXD0___5 = 890,
	FN_VI2_VSYNC_N___3 = 891,
	FN_AVB_RXD1___5 = 892,
	FN_VI2_D0_C0 = 893,
	FN_AVB_RXD2___5 = 894,
	FN_VI2_D1_C1 = 895,
	FN_AVB_RXD3___5 = 896,
	FN_VI2_D2_C2 = 897,
	FN_AVB_RXD4___5 = 898,
	FN_VI2_D3_C3 = 899,
	FN_AVB_RXD5___5 = 900,
	FN_VI2_D4_C4 = 901,
	FN_AVB_RXD6___5 = 902,
	FN_VI2_D5_C5 = 903,
	FN_AVB_RXD7___5 = 904,
	FN_VI2_D6_C6 = 905,
	FN_AVB_RX_ER___5 = 906,
	FN_VI2_D7_C7 = 907,
	FN_AVB_COL___5 = 908,
	FN_VI2_D8_Y0 = 909,
	FN_AVB_TXD3___5 = 910,
	FN_VI2_D9_Y1 = 911,
	FN_AVB_TX_EN___5 = 912,
	FN_VI2_D10_Y2 = 913,
	FN_AVB_TXD0___5 = 914,
	FN_VI2_D11_Y3 = 915,
	FN_AVB_TXD1___5 = 916,
	FN_VI2_FIELD___4 = 917,
	FN_AVB_TXD2___5 = 918,
	FN_VI3_CLK___3 = 919,
	FN_AVB_TX_CLK___5 = 920,
	FN_VI3_CLKENB___3 = 921,
	FN_AVB_TXD4___5 = 922,
	FN_VI3_HSYNC_N___2 = 923,
	FN_AVB_TXD5___5 = 924,
	FN_VI3_VSYNC_N___2 = 925,
	FN_AVB_TXD6___5 = 926,
	FN_VI3_D0_C0 = 927,
	FN_AVB_TXD7___5 = 928,
	FN_VI3_D1_C1 = 929,
	FN_AVB_TX_ER___5 = 930,
	FN_VI3_D2_C2 = 931,
	FN_AVB_GTX_CLK___5 = 932,
	FN_VI3_D3_C3 = 933,
	FN_AVB_MDC___5 = 934,
	FN_VI3_D4_C4 = 935,
	FN_AVB_MDIO___5 = 936,
	FN_VI3_D5_C5 = 937,
	FN_AVB_LINK___5 = 938,
	FN_VI3_D6_C6 = 939,
	FN_AVB_MAGIC___5 = 940,
	FN_VI3_D7_C7 = 941,
	FN_AVB_PHY_INT___5 = 942,
	FN_VI3_D8_Y0 = 943,
	FN_AVB_CRS___5 = 944,
	FN_VI3_D9_Y1 = 945,
	FN_AVB_GTXREFCLK___5 = 946,
	FN_VI3_D11_Y3 = 947,
	FN_AVB_AVTP_MATCH = 948,
	FN_VI4_CLKENB = 949,
	FN_VI0_D12_G4_Y4 = 950,
	FN_VI4_HSYNC_N = 951,
	FN_VI0_D13_G5_Y5 = 952,
	FN_VI4_VSYNC_N = 953,
	FN_VI0_D14_G6_Y6 = 954,
	FN_RDR_CLKOUT = 955,
	FN_VI4_D0_C0 = 956,
	FN_VI0_D15_G7_Y7 = 957,
	FN_VI4_D1_C1 = 958,
	FN_VI0_D16_R0 = 959,
	FN_VI1_D12_G4_Y4 = 960,
	FN_VI4_D2_C2 = 961,
	FN_VI0_D17_R1 = 962,
	FN_VI1_D13_G5_Y5 = 963,
	FN_VI4_D3_C3 = 964,
	FN_VI0_D18_R2 = 965,
	FN_VI1_D14_G6_Y6 = 966,
	FN_VI4_D4_C4 = 967,
	FN_VI0_D19_R3 = 968,
	FN_VI1_D15_G7_Y7 = 969,
	FN_VI4_D5_C5 = 970,
	FN_VI0_D20_R4 = 971,
	FN_VI2_D12_Y4 = 972,
	FN_VI4_D6_C6 = 973,
	FN_VI0_D21_R5 = 974,
	FN_VI2_D13_Y5 = 975,
	FN_VI4_D7_C7 = 976,
	FN_VI0_D22_R6 = 977,
	FN_VI2_D14_Y6 = 978,
	FN_VI4_D8_Y0 = 979,
	FN_VI0_D23_R7 = 980,
	FN_VI2_D15_Y7 = 981,
	FN_VI4_D9_Y1 = 982,
	FN_VI3_D12_Y4 = 983,
	FN_VI4_D10_Y2 = 984,
	FN_VI3_D13_Y5 = 985,
	FN_VI4_D11_Y3 = 986,
	FN_VI3_D14_Y6 = 987,
	FN_VI4_FIELD = 988,
	FN_VI3_D15_Y7 = 989,
	FN_VI5_CLKENB = 990,
	FN_VI1_D12_G4_Y4_B = 991,
	FN_VI5_HSYNC_N = 992,
	FN_VI1_D13_G5_Y5_B = 993,
	FN_VI5_VSYNC_N = 994,
	FN_VI1_D14_G6_Y6_B = 995,
	FN_VI5_D0_C0 = 996,
	FN_VI1_D15_G7_Y7_B = 997,
	FN_VI5_D1_C1 = 998,
	FN_VI1_D16_R0 = 999,
	FN_VI5_D2_C2 = 1000,
	FN_VI1_D17_R1 = 1001,
	FN_VI5_D3_C3 = 1002,
	FN_VI1_D18_R2 = 1003,
	FN_VI5_D4_C4 = 1004,
	FN_VI1_D19_R3 = 1005,
	FN_VI5_D5_C5 = 1006,
	FN_VI1_D20_R4 = 1007,
	FN_VI5_D6_C6 = 1008,
	FN_VI1_D21_R5 = 1009,
	FN_VI5_D7_C7 = 1010,
	FN_VI1_D22_R6 = 1011,
	FN_VI5_D8_Y0 = 1012,
	FN_VI1_D23_R7 = 1013,
	FN_MSIOF0_SCK___4 = 1014,
	FN_HSCK0___6 = 1015,
	FN_MSIOF0_SYNC___4 = 1016,
	FN_HCTS0_N___4 = 1017,
	FN_MSIOF0_TXD___4 = 1018,
	FN_HTX0___4 = 1019,
	FN_MSIOF0_RXD___4 = 1020,
	FN_HRX0___4 = 1021,
	FN_MSIOF1_SCK___4 = 1022,
	FN_HSCK1___5 = 1023,
	FN_MSIOF1_SYNC___4 = 1024,
	FN_HRTS1_N___3 = 1025,
	FN_MSIOF1_TXD___4 = 1026,
	FN_HTX1___4 = 1027,
	FN_MSIOF1_RXD___4 = 1028,
	FN_HRX1___4 = 1029,
	FN_DRACK0___7 = 1030,
	FN_SCK2___3 = 1031,
	FN_DACK0___7 = 1032,
	FN_TX2___4 = 1033,
	FN_DREQ0_N___4 = 1034,
	FN_RX2___4 = 1035,
	FN_DACK1___6 = 1036,
	FN_SCK3___2 = 1037,
	FN_TX3___2 = 1038,
	FN_DREQ1_N___4 = 1039,
	FN_RX3___2 = 1040,
	FN_PWM0___5 = 1041,
	FN_TCLK1___6 = 1042,
	FN_FSO_CFE_0 = 1043,
	FN_PWM1___6 = 1044,
	FN_TCLK2___4 = 1045,
	FN_FSO_CFE_1 = 1046,
	FN_PWM2___6 = 1047,
	FN_TCLK3 = 1048,
	FN_FSO_TOE = 1049,
	FN_PWM3___6 = 1050,
	FN_PWM4___6 = 1051,
	FN_SSI_SCK34___7 = 1052,
	FN_TPU0TO0___2 = 1053,
	FN_SSI_WS34___7 = 1054,
	FN_TPU0TO1___2 = 1055,
	FN_SSI_SDATA3___7 = 1056,
	FN_TPU0TO2___2 = 1057,
	FN_SSI_SCK4___6 = 1058,
	FN_TPU0TO3___2 = 1059,
	FN_SSI_WS4___6 = 1060,
	FN_SSI_SDATA4___6 = 1061,
	FN_AUDIO_CLKOUT___5 = 1062,
	FN_AUDIO_CLKA___6 = 1063,
	FN_AUDIO_CLKB___6 = 1064,
	FN_SEL_VI1_0___3 = 1065,
	FN_SEL_VI1_1___3 = 1066,
	PINMUX_FUNCTION_END___10 = 1067,
	PINMUX_MARK_BEGIN___10 = 1068,
	DU1_DB2_C0_DATA12_MARK = 1069,
	DU1_DB3_C1_DATA13_MARK = 1070,
	DU1_DB4_C2_DATA14_MARK = 1071,
	DU1_DB5_C3_DATA15_MARK = 1072,
	DU1_DB6_C4_MARK = 1073,
	DU1_DB7_C5_MARK = 1074,
	DU1_EXHSYNC_DU1_HSYNC_MARK___6 = 1075,
	DU1_EXVSYNC_DU1_VSYNC_MARK___6 = 1076,
	DU1_EXODDF_DU1_ODDF_DISP_CDE_MARK___6 = 1077,
	DU1_DISP_MARK___6 = 1078,
	DU1_CDE_MARK___6 = 1079,
	D0_MARK___7 = 1080,
	D1_MARK___7 = 1081,
	D2_MARK___7 = 1082,
	D3_MARK___7 = 1083,
	D4_MARK___7 = 1084,
	D5_MARK___7 = 1085,
	D6_MARK___7 = 1086,
	D7_MARK___7 = 1087,
	D8_MARK___7 = 1088,
	D9_MARK___7 = 1089,
	D10_MARK___7 = 1090,
	D11_MARK___7 = 1091,
	D12_MARK___6 = 1092,
	D13_MARK___6 = 1093,
	D14_MARK___6 = 1094,
	D15_MARK___6 = 1095,
	A0_MARK___9 = 1096,
	A1_MARK___8 = 1097,
	A2_MARK___8 = 1098,
	A3_MARK___8 = 1099,
	A4_MARK___7 = 1100,
	A5_MARK___7 = 1101,
	A6_MARK___8 = 1102,
	A7_MARK___8 = 1103,
	A8_MARK___8 = 1104,
	A9_MARK___8 = 1105,
	A10_MARK___8 = 1106,
	A11_MARK___7 = 1107,
	A12_MARK___7 = 1108,
	A13_MARK___7 = 1109,
	A14_MARK___7 = 1110,
	A15_MARK___7 = 1111,
	A16_MARK___7 = 1112,
	A17_MARK___8 = 1113,
	A18_MARK___8 = 1114,
	A19_MARK___8 = 1115,
	CS1_N_A26_MARK___5 = 1116,
	EX_CS0_N_MARK___4 = 1117,
	EX_CS1_N_MARK___4 = 1118,
	EX_CS2_N_MARK___4 = 1119,
	EX_CS3_N_MARK___4 = 1120,
	EX_CS4_N_MARK___4 = 1121,
	EX_CS5_N_MARK___4 = 1122,
	BS_N_MARK___5 = 1123,
	RD_N_MARK___6 = 1124,
	RD_WR_N_MARK___5 = 1125,
	WE0_N_MARK___6 = 1126,
	WE1_N_MARK___6 = 1127,
	EX_WAIT0_MARK___6 = 1128,
	IRQ0_MARK___8 = 1129,
	IRQ1_MARK___8 = 1130,
	IRQ2_MARK___7 = 1131,
	IRQ3_MARK___7 = 1132,
	CS0_N_MARK___6 = 1133,
	VI0_CLK_MARK___7 = 1134,
	VI0_CLKENB_MARK___7 = 1135,
	VI0_HSYNC_N_MARK___5 = 1136,
	VI0_VSYNC_N_MARK___5 = 1137,
	VI0_D0_B0_C0_MARK = 1138,
	VI0_D1_B1_C1_MARK = 1139,
	VI0_D2_B2_C2_MARK = 1140,
	VI0_D3_B3_C3_MARK = 1141,
	VI0_D4_B4_C4_MARK = 1142,
	VI0_D5_B5_C5_MARK = 1143,
	VI0_D6_B6_C6_MARK = 1144,
	VI0_D7_B7_C7_MARK = 1145,
	VI0_D8_G0_Y0_MARK = 1146,
	VI0_D9_G1_Y1_MARK = 1147,
	VI0_D10_G2_Y2_MARK = 1148,
	VI0_D11_G3_Y3_MARK = 1149,
	VI0_FIELD_MARK___7 = 1150,
	VI1_CLK_MARK___7 = 1151,
	VI1_CLKENB_MARK___7 = 1152,
	VI1_HSYNC_N_MARK___5 = 1153,
	VI1_VSYNC_N_MARK___5 = 1154,
	VI1_D0_B0_C0_MARK = 1155,
	VI1_D1_B1_C1_MARK = 1156,
	VI1_D2_B2_C2_MARK = 1157,
	VI1_D3_B3_C3_MARK = 1158,
	VI1_D4_B4_C4_MARK = 1159,
	VI1_D5_B5_C5_MARK = 1160,
	VI1_D6_B6_C6_MARK = 1161,
	VI1_D7_B7_C7_MARK = 1162,
	VI1_D8_G0_Y0_MARK = 1163,
	VI1_D9_G1_Y1_MARK = 1164,
	VI1_D10_G2_Y2_MARK = 1165,
	VI1_D11_G3_Y3_MARK = 1166,
	VI1_FIELD_MARK___7 = 1167,
	VI3_D10_Y2_MARK = 1168,
	VI3_FIELD_MARK___3 = 1169,
	VI4_CLK_MARK = 1170,
	VI5_CLK_MARK = 1171,
	VI5_D9_Y1_MARK = 1172,
	VI5_D10_Y2_MARK = 1173,
	VI5_D11_Y3_MARK = 1174,
	VI5_FIELD_MARK = 1175,
	HRTS0_N_MARK___4 = 1176,
	HCTS1_N_MARK___3 = 1177,
	SCK0_MARK___4 = 1178,
	CTS0_N_MARK___2 = 1179,
	RTS0_N_MARK___2 = 1180,
	TX0_MARK___4 = 1181,
	RX0_MARK___4 = 1182,
	SCK1_MARK___3 = 1183,
	CTS1_N_MARK___2 = 1184,
	RTS1_N_MARK___2 = 1185,
	TX1_MARK___4 = 1186,
	RX1_MARK___4 = 1187,
	SCIF_CLK_MARK___6 = 1188,
	CAN0_TX_MARK___5 = 1189,
	CAN0_RX_MARK___5 = 1190,
	CAN_CLK_MARK___5 = 1191,
	CAN1_TX_MARK___5 = 1192,
	CAN1_RX_MARK___5 = 1193,
	SD0_CLK_MARK___7 = 1194,
	SD0_CMD_MARK___7 = 1195,
	SD0_DAT0_MARK___5 = 1196,
	SD0_DAT1_MARK___5 = 1197,
	SD0_DAT2_MARK___5 = 1198,
	SD0_DAT3_MARK___5 = 1199,
	SD0_CD_MARK___7 = 1200,
	SD0_WP_MARK___7 = 1201,
	ADICLK_MARK___6 = 1202,
	ADICS_SAMP_MARK___6 = 1203,
	ADIDATA_MARK___6 = 1204,
	ADICHS0_MARK___6 = 1205,
	ADICHS1_MARK___6 = 1206,
	ADICHS2_MARK___6 = 1207,
	AVS1_MARK___4 = 1208,
	AVS2_MARK___4 = 1209,
	DU0_DR0_DATA0_MARK = 1210,
	DU0_DR1_DATA1_MARK = 1211,
	DU0_DR2_Y4_DATA2_MARK = 1212,
	DU0_DR3_Y5_DATA3_MARK = 1213,
	DU0_DR4_Y6_DATA4_MARK = 1214,
	DU0_DR5_Y7_DATA5_MARK = 1215,
	DU0_DR6_Y8_DATA6_MARK = 1216,
	DU0_DR7_Y9_DATA7_MARK = 1217,
	DU0_DG0_DATA8_MARK = 1218,
	DU0_DG1_DATA9_MARK = 1219,
	DU0_DG2_C6_DATA10_MARK = 1220,
	DU0_DG3_C7_DATA11_MARK = 1221,
	DU0_DG4_Y0_DATA12_MARK = 1222,
	DU0_DG5_Y1_DATA13_MARK = 1223,
	DU0_DG6_Y2_DATA14_MARK = 1224,
	DU0_DG7_Y3_DATA15_MARK = 1225,
	DU0_DB0_MARK___6 = 1226,
	DU0_DB1_MARK___6 = 1227,
	DU0_DB2_C0_MARK = 1228,
	DU0_DB3_C1_MARK = 1229,
	DU0_DB4_C2_MARK = 1230,
	DU0_DB5_C3_MARK = 1231,
	DU0_DB6_C4_MARK = 1232,
	DU0_DB7_C5_MARK = 1233,
	DU0_EXHSYNC_DU0_HSYNC_MARK___5 = 1234,
	DU0_EXVSYNC_DU0_VSYNC_MARK___5 = 1235,
	DU0_EXODDF_DU0_ODDF_DISP_CDE_MARK___5 = 1236,
	DU0_DISP_MARK___5 = 1237,
	DU0_CDE_MARK___6 = 1238,
	DU1_DR2_Y4_DATA0_MARK = 1239,
	DU1_DR3_Y5_DATA1_MARK = 1240,
	DU1_DR4_Y6_DATA2_MARK = 1241,
	DU1_DR5_Y7_DATA3_MARK = 1242,
	DU1_DR6_DATA4_MARK = 1243,
	DU1_DR7_DATA5_MARK = 1244,
	DU1_DG2_C6_DATA6_MARK = 1245,
	DU1_DG3_C7_DATA7_MARK = 1246,
	DU1_DG4_Y0_DATA8_MARK = 1247,
	DU1_DG5_Y1_DATA9_MARK = 1248,
	DU1_DG6_Y2_DATA10_MARK = 1249,
	DU1_DG7_Y3_DATA11_MARK = 1250,
	A20_MARK___8 = 1251,
	MOSI_IO0_MARK___4 = 1252,
	A21_MARK___8 = 1253,
	MISO_IO1_MARK___4 = 1254,
	A22_MARK___8 = 1255,
	IO2_MARK___4 = 1256,
	A23_MARK___8 = 1257,
	IO3_MARK___4 = 1258,
	A24_MARK___8 = 1259,
	SPCLK_MARK___4 = 1260,
	A25_MARK___8 = 1261,
	SSL_MARK___4 = 1262,
	VI2_CLK_MARK___4 = 1263,
	AVB_RX_CLK_MARK___5 = 1264,
	VI2_CLKENB_MARK___4 = 1265,
	AVB_RX_DV_MARK___5 = 1266,
	VI2_HSYNC_N_MARK___3 = 1267,
	AVB_RXD0_MARK___5 = 1268,
	VI2_VSYNC_N_MARK___3 = 1269,
	AVB_RXD1_MARK___5 = 1270,
	VI2_D0_C0_MARK = 1271,
	AVB_RXD2_MARK___5 = 1272,
	VI2_D1_C1_MARK = 1273,
	AVB_TX_CLK_MARK___5 = 1274,
	VI2_D2_C2_MARK = 1275,
	AVB_RXD4_MARK___5 = 1276,
	VI2_D3_C3_MARK = 1277,
	AVB_RXD5_MARK___5 = 1278,
	VI2_D4_C4_MARK = 1279,
	AVB_RXD6_MARK___5 = 1280,
	VI2_D5_C5_MARK = 1281,
	AVB_RXD7_MARK___5 = 1282,
	VI2_D6_C6_MARK = 1283,
	AVB_RX_ER_MARK___5 = 1284,
	VI2_D7_C7_MARK = 1285,
	AVB_COL_MARK___5 = 1286,
	VI2_D8_Y0_MARK = 1287,
	AVB_RXD3_MARK___5 = 1288,
	VI2_D9_Y1_MARK = 1289,
	AVB_TX_EN_MARK___5 = 1290,
	VI2_D10_Y2_MARK = 1291,
	AVB_TXD0_MARK___5 = 1292,
	VI2_D11_Y3_MARK = 1293,
	AVB_TXD1_MARK___5 = 1294,
	VI2_FIELD_MARK___4 = 1295,
	AVB_TXD2_MARK___5 = 1296,
	VI3_CLK_MARK___3 = 1297,
	AVB_TXD3_MARK___5 = 1298,
	VI3_CLKENB_MARK___3 = 1299,
	AVB_TXD4_MARK___5 = 1300,
	VI3_HSYNC_N_MARK___2 = 1301,
	AVB_TXD5_MARK___5 = 1302,
	VI3_VSYNC_N_MARK___2 = 1303,
	AVB_TXD6_MARK___5 = 1304,
	VI3_D0_C0_MARK = 1305,
	AVB_TXD7_MARK___5 = 1306,
	VI3_D1_C1_MARK = 1307,
	AVB_TX_ER_MARK___5 = 1308,
	VI3_D2_C2_MARK = 1309,
	AVB_GTX_CLK_MARK___5 = 1310,
	VI3_D3_C3_MARK = 1311,
	AVB_MDC_MARK___5 = 1312,
	VI3_D4_C4_MARK = 1313,
	AVB_MDIO_MARK___5 = 1314,
	VI3_D5_C5_MARK = 1315,
	AVB_LINK_MARK___5 = 1316,
	VI3_D6_C6_MARK = 1317,
	AVB_MAGIC_MARK___5 = 1318,
	VI3_D7_C7_MARK = 1319,
	AVB_PHY_INT_MARK___5 = 1320,
	VI3_D8_Y0_MARK = 1321,
	AVB_CRS_MARK___5 = 1322,
	VI3_D9_Y1_MARK = 1323,
	AVB_GTXREFCLK_MARK___5 = 1324,
	VI3_D11_Y3_MARK = 1325,
	AVB_AVTP_MATCH_MARK = 1326,
	VI4_CLKENB_MARK = 1327,
	VI0_D12_G4_Y4_MARK = 1328,
	VI4_HSYNC_N_MARK = 1329,
	VI0_D13_G5_Y5_MARK = 1330,
	VI4_VSYNC_N_MARK = 1331,
	VI0_D14_G6_Y6_MARK = 1332,
	RDR_CLKOUT_MARK = 1333,
	VI4_D0_C0_MARK = 1334,
	VI0_D15_G7_Y7_MARK = 1335,
	VI4_D1_C1_MARK = 1336,
	VI0_D16_R0_MARK = 1337,
	VI1_D12_G4_Y4_MARK = 1338,
	VI4_D2_C2_MARK = 1339,
	VI0_D17_R1_MARK = 1340,
	VI1_D13_G5_Y5_MARK = 1341,
	VI4_D3_C3_MARK = 1342,
	VI0_D18_R2_MARK = 1343,
	VI1_D14_G6_Y6_MARK = 1344,
	VI4_D4_C4_MARK = 1345,
	VI0_D19_R3_MARK = 1346,
	VI1_D15_G7_Y7_MARK = 1347,
	VI4_D5_C5_MARK = 1348,
	VI0_D20_R4_MARK = 1349,
	VI2_D12_Y4_MARK = 1350,
	VI4_D6_C6_MARK = 1351,
	VI0_D21_R5_MARK = 1352,
	VI2_D13_Y5_MARK = 1353,
	VI4_D7_C7_MARK = 1354,
	VI0_D22_R6_MARK = 1355,
	VI2_D14_Y6_MARK = 1356,
	VI4_D8_Y0_MARK = 1357,
	VI0_D23_R7_MARK = 1358,
	VI2_D15_Y7_MARK = 1359,
	VI4_D9_Y1_MARK = 1360,
	VI3_D12_Y4_MARK = 1361,
	VI4_D10_Y2_MARK = 1362,
	VI3_D13_Y5_MARK = 1363,
	VI4_D11_Y3_MARK = 1364,
	VI3_D14_Y6_MARK = 1365,
	VI4_FIELD_MARK = 1366,
	VI3_D15_Y7_MARK = 1367,
	VI5_CLKENB_MARK = 1368,
	VI1_D12_G4_Y4_B_MARK = 1369,
	VI5_HSYNC_N_MARK = 1370,
	VI1_D13_G5_Y5_B_MARK = 1371,
	VI5_VSYNC_N_MARK = 1372,
	VI1_D14_G6_Y6_B_MARK = 1373,
	VI5_D0_C0_MARK = 1374,
	VI1_D15_G7_Y7_B_MARK = 1375,
	VI5_D1_C1_MARK = 1376,
	VI1_D16_R0_MARK = 1377,
	VI5_D2_C2_MARK = 1378,
	VI1_D17_R1_MARK = 1379,
	VI5_D3_C3_MARK = 1380,
	VI1_D18_R2_MARK = 1381,
	VI5_D4_C4_MARK = 1382,
	VI1_D19_R3_MARK = 1383,
	VI5_D5_C5_MARK = 1384,
	VI1_D20_R4_MARK = 1385,
	VI5_D6_C6_MARK = 1386,
	VI1_D21_R5_MARK = 1387,
	VI5_D7_C7_MARK = 1388,
	VI1_D22_R6_MARK = 1389,
	VI5_D8_Y0_MARK = 1390,
	VI1_D23_R7_MARK = 1391,
	MSIOF0_SCK_MARK___5 = 1392,
	HSCK0_MARK___6 = 1393,
	MSIOF0_SYNC_MARK___5 = 1394,
	HCTS0_N_MARK___4 = 1395,
	MSIOF0_TXD_MARK___6 = 1396,
	HTX0_MARK___4 = 1397,
	MSIOF0_RXD_MARK___6 = 1398,
	HRX0_MARK___4 = 1399,
	MSIOF1_SCK_MARK___5 = 1400,
	HSCK1_MARK___5 = 1401,
	MSIOF1_SYNC_MARK___5 = 1402,
	HRTS1_N_MARK___3 = 1403,
	MSIOF1_TXD_MARK___5 = 1404,
	HTX1_MARK___4 = 1405,
	MSIOF1_RXD_MARK___5 = 1406,
	HRX1_MARK___4 = 1407,
	DRACK0_MARK___7 = 1408,
	SCK2_MARK___3 = 1409,
	DACK0_MARK___8 = 1410,
	TX2_MARK___4 = 1411,
	DREQ0_N_MARK___4 = 1412,
	RX2_MARK___4 = 1413,
	DACK1_MARK___7 = 1414,
	SCK3_MARK___2 = 1415,
	TX3_MARK___2 = 1416,
	DREQ1_N_MARK___4 = 1417,
	RX3_MARK___2 = 1418,
	PWM0_MARK___6 = 1419,
	TCLK1_MARK___6 = 1420,
	FSO_CFE_0_MARK = 1421,
	PWM1_MARK___7 = 1422,
	TCLK2_MARK___4 = 1423,
	FSO_CFE_1_MARK = 1424,
	PWM2_MARK___6 = 1425,
	TCLK3_MARK = 1426,
	FSO_TOE_MARK = 1427,
	PWM3_MARK___6 = 1428,
	PWM4_MARK___6 = 1429,
	SSI_SCK34_MARK___7 = 1430,
	TPU0TO0_MARK___4 = 1431,
	SSI_WS34_MARK___7 = 1432,
	TPU0TO1_MARK___4 = 1433,
	SSI_SDATA3_MARK___7 = 1434,
	TPU0TO2_MARK___3 = 1435,
	SSI_SCK4_MARK___6 = 1436,
	TPU0TO3_MARK___4 = 1437,
	SSI_WS4_MARK___6 = 1438,
	SSI_SDATA4_MARK___6 = 1439,
	AUDIO_CLKOUT_MARK___5 = 1440,
	AUDIO_CLKA_MARK___6 = 1441,
	AUDIO_CLKB_MARK___6 = 1442,
	PINMUX_MARK_END___10 = 1443,
};

struct regulator_consumer_supply {
	const char *dev_name;
	const char *supply;
};

enum {
	PINMUX_RESERVED___11 = 0,
	PINMUX_DATA_BEGIN___11 = 1,
	PORT0_DATA___4 = 2,
	PORT1_DATA___4 = 3,
	PORT2_DATA___4 = 4,
	PORT3_DATA___4 = 5,
	PORT4_DATA___4 = 6,
	PORT5_DATA___4 = 7,
	PORT6_DATA___4 = 8,
	PORT7_DATA___4 = 9,
	PORT8_DATA___4 = 10,
	PORT9_DATA___4 = 11,
	PORT10_DATA___4 = 12,
	PORT11_DATA___4 = 13,
	PORT12_DATA___4 = 14,
	PORT13_DATA___4 = 15,
	PORT14_DATA___4 = 16,
	PORT15_DATA___4 = 17,
	PORT16_DATA___4 = 18,
	PORT17_DATA___4 = 19,
	PORT18_DATA___4 = 20,
	PORT19_DATA___4 = 21,
	PORT20_DATA___4 = 22,
	PORT21_DATA___4 = 23,
	PORT22_DATA___4 = 24,
	PORT23_DATA___4 = 25,
	PORT24_DATA___4 = 26,
	PORT25_DATA___4 = 27,
	PORT26_DATA___4 = 28,
	PORT27_DATA___4 = 29,
	PORT28_DATA___4 = 30,
	PORT29_DATA___4 = 31,
	PORT30_DATA___4 = 32,
	PORT31_DATA___3 = 33,
	PORT32_DATA___4 = 34,
	PORT33_DATA___4 = 35,
	PORT34_DATA___4 = 36,
	PORT35_DATA___4 = 37,
	PORT36_DATA___4 = 38,
	PORT37_DATA___4 = 39,
	PORT38_DATA___4 = 40,
	PORT39_DATA___4 = 41,
	PORT40_DATA___4 = 42,
	PORT41_DATA___3 = 43,
	PORT42_DATA___3 = 44,
	PORT43_DATA___3 = 45,
	PORT44_DATA___3 = 46,
	PORT45_DATA___3 = 47,
	PORT46_DATA___3 = 48,
	PORT47_DATA___3 = 49,
	PORT48_DATA___3 = 50,
	PORT49_DATA___3 = 51,
	PORT50_DATA___3 = 52,
	PORT51_DATA___3 = 53,
	PORT52_DATA___3 = 54,
	PORT53_DATA___3 = 55,
	PORT54_DATA___3 = 56,
	PORT55_DATA___3 = 57,
	PORT56_DATA___3 = 58,
	PORT57_DATA___3 = 59,
	PORT58_DATA___3 = 60,
	PORT59_DATA___3 = 61,
	PORT60_DATA___3 = 62,
	PORT61_DATA___3 = 63,
	PORT62_DATA___3 = 64,
	PORT63_DATA___3 = 65,
	PORT64_DATA___4 = 66,
	PORT65_DATA___4 = 67,
	PORT66_DATA___4 = 68,
	PORT67_DATA___4 = 69,
	PORT68_DATA___4 = 70,
	PORT69_DATA___4 = 71,
	PORT70_DATA___4 = 72,
	PORT71_DATA___4 = 73,
	PORT72_DATA___4 = 74,
	PORT73_DATA___4 = 75,
	PORT74_DATA___4 = 76,
	PORT75_DATA___4 = 77,
	PORT76_DATA___4 = 78,
	PORT77_DATA___4 = 79,
	PORT78_DATA___4 = 80,
	PORT79_DATA___4 = 81,
	PORT80_DATA___4 = 82,
	PORT81_DATA___4 = 83,
	PORT82_DATA___4 = 84,
	PORT83_DATA___4 = 85,
	PORT84_DATA___4 = 86,
	PORT85_DATA___4 = 87,
	PORT86_DATA___3 = 88,
	PORT87_DATA___3 = 89,
	PORT88_DATA___3 = 90,
	PORT89_DATA___3 = 91,
	PORT90_DATA___3 = 92,
	PORT91_DATA___3 = 93,
	PORT92_DATA___3 = 94,
	PORT93_DATA___3 = 95,
	PORT94_DATA___3 = 96,
	PORT95_DATA___3 = 97,
	PORT96_DATA___4 = 98,
	PORT97_DATA___4 = 99,
	PORT98_DATA___4 = 100,
	PORT99_DATA___4 = 101,
	PORT100_DATA___4 = 102,
	PORT101_DATA___4 = 103,
	PORT102_DATA___4 = 104,
	PORT103_DATA___4 = 105,
	PORT104_DATA___4 = 106,
	PORT105_DATA___4 = 107,
	PORT106_DATA___4 = 108,
	PORT107_DATA___4 = 109,
	PORT108_DATA___4 = 110,
	PORT109_DATA___4 = 111,
	PORT110_DATA___4 = 112,
	PORT111_DATA___4 = 113,
	PORT112_DATA___4 = 114,
	PORT113_DATA___4 = 115,
	PORT114_DATA___4 = 116,
	PORT115_DATA___4 = 117,
	PORT116_DATA___4 = 118,
	PORT117_DATA___4 = 119,
	PORT118_DATA___4 = 120,
	PORT128_DATA___4 = 121,
	PORT129_DATA___4 = 122,
	PORT130_DATA___4 = 123,
	PORT131_DATA___4 = 124,
	PORT132_DATA___4 = 125,
	PORT133_DATA___4 = 126,
	PORT134_DATA___4 = 127,
	PORT135_DATA___3 = 128,
	PORT136_DATA___3 = 129,
	PORT137_DATA___3 = 130,
	PORT138_DATA___3 = 131,
	PORT139_DATA___3 = 132,
	PORT140_DATA___3 = 133,
	PORT141_DATA___3 = 134,
	PORT142_DATA___3 = 135,
	PORT143_DATA___3 = 136,
	PORT144_DATA___3 = 137,
	PORT145_DATA___3 = 138,
	PORT146_DATA___3 = 139,
	PORT147_DATA___3 = 140,
	PORT148_DATA___3 = 141,
	PORT149_DATA___3 = 142,
	PORT150_DATA___3 = 143,
	PORT151_DATA___3 = 144,
	PORT152_DATA___3 = 145,
	PORT153_DATA___3 = 146,
	PORT154_DATA___3 = 147,
	PORT155_DATA___3 = 148,
	PORT156_DATA___3 = 149,
	PORT157_DATA___3 = 150,
	PORT158_DATA___3 = 151,
	PORT159_DATA___2 = 152,
	PORT160_DATA___3 = 153,
	PORT161_DATA___3 = 154,
	PORT162_DATA___3 = 155,
	PORT163_DATA___3 = 156,
	PORT164_DATA___3 = 157,
	PORT192_DATA___3 = 158,
	PORT193_DATA___3 = 159,
	PORT194_DATA___3 = 160,
	PORT195_DATA___3 = 161,
	PORT196_DATA___3 = 162,
	PORT197_DATA___3 = 163,
	PORT198_DATA___3 = 164,
	PORT199_DATA___3 = 165,
	PORT200_DATA___3 = 166,
	PORT201_DATA___3 = 167,
	PORT202_DATA___3 = 168,
	PORT203_DATA___3 = 169,
	PORT204_DATA___3 = 170,
	PORT205_DATA___3 = 171,
	PORT206_DATA___3 = 172,
	PORT207_DATA___3 = 173,
	PORT208_DATA___3 = 174,
	PORT209_DATA___3 = 175,
	PORT210_DATA___3 = 176,
	PORT211_DATA___3 = 177,
	PORT212_DATA___2 = 178,
	PORT213_DATA___2 = 179,
	PORT214_DATA___2 = 180,
	PORT215_DATA___2 = 181,
	PORT216_DATA___2 = 182,
	PORT217_DATA___2 = 183,
	PORT218_DATA___2 = 184,
	PORT219_DATA___2 = 185,
	PORT220_DATA___2 = 186,
	PORT221_DATA___2 = 187,
	PORT222_DATA___2 = 188,
	PORT223_DATA = 189,
	PORT224_DATA___2 = 190,
	PORT225_DATA___2 = 191,
	PORT226_DATA___2 = 192,
	PORT227_DATA___2 = 193,
	PORT228_DATA___2 = 194,
	PORT229_DATA___2 = 195,
	PORT230_DATA___2 = 196,
	PORT231_DATA___2 = 197,
	PORT232_DATA___2 = 198,
	PORT233_DATA___2 = 199,
	PORT234_DATA___2 = 200,
	PORT235_DATA___2 = 201,
	PORT236_DATA___2 = 202,
	PORT237_DATA___2 = 203,
	PORT238_DATA___2 = 204,
	PORT239_DATA___2 = 205,
	PORT240_DATA___2 = 206,
	PORT241_DATA___2 = 207,
	PORT242_DATA___2 = 208,
	PORT243_DATA___2 = 209,
	PORT244_DATA___2 = 210,
	PORT245_DATA___2 = 211,
	PORT246_DATA___2 = 212,
	PORT247_DATA___2 = 213,
	PORT248_DATA___2 = 214,
	PORT249_DATA___2 = 215,
	PORT250_DATA___2 = 216,
	PORT251_DATA = 217,
	PORT252_DATA = 218,
	PORT253_DATA = 219,
	PORT254_DATA = 220,
	PORT255_DATA = 221,
	PORT256_DATA___2 = 222,
	PORT257_DATA___2 = 223,
	PORT258_DATA___2 = 224,
	PORT259_DATA___2 = 225,
	PORT260_DATA___2 = 226,
	PORT261_DATA___2 = 227,
	PORT262_DATA___2 = 228,
	PORT263_DATA___2 = 229,
	PORT264_DATA___2 = 230,
	PORT265_DATA___2 = 231,
	PORT266_DATA___2 = 232,
	PORT267_DATA___2 = 233,
	PORT268_DATA___2 = 234,
	PORT269_DATA___2 = 235,
	PORT270_DATA___2 = 236,
	PORT271_DATA___2 = 237,
	PORT272_DATA___2 = 238,
	PORT273_DATA___2 = 239,
	PORT274_DATA___2 = 240,
	PORT275_DATA___2 = 241,
	PORT276_DATA___2 = 242,
	PORT277_DATA___2 = 243,
	PORT278_DATA___2 = 244,
	PORT279_DATA___2 = 245,
	PORT280_DATA___2 = 246,
	PORT281_DATA___2 = 247,
	PORT282_DATA___2 = 248,
	PORT288_DATA___2 = 249,
	PORT289_DATA___2 = 250,
	PORT290_DATA___2 = 251,
	PORT291_DATA___2 = 252,
	PORT292_DATA___2 = 253,
	PORT293_DATA___2 = 254,
	PORT294_DATA___2 = 255,
	PORT295_DATA___2 = 256,
	PORT296_DATA___2 = 257,
	PORT297_DATA___2 = 258,
	PORT298_DATA___2 = 259,
	PORT299_DATA___2 = 260,
	PORT300_DATA___2 = 261,
	PORT301_DATA___2 = 262,
	PORT302_DATA___2 = 263,
	PORT303_DATA___2 = 264,
	PORT304_DATA___2 = 265,
	PORT305_DATA___2 = 266,
	PORT306_DATA___2 = 267,
	PORT307_DATA___2 = 268,
	PORT308_DATA___2 = 269,
	PORT309_DATA = 270,
	PINMUX_DATA_END___11 = 271,
	PINMUX_INPUT_BEGIN___3 = 272,
	PORT0_IN___3 = 273,
	PORT1_IN___3 = 274,
	PORT2_IN___3 = 275,
	PORT3_IN___3 = 276,
	PORT4_IN___3 = 277,
	PORT5_IN___3 = 278,
	PORT6_IN___3 = 279,
	PORT7_IN___3 = 280,
	PORT8_IN___3 = 281,
	PORT9_IN___3 = 282,
	PORT10_IN___3 = 283,
	PORT11_IN___3 = 284,
	PORT12_IN___3 = 285,
	PORT13_IN___3 = 286,
	PORT14_IN___3 = 287,
	PORT15_IN___3 = 288,
	PORT16_IN___3 = 289,
	PORT17_IN___3 = 290,
	PORT18_IN___3 = 291,
	PORT19_IN___3 = 292,
	PORT20_IN___3 = 293,
	PORT21_IN___3 = 294,
	PORT22_IN___3 = 295,
	PORT23_IN___3 = 296,
	PORT24_IN___3 = 297,
	PORT25_IN___3 = 298,
	PORT26_IN___3 = 299,
	PORT27_IN___3 = 300,
	PORT28_IN___3 = 301,
	PORT29_IN___3 = 302,
	PORT30_IN___3 = 303,
	PORT31_IN___2 = 304,
	PORT32_IN___3 = 305,
	PORT33_IN___3 = 306,
	PORT34_IN___3 = 307,
	PORT35_IN___3 = 308,
	PORT36_IN___3 = 309,
	PORT37_IN___3 = 310,
	PORT38_IN___3 = 311,
	PORT39_IN___3 = 312,
	PORT40_IN___3 = 313,
	PORT41_IN___2 = 314,
	PORT42_IN___2 = 315,
	PORT43_IN___2 = 316,
	PORT44_IN___2 = 317,
	PORT45_IN___2 = 318,
	PORT46_IN___2 = 319,
	PORT47_IN___2 = 320,
	PORT48_IN___2 = 321,
	PORT49_IN___2 = 322,
	PORT50_IN___2 = 323,
	PORT51_IN___2 = 324,
	PORT52_IN___2 = 325,
	PORT53_IN___2 = 326,
	PORT54_IN___2 = 327,
	PORT55_IN___2 = 328,
	PORT56_IN___2 = 329,
	PORT57_IN___2 = 330,
	PORT58_IN___2 = 331,
	PORT59_IN___2 = 332,
	PORT60_IN___2 = 333,
	PORT61_IN___2 = 334,
	PORT62_IN___2 = 335,
	PORT63_IN___2 = 336,
	PORT64_IN___3 = 337,
	PORT65_IN___3 = 338,
	PORT66_IN___3 = 339,
	PORT67_IN___3 = 340,
	PORT68_IN___3 = 341,
	PORT69_IN___3 = 342,
	PORT70_IN___3 = 343,
	PORT71_IN___3 = 344,
	PORT72_IN___3 = 345,
	PORT73_IN___3 = 346,
	PORT74_IN___3 = 347,
	PORT75_IN___3 = 348,
	PORT76_IN___3 = 349,
	PORT77_IN___3 = 350,
	PORT78_IN___3 = 351,
	PORT79_IN___3 = 352,
	PORT80_IN___3 = 353,
	PORT81_IN___3 = 354,
	PORT82_IN___3 = 355,
	PORT83_IN___3 = 356,
	PORT84_IN___3 = 357,
	PORT85_IN___3 = 358,
	PORT86_IN___2 = 359,
	PORT87_IN___2 = 360,
	PORT88_IN___2 = 361,
	PORT89_IN___2 = 362,
	PORT90_IN___2 = 363,
	PORT91_IN___2 = 364,
	PORT92_IN___2 = 365,
	PORT93_IN___2 = 366,
	PORT94_IN___2 = 367,
	PORT95_IN___2 = 368,
	PORT96_IN___3 = 369,
	PORT97_IN___3 = 370,
	PORT98_IN___3 = 371,
	PORT99_IN___3 = 372,
	PORT100_IN___3 = 373,
	PORT101_IN___3 = 374,
	PORT102_IN___3 = 375,
	PORT103_IN___3 = 376,
	PORT104_IN___3 = 377,
	PORT105_IN___3 = 378,
	PORT106_IN___3 = 379,
	PORT107_IN___3 = 380,
	PORT108_IN___3 = 381,
	PORT109_IN___3 = 382,
	PORT110_IN___3 = 383,
	PORT111_IN___3 = 384,
	PORT112_IN___3 = 385,
	PORT113_IN___3 = 386,
	PORT114_IN___3 = 387,
	PORT115_IN___3 = 388,
	PORT116_IN___3 = 389,
	PORT117_IN___3 = 390,
	PORT118_IN___3 = 391,
	PORT128_IN___3 = 392,
	PORT129_IN___3 = 393,
	PORT130_IN___3 = 394,
	PORT131_IN___3 = 395,
	PORT132_IN___3 = 396,
	PORT133_IN___3 = 397,
	PORT134_IN___3 = 398,
	PORT135_IN___2 = 399,
	PORT136_IN___2 = 400,
	PORT137_IN___2 = 401,
	PORT138_IN___2 = 402,
	PORT139_IN___2 = 403,
	PORT140_IN___2 = 404,
	PORT141_IN___2 = 405,
	PORT142_IN___2 = 406,
	PORT143_IN___2 = 407,
	PORT144_IN___2 = 408,
	PORT145_IN___2 = 409,
	PORT146_IN___2 = 410,
	PORT147_IN___2 = 411,
	PORT148_IN___2 = 412,
	PORT149_IN___2 = 413,
	PORT150_IN___2 = 414,
	PORT151_IN___2 = 415,
	PORT152_IN___2 = 416,
	PORT153_IN___2 = 417,
	PORT154_IN___2 = 418,
	PORT155_IN___2 = 419,
	PORT156_IN___2 = 420,
	PORT157_IN___2 = 421,
	PORT158_IN___2 = 422,
	PORT159_IN___2 = 423,
	PORT160_IN___3 = 424,
	PORT161_IN___3 = 425,
	PORT162_IN___3 = 426,
	PORT163_IN___3 = 427,
	PORT164_IN___3 = 428,
	PORT192_IN___3 = 429,
	PORT193_IN___3 = 430,
	PORT194_IN___3 = 431,
	PORT195_IN___3 = 432,
	PORT196_IN___3 = 433,
	PORT197_IN___3 = 434,
	PORT198_IN___3 = 435,
	PORT199_IN___3 = 436,
	PORT200_IN___3 = 437,
	PORT201_IN___3 = 438,
	PORT202_IN___3 = 439,
	PORT203_IN___3 = 440,
	PORT204_IN___3 = 441,
	PORT205_IN___3 = 442,
	PORT206_IN___3 = 443,
	PORT207_IN___3 = 444,
	PORT208_IN___3 = 445,
	PORT209_IN___3 = 446,
	PORT210_IN___3 = 447,
	PORT211_IN___3 = 448,
	PORT212_IN___2 = 449,
	PORT213_IN___2 = 450,
	PORT214_IN___2 = 451,
	PORT215_IN___2 = 452,
	PORT216_IN___2 = 453,
	PORT217_IN___2 = 454,
	PORT218_IN___2 = 455,
	PORT219_IN___2 = 456,
	PORT220_IN___2 = 457,
	PORT221_IN___2 = 458,
	PORT222_IN___2 = 459,
	PORT223_IN = 460,
	PORT224_IN___2 = 461,
	PORT225_IN___2 = 462,
	PORT226_IN___2 = 463,
	PORT227_IN___2 = 464,
	PORT228_IN___2 = 465,
	PORT229_IN___2 = 466,
	PORT230_IN___2 = 467,
	PORT231_IN___2 = 468,
	PORT232_IN___2 = 469,
	PORT233_IN___2 = 470,
	PORT234_IN___2 = 471,
	PORT235_IN___2 = 472,
	PORT236_IN___2 = 473,
	PORT237_IN___2 = 474,
	PORT238_IN___2 = 475,
	PORT239_IN___2 = 476,
	PORT240_IN___2 = 477,
	PORT241_IN___2 = 478,
	PORT242_IN___2 = 479,
	PORT243_IN___2 = 480,
	PORT244_IN___2 = 481,
	PORT245_IN___2 = 482,
	PORT246_IN___2 = 483,
	PORT247_IN___2 = 484,
	PORT248_IN___2 = 485,
	PORT249_IN___2 = 486,
	PORT250_IN___2 = 487,
	PORT251_IN = 488,
	PORT252_IN = 489,
	PORT253_IN = 490,
	PORT254_IN = 491,
	PORT255_IN = 492,
	PORT256_IN___2 = 493,
	PORT257_IN___2 = 494,
	PORT258_IN___2 = 495,
	PORT259_IN___2 = 496,
	PORT260_IN___2 = 497,
	PORT261_IN___2 = 498,
	PORT262_IN___2 = 499,
	PORT263_IN___2 = 500,
	PORT264_IN___2 = 501,
	PORT265_IN___2 = 502,
	PORT266_IN___2 = 503,
	PORT267_IN___2 = 504,
	PORT268_IN___2 = 505,
	PORT269_IN___2 = 506,
	PORT270_IN___2 = 507,
	PORT271_IN___2 = 508,
	PORT272_IN___2 = 509,
	PORT273_IN___2 = 510,
	PORT274_IN___2 = 511,
	PORT275_IN___2 = 512,
	PORT276_IN___2 = 513,
	PORT277_IN___2 = 514,
	PORT278_IN___2 = 515,
	PORT279_IN___2 = 516,
	PORT280_IN___2 = 517,
	PORT281_IN___2 = 518,
	PORT282_IN___2 = 519,
	PORT288_IN___2 = 520,
	PORT289_IN___2 = 521,
	PORT290_IN___2 = 522,
	PORT291_IN___2 = 523,
	PORT292_IN___2 = 524,
	PORT293_IN___2 = 525,
	PORT294_IN___2 = 526,
	PORT295_IN___2 = 527,
	PORT296_IN___2 = 528,
	PORT297_IN___2 = 529,
	PORT298_IN___2 = 530,
	PORT299_IN___2 = 531,
	PORT300_IN___2 = 532,
	PORT301_IN___2 = 533,
	PORT302_IN___2 = 534,
	PORT303_IN___2 = 535,
	PORT304_IN___2 = 536,
	PORT305_IN___2 = 537,
	PORT306_IN___2 = 538,
	PORT307_IN___2 = 539,
	PORT308_IN___2 = 540,
	PORT309_IN = 541,
	PINMUX_INPUT_END___3 = 542,
	PINMUX_OUTPUT_BEGIN___3 = 543,
	PORT0_OUT___3 = 544,
	PORT1_OUT___3 = 545,
	PORT2_OUT___3 = 546,
	PORT3_OUT___3 = 547,
	PORT4_OUT___3 = 548,
	PORT5_OUT___3 = 549,
	PORT6_OUT___3 = 550,
	PORT7_OUT___3 = 551,
	PORT8_OUT___3 = 552,
	PORT9_OUT___3 = 553,
	PORT10_OUT___3 = 554,
	PORT11_OUT___3 = 555,
	PORT12_OUT___3 = 556,
	PORT13_OUT___3 = 557,
	PORT14_OUT___3 = 558,
	PORT15_OUT___3 = 559,
	PORT16_OUT___3 = 560,
	PORT17_OUT___3 = 561,
	PORT18_OUT___3 = 562,
	PORT19_OUT___3 = 563,
	PORT20_OUT___3 = 564,
	PORT21_OUT___3 = 565,
	PORT22_OUT___3 = 566,
	PORT23_OUT___3 = 567,
	PORT24_OUT___3 = 568,
	PORT25_OUT___3 = 569,
	PORT26_OUT___3 = 570,
	PORT27_OUT___3 = 571,
	PORT28_OUT___3 = 572,
	PORT29_OUT___3 = 573,
	PORT30_OUT___3 = 574,
	PORT31_OUT___2 = 575,
	PORT32_OUT___3 = 576,
	PORT33_OUT___3 = 577,
	PORT34_OUT___3 = 578,
	PORT35_OUT___3 = 579,
	PORT36_OUT___3 = 580,
	PORT37_OUT___3 = 581,
	PORT38_OUT___3 = 582,
	PORT39_OUT___3 = 583,
	PORT40_OUT___3 = 584,
	PORT41_OUT___2 = 585,
	PORT42_OUT___2 = 586,
	PORT43_OUT___2 = 587,
	PORT44_OUT___2 = 588,
	PORT45_OUT___2 = 589,
	PORT46_OUT___2 = 590,
	PORT47_OUT___2 = 591,
	PORT48_OUT___2 = 592,
	PORT49_OUT___2 = 593,
	PORT50_OUT___2 = 594,
	PORT51_OUT___2 = 595,
	PORT52_OUT___2 = 596,
	PORT53_OUT___2 = 597,
	PORT54_OUT___2 = 598,
	PORT55_OUT___2 = 599,
	PORT56_OUT___2 = 600,
	PORT57_OUT___2 = 601,
	PORT58_OUT___2 = 602,
	PORT59_OUT___2 = 603,
	PORT60_OUT___2 = 604,
	PORT61_OUT___2 = 605,
	PORT62_OUT___2 = 606,
	PORT63_OUT___2 = 607,
	PORT64_OUT___3 = 608,
	PORT65_OUT___3 = 609,
	PORT66_OUT___3 = 610,
	PORT67_OUT___3 = 611,
	PORT68_OUT___3 = 612,
	PORT69_OUT___3 = 613,
	PORT70_OUT___3 = 614,
	PORT71_OUT___3 = 615,
	PORT72_OUT___3 = 616,
	PORT73_OUT___3 = 617,
	PORT74_OUT___3 = 618,
	PORT75_OUT___3 = 619,
	PORT76_OUT___3 = 620,
	PORT77_OUT___3 = 621,
	PORT78_OUT___3 = 622,
	PORT79_OUT___3 = 623,
	PORT80_OUT___3 = 624,
	PORT81_OUT___3 = 625,
	PORT82_OUT___3 = 626,
	PORT83_OUT___3 = 627,
	PORT84_OUT___3 = 628,
	PORT85_OUT___3 = 629,
	PORT86_OUT___2 = 630,
	PORT87_OUT___2 = 631,
	PORT88_OUT___2 = 632,
	PORT89_OUT___2 = 633,
	PORT90_OUT___2 = 634,
	PORT91_OUT___2 = 635,
	PORT92_OUT___2 = 636,
	PORT93_OUT___2 = 637,
	PORT94_OUT___2 = 638,
	PORT95_OUT___2 = 639,
	PORT96_OUT___3 = 640,
	PORT97_OUT___3 = 641,
	PORT98_OUT___3 = 642,
	PORT99_OUT___3 = 643,
	PORT100_OUT___3 = 644,
	PORT101_OUT___3 = 645,
	PORT102_OUT___3 = 646,
	PORT103_OUT___3 = 647,
	PORT104_OUT___3 = 648,
	PORT105_OUT___3 = 649,
	PORT106_OUT___3 = 650,
	PORT107_OUT___3 = 651,
	PORT108_OUT___3 = 652,
	PORT109_OUT___3 = 653,
	PORT110_OUT___3 = 654,
	PORT111_OUT___3 = 655,
	PORT112_OUT___3 = 656,
	PORT113_OUT___3 = 657,
	PORT114_OUT___3 = 658,
	PORT115_OUT___3 = 659,
	PORT116_OUT___3 = 660,
	PORT117_OUT___3 = 661,
	PORT118_OUT___3 = 662,
	PORT128_OUT___3 = 663,
	PORT129_OUT___3 = 664,
	PORT130_OUT___3 = 665,
	PORT131_OUT___3 = 666,
	PORT132_OUT___3 = 667,
	PORT133_OUT___3 = 668,
	PORT134_OUT___3 = 669,
	PORT135_OUT___2 = 670,
	PORT136_OUT___2 = 671,
	PORT137_OUT___2 = 672,
	PORT138_OUT___2 = 673,
	PORT139_OUT___2 = 674,
	PORT140_OUT___2 = 675,
	PORT141_OUT___2 = 676,
	PORT142_OUT___2 = 677,
	PORT143_OUT___2 = 678,
	PORT144_OUT___2 = 679,
	PORT145_OUT___2 = 680,
	PORT146_OUT___2 = 681,
	PORT147_OUT___2 = 682,
	PORT148_OUT___2 = 683,
	PORT149_OUT___2 = 684,
	PORT150_OUT___2 = 685,
	PORT151_OUT___2 = 686,
	PORT152_OUT___2 = 687,
	PORT153_OUT___2 = 688,
	PORT154_OUT___2 = 689,
	PORT155_OUT___2 = 690,
	PORT156_OUT___2 = 691,
	PORT157_OUT___2 = 692,
	PORT158_OUT___2 = 693,
	PORT159_OUT___2 = 694,
	PORT160_OUT___3 = 695,
	PORT161_OUT___3 = 696,
	PORT162_OUT___3 = 697,
	PORT163_OUT___3 = 698,
	PORT164_OUT___3 = 699,
	PORT192_OUT___3 = 700,
	PORT193_OUT___3 = 701,
	PORT194_OUT___3 = 702,
	PORT195_OUT___3 = 703,
	PORT196_OUT___3 = 704,
	PORT197_OUT___3 = 705,
	PORT198_OUT___3 = 706,
	PORT199_OUT___3 = 707,
	PORT200_OUT___3 = 708,
	PORT201_OUT___3 = 709,
	PORT202_OUT___3 = 710,
	PORT203_OUT___3 = 711,
	PORT204_OUT___3 = 712,
	PORT205_OUT___3 = 713,
	PORT206_OUT___3 = 714,
	PORT207_OUT___3 = 715,
	PORT208_OUT___3 = 716,
	PORT209_OUT___3 = 717,
	PORT210_OUT___3 = 718,
	PORT211_OUT___3 = 719,
	PORT212_OUT___2 = 720,
	PORT213_OUT___2 = 721,
	PORT214_OUT___2 = 722,
	PORT215_OUT___2 = 723,
	PORT216_OUT___2 = 724,
	PORT217_OUT___2 = 725,
	PORT218_OUT___2 = 726,
	PORT219_OUT___2 = 727,
	PORT220_OUT___2 = 728,
	PORT221_OUT___2 = 729,
	PORT222_OUT___2 = 730,
	PORT223_OUT = 731,
	PORT224_OUT___2 = 732,
	PORT225_OUT___2 = 733,
	PORT226_OUT___2 = 734,
	PORT227_OUT___2 = 735,
	PORT228_OUT___2 = 736,
	PORT229_OUT___2 = 737,
	PORT230_OUT___2 = 738,
	PORT231_OUT___2 = 739,
	PORT232_OUT___2 = 740,
	PORT233_OUT___2 = 741,
	PORT234_OUT___2 = 742,
	PORT235_OUT___2 = 743,
	PORT236_OUT___2 = 744,
	PORT237_OUT___2 = 745,
	PORT238_OUT___2 = 746,
	PORT239_OUT___2 = 747,
	PORT240_OUT___2 = 748,
	PORT241_OUT___2 = 749,
	PORT242_OUT___2 = 750,
	PORT243_OUT___2 = 751,
	PORT244_OUT___2 = 752,
	PORT245_OUT___2 = 753,
	PORT246_OUT___2 = 754,
	PORT247_OUT___2 = 755,
	PORT248_OUT___2 = 756,
	PORT249_OUT___2 = 757,
	PORT250_OUT___2 = 758,
	PORT251_OUT = 759,
	PORT252_OUT = 760,
	PORT253_OUT = 761,
	PORT254_OUT = 762,
	PORT255_OUT = 763,
	PORT256_OUT___2 = 764,
	PORT257_OUT___2 = 765,
	PORT258_OUT___2 = 766,
	PORT259_OUT___2 = 767,
	PORT260_OUT___2 = 768,
	PORT261_OUT___2 = 769,
	PORT262_OUT___2 = 770,
	PORT263_OUT___2 = 771,
	PORT264_OUT___2 = 772,
	PORT265_OUT___2 = 773,
	PORT266_OUT___2 = 774,
	PORT267_OUT___2 = 775,
	PORT268_OUT___2 = 776,
	PORT269_OUT___2 = 777,
	PORT270_OUT___2 = 778,
	PORT271_OUT___2 = 779,
	PORT272_OUT___2 = 780,
	PORT273_OUT___2 = 781,
	PORT274_OUT___2 = 782,
	PORT275_OUT___2 = 783,
	PORT276_OUT___2 = 784,
	PORT277_OUT___2 = 785,
	PORT278_OUT___2 = 786,
	PORT279_OUT___2 = 787,
	PORT280_OUT___2 = 788,
	PORT281_OUT___2 = 789,
	PORT282_OUT___2 = 790,
	PORT288_OUT___2 = 791,
	PORT289_OUT___2 = 792,
	PORT290_OUT___2 = 793,
	PORT291_OUT___2 = 794,
	PORT292_OUT___2 = 795,
	PORT293_OUT___2 = 796,
	PORT294_OUT___2 = 797,
	PORT295_OUT___2 = 798,
	PORT296_OUT___2 = 799,
	PORT297_OUT___2 = 800,
	PORT298_OUT___2 = 801,
	PORT299_OUT___2 = 802,
	PORT300_OUT___2 = 803,
	PORT301_OUT___2 = 804,
	PORT302_OUT___2 = 805,
	PORT303_OUT___2 = 806,
	PORT304_OUT___2 = 807,
	PORT305_OUT___2 = 808,
	PORT306_OUT___2 = 809,
	PORT307_OUT___2 = 810,
	PORT308_OUT___2 = 811,
	PORT309_OUT = 812,
	PINMUX_OUTPUT_END___3 = 813,
	PINMUX_FUNCTION_BEGIN___11 = 814,
	PORT0_FN_IN___3 = 815,
	PORT1_FN_IN___3 = 816,
	PORT2_FN_IN___3 = 817,
	PORT3_FN_IN___3 = 818,
	PORT4_FN_IN___3 = 819,
	PORT5_FN_IN___3 = 820,
	PORT6_FN_IN___3 = 821,
	PORT7_FN_IN___3 = 822,
	PORT8_FN_IN___3 = 823,
	PORT9_FN_IN___3 = 824,
	PORT10_FN_IN___3 = 825,
	PORT11_FN_IN___3 = 826,
	PORT12_FN_IN___3 = 827,
	PORT13_FN_IN___3 = 828,
	PORT14_FN_IN___3 = 829,
	PORT15_FN_IN___3 = 830,
	PORT16_FN_IN___3 = 831,
	PORT17_FN_IN___3 = 832,
	PORT18_FN_IN___3 = 833,
	PORT19_FN_IN___3 = 834,
	PORT20_FN_IN___3 = 835,
	PORT21_FN_IN___3 = 836,
	PORT22_FN_IN___3 = 837,
	PORT23_FN_IN___3 = 838,
	PORT24_FN_IN___3 = 839,
	PORT25_FN_IN___3 = 840,
	PORT26_FN_IN___3 = 841,
	PORT27_FN_IN___3 = 842,
	PORT28_FN_IN___3 = 843,
	PORT29_FN_IN___3 = 844,
	PORT30_FN_IN___3 = 845,
	PORT31_FN_IN___2 = 846,
	PORT32_FN_IN___3 = 847,
	PORT33_FN_IN___3 = 848,
	PORT34_FN_IN___3 = 849,
	PORT35_FN_IN___3 = 850,
	PORT36_FN_IN___3 = 851,
	PORT37_FN_IN___3 = 852,
	PORT38_FN_IN___3 = 853,
	PORT39_FN_IN___3 = 854,
	PORT40_FN_IN___3 = 855,
	PORT41_FN_IN___2 = 856,
	PORT42_FN_IN___2 = 857,
	PORT43_FN_IN___2 = 858,
	PORT44_FN_IN___2 = 859,
	PORT45_FN_IN___2 = 860,
	PORT46_FN_IN___2 = 861,
	PORT47_FN_IN___2 = 862,
	PORT48_FN_IN___2 = 863,
	PORT49_FN_IN___2 = 864,
	PORT50_FN_IN___2 = 865,
	PORT51_FN_IN___2 = 866,
	PORT52_FN_IN___2 = 867,
	PORT53_FN_IN___2 = 868,
	PORT54_FN_IN___2 = 869,
	PORT55_FN_IN___2 = 870,
	PORT56_FN_IN___2 = 871,
	PORT57_FN_IN___2 = 872,
	PORT58_FN_IN___2 = 873,
	PORT59_FN_IN___2 = 874,
	PORT60_FN_IN___2 = 875,
	PORT61_FN_IN___2 = 876,
	PORT62_FN_IN___2 = 877,
	PORT63_FN_IN___2 = 878,
	PORT64_FN_IN___3 = 879,
	PORT65_FN_IN___3 = 880,
	PORT66_FN_IN___3 = 881,
	PORT67_FN_IN___3 = 882,
	PORT68_FN_IN___3 = 883,
	PORT69_FN_IN___3 = 884,
	PORT70_FN_IN___3 = 885,
	PORT71_FN_IN___3 = 886,
	PORT72_FN_IN___3 = 887,
	PORT73_FN_IN___3 = 888,
	PORT74_FN_IN___3 = 889,
	PORT75_FN_IN___3 = 890,
	PORT76_FN_IN___3 = 891,
	PORT77_FN_IN___3 = 892,
	PORT78_FN_IN___3 = 893,
	PORT79_FN_IN___3 = 894,
	PORT80_FN_IN___3 = 895,
	PORT81_FN_IN___3 = 896,
	PORT82_FN_IN___3 = 897,
	PORT83_FN_IN___3 = 898,
	PORT84_FN_IN___3 = 899,
	PORT85_FN_IN___3 = 900,
	PORT86_FN_IN___2 = 901,
	PORT87_FN_IN___2 = 902,
	PORT88_FN_IN___2 = 903,
	PORT89_FN_IN___2 = 904,
	PORT90_FN_IN___2 = 905,
	PORT91_FN_IN___2 = 906,
	PORT92_FN_IN___2 = 907,
	PORT93_FN_IN___2 = 908,
	PORT94_FN_IN___2 = 909,
	PORT95_FN_IN___2 = 910,
	PORT96_FN_IN___3 = 911,
	PORT97_FN_IN___3 = 912,
	PORT98_FN_IN___3 = 913,
	PORT99_FN_IN___3 = 914,
	PORT100_FN_IN___3 = 915,
	PORT101_FN_IN___3 = 916,
	PORT102_FN_IN___3 = 917,
	PORT103_FN_IN___3 = 918,
	PORT104_FN_IN___3 = 919,
	PORT105_FN_IN___3 = 920,
	PORT106_FN_IN___3 = 921,
	PORT107_FN_IN___3 = 922,
	PORT108_FN_IN___3 = 923,
	PORT109_FN_IN___3 = 924,
	PORT110_FN_IN___3 = 925,
	PORT111_FN_IN___3 = 926,
	PORT112_FN_IN___3 = 927,
	PORT113_FN_IN___3 = 928,
	PORT114_FN_IN___3 = 929,
	PORT115_FN_IN___3 = 930,
	PORT116_FN_IN___3 = 931,
	PORT117_FN_IN___3 = 932,
	PORT118_FN_IN___3 = 933,
	PORT128_FN_IN___3 = 934,
	PORT129_FN_IN___3 = 935,
	PORT130_FN_IN___3 = 936,
	PORT131_FN_IN___3 = 937,
	PORT132_FN_IN___3 = 938,
	PORT133_FN_IN___3 = 939,
	PORT134_FN_IN___3 = 940,
	PORT135_FN_IN___2 = 941,
	PORT136_FN_IN___2 = 942,
	PORT137_FN_IN___2 = 943,
	PORT138_FN_IN___2 = 944,
	PORT139_FN_IN___2 = 945,
	PORT140_FN_IN___2 = 946,
	PORT141_FN_IN___2 = 947,
	PORT142_FN_IN___2 = 948,
	PORT143_FN_IN___2 = 949,
	PORT144_FN_IN___2 = 950,
	PORT145_FN_IN___2 = 951,
	PORT146_FN_IN___2 = 952,
	PORT147_FN_IN___2 = 953,
	PORT148_FN_IN___2 = 954,
	PORT149_FN_IN___2 = 955,
	PORT150_FN_IN___2 = 956,
	PORT151_FN_IN___2 = 957,
	PORT152_FN_IN___2 = 958,
	PORT153_FN_IN___2 = 959,
	PORT154_FN_IN___2 = 960,
	PORT155_FN_IN___2 = 961,
	PORT156_FN_IN___2 = 962,
	PORT157_FN_IN___2 = 963,
	PORT158_FN_IN___2 = 964,
	PORT159_FN_IN___2 = 965,
	PORT160_FN_IN___3 = 966,
	PORT161_FN_IN___3 = 967,
	PORT162_FN_IN___3 = 968,
	PORT163_FN_IN___3 = 969,
	PORT164_FN_IN___3 = 970,
	PORT192_FN_IN___3 = 971,
	PORT193_FN_IN___3 = 972,
	PORT194_FN_IN___3 = 973,
	PORT195_FN_IN___3 = 974,
	PORT196_FN_IN___3 = 975,
	PORT197_FN_IN___3 = 976,
	PORT198_FN_IN___3 = 977,
	PORT199_FN_IN___3 = 978,
	PORT200_FN_IN___3 = 979,
	PORT201_FN_IN___3 = 980,
	PORT202_FN_IN___3 = 981,
	PORT203_FN_IN___3 = 982,
	PORT204_FN_IN___3 = 983,
	PORT205_FN_IN___3 = 984,
	PORT206_FN_IN___3 = 985,
	PORT207_FN_IN___3 = 986,
	PORT208_FN_IN___3 = 987,
	PORT209_FN_IN___3 = 988,
	PORT210_FN_IN___3 = 989,
	PORT211_FN_IN___3 = 990,
	PORT212_FN_IN___2 = 991,
	PORT213_FN_IN___2 = 992,
	PORT214_FN_IN___2 = 993,
	PORT215_FN_IN___2 = 994,
	PORT216_FN_IN___2 = 995,
	PORT217_FN_IN___2 = 996,
	PORT218_FN_IN___2 = 997,
	PORT219_FN_IN___2 = 998,
	PORT220_FN_IN___2 = 999,
	PORT221_FN_IN___2 = 1000,
	PORT222_FN_IN___2 = 1001,
	PORT223_FN_IN = 1002,
	PORT224_FN_IN___2 = 1003,
	PORT225_FN_IN___2 = 1004,
	PORT226_FN_IN___2 = 1005,
	PORT227_FN_IN___2 = 1006,
	PORT228_FN_IN___2 = 1007,
	PORT229_FN_IN___2 = 1008,
	PORT230_FN_IN___2 = 1009,
	PORT231_FN_IN___2 = 1010,
	PORT232_FN_IN___2 = 1011,
	PORT233_FN_IN___2 = 1012,
	PORT234_FN_IN___2 = 1013,
	PORT235_FN_IN___2 = 1014,
	PORT236_FN_IN___2 = 1015,
	PORT237_FN_IN___2 = 1016,
	PORT238_FN_IN___2 = 1017,
	PORT239_FN_IN___2 = 1018,
	PORT240_FN_IN___2 = 1019,
	PORT241_FN_IN___2 = 1020,
	PORT242_FN_IN___2 = 1021,
	PORT243_FN_IN___2 = 1022,
	PORT244_FN_IN___2 = 1023,
	PORT245_FN_IN___2 = 1024,
	PORT246_FN_IN___2 = 1025,
	PORT247_FN_IN___2 = 1026,
	PORT248_FN_IN___2 = 1027,
	PORT249_FN_IN___2 = 1028,
	PORT250_FN_IN___2 = 1029,
	PORT251_FN_IN = 1030,
	PORT252_FN_IN = 1031,
	PORT253_FN_IN = 1032,
	PORT254_FN_IN = 1033,
	PORT255_FN_IN = 1034,
	PORT256_FN_IN___2 = 1035,
	PORT257_FN_IN___2 = 1036,
	PORT258_FN_IN___2 = 1037,
	PORT259_FN_IN___2 = 1038,
	PORT260_FN_IN___2 = 1039,
	PORT261_FN_IN___2 = 1040,
	PORT262_FN_IN___2 = 1041,
	PORT263_FN_IN___2 = 1042,
	PORT264_FN_IN___2 = 1043,
	PORT265_FN_IN___2 = 1044,
	PORT266_FN_IN___2 = 1045,
	PORT267_FN_IN___2 = 1046,
	PORT268_FN_IN___2 = 1047,
	PORT269_FN_IN___2 = 1048,
	PORT270_FN_IN___2 = 1049,
	PORT271_FN_IN___2 = 1050,
	PORT272_FN_IN___2 = 1051,
	PORT273_FN_IN___2 = 1052,
	PORT274_FN_IN___2 = 1053,
	PORT275_FN_IN___2 = 1054,
	PORT276_FN_IN___2 = 1055,
	PORT277_FN_IN___2 = 1056,
	PORT278_FN_IN___2 = 1057,
	PORT279_FN_IN___2 = 1058,
	PORT280_FN_IN___2 = 1059,
	PORT281_FN_IN___2 = 1060,
	PORT282_FN_IN___2 = 1061,
	PORT288_FN_IN___2 = 1062,
	PORT289_FN_IN___2 = 1063,
	PORT290_FN_IN___2 = 1064,
	PORT291_FN_IN___2 = 1065,
	PORT292_FN_IN___2 = 1066,
	PORT293_FN_IN___2 = 1067,
	PORT294_FN_IN___2 = 1068,
	PORT295_FN_IN___2 = 1069,
	PORT296_FN_IN___2 = 1070,
	PORT297_FN_IN___2 = 1071,
	PORT298_FN_IN___2 = 1072,
	PORT299_FN_IN___2 = 1073,
	PORT300_FN_IN___2 = 1074,
	PORT301_FN_IN___2 = 1075,
	PORT302_FN_IN___2 = 1076,
	PORT303_FN_IN___2 = 1077,
	PORT304_FN_IN___2 = 1078,
	PORT305_FN_IN___2 = 1079,
	PORT306_FN_IN___2 = 1080,
	PORT307_FN_IN___2 = 1081,
	PORT308_FN_IN___2 = 1082,
	PORT309_FN_IN = 1083,
	PORT0_FN_OUT___3 = 1084,
	PORT1_FN_OUT___3 = 1085,
	PORT2_FN_OUT___3 = 1086,
	PORT3_FN_OUT___3 = 1087,
	PORT4_FN_OUT___3 = 1088,
	PORT5_FN_OUT___3 = 1089,
	PORT6_FN_OUT___3 = 1090,
	PORT7_FN_OUT___3 = 1091,
	PORT8_FN_OUT___3 = 1092,
	PORT9_FN_OUT___3 = 1093,
	PORT10_FN_OUT___3 = 1094,
	PORT11_FN_OUT___3 = 1095,
	PORT12_FN_OUT___3 = 1096,
	PORT13_FN_OUT___3 = 1097,
	PORT14_FN_OUT___3 = 1098,
	PORT15_FN_OUT___3 = 1099,
	PORT16_FN_OUT___3 = 1100,
	PORT17_FN_OUT___3 = 1101,
	PORT18_FN_OUT___3 = 1102,
	PORT19_FN_OUT___3 = 1103,
	PORT20_FN_OUT___3 = 1104,
	PORT21_FN_OUT___3 = 1105,
	PORT22_FN_OUT___3 = 1106,
	PORT23_FN_OUT___3 = 1107,
	PORT24_FN_OUT___3 = 1108,
	PORT25_FN_OUT___3 = 1109,
	PORT26_FN_OUT___3 = 1110,
	PORT27_FN_OUT___3 = 1111,
	PORT28_FN_OUT___3 = 1112,
	PORT29_FN_OUT___3 = 1113,
	PORT30_FN_OUT___3 = 1114,
	PORT31_FN_OUT___2 = 1115,
	PORT32_FN_OUT___3 = 1116,
	PORT33_FN_OUT___3 = 1117,
	PORT34_FN_OUT___3 = 1118,
	PORT35_FN_OUT___3 = 1119,
	PORT36_FN_OUT___3 = 1120,
	PORT37_FN_OUT___3 = 1121,
	PORT38_FN_OUT___3 = 1122,
	PORT39_FN_OUT___3 = 1123,
	PORT40_FN_OUT___3 = 1124,
	PORT41_FN_OUT___2 = 1125,
	PORT42_FN_OUT___2 = 1126,
	PORT43_FN_OUT___2 = 1127,
	PORT44_FN_OUT___2 = 1128,
	PORT45_FN_OUT___2 = 1129,
	PORT46_FN_OUT___2 = 1130,
	PORT47_FN_OUT___2 = 1131,
	PORT48_FN_OUT___2 = 1132,
	PORT49_FN_OUT___2 = 1133,
	PORT50_FN_OUT___2 = 1134,
	PORT51_FN_OUT___2 = 1135,
	PORT52_FN_OUT___2 = 1136,
	PORT53_FN_OUT___2 = 1137,
	PORT54_FN_OUT___2 = 1138,
	PORT55_FN_OUT___2 = 1139,
	PORT56_FN_OUT___2 = 1140,
	PORT57_FN_OUT___2 = 1141,
	PORT58_FN_OUT___2 = 1142,
	PORT59_FN_OUT___2 = 1143,
	PORT60_FN_OUT___2 = 1144,
	PORT61_FN_OUT___2 = 1145,
	PORT62_FN_OUT___2 = 1146,
	PORT63_FN_OUT___2 = 1147,
	PORT64_FN_OUT___3 = 1148,
	PORT65_FN_OUT___3 = 1149,
	PORT66_FN_OUT___3 = 1150,
	PORT67_FN_OUT___3 = 1151,
	PORT68_FN_OUT___3 = 1152,
	PORT69_FN_OUT___3 = 1153,
	PORT70_FN_OUT___3 = 1154,
	PORT71_FN_OUT___3 = 1155,
	PORT72_FN_OUT___3 = 1156,
	PORT73_FN_OUT___3 = 1157,
	PORT74_FN_OUT___3 = 1158,
	PORT75_FN_OUT___3 = 1159,
	PORT76_FN_OUT___3 = 1160,
	PORT77_FN_OUT___3 = 1161,
	PORT78_FN_OUT___3 = 1162,
	PORT79_FN_OUT___3 = 1163,
	PORT80_FN_OUT___3 = 1164,
	PORT81_FN_OUT___3 = 1165,
	PORT82_FN_OUT___3 = 1166,
	PORT83_FN_OUT___3 = 1167,
	PORT84_FN_OUT___3 = 1168,
	PORT85_FN_OUT___3 = 1169,
	PORT86_FN_OUT___2 = 1170,
	PORT87_FN_OUT___2 = 1171,
	PORT88_FN_OUT___2 = 1172,
	PORT89_FN_OUT___2 = 1173,
	PORT90_FN_OUT___2 = 1174,
	PORT91_FN_OUT___2 = 1175,
	PORT92_FN_OUT___2 = 1176,
	PORT93_FN_OUT___2 = 1177,
	PORT94_FN_OUT___2 = 1178,
	PORT95_FN_OUT___2 = 1179,
	PORT96_FN_OUT___3 = 1180,
	PORT97_FN_OUT___3 = 1181,
	PORT98_FN_OUT___3 = 1182,
	PORT99_FN_OUT___3 = 1183,
	PORT100_FN_OUT___3 = 1184,
	PORT101_FN_OUT___3 = 1185,
	PORT102_FN_OUT___3 = 1186,
	PORT103_FN_OUT___3 = 1187,
	PORT104_FN_OUT___3 = 1188,
	PORT105_FN_OUT___3 = 1189,
	PORT106_FN_OUT___3 = 1190,
	PORT107_FN_OUT___3 = 1191,
	PORT108_FN_OUT___3 = 1192,
	PORT109_FN_OUT___3 = 1193,
	PORT110_FN_OUT___3 = 1194,
	PORT111_FN_OUT___3 = 1195,
	PORT112_FN_OUT___3 = 1196,
	PORT113_FN_OUT___3 = 1197,
	PORT114_FN_OUT___3 = 1198,
	PORT115_FN_OUT___3 = 1199,
	PORT116_FN_OUT___3 = 1200,
	PORT117_FN_OUT___3 = 1201,
	PORT118_FN_OUT___3 = 1202,
	PORT128_FN_OUT___3 = 1203,
	PORT129_FN_OUT___3 = 1204,
	PORT130_FN_OUT___3 = 1205,
	PORT131_FN_OUT___3 = 1206,
	PORT132_FN_OUT___3 = 1207,
	PORT133_FN_OUT___3 = 1208,
	PORT134_FN_OUT___3 = 1209,
	PORT135_FN_OUT___2 = 1210,
	PORT136_FN_OUT___2 = 1211,
	PORT137_FN_OUT___2 = 1212,
	PORT138_FN_OUT___2 = 1213,
	PORT139_FN_OUT___2 = 1214,
	PORT140_FN_OUT___2 = 1215,
	PORT141_FN_OUT___2 = 1216,
	PORT142_FN_OUT___2 = 1217,
	PORT143_FN_OUT___2 = 1218,
	PORT144_FN_OUT___2 = 1219,
	PORT145_FN_OUT___2 = 1220,
	PORT146_FN_OUT___2 = 1221,
	PORT147_FN_OUT___2 = 1222,
	PORT148_FN_OUT___2 = 1223,
	PORT149_FN_OUT___2 = 1224,
	PORT150_FN_OUT___2 = 1225,
	PORT151_FN_OUT___2 = 1226,
	PORT152_FN_OUT___2 = 1227,
	PORT153_FN_OUT___2 = 1228,
	PORT154_FN_OUT___2 = 1229,
	PORT155_FN_OUT___2 = 1230,
	PORT156_FN_OUT___2 = 1231,
	PORT157_FN_OUT___2 = 1232,
	PORT158_FN_OUT___2 = 1233,
	PORT159_FN_OUT___2 = 1234,
	PORT160_FN_OUT___3 = 1235,
	PORT161_FN_OUT___3 = 1236,
	PORT162_FN_OUT___3 = 1237,
	PORT163_FN_OUT___3 = 1238,
	PORT164_FN_OUT___3 = 1239,
	PORT192_FN_OUT___3 = 1240,
	PORT193_FN_OUT___3 = 1241,
	PORT194_FN_OUT___3 = 1242,
	PORT195_FN_OUT___3 = 1243,
	PORT196_FN_OUT___3 = 1244,
	PORT197_FN_OUT___3 = 1245,
	PORT198_FN_OUT___3 = 1246,
	PORT199_FN_OUT___3 = 1247,
	PORT200_FN_OUT___3 = 1248,
	PORT201_FN_OUT___3 = 1249,
	PORT202_FN_OUT___3 = 1250,
	PORT203_FN_OUT___3 = 1251,
	PORT204_FN_OUT___3 = 1252,
	PORT205_FN_OUT___3 = 1253,
	PORT206_FN_OUT___3 = 1254,
	PORT207_FN_OUT___3 = 1255,
	PORT208_FN_OUT___3 = 1256,
	PORT209_FN_OUT___3 = 1257,
	PORT210_FN_OUT___3 = 1258,
	PORT211_FN_OUT___3 = 1259,
	PORT212_FN_OUT___2 = 1260,
	PORT213_FN_OUT___2 = 1261,
	PORT214_FN_OUT___2 = 1262,
	PORT215_FN_OUT___2 = 1263,
	PORT216_FN_OUT___2 = 1264,
	PORT217_FN_OUT___2 = 1265,
	PORT218_FN_OUT___2 = 1266,
	PORT219_FN_OUT___2 = 1267,
	PORT220_FN_OUT___2 = 1268,
	PORT221_FN_OUT___2 = 1269,
	PORT222_FN_OUT___2 = 1270,
	PORT223_FN_OUT = 1271,
	PORT224_FN_OUT___2 = 1272,
	PORT225_FN_OUT___2 = 1273,
	PORT226_FN_OUT___2 = 1274,
	PORT227_FN_OUT___2 = 1275,
	PORT228_FN_OUT___2 = 1276,
	PORT229_FN_OUT___2 = 1277,
	PORT230_FN_OUT___2 = 1278,
	PORT231_FN_OUT___2 = 1279,
	PORT232_FN_OUT___2 = 1280,
	PORT233_FN_OUT___2 = 1281,
	PORT234_FN_OUT___2 = 1282,
	PORT235_FN_OUT___2 = 1283,
	PORT236_FN_OUT___2 = 1284,
	PORT237_FN_OUT___2 = 1285,
	PORT238_FN_OUT___2 = 1286,
	PORT239_FN_OUT___2 = 1287,
	PORT240_FN_OUT___2 = 1288,
	PORT241_FN_OUT___2 = 1289,
	PORT242_FN_OUT___2 = 1290,
	PORT243_FN_OUT___2 = 1291,
	PORT244_FN_OUT___2 = 1292,
	PORT245_FN_OUT___2 = 1293,
	PORT246_FN_OUT___2 = 1294,
	PORT247_FN_OUT___2 = 1295,
	PORT248_FN_OUT___2 = 1296,
	PORT249_FN_OUT___2 = 1297,
	PORT250_FN_OUT___2 = 1298,
	PORT251_FN_OUT = 1299,
	PORT252_FN_OUT = 1300,
	PORT253_FN_OUT = 1301,
	PORT254_FN_OUT = 1302,
	PORT255_FN_OUT = 1303,
	PORT256_FN_OUT___2 = 1304,
	PORT257_FN_OUT___2 = 1305,
	PORT258_FN_OUT___2 = 1306,
	PORT259_FN_OUT___2 = 1307,
	PORT260_FN_OUT___2 = 1308,
	PORT261_FN_OUT___2 = 1309,
	PORT262_FN_OUT___2 = 1310,
	PORT263_FN_OUT___2 = 1311,
	PORT264_FN_OUT___2 = 1312,
	PORT265_FN_OUT___2 = 1313,
	PORT266_FN_OUT___2 = 1314,
	PORT267_FN_OUT___2 = 1315,
	PORT268_FN_OUT___2 = 1316,
	PORT269_FN_OUT___2 = 1317,
	PORT270_FN_OUT___2 = 1318,
	PORT271_FN_OUT___2 = 1319,
	PORT272_FN_OUT___2 = 1320,
	PORT273_FN_OUT___2 = 1321,
	PORT274_FN_OUT___2 = 1322,
	PORT275_FN_OUT___2 = 1323,
	PORT276_FN_OUT___2 = 1324,
	PORT277_FN_OUT___2 = 1325,
	PORT278_FN_OUT___2 = 1326,
	PORT279_FN_OUT___2 = 1327,
	PORT280_FN_OUT___2 = 1328,
	PORT281_FN_OUT___2 = 1329,
	PORT282_FN_OUT___2 = 1330,
	PORT288_FN_OUT___2 = 1331,
	PORT289_FN_OUT___2 = 1332,
	PORT290_FN_OUT___2 = 1333,
	PORT291_FN_OUT___2 = 1334,
	PORT292_FN_OUT___2 = 1335,
	PORT293_FN_OUT___2 = 1336,
	PORT294_FN_OUT___2 = 1337,
	PORT295_FN_OUT___2 = 1338,
	PORT296_FN_OUT___2 = 1339,
	PORT297_FN_OUT___2 = 1340,
	PORT298_FN_OUT___2 = 1341,
	PORT299_FN_OUT___2 = 1342,
	PORT300_FN_OUT___2 = 1343,
	PORT301_FN_OUT___2 = 1344,
	PORT302_FN_OUT___2 = 1345,
	PORT303_FN_OUT___2 = 1346,
	PORT304_FN_OUT___2 = 1347,
	PORT305_FN_OUT___2 = 1348,
	PORT306_FN_OUT___2 = 1349,
	PORT307_FN_OUT___2 = 1350,
	PORT308_FN_OUT___2 = 1351,
	PORT309_FN_OUT = 1352,
	PORT0_FN0___3 = 1353,
	PORT1_FN0___3 = 1354,
	PORT2_FN0___3 = 1355,
	PORT3_FN0___3 = 1356,
	PORT4_FN0___3 = 1357,
	PORT5_FN0___3 = 1358,
	PORT6_FN0___3 = 1359,
	PORT7_FN0___3 = 1360,
	PORT8_FN0___3 = 1361,
	PORT9_FN0___3 = 1362,
	PORT10_FN0___3 = 1363,
	PORT11_FN0___3 = 1364,
	PORT12_FN0___3 = 1365,
	PORT13_FN0___3 = 1366,
	PORT14_FN0___3 = 1367,
	PORT15_FN0___3 = 1368,
	PORT16_FN0___3 = 1369,
	PORT17_FN0___3 = 1370,
	PORT18_FN0___3 = 1371,
	PORT19_FN0___3 = 1372,
	PORT20_FN0___3 = 1373,
	PORT21_FN0___3 = 1374,
	PORT22_FN0___3 = 1375,
	PORT23_FN0___3 = 1376,
	PORT24_FN0___3 = 1377,
	PORT25_FN0___3 = 1378,
	PORT26_FN0___3 = 1379,
	PORT27_FN0___3 = 1380,
	PORT28_FN0___3 = 1381,
	PORT29_FN0___3 = 1382,
	PORT30_FN0___3 = 1383,
	PORT31_FN0___2 = 1384,
	PORT32_FN0___3 = 1385,
	PORT33_FN0___3 = 1386,
	PORT34_FN0___3 = 1387,
	PORT35_FN0___3 = 1388,
	PORT36_FN0___3 = 1389,
	PORT37_FN0___3 = 1390,
	PORT38_FN0___3 = 1391,
	PORT39_FN0___3 = 1392,
	PORT40_FN0___3 = 1393,
	PORT41_FN0___2 = 1394,
	PORT42_FN0___2 = 1395,
	PORT43_FN0___2 = 1396,
	PORT44_FN0___2 = 1397,
	PORT45_FN0___2 = 1398,
	PORT46_FN0___2 = 1399,
	PORT47_FN0___2 = 1400,
	PORT48_FN0___2 = 1401,
	PORT49_FN0___2 = 1402,
	PORT50_FN0___2 = 1403,
	PORT51_FN0___2 = 1404,
	PORT52_FN0___2 = 1405,
	PORT53_FN0___2 = 1406,
	PORT54_FN0___2 = 1407,
	PORT55_FN0___2 = 1408,
	PORT56_FN0___2 = 1409,
	PORT57_FN0___2 = 1410,
	PORT58_FN0___2 = 1411,
	PORT59_FN0___2 = 1412,
	PORT60_FN0___2 = 1413,
	PORT61_FN0___2 = 1414,
	PORT62_FN0___2 = 1415,
	PORT63_FN0___2 = 1416,
	PORT64_FN0___3 = 1417,
	PORT65_FN0___3 = 1418,
	PORT66_FN0___3 = 1419,
	PORT67_FN0___3 = 1420,
	PORT68_FN0___3 = 1421,
	PORT69_FN0___3 = 1422,
	PORT70_FN0___3 = 1423,
	PORT71_FN0___3 = 1424,
	PORT72_FN0___3 = 1425,
	PORT73_FN0___3 = 1426,
	PORT74_FN0___3 = 1427,
	PORT75_FN0___3 = 1428,
	PORT76_FN0___3 = 1429,
	PORT77_FN0___3 = 1430,
	PORT78_FN0___3 = 1431,
	PORT79_FN0___3 = 1432,
	PORT80_FN0___3 = 1433,
	PORT81_FN0___3 = 1434,
	PORT82_FN0___3 = 1435,
	PORT83_FN0___3 = 1436,
	PORT84_FN0___3 = 1437,
	PORT85_FN0___3 = 1438,
	PORT86_FN0___2 = 1439,
	PORT87_FN0___2 = 1440,
	PORT88_FN0___2 = 1441,
	PORT89_FN0___2 = 1442,
	PORT90_FN0___2 = 1443,
	PORT91_FN0___2 = 1444,
	PORT92_FN0___2 = 1445,
	PORT93_FN0___2 = 1446,
	PORT94_FN0___2 = 1447,
	PORT95_FN0___2 = 1448,
	PORT96_FN0___3 = 1449,
	PORT97_FN0___3 = 1450,
	PORT98_FN0___3 = 1451,
	PORT99_FN0___3 = 1452,
	PORT100_FN0___3 = 1453,
	PORT101_FN0___3 = 1454,
	PORT102_FN0___3 = 1455,
	PORT103_FN0___3 = 1456,
	PORT104_FN0___3 = 1457,
	PORT105_FN0___3 = 1458,
	PORT106_FN0___3 = 1459,
	PORT107_FN0___3 = 1460,
	PORT108_FN0___3 = 1461,
	PORT109_FN0___3 = 1462,
	PORT110_FN0___3 = 1463,
	PORT111_FN0___3 = 1464,
	PORT112_FN0___3 = 1465,
	PORT113_FN0___3 = 1466,
	PORT114_FN0___3 = 1467,
	PORT115_FN0___3 = 1468,
	PORT116_FN0___3 = 1469,
	PORT117_FN0___3 = 1470,
	PORT118_FN0___3 = 1471,
	PORT128_FN0___3 = 1472,
	PORT129_FN0___3 = 1473,
	PORT130_FN0___3 = 1474,
	PORT131_FN0___3 = 1475,
	PORT132_FN0___3 = 1476,
	PORT133_FN0___3 = 1477,
	PORT134_FN0___3 = 1478,
	PORT135_FN0___2 = 1479,
	PORT136_FN0___2 = 1480,
	PORT137_FN0___2 = 1481,
	PORT138_FN0___2 = 1482,
	PORT139_FN0___2 = 1483,
	PORT140_FN0___2 = 1484,
	PORT141_FN0___2 = 1485,
	PORT142_FN0___2 = 1486,
	PORT143_FN0___2 = 1487,
	PORT144_FN0___2 = 1488,
	PORT145_FN0___2 = 1489,
	PORT146_FN0___2 = 1490,
	PORT147_FN0___2 = 1491,
	PORT148_FN0___2 = 1492,
	PORT149_FN0___2 = 1493,
	PORT150_FN0___2 = 1494,
	PORT151_FN0___2 = 1495,
	PORT152_FN0___2 = 1496,
	PORT153_FN0___2 = 1497,
	PORT154_FN0___2 = 1498,
	PORT155_FN0___2 = 1499,
	PORT156_FN0___2 = 1500,
	PORT157_FN0___2 = 1501,
	PORT158_FN0___2 = 1502,
	PORT159_FN0___2 = 1503,
	PORT160_FN0___3 = 1504,
	PORT161_FN0___3 = 1505,
	PORT162_FN0___3 = 1506,
	PORT163_FN0___3 = 1507,
	PORT164_FN0___3 = 1508,
	PORT192_FN0___3 = 1509,
	PORT193_FN0___3 = 1510,
	PORT194_FN0___3 = 1511,
	PORT195_FN0___3 = 1512,
	PORT196_FN0___3 = 1513,
	PORT197_FN0___3 = 1514,
	PORT198_FN0___3 = 1515,
	PORT199_FN0___3 = 1516,
	PORT200_FN0___3 = 1517,
	PORT201_FN0___3 = 1518,
	PORT202_FN0___3 = 1519,
	PORT203_FN0___3 = 1520,
	PORT204_FN0___3 = 1521,
	PORT205_FN0___3 = 1522,
	PORT206_FN0___3 = 1523,
	PORT207_FN0___3 = 1524,
	PORT208_FN0___3 = 1525,
	PORT209_FN0___3 = 1526,
	PORT210_FN0___3 = 1527,
	PORT211_FN0___3 = 1528,
	PORT212_FN0___2 = 1529,
	PORT213_FN0___2 = 1530,
	PORT214_FN0___2 = 1531,
	PORT215_FN0___2 = 1532,
	PORT216_FN0___2 = 1533,
	PORT217_FN0___2 = 1534,
	PORT218_FN0___2 = 1535,
	PORT219_FN0___2 = 1536,
	PORT220_FN0___2 = 1537,
	PORT221_FN0___2 = 1538,
	PORT222_FN0___2 = 1539,
	PORT223_FN0 = 1540,
	PORT224_FN0___2 = 1541,
	PORT225_FN0___2 = 1542,
	PORT226_FN0___2 = 1543,
	PORT227_FN0___2 = 1544,
	PORT228_FN0___2 = 1545,
	PORT229_FN0___2 = 1546,
	PORT230_FN0___2 = 1547,
	PORT231_FN0___2 = 1548,
	PORT232_FN0___2 = 1549,
	PORT233_FN0___2 = 1550,
	PORT234_FN0___2 = 1551,
	PORT235_FN0___2 = 1552,
	PORT236_FN0___2 = 1553,
	PORT237_FN0___2 = 1554,
	PORT238_FN0___2 = 1555,
	PORT239_FN0___2 = 1556,
	PORT240_FN0___2 = 1557,
	PORT241_FN0___2 = 1558,
	PORT242_FN0___2 = 1559,
	PORT243_FN0___2 = 1560,
	PORT244_FN0___2 = 1561,
	PORT245_FN0___2 = 1562,
	PORT246_FN0___2 = 1563,
	PORT247_FN0___2 = 1564,
	PORT248_FN0___2 = 1565,
	PORT249_FN0___2 = 1566,
	PORT250_FN0___2 = 1567,
	PORT251_FN0 = 1568,
	PORT252_FN0 = 1569,
	PORT253_FN0 = 1570,
	PORT254_FN0 = 1571,
	PORT255_FN0 = 1572,
	PORT256_FN0___2 = 1573,
	PORT257_FN0___2 = 1574,
	PORT258_FN0___2 = 1575,
	PORT259_FN0___2 = 1576,
	PORT260_FN0___2 = 1577,
	PORT261_FN0___2 = 1578,
	PORT262_FN0___2 = 1579,
	PORT263_FN0___2 = 1580,
	PORT264_FN0___2 = 1581,
	PORT265_FN0___2 = 1582,
	PORT266_FN0___2 = 1583,
	PORT267_FN0___2 = 1584,
	PORT268_FN0___2 = 1585,
	PORT269_FN0___2 = 1586,
	PORT270_FN0___2 = 1587,
	PORT271_FN0___2 = 1588,
	PORT272_FN0___2 = 1589,
	PORT273_FN0___2 = 1590,
	PORT274_FN0___2 = 1591,
	PORT275_FN0___2 = 1592,
	PORT276_FN0___2 = 1593,
	PORT277_FN0___2 = 1594,
	PORT278_FN0___2 = 1595,
	PORT279_FN0___2 = 1596,
	PORT280_FN0___2 = 1597,
	PORT281_FN0___2 = 1598,
	PORT282_FN0___2 = 1599,
	PORT288_FN0___2 = 1600,
	PORT289_FN0___2 = 1601,
	PORT290_FN0___2 = 1602,
	PORT291_FN0___2 = 1603,
	PORT292_FN0___2 = 1604,
	PORT293_FN0___2 = 1605,
	PORT294_FN0___2 = 1606,
	PORT295_FN0___2 = 1607,
	PORT296_FN0___2 = 1608,
	PORT297_FN0___2 = 1609,
	PORT298_FN0___2 = 1610,
	PORT299_FN0___2 = 1611,
	PORT300_FN0___2 = 1612,
	PORT301_FN0___2 = 1613,
	PORT302_FN0___2 = 1614,
	PORT303_FN0___2 = 1615,
	PORT304_FN0___2 = 1616,
	PORT305_FN0___2 = 1617,
	PORT306_FN0___2 = 1618,
	PORT307_FN0___2 = 1619,
	PORT308_FN0___2 = 1620,
	PORT309_FN0 = 1621,
	PORT0_FN1___3 = 1622,
	PORT1_FN1___3 = 1623,
	PORT2_FN1___3 = 1624,
	PORT3_FN1___3 = 1625,
	PORT4_FN1___3 = 1626,
	PORT5_FN1___3 = 1627,
	PORT6_FN1___3 = 1628,
	PORT7_FN1___3 = 1629,
	PORT8_FN1___3 = 1630,
	PORT9_FN1___3 = 1631,
	PORT10_FN1___3 = 1632,
	PORT11_FN1___3 = 1633,
	PORT12_FN1___3 = 1634,
	PORT13_FN1___3 = 1635,
	PORT14_FN1___3 = 1636,
	PORT15_FN1___3 = 1637,
	PORT16_FN1___3 = 1638,
	PORT17_FN1___3 = 1639,
	PORT18_FN1___3 = 1640,
	PORT19_FN1___3 = 1641,
	PORT20_FN1___3 = 1642,
	PORT21_FN1___3 = 1643,
	PORT22_FN1___3 = 1644,
	PORT23_FN1___3 = 1645,
	PORT24_FN1___3 = 1646,
	PORT25_FN1___3 = 1647,
	PORT26_FN1___3 = 1648,
	PORT27_FN1___3 = 1649,
	PORT28_FN1___3 = 1650,
	PORT29_FN1___3 = 1651,
	PORT30_FN1___3 = 1652,
	PORT31_FN1___2 = 1653,
	PORT32_FN1___3 = 1654,
	PORT33_FN1___3 = 1655,
	PORT34_FN1___3 = 1656,
	PORT35_FN1___3 = 1657,
	PORT36_FN1___3 = 1658,
	PORT37_FN1___3 = 1659,
	PORT38_FN1___3 = 1660,
	PORT39_FN1___3 = 1661,
	PORT40_FN1___3 = 1662,
	PORT41_FN1___2 = 1663,
	PORT42_FN1___2 = 1664,
	PORT43_FN1___2 = 1665,
	PORT44_FN1___2 = 1666,
	PORT45_FN1___2 = 1667,
	PORT46_FN1___2 = 1668,
	PORT47_FN1___2 = 1669,
	PORT48_FN1___2 = 1670,
	PORT49_FN1___2 = 1671,
	PORT50_FN1___2 = 1672,
	PORT51_FN1___2 = 1673,
	PORT52_FN1___2 = 1674,
	PORT53_FN1___2 = 1675,
	PORT54_FN1___2 = 1676,
	PORT55_FN1___2 = 1677,
	PORT56_FN1___2 = 1678,
	PORT57_FN1___2 = 1679,
	PORT58_FN1___2 = 1680,
	PORT59_FN1___2 = 1681,
	PORT60_FN1___2 = 1682,
	PORT61_FN1___2 = 1683,
	PORT62_FN1___2 = 1684,
	PORT63_FN1___2 = 1685,
	PORT64_FN1___3 = 1686,
	PORT65_FN1___3 = 1687,
	PORT66_FN1___3 = 1688,
	PORT67_FN1___3 = 1689,
	PORT68_FN1___3 = 1690,
	PORT69_FN1___3 = 1691,
	PORT70_FN1___3 = 1692,
	PORT71_FN1___3 = 1693,
	PORT72_FN1___3 = 1694,
	PORT73_FN1___3 = 1695,
	PORT74_FN1___3 = 1696,
	PORT75_FN1___3 = 1697,
	PORT76_FN1___3 = 1698,
	PORT77_FN1___3 = 1699,
	PORT78_FN1___3 = 1700,
	PORT79_FN1___3 = 1701,
	PORT80_FN1___3 = 1702,
	PORT81_FN1___3 = 1703,
	PORT82_FN1___3 = 1704,
	PORT83_FN1___3 = 1705,
	PORT84_FN1___3 = 1706,
	PORT85_FN1___3 = 1707,
	PORT86_FN1___2 = 1708,
	PORT87_FN1___2 = 1709,
	PORT88_FN1___2 = 1710,
	PORT89_FN1___2 = 1711,
	PORT90_FN1___2 = 1712,
	PORT91_FN1___2 = 1713,
	PORT92_FN1___2 = 1714,
	PORT93_FN1___2 = 1715,
	PORT94_FN1___2 = 1716,
	PORT95_FN1___2 = 1717,
	PORT96_FN1___3 = 1718,
	PORT97_FN1___3 = 1719,
	PORT98_FN1___3 = 1720,
	PORT99_FN1___3 = 1721,
	PORT100_FN1___3 = 1722,
	PORT101_FN1___3 = 1723,
	PORT102_FN1___3 = 1724,
	PORT103_FN1___3 = 1725,
	PORT104_FN1___3 = 1726,
	PORT105_FN1___3 = 1727,
	PORT106_FN1___3 = 1728,
	PORT107_FN1___3 = 1729,
	PORT108_FN1___3 = 1730,
	PORT109_FN1___3 = 1731,
	PORT110_FN1___3 = 1732,
	PORT111_FN1___3 = 1733,
	PORT112_FN1___3 = 1734,
	PORT113_FN1___3 = 1735,
	PORT114_FN1___3 = 1736,
	PORT115_FN1___3 = 1737,
	PORT116_FN1___3 = 1738,
	PORT117_FN1___3 = 1739,
	PORT118_FN1___3 = 1740,
	PORT128_FN1___3 = 1741,
	PORT129_FN1___3 = 1742,
	PORT130_FN1___3 = 1743,
	PORT131_FN1___3 = 1744,
	PORT132_FN1___3 = 1745,
	PORT133_FN1___3 = 1746,
	PORT134_FN1___3 = 1747,
	PORT135_FN1___2 = 1748,
	PORT136_FN1___2 = 1749,
	PORT137_FN1___2 = 1750,
	PORT138_FN1___2 = 1751,
	PORT139_FN1___2 = 1752,
	PORT140_FN1___2 = 1753,
	PORT141_FN1___2 = 1754,
	PORT142_FN1___2 = 1755,
	PORT143_FN1___2 = 1756,
	PORT144_FN1___2 = 1757,
	PORT145_FN1___2 = 1758,
	PORT146_FN1___2 = 1759,
	PORT147_FN1___2 = 1760,
	PORT148_FN1___2 = 1761,
	PORT149_FN1___2 = 1762,
	PORT150_FN1___2 = 1763,
	PORT151_FN1___2 = 1764,
	PORT152_FN1___2 = 1765,
	PORT153_FN1___2 = 1766,
	PORT154_FN1___2 = 1767,
	PORT155_FN1___2 = 1768,
	PORT156_FN1___2 = 1769,
	PORT157_FN1___2 = 1770,
	PORT158_FN1___2 = 1771,
	PORT159_FN1___2 = 1772,
	PORT160_FN1___3 = 1773,
	PORT161_FN1___3 = 1774,
	PORT162_FN1___3 = 1775,
	PORT163_FN1___3 = 1776,
	PORT164_FN1___3 = 1777,
	PORT192_FN1___3 = 1778,
	PORT193_FN1___3 = 1779,
	PORT194_FN1___3 = 1780,
	PORT195_FN1___3 = 1781,
	PORT196_FN1___3 = 1782,
	PORT197_FN1___3 = 1783,
	PORT198_FN1___3 = 1784,
	PORT199_FN1___3 = 1785,
	PORT200_FN1___3 = 1786,
	PORT201_FN1___3 = 1787,
	PORT202_FN1___3 = 1788,
	PORT203_FN1___3 = 1789,
	PORT204_FN1___3 = 1790,
	PORT205_FN1___3 = 1791,
	PORT206_FN1___3 = 1792,
	PORT207_FN1___3 = 1793,
	PORT208_FN1___3 = 1794,
	PORT209_FN1___3 = 1795,
	PORT210_FN1___3 = 1796,
	PORT211_FN1___3 = 1797,
	PORT212_FN1___2 = 1798,
	PORT213_FN1___2 = 1799,
	PORT214_FN1___2 = 1800,
	PORT215_FN1___2 = 1801,
	PORT216_FN1___2 = 1802,
	PORT217_FN1___2 = 1803,
	PORT218_FN1___2 = 1804,
	PORT219_FN1___2 = 1805,
	PORT220_FN1___2 = 1806,
	PORT221_FN1___2 = 1807,
	PORT222_FN1___2 = 1808,
	PORT223_FN1 = 1809,
	PORT224_FN1___2 = 1810,
	PORT225_FN1___2 = 1811,
	PORT226_FN1___2 = 1812,
	PORT227_FN1___2 = 1813,
	PORT228_FN1___2 = 1814,
	PORT229_FN1___2 = 1815,
	PORT230_FN1___2 = 1816,
	PORT231_FN1___2 = 1817,
	PORT232_FN1___2 = 1818,
	PORT233_FN1___2 = 1819,
	PORT234_FN1___2 = 1820,
	PORT235_FN1___2 = 1821,
	PORT236_FN1___2 = 1822,
	PORT237_FN1___2 = 1823,
	PORT238_FN1___2 = 1824,
	PORT239_FN1___2 = 1825,
	PORT240_FN1___2 = 1826,
	PORT241_FN1___2 = 1827,
	PORT242_FN1___2 = 1828,
	PORT243_FN1___2 = 1829,
	PORT244_FN1___2 = 1830,
	PORT245_FN1___2 = 1831,
	PORT246_FN1___2 = 1832,
	PORT247_FN1___2 = 1833,
	PORT248_FN1___2 = 1834,
	PORT249_FN1___2 = 1835,
	PORT250_FN1___2 = 1836,
	PORT251_FN1 = 1837,
	PORT252_FN1 = 1838,
	PORT253_FN1 = 1839,
	PORT254_FN1 = 1840,
	PORT255_FN1 = 1841,
	PORT256_FN1___2 = 1842,
	PORT257_FN1___2 = 1843,
	PORT258_FN1___2 = 1844,
	PORT259_FN1___2 = 1845,
	PORT260_FN1___2 = 1846,
	PORT261_FN1___2 = 1847,
	PORT262_FN1___2 = 1848,
	PORT263_FN1___2 = 1849,
	PORT264_FN1___2 = 1850,
	PORT265_FN1___2 = 1851,
	PORT266_FN1___2 = 1852,
	PORT267_FN1___2 = 1853,
	PORT268_FN1___2 = 1854,
	PORT269_FN1___2 = 1855,
	PORT270_FN1___2 = 1856,
	PORT271_FN1___2 = 1857,
	PORT272_FN1___2 = 1858,
	PORT273_FN1___2 = 1859,
	PORT274_FN1___2 = 1860,
	PORT275_FN1___2 = 1861,
	PORT276_FN1___2 = 1862,
	PORT277_FN1___2 = 1863,
	PORT278_FN1___2 = 1864,
	PORT279_FN1___2 = 1865,
	PORT280_FN1___2 = 1866,
	PORT281_FN1___2 = 1867,
	PORT282_FN1___2 = 1868,
	PORT288_FN1___2 = 1869,
	PORT289_FN1___2 = 1870,
	PORT290_FN1___2 = 1871,
	PORT291_FN1___2 = 1872,
	PORT292_FN1___2 = 1873,
	PORT293_FN1___2 = 1874,
	PORT294_FN1___2 = 1875,
	PORT295_FN1___2 = 1876,
	PORT296_FN1___2 = 1877,
	PORT297_FN1___2 = 1878,
	PORT298_FN1___2 = 1879,
	PORT299_FN1___2 = 1880,
	PORT300_FN1___2 = 1881,
	PORT301_FN1___2 = 1882,
	PORT302_FN1___2 = 1883,
	PORT303_FN1___2 = 1884,
	PORT304_FN1___2 = 1885,
	PORT305_FN1___2 = 1886,
	PORT306_FN1___2 = 1887,
	PORT307_FN1___2 = 1888,
	PORT308_FN1___2 = 1889,
	PORT309_FN1 = 1890,
	PORT0_FN2___3 = 1891,
	PORT1_FN2___3 = 1892,
	PORT2_FN2___3 = 1893,
	PORT3_FN2___3 = 1894,
	PORT4_FN2___3 = 1895,
	PORT5_FN2___3 = 1896,
	PORT6_FN2___3 = 1897,
	PORT7_FN2___3 = 1898,
	PORT8_FN2___3 = 1899,
	PORT9_FN2___3 = 1900,
	PORT10_FN2___3 = 1901,
	PORT11_FN2___3 = 1902,
	PORT12_FN2___3 = 1903,
	PORT13_FN2___3 = 1904,
	PORT14_FN2___3 = 1905,
	PORT15_FN2___3 = 1906,
	PORT16_FN2___3 = 1907,
	PORT17_FN2___3 = 1908,
	PORT18_FN2___3 = 1909,
	PORT19_FN2___3 = 1910,
	PORT20_FN2___3 = 1911,
	PORT21_FN2___3 = 1912,
	PORT22_FN2___3 = 1913,
	PORT23_FN2___3 = 1914,
	PORT24_FN2___3 = 1915,
	PORT25_FN2___3 = 1916,
	PORT26_FN2___3 = 1917,
	PORT27_FN2___3 = 1918,
	PORT28_FN2___3 = 1919,
	PORT29_FN2___3 = 1920,
	PORT30_FN2___3 = 1921,
	PORT31_FN2___2 = 1922,
	PORT32_FN2___3 = 1923,
	PORT33_FN2___3 = 1924,
	PORT34_FN2___3 = 1925,
	PORT35_FN2___3 = 1926,
	PORT36_FN2___3 = 1927,
	PORT37_FN2___3 = 1928,
	PORT38_FN2___3 = 1929,
	PORT39_FN2___3 = 1930,
	PORT40_FN2___3 = 1931,
	PORT41_FN2___2 = 1932,
	PORT42_FN2___2 = 1933,
	PORT43_FN2___2 = 1934,
	PORT44_FN2___2 = 1935,
	PORT45_FN2___2 = 1936,
	PORT46_FN2___2 = 1937,
	PORT47_FN2___2 = 1938,
	PORT48_FN2___2 = 1939,
	PORT49_FN2___2 = 1940,
	PORT50_FN2___2 = 1941,
	PORT51_FN2___2 = 1942,
	PORT52_FN2___2 = 1943,
	PORT53_FN2___2 = 1944,
	PORT54_FN2___2 = 1945,
	PORT55_FN2___2 = 1946,
	PORT56_FN2___2 = 1947,
	PORT57_FN2___2 = 1948,
	PORT58_FN2___2 = 1949,
	PORT59_FN2___2 = 1950,
	PORT60_FN2___2 = 1951,
	PORT61_FN2___2 = 1952,
	PORT62_FN2___2 = 1953,
	PORT63_FN2___2 = 1954,
	PORT64_FN2___3 = 1955,
	PORT65_FN2___3 = 1956,
	PORT66_FN2___3 = 1957,
	PORT67_FN2___3 = 1958,
	PORT68_FN2___3 = 1959,
	PORT69_FN2___3 = 1960,
	PORT70_FN2___3 = 1961,
	PORT71_FN2___3 = 1962,
	PORT72_FN2___3 = 1963,
	PORT73_FN2___3 = 1964,
	PORT74_FN2___3 = 1965,
	PORT75_FN2___3 = 1966,
	PORT76_FN2___3 = 1967,
	PORT77_FN2___3 = 1968,
	PORT78_FN2___3 = 1969,
	PORT79_FN2___3 = 1970,
	PORT80_FN2___3 = 1971,
	PORT81_FN2___3 = 1972,
	PORT82_FN2___3 = 1973,
	PORT83_FN2___3 = 1974,
	PORT84_FN2___3 = 1975,
	PORT85_FN2___3 = 1976,
	PORT86_FN2___2 = 1977,
	PORT87_FN2___2 = 1978,
	PORT88_FN2___2 = 1979,
	PORT89_FN2___2 = 1980,
	PORT90_FN2___2 = 1981,
	PORT91_FN2___2 = 1982,
	PORT92_FN2___2 = 1983,
	PORT93_FN2___2 = 1984,
	PORT94_FN2___2 = 1985,
	PORT95_FN2___2 = 1986,
	PORT96_FN2___3 = 1987,
	PORT97_FN2___3 = 1988,
	PORT98_FN2___3 = 1989,
	PORT99_FN2___3 = 1990,
	PORT100_FN2___3 = 1991,
	PORT101_FN2___3 = 1992,
	PORT102_FN2___3 = 1993,
	PORT103_FN2___3 = 1994,
	PORT104_FN2___3 = 1995,
	PORT105_FN2___3 = 1996,
	PORT106_FN2___3 = 1997,
	PORT107_FN2___3 = 1998,
	PORT108_FN2___3 = 1999,
	PORT109_FN2___3 = 2000,
	PORT110_FN2___3 = 2001,
	PORT111_FN2___3 = 2002,
	PORT112_FN2___3 = 2003,
	PORT113_FN2___3 = 2004,
	PORT114_FN2___3 = 2005,
	PORT115_FN2___3 = 2006,
	PORT116_FN2___3 = 2007,
	PORT117_FN2___3 = 2008,
	PORT118_FN2___3 = 2009,
	PORT128_FN2___3 = 2010,
	PORT129_FN2___3 = 2011,
	PORT130_FN2___3 = 2012,
	PORT131_FN2___3 = 2013,
	PORT132_FN2___3 = 2014,
	PORT133_FN2___3 = 2015,
	PORT134_FN2___3 = 2016,
	PORT135_FN2___2 = 2017,
	PORT136_FN2___2 = 2018,
	PORT137_FN2___2 = 2019,
	PORT138_FN2___2 = 2020,
	PORT139_FN2___2 = 2021,
	PORT140_FN2___2 = 2022,
	PORT141_FN2___2 = 2023,
	PORT142_FN2___2 = 2024,
	PORT143_FN2___2 = 2025,
	PORT144_FN2___2 = 2026,
	PORT145_FN2___2 = 2027,
	PORT146_FN2___2 = 2028,
	PORT147_FN2___2 = 2029,
	PORT148_FN2___2 = 2030,
	PORT149_FN2___2 = 2031,
	PORT150_FN2___2 = 2032,
	PORT151_FN2___2 = 2033,
	PORT152_FN2___2 = 2034,
	PORT153_FN2___2 = 2035,
	PORT154_FN2___2 = 2036,
	PORT155_FN2___2 = 2037,
	PORT156_FN2___2 = 2038,
	PORT157_FN2___2 = 2039,
	PORT158_FN2___2 = 2040,
	PORT159_FN2___2 = 2041,
	PORT160_FN2___3 = 2042,
	PORT161_FN2___3 = 2043,
	PORT162_FN2___3 = 2044,
	PORT163_FN2___3 = 2045,
	PORT164_FN2___3 = 2046,
	PORT192_FN2___3 = 2047,
	PORT193_FN2___3 = 2048,
	PORT194_FN2___3 = 2049,
	PORT195_FN2___3 = 2050,
	PORT196_FN2___3 = 2051,
	PORT197_FN2___3 = 2052,
	PORT198_FN2___3 = 2053,
	PORT199_FN2___3 = 2054,
	PORT200_FN2___3 = 2055,
	PORT201_FN2___3 = 2056,
	PORT202_FN2___3 = 2057,
	PORT203_FN2___3 = 2058,
	PORT204_FN2___3 = 2059,
	PORT205_FN2___3 = 2060,
	PORT206_FN2___3 = 2061,
	PORT207_FN2___3 = 2062,
	PORT208_FN2___3 = 2063,
	PORT209_FN2___3 = 2064,
	PORT210_FN2___3 = 2065,
	PORT211_FN2___3 = 2066,
	PORT212_FN2___2 = 2067,
	PORT213_FN2___2 = 2068,
	PORT214_FN2___2 = 2069,
	PORT215_FN2___2 = 2070,
	PORT216_FN2___2 = 2071,
	PORT217_FN2___2 = 2072,
	PORT218_FN2___2 = 2073,
	PORT219_FN2___2 = 2074,
	PORT220_FN2___2 = 2075,
	PORT221_FN2___2 = 2076,
	PORT222_FN2___2 = 2077,
	PORT223_FN2 = 2078,
	PORT224_FN2___2 = 2079,
	PORT225_FN2___2 = 2080,
	PORT226_FN2___2 = 2081,
	PORT227_FN2___2 = 2082,
	PORT228_FN2___2 = 2083,
	PORT229_FN2___2 = 2084,
	PORT230_FN2___2 = 2085,
	PORT231_FN2___2 = 2086,
	PORT232_FN2___2 = 2087,
	PORT233_FN2___2 = 2088,
	PORT234_FN2___2 = 2089,
	PORT235_FN2___2 = 2090,
	PORT236_FN2___2 = 2091,
	PORT237_FN2___2 = 2092,
	PORT238_FN2___2 = 2093,
	PORT239_FN2___2 = 2094,
	PORT240_FN2___2 = 2095,
	PORT241_FN2___2 = 2096,
	PORT242_FN2___2 = 2097,
	PORT243_FN2___2 = 2098,
	PORT244_FN2___2 = 2099,
	PORT245_FN2___2 = 2100,
	PORT246_FN2___2 = 2101,
	PORT247_FN2___2 = 2102,
	PORT248_FN2___2 = 2103,
	PORT249_FN2___2 = 2104,
	PORT250_FN2___2 = 2105,
	PORT251_FN2 = 2106,
	PORT252_FN2 = 2107,
	PORT253_FN2 = 2108,
	PORT254_FN2 = 2109,
	PORT255_FN2 = 2110,
	PORT256_FN2___2 = 2111,
	PORT257_FN2___2 = 2112,
	PORT258_FN2___2 = 2113,
	PORT259_FN2___2 = 2114,
	PORT260_FN2___2 = 2115,
	PORT261_FN2___2 = 2116,
	PORT262_FN2___2 = 2117,
	PORT263_FN2___2 = 2118,
	PORT264_FN2___2 = 2119,
	PORT265_FN2___2 = 2120,
	PORT266_FN2___2 = 2121,
	PORT267_FN2___2 = 2122,
	PORT268_FN2___2 = 2123,
	PORT269_FN2___2 = 2124,
	PORT270_FN2___2 = 2125,
	PORT271_FN2___2 = 2126,
	PORT272_FN2___2 = 2127,
	PORT273_FN2___2 = 2128,
	PORT274_FN2___2 = 2129,
	PORT275_FN2___2 = 2130,
	PORT276_FN2___2 = 2131,
	PORT277_FN2___2 = 2132,
	PORT278_FN2___2 = 2133,
	PORT279_FN2___2 = 2134,
	PORT280_FN2___2 = 2135,
	PORT281_FN2___2 = 2136,
	PORT282_FN2___2 = 2137,
	PORT288_FN2___2 = 2138,
	PORT289_FN2___2 = 2139,
	PORT290_FN2___2 = 2140,
	PORT291_FN2___2 = 2141,
	PORT292_FN2___2 = 2142,
	PORT293_FN2___2 = 2143,
	PORT294_FN2___2 = 2144,
	PORT295_FN2___2 = 2145,
	PORT296_FN2___2 = 2146,
	PORT297_FN2___2 = 2147,
	PORT298_FN2___2 = 2148,
	PORT299_FN2___2 = 2149,
	PORT300_FN2___2 = 2150,
	PORT301_FN2___2 = 2151,
	PORT302_FN2___2 = 2152,
	PORT303_FN2___2 = 2153,
	PORT304_FN2___2 = 2154,
	PORT305_FN2___2 = 2155,
	PORT306_FN2___2 = 2156,
	PORT307_FN2___2 = 2157,
	PORT308_FN2___2 = 2158,
	PORT309_FN2 = 2159,
	PORT0_FN3___3 = 2160,
	PORT1_FN3___3 = 2161,
	PORT2_FN3___3 = 2162,
	PORT3_FN3___3 = 2163,
	PORT4_FN3___3 = 2164,
	PORT5_FN3___3 = 2165,
	PORT6_FN3___3 = 2166,
	PORT7_FN3___3 = 2167,
	PORT8_FN3___3 = 2168,
	PORT9_FN3___3 = 2169,
	PORT10_FN3___3 = 2170,
	PORT11_FN3___3 = 2171,
	PORT12_FN3___3 = 2172,
	PORT13_FN3___3 = 2173,
	PORT14_FN3___3 = 2174,
	PORT15_FN3___3 = 2175,
	PORT16_FN3___3 = 2176,
	PORT17_FN3___3 = 2177,
	PORT18_FN3___3 = 2178,
	PORT19_FN3___3 = 2179,
	PORT20_FN3___3 = 2180,
	PORT21_FN3___3 = 2181,
	PORT22_FN3___3 = 2182,
	PORT23_FN3___3 = 2183,
	PORT24_FN3___3 = 2184,
	PORT25_FN3___3 = 2185,
	PORT26_FN3___3 = 2186,
	PORT27_FN3___3 = 2187,
	PORT28_FN3___3 = 2188,
	PORT29_FN3___3 = 2189,
	PORT30_FN3___3 = 2190,
	PORT31_FN3___2 = 2191,
	PORT32_FN3___3 = 2192,
	PORT33_FN3___3 = 2193,
	PORT34_FN3___3 = 2194,
	PORT35_FN3___3 = 2195,
	PORT36_FN3___3 = 2196,
	PORT37_FN3___3 = 2197,
	PORT38_FN3___3 = 2198,
	PORT39_FN3___3 = 2199,
	PORT40_FN3___3 = 2200,
	PORT41_FN3___2 = 2201,
	PORT42_FN3___2 = 2202,
	PORT43_FN3___2 = 2203,
	PORT44_FN3___2 = 2204,
	PORT45_FN3___2 = 2205,
	PORT46_FN3___2 = 2206,
	PORT47_FN3___2 = 2207,
	PORT48_FN3___2 = 2208,
	PORT49_FN3___2 = 2209,
	PORT50_FN3___2 = 2210,
	PORT51_FN3___2 = 2211,
	PORT52_FN3___2 = 2212,
	PORT53_FN3___2 = 2213,
	PORT54_FN3___2 = 2214,
	PORT55_FN3___2 = 2215,
	PORT56_FN3___2 = 2216,
	PORT57_FN3___2 = 2217,
	PORT58_FN3___2 = 2218,
	PORT59_FN3___2 = 2219,
	PORT60_FN3___2 = 2220,
	PORT61_FN3___2 = 2221,
	PORT62_FN3___2 = 2222,
	PORT63_FN3___2 = 2223,
	PORT64_FN3___3 = 2224,
	PORT65_FN3___3 = 2225,
	PORT66_FN3___3 = 2226,
	PORT67_FN3___3 = 2227,
	PORT68_FN3___3 = 2228,
	PORT69_FN3___3 = 2229,
	PORT70_FN3___3 = 2230,
	PORT71_FN3___3 = 2231,
	PORT72_FN3___3 = 2232,
	PORT73_FN3___3 = 2233,
	PORT74_FN3___3 = 2234,
	PORT75_FN3___3 = 2235,
	PORT76_FN3___3 = 2236,
	PORT77_FN3___3 = 2237,
	PORT78_FN3___3 = 2238,
	PORT79_FN3___3 = 2239,
	PORT80_FN3___3 = 2240,
	PORT81_FN3___3 = 2241,
	PORT82_FN3___3 = 2242,
	PORT83_FN3___3 = 2243,
	PORT84_FN3___3 = 2244,
	PORT85_FN3___3 = 2245,
	PORT86_FN3___2 = 2246,
	PORT87_FN3___2 = 2247,
	PORT88_FN3___2 = 2248,
	PORT89_FN3___2 = 2249,
	PORT90_FN3___2 = 2250,
	PORT91_FN3___2 = 2251,
	PORT92_FN3___2 = 2252,
	PORT93_FN3___2 = 2253,
	PORT94_FN3___2 = 2254,
	PORT95_FN3___2 = 2255,
	PORT96_FN3___3 = 2256,
	PORT97_FN3___3 = 2257,
	PORT98_FN3___3 = 2258,
	PORT99_FN3___3 = 2259,
	PORT100_FN3___3 = 2260,
	PORT101_FN3___3 = 2261,
	PORT102_FN3___3 = 2262,
	PORT103_FN3___3 = 2263,
	PORT104_FN3___3 = 2264,
	PORT105_FN3___3 = 2265,
	PORT106_FN3___3 = 2266,
	PORT107_FN3___3 = 2267,
	PORT108_FN3___3 = 2268,
	PORT109_FN3___3 = 2269,
	PORT110_FN3___3 = 2270,
	PORT111_FN3___3 = 2271,
	PORT112_FN3___3 = 2272,
	PORT113_FN3___3 = 2273,
	PORT114_FN3___3 = 2274,
	PORT115_FN3___3 = 2275,
	PORT116_FN3___3 = 2276,
	PORT117_FN3___3 = 2277,
	PORT118_FN3___3 = 2278,
	PORT128_FN3___3 = 2279,
	PORT129_FN3___3 = 2280,
	PORT130_FN3___3 = 2281,
	PORT131_FN3___3 = 2282,
	PORT132_FN3___3 = 2283,
	PORT133_FN3___3 = 2284,
	PORT134_FN3___3 = 2285,
	PORT135_FN3___2 = 2286,
	PORT136_FN3___2 = 2287,
	PORT137_FN3___2 = 2288,
	PORT138_FN3___2 = 2289,
	PORT139_FN3___2 = 2290,
	PORT140_FN3___2 = 2291,
	PORT141_FN3___2 = 2292,
	PORT142_FN3___2 = 2293,
	PORT143_FN3___2 = 2294,
	PORT144_FN3___2 = 2295,
	PORT145_FN3___2 = 2296,
	PORT146_FN3___2 = 2297,
	PORT147_FN3___2 = 2298,
	PORT148_FN3___2 = 2299,
	PORT149_FN3___2 = 2300,
	PORT150_FN3___2 = 2301,
	PORT151_FN3___2 = 2302,
	PORT152_FN3___2 = 2303,
	PORT153_FN3___2 = 2304,
	PORT154_FN3___2 = 2305,
	PORT155_FN3___2 = 2306,
	PORT156_FN3___2 = 2307,
	PORT157_FN3___2 = 2308,
	PORT158_FN3___2 = 2309,
	PORT159_FN3___2 = 2310,
	PORT160_FN3___3 = 2311,
	PORT161_FN3___3 = 2312,
	PORT162_FN3___3 = 2313,
	PORT163_FN3___3 = 2314,
	PORT164_FN3___3 = 2315,
	PORT192_FN3___3 = 2316,
	PORT193_FN3___3 = 2317,
	PORT194_FN3___3 = 2318,
	PORT195_FN3___3 = 2319,
	PORT196_FN3___3 = 2320,
	PORT197_FN3___3 = 2321,
	PORT198_FN3___3 = 2322,
	PORT199_FN3___3 = 2323,
	PORT200_FN3___3 = 2324,
	PORT201_FN3___3 = 2325,
	PORT202_FN3___3 = 2326,
	PORT203_FN3___3 = 2327,
	PORT204_FN3___3 = 2328,
	PORT205_FN3___3 = 2329,
	PORT206_FN3___3 = 2330,
	PORT207_FN3___3 = 2331,
	PORT208_FN3___3 = 2332,
	PORT209_FN3___3 = 2333,
	PORT210_FN3___3 = 2334,
	PORT211_FN3___3 = 2335,
	PORT212_FN3___2 = 2336,
	PORT213_FN3___2 = 2337,
	PORT214_FN3___2 = 2338,
	PORT215_FN3___2 = 2339,
	PORT216_FN3___2 = 2340,
	PORT217_FN3___2 = 2341,
	PORT218_FN3___2 = 2342,
	PORT219_FN3___2 = 2343,
	PORT220_FN3___2 = 2344,
	PORT221_FN3___2 = 2345,
	PORT222_FN3___2 = 2346,
	PORT223_FN3 = 2347,
	PORT224_FN3___2 = 2348,
	PORT225_FN3___2 = 2349,
	PORT226_FN3___2 = 2350,
	PORT227_FN3___2 = 2351,
	PORT228_FN3___2 = 2352,
	PORT229_FN3___2 = 2353,
	PORT230_FN3___2 = 2354,
	PORT231_FN3___2 = 2355,
	PORT232_FN3___2 = 2356,
	PORT233_FN3___2 = 2357,
	PORT234_FN3___2 = 2358,
	PORT235_FN3___2 = 2359,
	PORT236_FN3___2 = 2360,
	PORT237_FN3___2 = 2361,
	PORT238_FN3___2 = 2362,
	PORT239_FN3___2 = 2363,
	PORT240_FN3___2 = 2364,
	PORT241_FN3___2 = 2365,
	PORT242_FN3___2 = 2366,
	PORT243_FN3___2 = 2367,
	PORT244_FN3___2 = 2368,
	PORT245_FN3___2 = 2369,
	PORT246_FN3___2 = 2370,
	PORT247_FN3___2 = 2371,
	PORT248_FN3___2 = 2372,
	PORT249_FN3___2 = 2373,
	PORT250_FN3___2 = 2374,
	PORT251_FN3 = 2375,
	PORT252_FN3 = 2376,
	PORT253_FN3 = 2377,
	PORT254_FN3 = 2378,
	PORT255_FN3 = 2379,
	PORT256_FN3___2 = 2380,
	PORT257_FN3___2 = 2381,
	PORT258_FN3___2 = 2382,
	PORT259_FN3___2 = 2383,
	PORT260_FN3___2 = 2384,
	PORT261_FN3___2 = 2385,
	PORT262_FN3___2 = 2386,
	PORT263_FN3___2 = 2387,
	PORT264_FN3___2 = 2388,
	PORT265_FN3___2 = 2389,
	PORT266_FN3___2 = 2390,
	PORT267_FN3___2 = 2391,
	PORT268_FN3___2 = 2392,
	PORT269_FN3___2 = 2393,
	PORT270_FN3___2 = 2394,
	PORT271_FN3___2 = 2395,
	PORT272_FN3___2 = 2396,
	PORT273_FN3___2 = 2397,
	PORT274_FN3___2 = 2398,
	PORT275_FN3___2 = 2399,
	PORT276_FN3___2 = 2400,
	PORT277_FN3___2 = 2401,
	PORT278_FN3___2 = 2402,
	PORT279_FN3___2 = 2403,
	PORT280_FN3___2 = 2404,
	PORT281_FN3___2 = 2405,
	PORT282_FN3___2 = 2406,
	PORT288_FN3___2 = 2407,
	PORT289_FN3___2 = 2408,
	PORT290_FN3___2 = 2409,
	PORT291_FN3___2 = 2410,
	PORT292_FN3___2 = 2411,
	PORT293_FN3___2 = 2412,
	PORT294_FN3___2 = 2413,
	PORT295_FN3___2 = 2414,
	PORT296_FN3___2 = 2415,
	PORT297_FN3___2 = 2416,
	PORT298_FN3___2 = 2417,
	PORT299_FN3___2 = 2418,
	PORT300_FN3___2 = 2419,
	PORT301_FN3___2 = 2420,
	PORT302_FN3___2 = 2421,
	PORT303_FN3___2 = 2422,
	PORT304_FN3___2 = 2423,
	PORT305_FN3___2 = 2424,
	PORT306_FN3___2 = 2425,
	PORT307_FN3___2 = 2426,
	PORT308_FN3___2 = 2427,
	PORT309_FN3 = 2428,
	PORT0_FN4___3 = 2429,
	PORT1_FN4___3 = 2430,
	PORT2_FN4___3 = 2431,
	PORT3_FN4___3 = 2432,
	PORT4_FN4___3 = 2433,
	PORT5_FN4___3 = 2434,
	PORT6_FN4___3 = 2435,
	PORT7_FN4___3 = 2436,
	PORT8_FN4___3 = 2437,
	PORT9_FN4___3 = 2438,
	PORT10_FN4___3 = 2439,
	PORT11_FN4___3 = 2440,
	PORT12_FN4___3 = 2441,
	PORT13_FN4___3 = 2442,
	PORT14_FN4___3 = 2443,
	PORT15_FN4___3 = 2444,
	PORT16_FN4___3 = 2445,
	PORT17_FN4___3 = 2446,
	PORT18_FN4___3 = 2447,
	PORT19_FN4___3 = 2448,
	PORT20_FN4___3 = 2449,
	PORT21_FN4___3 = 2450,
	PORT22_FN4___3 = 2451,
	PORT23_FN4___3 = 2452,
	PORT24_FN4___3 = 2453,
	PORT25_FN4___3 = 2454,
	PORT26_FN4___3 = 2455,
	PORT27_FN4___3 = 2456,
	PORT28_FN4___3 = 2457,
	PORT29_FN4___3 = 2458,
	PORT30_FN4___3 = 2459,
	PORT31_FN4___2 = 2460,
	PORT32_FN4___3 = 2461,
	PORT33_FN4___3 = 2462,
	PORT34_FN4___3 = 2463,
	PORT35_FN4___3 = 2464,
	PORT36_FN4___3 = 2465,
	PORT37_FN4___3 = 2466,
	PORT38_FN4___3 = 2467,
	PORT39_FN4___3 = 2468,
	PORT40_FN4___3 = 2469,
	PORT41_FN4___2 = 2470,
	PORT42_FN4___2 = 2471,
	PORT43_FN4___2 = 2472,
	PORT44_FN4___2 = 2473,
	PORT45_FN4___2 = 2474,
	PORT46_FN4___2 = 2475,
	PORT47_FN4___2 = 2476,
	PORT48_FN4___2 = 2477,
	PORT49_FN4___2 = 2478,
	PORT50_FN4___2 = 2479,
	PORT51_FN4___2 = 2480,
	PORT52_FN4___2 = 2481,
	PORT53_FN4___2 = 2482,
	PORT54_FN4___2 = 2483,
	PORT55_FN4___2 = 2484,
	PORT56_FN4___2 = 2485,
	PORT57_FN4___2 = 2486,
	PORT58_FN4___2 = 2487,
	PORT59_FN4___2 = 2488,
	PORT60_FN4___2 = 2489,
	PORT61_FN4___2 = 2490,
	PORT62_FN4___2 = 2491,
	PORT63_FN4___2 = 2492,
	PORT64_FN4___3 = 2493,
	PORT65_FN4___3 = 2494,
	PORT66_FN4___3 = 2495,
	PORT67_FN4___3 = 2496,
	PORT68_FN4___3 = 2497,
	PORT69_FN4___3 = 2498,
	PORT70_FN4___3 = 2499,
	PORT71_FN4___3 = 2500,
	PORT72_FN4___3 = 2501,
	PORT73_FN4___3 = 2502,
	PORT74_FN4___3 = 2503,
	PORT75_FN4___3 = 2504,
	PORT76_FN4___3 = 2505,
	PORT77_FN4___3 = 2506,
	PORT78_FN4___3 = 2507,
	PORT79_FN4___3 = 2508,
	PORT80_FN4___3 = 2509,
	PORT81_FN4___3 = 2510,
	PORT82_FN4___3 = 2511,
	PORT83_FN4___3 = 2512,
	PORT84_FN4___3 = 2513,
	PORT85_FN4___3 = 2514,
	PORT86_FN4___2 = 2515,
	PORT87_FN4___2 = 2516,
	PORT88_FN4___2 = 2517,
	PORT89_FN4___2 = 2518,
	PORT90_FN4___2 = 2519,
	PORT91_FN4___2 = 2520,
	PORT92_FN4___2 = 2521,
	PORT93_FN4___2 = 2522,
	PORT94_FN4___2 = 2523,
	PORT95_FN4___2 = 2524,
	PORT96_FN4___3 = 2525,
	PORT97_FN4___3 = 2526,
	PORT98_FN4___3 = 2527,
	PORT99_FN4___3 = 2528,
	PORT100_FN4___3 = 2529,
	PORT101_FN4___3 = 2530,
	PORT102_FN4___3 = 2531,
	PORT103_FN4___3 = 2532,
	PORT104_FN4___3 = 2533,
	PORT105_FN4___3 = 2534,
	PORT106_FN4___3 = 2535,
	PORT107_FN4___3 = 2536,
	PORT108_FN4___3 = 2537,
	PORT109_FN4___3 = 2538,
	PORT110_FN4___3 = 2539,
	PORT111_FN4___3 = 2540,
	PORT112_FN4___3 = 2541,
	PORT113_FN4___3 = 2542,
	PORT114_FN4___3 = 2543,
	PORT115_FN4___3 = 2544,
	PORT116_FN4___3 = 2545,
	PORT117_FN4___3 = 2546,
	PORT118_FN4___3 = 2547,
	PORT128_FN4___3 = 2548,
	PORT129_FN4___3 = 2549,
	PORT130_FN4___3 = 2550,
	PORT131_FN4___3 = 2551,
	PORT132_FN4___3 = 2552,
	PORT133_FN4___3 = 2553,
	PORT134_FN4___3 = 2554,
	PORT135_FN4___2 = 2555,
	PORT136_FN4___2 = 2556,
	PORT137_FN4___2 = 2557,
	PORT138_FN4___2 = 2558,
	PORT139_FN4___2 = 2559,
	PORT140_FN4___2 = 2560,
	PORT141_FN4___2 = 2561,
	PORT142_FN4___2 = 2562,
	PORT143_FN4___2 = 2563,
	PORT144_FN4___2 = 2564,
	PORT145_FN4___2 = 2565,
	PORT146_FN4___2 = 2566,
	PORT147_FN4___2 = 2567,
	PORT148_FN4___2 = 2568,
	PORT149_FN4___2 = 2569,
	PORT150_FN4___2 = 2570,
	PORT151_FN4___2 = 2571,
	PORT152_FN4___2 = 2572,
	PORT153_FN4___2 = 2573,
	PORT154_FN4___2 = 2574,
	PORT155_FN4___2 = 2575,
	PORT156_FN4___2 = 2576,
	PORT157_FN4___2 = 2577,
	PORT158_FN4___2 = 2578,
	PORT159_FN4___2 = 2579,
	PORT160_FN4___3 = 2580,
	PORT161_FN4___3 = 2581,
	PORT162_FN4___3 = 2582,
	PORT163_FN4___3 = 2583,
	PORT164_FN4___3 = 2584,
	PORT192_FN4___3 = 2585,
	PORT193_FN4___3 = 2586,
	PORT194_FN4___3 = 2587,
	PORT195_FN4___3 = 2588,
	PORT196_FN4___3 = 2589,
	PORT197_FN4___3 = 2590,
	PORT198_FN4___3 = 2591,
	PORT199_FN4___3 = 2592,
	PORT200_FN4___3 = 2593,
	PORT201_FN4___3 = 2594,
	PORT202_FN4___3 = 2595,
	PORT203_FN4___3 = 2596,
	PORT204_FN4___3 = 2597,
	PORT205_FN4___3 = 2598,
	PORT206_FN4___3 = 2599,
	PORT207_FN4___3 = 2600,
	PORT208_FN4___3 = 2601,
	PORT209_FN4___3 = 2602,
	PORT210_FN4___3 = 2603,
	PORT211_FN4___3 = 2604,
	PORT212_FN4___2 = 2605,
	PORT213_FN4___2 = 2606,
	PORT214_FN4___2 = 2607,
	PORT215_FN4___2 = 2608,
	PORT216_FN4___2 = 2609,
	PORT217_FN4___2 = 2610,
	PORT218_FN4___2 = 2611,
	PORT219_FN4___2 = 2612,
	PORT220_FN4___2 = 2613,
	PORT221_FN4___2 = 2614,
	PORT222_FN4___2 = 2615,
	PORT223_FN4 = 2616,
	PORT224_FN4___2 = 2617,
	PORT225_FN4___2 = 2618,
	PORT226_FN4___2 = 2619,
	PORT227_FN4___2 = 2620,
	PORT228_FN4___2 = 2621,
	PORT229_FN4___2 = 2622,
	PORT230_FN4___2 = 2623,
	PORT231_FN4___2 = 2624,
	PORT232_FN4___2 = 2625,
	PORT233_FN4___2 = 2626,
	PORT234_FN4___2 = 2627,
	PORT235_FN4___2 = 2628,
	PORT236_FN4___2 = 2629,
	PORT237_FN4___2 = 2630,
	PORT238_FN4___2 = 2631,
	PORT239_FN4___2 = 2632,
	PORT240_FN4___2 = 2633,
	PORT241_FN4___2 = 2634,
	PORT242_FN4___2 = 2635,
	PORT243_FN4___2 = 2636,
	PORT244_FN4___2 = 2637,
	PORT245_FN4___2 = 2638,
	PORT246_FN4___2 = 2639,
	PORT247_FN4___2 = 2640,
	PORT248_FN4___2 = 2641,
	PORT249_FN4___2 = 2642,
	PORT250_FN4___2 = 2643,
	PORT251_FN4 = 2644,
	PORT252_FN4 = 2645,
	PORT253_FN4 = 2646,
	PORT254_FN4 = 2647,
	PORT255_FN4 = 2648,
	PORT256_FN4___2 = 2649,
	PORT257_FN4___2 = 2650,
	PORT258_FN4___2 = 2651,
	PORT259_FN4___2 = 2652,
	PORT260_FN4___2 = 2653,
	PORT261_FN4___2 = 2654,
	PORT262_FN4___2 = 2655,
	PORT263_FN4___2 = 2656,
	PORT264_FN4___2 = 2657,
	PORT265_FN4___2 = 2658,
	PORT266_FN4___2 = 2659,
	PORT267_FN4___2 = 2660,
	PORT268_FN4___2 = 2661,
	PORT269_FN4___2 = 2662,
	PORT270_FN4___2 = 2663,
	PORT271_FN4___2 = 2664,
	PORT272_FN4___2 = 2665,
	PORT273_FN4___2 = 2666,
	PORT274_FN4___2 = 2667,
	PORT275_FN4___2 = 2668,
	PORT276_FN4___2 = 2669,
	PORT277_FN4___2 = 2670,
	PORT278_FN4___2 = 2671,
	PORT279_FN4___2 = 2672,
	PORT280_FN4___2 = 2673,
	PORT281_FN4___2 = 2674,
	PORT282_FN4___2 = 2675,
	PORT288_FN4___2 = 2676,
	PORT289_FN4___2 = 2677,
	PORT290_FN4___2 = 2678,
	PORT291_FN4___2 = 2679,
	PORT292_FN4___2 = 2680,
	PORT293_FN4___2 = 2681,
	PORT294_FN4___2 = 2682,
	PORT295_FN4___2 = 2683,
	PORT296_FN4___2 = 2684,
	PORT297_FN4___2 = 2685,
	PORT298_FN4___2 = 2686,
	PORT299_FN4___2 = 2687,
	PORT300_FN4___2 = 2688,
	PORT301_FN4___2 = 2689,
	PORT302_FN4___2 = 2690,
	PORT303_FN4___2 = 2691,
	PORT304_FN4___2 = 2692,
	PORT305_FN4___2 = 2693,
	PORT306_FN4___2 = 2694,
	PORT307_FN4___2 = 2695,
	PORT308_FN4___2 = 2696,
	PORT309_FN4 = 2697,
	PORT0_FN5___3 = 2698,
	PORT1_FN5___3 = 2699,
	PORT2_FN5___3 = 2700,
	PORT3_FN5___3 = 2701,
	PORT4_FN5___3 = 2702,
	PORT5_FN5___3 = 2703,
	PORT6_FN5___3 = 2704,
	PORT7_FN5___3 = 2705,
	PORT8_FN5___3 = 2706,
	PORT9_FN5___3 = 2707,
	PORT10_FN5___3 = 2708,
	PORT11_FN5___3 = 2709,
	PORT12_FN5___3 = 2710,
	PORT13_FN5___3 = 2711,
	PORT14_FN5___3 = 2712,
	PORT15_FN5___3 = 2713,
	PORT16_FN5___3 = 2714,
	PORT17_FN5___3 = 2715,
	PORT18_FN5___3 = 2716,
	PORT19_FN5___3 = 2717,
	PORT20_FN5___3 = 2718,
	PORT21_FN5___3 = 2719,
	PORT22_FN5___3 = 2720,
	PORT23_FN5___3 = 2721,
	PORT24_FN5___3 = 2722,
	PORT25_FN5___3 = 2723,
	PORT26_FN5___3 = 2724,
	PORT27_FN5___3 = 2725,
	PORT28_FN5___3 = 2726,
	PORT29_FN5___3 = 2727,
	PORT30_FN5___3 = 2728,
	PORT31_FN5___2 = 2729,
	PORT32_FN5___3 = 2730,
	PORT33_FN5___3 = 2731,
	PORT34_FN5___3 = 2732,
	PORT35_FN5___3 = 2733,
	PORT36_FN5___3 = 2734,
	PORT37_FN5___3 = 2735,
	PORT38_FN5___3 = 2736,
	PORT39_FN5___3 = 2737,
	PORT40_FN5___3 = 2738,
	PORT41_FN5___2 = 2739,
	PORT42_FN5___2 = 2740,
	PORT43_FN5___2 = 2741,
	PORT44_FN5___2 = 2742,
	PORT45_FN5___2 = 2743,
	PORT46_FN5___2 = 2744,
	PORT47_FN5___2 = 2745,
	PORT48_FN5___2 = 2746,
	PORT49_FN5___2 = 2747,
	PORT50_FN5___2 = 2748,
	PORT51_FN5___2 = 2749,
	PORT52_FN5___2 = 2750,
	PORT53_FN5___2 = 2751,
	PORT54_FN5___2 = 2752,
	PORT55_FN5___2 = 2753,
	PORT56_FN5___2 = 2754,
	PORT57_FN5___2 = 2755,
	PORT58_FN5___2 = 2756,
	PORT59_FN5___2 = 2757,
	PORT60_FN5___2 = 2758,
	PORT61_FN5___2 = 2759,
	PORT62_FN5___2 = 2760,
	PORT63_FN5___2 = 2761,
	PORT64_FN5___3 = 2762,
	PORT65_FN5___3 = 2763,
	PORT66_FN5___3 = 2764,
	PORT67_FN5___3 = 2765,
	PORT68_FN5___3 = 2766,
	PORT69_FN5___3 = 2767,
	PORT70_FN5___3 = 2768,
	PORT71_FN5___3 = 2769,
	PORT72_FN5___3 = 2770,
	PORT73_FN5___3 = 2771,
	PORT74_FN5___3 = 2772,
	PORT75_FN5___3 = 2773,
	PORT76_FN5___3 = 2774,
	PORT77_FN5___3 = 2775,
	PORT78_FN5___3 = 2776,
	PORT79_FN5___3 = 2777,
	PORT80_FN5___3 = 2778,
	PORT81_FN5___3 = 2779,
	PORT82_FN5___3 = 2780,
	PORT83_FN5___3 = 2781,
	PORT84_FN5___3 = 2782,
	PORT85_FN5___3 = 2783,
	PORT86_FN5___2 = 2784,
	PORT87_FN5___2 = 2785,
	PORT88_FN5___2 = 2786,
	PORT89_FN5___2 = 2787,
	PORT90_FN5___2 = 2788,
	PORT91_FN5___2 = 2789,
	PORT92_FN5___2 = 2790,
	PORT93_FN5___2 = 2791,
	PORT94_FN5___2 = 2792,
	PORT95_FN5___2 = 2793,
	PORT96_FN5___3 = 2794,
	PORT97_FN5___3 = 2795,
	PORT98_FN5___3 = 2796,
	PORT99_FN5___3 = 2797,
	PORT100_FN5___3 = 2798,
	PORT101_FN5___3 = 2799,
	PORT102_FN5___3 = 2800,
	PORT103_FN5___3 = 2801,
	PORT104_FN5___3 = 2802,
	PORT105_FN5___3 = 2803,
	PORT106_FN5___3 = 2804,
	PORT107_FN5___3 = 2805,
	PORT108_FN5___3 = 2806,
	PORT109_FN5___3 = 2807,
	PORT110_FN5___3 = 2808,
	PORT111_FN5___3 = 2809,
	PORT112_FN5___3 = 2810,
	PORT113_FN5___3 = 2811,
	PORT114_FN5___3 = 2812,
	PORT115_FN5___3 = 2813,
	PORT116_FN5___3 = 2814,
	PORT117_FN5___3 = 2815,
	PORT118_FN5___3 = 2816,
	PORT128_FN5___3 = 2817,
	PORT129_FN5___3 = 2818,
	PORT130_FN5___3 = 2819,
	PORT131_FN5___3 = 2820,
	PORT132_FN5___3 = 2821,
	PORT133_FN5___3 = 2822,
	PORT134_FN5___3 = 2823,
	PORT135_FN5___2 = 2824,
	PORT136_FN5___2 = 2825,
	PORT137_FN5___2 = 2826,
	PORT138_FN5___2 = 2827,
	PORT139_FN5___2 = 2828,
	PORT140_FN5___2 = 2829,
	PORT141_FN5___2 = 2830,
	PORT142_FN5___2 = 2831,
	PORT143_FN5___2 = 2832,
	PORT144_FN5___2 = 2833,
	PORT145_FN5___2 = 2834,
	PORT146_FN5___2 = 2835,
	PORT147_FN5___2 = 2836,
	PORT148_FN5___2 = 2837,
	PORT149_FN5___2 = 2838,
	PORT150_FN5___2 = 2839,
	PORT151_FN5___2 = 2840,
	PORT152_FN5___2 = 2841,
	PORT153_FN5___2 = 2842,
	PORT154_FN5___2 = 2843,
	PORT155_FN5___2 = 2844,
	PORT156_FN5___2 = 2845,
	PORT157_FN5___2 = 2846,
	PORT158_FN5___2 = 2847,
	PORT159_FN5___2 = 2848,
	PORT160_FN5___3 = 2849,
	PORT161_FN5___3 = 2850,
	PORT162_FN5___3 = 2851,
	PORT163_FN5___3 = 2852,
	PORT164_FN5___3 = 2853,
	PORT192_FN5___3 = 2854,
	PORT193_FN5___3 = 2855,
	PORT194_FN5___3 = 2856,
	PORT195_FN5___3 = 2857,
	PORT196_FN5___3 = 2858,
	PORT197_FN5___3 = 2859,
	PORT198_FN5___3 = 2860,
	PORT199_FN5___3 = 2861,
	PORT200_FN5___3 = 2862,
	PORT201_FN5___3 = 2863,
	PORT202_FN5___3 = 2864,
	PORT203_FN5___3 = 2865,
	PORT204_FN5___3 = 2866,
	PORT205_FN5___3 = 2867,
	PORT206_FN5___3 = 2868,
	PORT207_FN5___3 = 2869,
	PORT208_FN5___3 = 2870,
	PORT209_FN5___3 = 2871,
	PORT210_FN5___3 = 2872,
	PORT211_FN5___3 = 2873,
	PORT212_FN5___2 = 2874,
	PORT213_FN5___2 = 2875,
	PORT214_FN5___2 = 2876,
	PORT215_FN5___2 = 2877,
	PORT216_FN5___2 = 2878,
	PORT217_FN5___2 = 2879,
	PORT218_FN5___2 = 2880,
	PORT219_FN5___2 = 2881,
	PORT220_FN5___2 = 2882,
	PORT221_FN5___2 = 2883,
	PORT222_FN5___2 = 2884,
	PORT223_FN5 = 2885,
	PORT224_FN5___2 = 2886,
	PORT225_FN5___2 = 2887,
	PORT226_FN5___2 = 2888,
	PORT227_FN5___2 = 2889,
	PORT228_FN5___2 = 2890,
	PORT229_FN5___2 = 2891,
	PORT230_FN5___2 = 2892,
	PORT231_FN5___2 = 2893,
	PORT232_FN5___2 = 2894,
	PORT233_FN5___2 = 2895,
	PORT234_FN5___2 = 2896,
	PORT235_FN5___2 = 2897,
	PORT236_FN5___2 = 2898,
	PORT237_FN5___2 = 2899,
	PORT238_FN5___2 = 2900,
	PORT239_FN5___2 = 2901,
	PORT240_FN5___2 = 2902,
	PORT241_FN5___2 = 2903,
	PORT242_FN5___2 = 2904,
	PORT243_FN5___2 = 2905,
	PORT244_FN5___2 = 2906,
	PORT245_FN5___2 = 2907,
	PORT246_FN5___2 = 2908,
	PORT247_FN5___2 = 2909,
	PORT248_FN5___2 = 2910,
	PORT249_FN5___2 = 2911,
	PORT250_FN5___2 = 2912,
	PORT251_FN5 = 2913,
	PORT252_FN5 = 2914,
	PORT253_FN5 = 2915,
	PORT254_FN5 = 2916,
	PORT255_FN5 = 2917,
	PORT256_FN5___2 = 2918,
	PORT257_FN5___2 = 2919,
	PORT258_FN5___2 = 2920,
	PORT259_FN5___2 = 2921,
	PORT260_FN5___2 = 2922,
	PORT261_FN5___2 = 2923,
	PORT262_FN5___2 = 2924,
	PORT263_FN5___2 = 2925,
	PORT264_FN5___2 = 2926,
	PORT265_FN5___2 = 2927,
	PORT266_FN5___2 = 2928,
	PORT267_FN5___2 = 2929,
	PORT268_FN5___2 = 2930,
	PORT269_FN5___2 = 2931,
	PORT270_FN5___2 = 2932,
	PORT271_FN5___2 = 2933,
	PORT272_FN5___2 = 2934,
	PORT273_FN5___2 = 2935,
	PORT274_FN5___2 = 2936,
	PORT275_FN5___2 = 2937,
	PORT276_FN5___2 = 2938,
	PORT277_FN5___2 = 2939,
	PORT278_FN5___2 = 2940,
	PORT279_FN5___2 = 2941,
	PORT280_FN5___2 = 2942,
	PORT281_FN5___2 = 2943,
	PORT282_FN5___2 = 2944,
	PORT288_FN5___2 = 2945,
	PORT289_FN5___2 = 2946,
	PORT290_FN5___2 = 2947,
	PORT291_FN5___2 = 2948,
	PORT292_FN5___2 = 2949,
	PORT293_FN5___2 = 2950,
	PORT294_FN5___2 = 2951,
	PORT295_FN5___2 = 2952,
	PORT296_FN5___2 = 2953,
	PORT297_FN5___2 = 2954,
	PORT298_FN5___2 = 2955,
	PORT299_FN5___2 = 2956,
	PORT300_FN5___2 = 2957,
	PORT301_FN5___2 = 2958,
	PORT302_FN5___2 = 2959,
	PORT303_FN5___2 = 2960,
	PORT304_FN5___2 = 2961,
	PORT305_FN5___2 = 2962,
	PORT306_FN5___2 = 2963,
	PORT307_FN5___2 = 2964,
	PORT308_FN5___2 = 2965,
	PORT309_FN5 = 2966,
	PORT0_FN6___3 = 2967,
	PORT1_FN6___3 = 2968,
	PORT2_FN6___3 = 2969,
	PORT3_FN6___3 = 2970,
	PORT4_FN6___3 = 2971,
	PORT5_FN6___3 = 2972,
	PORT6_FN6___3 = 2973,
	PORT7_FN6___3 = 2974,
	PORT8_FN6___3 = 2975,
	PORT9_FN6___3 = 2976,
	PORT10_FN6___3 = 2977,
	PORT11_FN6___3 = 2978,
	PORT12_FN6___3 = 2979,
	PORT13_FN6___3 = 2980,
	PORT14_FN6___3 = 2981,
	PORT15_FN6___3 = 2982,
	PORT16_FN6___3 = 2983,
	PORT17_FN6___3 = 2984,
	PORT18_FN6___3 = 2985,
	PORT19_FN6___3 = 2986,
	PORT20_FN6___3 = 2987,
	PORT21_FN6___3 = 2988,
	PORT22_FN6___3 = 2989,
	PORT23_FN6___3 = 2990,
	PORT24_FN6___3 = 2991,
	PORT25_FN6___3 = 2992,
	PORT26_FN6___3 = 2993,
	PORT27_FN6___3 = 2994,
	PORT28_FN6___3 = 2995,
	PORT29_FN6___3 = 2996,
	PORT30_FN6___3 = 2997,
	PORT31_FN6___2 = 2998,
	PORT32_FN6___3 = 2999,
	PORT33_FN6___3 = 3000,
	PORT34_FN6___3 = 3001,
	PORT35_FN6___3 = 3002,
	PORT36_FN6___3 = 3003,
	PORT37_FN6___3 = 3004,
	PORT38_FN6___3 = 3005,
	PORT39_FN6___3 = 3006,
	PORT40_FN6___3 = 3007,
	PORT41_FN6___2 = 3008,
	PORT42_FN6___2 = 3009,
	PORT43_FN6___2 = 3010,
	PORT44_FN6___2 = 3011,
	PORT45_FN6___2 = 3012,
	PORT46_FN6___2 = 3013,
	PORT47_FN6___2 = 3014,
	PORT48_FN6___2 = 3015,
	PORT49_FN6___2 = 3016,
	PORT50_FN6___2 = 3017,
	PORT51_FN6___2 = 3018,
	PORT52_FN6___2 = 3019,
	PORT53_FN6___2 = 3020,
	PORT54_FN6___2 = 3021,
	PORT55_FN6___2 = 3022,
	PORT56_FN6___2 = 3023,
	PORT57_FN6___2 = 3024,
	PORT58_FN6___2 = 3025,
	PORT59_FN6___2 = 3026,
	PORT60_FN6___2 = 3027,
	PORT61_FN6___2 = 3028,
	PORT62_FN6___2 = 3029,
	PORT63_FN6___2 = 3030,
	PORT64_FN6___3 = 3031,
	PORT65_FN6___3 = 3032,
	PORT66_FN6___3 = 3033,
	PORT67_FN6___3 = 3034,
	PORT68_FN6___3 = 3035,
	PORT69_FN6___3 = 3036,
	PORT70_FN6___3 = 3037,
	PORT71_FN6___3 = 3038,
	PORT72_FN6___3 = 3039,
	PORT73_FN6___3 = 3040,
	PORT74_FN6___3 = 3041,
	PORT75_FN6___3 = 3042,
	PORT76_FN6___3 = 3043,
	PORT77_FN6___3 = 3044,
	PORT78_FN6___3 = 3045,
	PORT79_FN6___3 = 3046,
	PORT80_FN6___3 = 3047,
	PORT81_FN6___3 = 3048,
	PORT82_FN6___3 = 3049,
	PORT83_FN6___3 = 3050,
	PORT84_FN6___3 = 3051,
	PORT85_FN6___3 = 3052,
	PORT86_FN6___2 = 3053,
	PORT87_FN6___2 = 3054,
	PORT88_FN6___2 = 3055,
	PORT89_FN6___2 = 3056,
	PORT90_FN6___2 = 3057,
	PORT91_FN6___2 = 3058,
	PORT92_FN6___2 = 3059,
	PORT93_FN6___2 = 3060,
	PORT94_FN6___2 = 3061,
	PORT95_FN6___2 = 3062,
	PORT96_FN6___3 = 3063,
	PORT97_FN6___3 = 3064,
	PORT98_FN6___3 = 3065,
	PORT99_FN6___3 = 3066,
	PORT100_FN6___3 = 3067,
	PORT101_FN6___3 = 3068,
	PORT102_FN6___3 = 3069,
	PORT103_FN6___3 = 3070,
	PORT104_FN6___3 = 3071,
	PORT105_FN6___3 = 3072,
	PORT106_FN6___3 = 3073,
	PORT107_FN6___3 = 3074,
	PORT108_FN6___3 = 3075,
	PORT109_FN6___3 = 3076,
	PORT110_FN6___3 = 3077,
	PORT111_FN6___3 = 3078,
	PORT112_FN6___3 = 3079,
	PORT113_FN6___3 = 3080,
	PORT114_FN6___3 = 3081,
	PORT115_FN6___3 = 3082,
	PORT116_FN6___3 = 3083,
	PORT117_FN6___3 = 3084,
	PORT118_FN6___3 = 3085,
	PORT128_FN6___3 = 3086,
	PORT129_FN6___3 = 3087,
	PORT130_FN6___3 = 3088,
	PORT131_FN6___3 = 3089,
	PORT132_FN6___3 = 3090,
	PORT133_FN6___3 = 3091,
	PORT134_FN6___3 = 3092,
	PORT135_FN6___2 = 3093,
	PORT136_FN6___2 = 3094,
	PORT137_FN6___2 = 3095,
	PORT138_FN6___2 = 3096,
	PORT139_FN6___2 = 3097,
	PORT140_FN6___2 = 3098,
	PORT141_FN6___2 = 3099,
	PORT142_FN6___2 = 3100,
	PORT143_FN6___2 = 3101,
	PORT144_FN6___2 = 3102,
	PORT145_FN6___2 = 3103,
	PORT146_FN6___2 = 3104,
	PORT147_FN6___2 = 3105,
	PORT148_FN6___2 = 3106,
	PORT149_FN6___2 = 3107,
	PORT150_FN6___2 = 3108,
	PORT151_FN6___2 = 3109,
	PORT152_FN6___2 = 3110,
	PORT153_FN6___2 = 3111,
	PORT154_FN6___2 = 3112,
	PORT155_FN6___2 = 3113,
	PORT156_FN6___2 = 3114,
	PORT157_FN6___2 = 3115,
	PORT158_FN6___2 = 3116,
	PORT159_FN6___2 = 3117,
	PORT160_FN6___3 = 3118,
	PORT161_FN6___3 = 3119,
	PORT162_FN6___3 = 3120,
	PORT163_FN6___3 = 3121,
	PORT164_FN6___3 = 3122,
	PORT192_FN6___3 = 3123,
	PORT193_FN6___3 = 3124,
	PORT194_FN6___3 = 3125,
	PORT195_FN6___3 = 3126,
	PORT196_FN6___3 = 3127,
	PORT197_FN6___3 = 3128,
	PORT198_FN6___3 = 3129,
	PORT199_FN6___3 = 3130,
	PORT200_FN6___3 = 3131,
	PORT201_FN6___3 = 3132,
	PORT202_FN6___3 = 3133,
	PORT203_FN6___3 = 3134,
	PORT204_FN6___3 = 3135,
	PORT205_FN6___3 = 3136,
	PORT206_FN6___3 = 3137,
	PORT207_FN6___3 = 3138,
	PORT208_FN6___3 = 3139,
	PORT209_FN6___3 = 3140,
	PORT210_FN6___3 = 3141,
	PORT211_FN6___3 = 3142,
	PORT212_FN6___2 = 3143,
	PORT213_FN6___2 = 3144,
	PORT214_FN6___2 = 3145,
	PORT215_FN6___2 = 3146,
	PORT216_FN6___2 = 3147,
	PORT217_FN6___2 = 3148,
	PORT218_FN6___2 = 3149,
	PORT219_FN6___2 = 3150,
	PORT220_FN6___2 = 3151,
	PORT221_FN6___2 = 3152,
	PORT222_FN6___2 = 3153,
	PORT223_FN6 = 3154,
	PORT224_FN6___2 = 3155,
	PORT225_FN6___2 = 3156,
	PORT226_FN6___2 = 3157,
	PORT227_FN6___2 = 3158,
	PORT228_FN6___2 = 3159,
	PORT229_FN6___2 = 3160,
	PORT230_FN6___2 = 3161,
	PORT231_FN6___2 = 3162,
	PORT232_FN6___2 = 3163,
	PORT233_FN6___2 = 3164,
	PORT234_FN6___2 = 3165,
	PORT235_FN6___2 = 3166,
	PORT236_FN6___2 = 3167,
	PORT237_FN6___2 = 3168,
	PORT238_FN6___2 = 3169,
	PORT239_FN6___2 = 3170,
	PORT240_FN6___2 = 3171,
	PORT241_FN6___2 = 3172,
	PORT242_FN6___2 = 3173,
	PORT243_FN6___2 = 3174,
	PORT244_FN6___2 = 3175,
	PORT245_FN6___2 = 3176,
	PORT246_FN6___2 = 3177,
	PORT247_FN6___2 = 3178,
	PORT248_FN6___2 = 3179,
	PORT249_FN6___2 = 3180,
	PORT250_FN6___2 = 3181,
	PORT251_FN6 = 3182,
	PORT252_FN6 = 3183,
	PORT253_FN6 = 3184,
	PORT254_FN6 = 3185,
	PORT255_FN6 = 3186,
	PORT256_FN6___2 = 3187,
	PORT257_FN6___2 = 3188,
	PORT258_FN6___2 = 3189,
	PORT259_FN6___2 = 3190,
	PORT260_FN6___2 = 3191,
	PORT261_FN6___2 = 3192,
	PORT262_FN6___2 = 3193,
	PORT263_FN6___2 = 3194,
	PORT264_FN6___2 = 3195,
	PORT265_FN6___2 = 3196,
	PORT266_FN6___2 = 3197,
	PORT267_FN6___2 = 3198,
	PORT268_FN6___2 = 3199,
	PORT269_FN6___2 = 3200,
	PORT270_FN6___2 = 3201,
	PORT271_FN6___2 = 3202,
	PORT272_FN6___2 = 3203,
	PORT273_FN6___2 = 3204,
	PORT274_FN6___2 = 3205,
	PORT275_FN6___2 = 3206,
	PORT276_FN6___2 = 3207,
	PORT277_FN6___2 = 3208,
	PORT278_FN6___2 = 3209,
	PORT279_FN6___2 = 3210,
	PORT280_FN6___2 = 3211,
	PORT281_FN6___2 = 3212,
	PORT282_FN6___2 = 3213,
	PORT288_FN6___2 = 3214,
	PORT289_FN6___2 = 3215,
	PORT290_FN6___2 = 3216,
	PORT291_FN6___2 = 3217,
	PORT292_FN6___2 = 3218,
	PORT293_FN6___2 = 3219,
	PORT294_FN6___2 = 3220,
	PORT295_FN6___2 = 3221,
	PORT296_FN6___2 = 3222,
	PORT297_FN6___2 = 3223,
	PORT298_FN6___2 = 3224,
	PORT299_FN6___2 = 3225,
	PORT300_FN6___2 = 3226,
	PORT301_FN6___2 = 3227,
	PORT302_FN6___2 = 3228,
	PORT303_FN6___2 = 3229,
	PORT304_FN6___2 = 3230,
	PORT305_FN6___2 = 3231,
	PORT306_FN6___2 = 3232,
	PORT307_FN6___2 = 3233,
	PORT308_FN6___2 = 3234,
	PORT309_FN6 = 3235,
	PORT0_FN7___3 = 3236,
	PORT1_FN7___3 = 3237,
	PORT2_FN7___3 = 3238,
	PORT3_FN7___3 = 3239,
	PORT4_FN7___3 = 3240,
	PORT5_FN7___3 = 3241,
	PORT6_FN7___3 = 3242,
	PORT7_FN7___3 = 3243,
	PORT8_FN7___3 = 3244,
	PORT9_FN7___3 = 3245,
	PORT10_FN7___3 = 3246,
	PORT11_FN7___3 = 3247,
	PORT12_FN7___3 = 3248,
	PORT13_FN7___3 = 3249,
	PORT14_FN7___3 = 3250,
	PORT15_FN7___3 = 3251,
	PORT16_FN7___3 = 3252,
	PORT17_FN7___3 = 3253,
	PORT18_FN7___3 = 3254,
	PORT19_FN7___3 = 3255,
	PORT20_FN7___3 = 3256,
	PORT21_FN7___3 = 3257,
	PORT22_FN7___3 = 3258,
	PORT23_FN7___3 = 3259,
	PORT24_FN7___3 = 3260,
	PORT25_FN7___3 = 3261,
	PORT26_FN7___3 = 3262,
	PORT27_FN7___3 = 3263,
	PORT28_FN7___3 = 3264,
	PORT29_FN7___3 = 3265,
	PORT30_FN7___3 = 3266,
	PORT31_FN7___2 = 3267,
	PORT32_FN7___3 = 3268,
	PORT33_FN7___3 = 3269,
	PORT34_FN7___3 = 3270,
	PORT35_FN7___3 = 3271,
	PORT36_FN7___3 = 3272,
	PORT37_FN7___3 = 3273,
	PORT38_FN7___3 = 3274,
	PORT39_FN7___3 = 3275,
	PORT40_FN7___3 = 3276,
	PORT41_FN7___2 = 3277,
	PORT42_FN7___2 = 3278,
	PORT43_FN7___2 = 3279,
	PORT44_FN7___2 = 3280,
	PORT45_FN7___2 = 3281,
	PORT46_FN7___2 = 3282,
	PORT47_FN7___2 = 3283,
	PORT48_FN7___2 = 3284,
	PORT49_FN7___2 = 3285,
	PORT50_FN7___2 = 3286,
	PORT51_FN7___2 = 3287,
	PORT52_FN7___2 = 3288,
	PORT53_FN7___2 = 3289,
	PORT54_FN7___2 = 3290,
	PORT55_FN7___2 = 3291,
	PORT56_FN7___2 = 3292,
	PORT57_FN7___2 = 3293,
	PORT58_FN7___2 = 3294,
	PORT59_FN7___2 = 3295,
	PORT60_FN7___2 = 3296,
	PORT61_FN7___2 = 3297,
	PORT62_FN7___2 = 3298,
	PORT63_FN7___2 = 3299,
	PORT64_FN7___3 = 3300,
	PORT65_FN7___3 = 3301,
	PORT66_FN7___3 = 3302,
	PORT67_FN7___3 = 3303,
	PORT68_FN7___3 = 3304,
	PORT69_FN7___3 = 3305,
	PORT70_FN7___3 = 3306,
	PORT71_FN7___3 = 3307,
	PORT72_FN7___3 = 3308,
	PORT73_FN7___3 = 3309,
	PORT74_FN7___3 = 3310,
	PORT75_FN7___3 = 3311,
	PORT76_FN7___3 = 3312,
	PORT77_FN7___3 = 3313,
	PORT78_FN7___3 = 3314,
	PORT79_FN7___3 = 3315,
	PORT80_FN7___3 = 3316,
	PORT81_FN7___3 = 3317,
	PORT82_FN7___3 = 3318,
	PORT83_FN7___3 = 3319,
	PORT84_FN7___3 = 3320,
	PORT85_FN7___3 = 3321,
	PORT86_FN7___2 = 3322,
	PORT87_FN7___2 = 3323,
	PORT88_FN7___2 = 3324,
	PORT89_FN7___2 = 3325,
	PORT90_FN7___2 = 3326,
	PORT91_FN7___2 = 3327,
	PORT92_FN7___2 = 3328,
	PORT93_FN7___2 = 3329,
	PORT94_FN7___2 = 3330,
	PORT95_FN7___2 = 3331,
	PORT96_FN7___3 = 3332,
	PORT97_FN7___3 = 3333,
	PORT98_FN7___3 = 3334,
	PORT99_FN7___3 = 3335,
	PORT100_FN7___3 = 3336,
	PORT101_FN7___3 = 3337,
	PORT102_FN7___3 = 3338,
	PORT103_FN7___3 = 3339,
	PORT104_FN7___3 = 3340,
	PORT105_FN7___3 = 3341,
	PORT106_FN7___3 = 3342,
	PORT107_FN7___3 = 3343,
	PORT108_FN7___3 = 3344,
	PORT109_FN7___3 = 3345,
	PORT110_FN7___3 = 3346,
	PORT111_FN7___3 = 3347,
	PORT112_FN7___3 = 3348,
	PORT113_FN7___3 = 3349,
	PORT114_FN7___3 = 3350,
	PORT115_FN7___3 = 3351,
	PORT116_FN7___3 = 3352,
	PORT117_FN7___3 = 3353,
	PORT118_FN7___3 = 3354,
	PORT128_FN7___3 = 3355,
	PORT129_FN7___3 = 3356,
	PORT130_FN7___3 = 3357,
	PORT131_FN7___3 = 3358,
	PORT132_FN7___3 = 3359,
	PORT133_FN7___3 = 3360,
	PORT134_FN7___3 = 3361,
	PORT135_FN7___2 = 3362,
	PORT136_FN7___2 = 3363,
	PORT137_FN7___2 = 3364,
	PORT138_FN7___2 = 3365,
	PORT139_FN7___2 = 3366,
	PORT140_FN7___2 = 3367,
	PORT141_FN7___2 = 3368,
	PORT142_FN7___2 = 3369,
	PORT143_FN7___2 = 3370,
	PORT144_FN7___2 = 3371,
	PORT145_FN7___2 = 3372,
	PORT146_FN7___2 = 3373,
	PORT147_FN7___2 = 3374,
	PORT148_FN7___2 = 3375,
	PORT149_FN7___2 = 3376,
	PORT150_FN7___2 = 3377,
	PORT151_FN7___2 = 3378,
	PORT152_FN7___2 = 3379,
	PORT153_FN7___2 = 3380,
	PORT154_FN7___2 = 3381,
	PORT155_FN7___2 = 3382,
	PORT156_FN7___2 = 3383,
	PORT157_FN7___2 = 3384,
	PORT158_FN7___2 = 3385,
	PORT159_FN7___2 = 3386,
	PORT160_FN7___3 = 3387,
	PORT161_FN7___3 = 3388,
	PORT162_FN7___3 = 3389,
	PORT163_FN7___3 = 3390,
	PORT164_FN7___3 = 3391,
	PORT192_FN7___3 = 3392,
	PORT193_FN7___3 = 3393,
	PORT194_FN7___3 = 3394,
	PORT195_FN7___3 = 3395,
	PORT196_FN7___3 = 3396,
	PORT197_FN7___3 = 3397,
	PORT198_FN7___3 = 3398,
	PORT199_FN7___3 = 3399,
	PORT200_FN7___3 = 3400,
	PORT201_FN7___3 = 3401,
	PORT202_FN7___3 = 3402,
	PORT203_FN7___3 = 3403,
	PORT204_FN7___3 = 3404,
	PORT205_FN7___3 = 3405,
	PORT206_FN7___3 = 3406,
	PORT207_FN7___3 = 3407,
	PORT208_FN7___3 = 3408,
	PORT209_FN7___3 = 3409,
	PORT210_FN7___3 = 3410,
	PORT211_FN7___3 = 3411,
	PORT212_FN7___2 = 3412,
	PORT213_FN7___2 = 3413,
	PORT214_FN7___2 = 3414,
	PORT215_FN7___2 = 3415,
	PORT216_FN7___2 = 3416,
	PORT217_FN7___2 = 3417,
	PORT218_FN7___2 = 3418,
	PORT219_FN7___2 = 3419,
	PORT220_FN7___2 = 3420,
	PORT221_FN7___2 = 3421,
	PORT222_FN7___2 = 3422,
	PORT223_FN7 = 3423,
	PORT224_FN7___2 = 3424,
	PORT225_FN7___2 = 3425,
	PORT226_FN7___2 = 3426,
	PORT227_FN7___2 = 3427,
	PORT228_FN7___2 = 3428,
	PORT229_FN7___2 = 3429,
	PORT230_FN7___2 = 3430,
	PORT231_FN7___2 = 3431,
	PORT232_FN7___2 = 3432,
	PORT233_FN7___2 = 3433,
	PORT234_FN7___2 = 3434,
	PORT235_FN7___2 = 3435,
	PORT236_FN7___2 = 3436,
	PORT237_FN7___2 = 3437,
	PORT238_FN7___2 = 3438,
	PORT239_FN7___2 = 3439,
	PORT240_FN7___2 = 3440,
	PORT241_FN7___2 = 3441,
	PORT242_FN7___2 = 3442,
	PORT243_FN7___2 = 3443,
	PORT244_FN7___2 = 3444,
	PORT245_FN7___2 = 3445,
	PORT246_FN7___2 = 3446,
	PORT247_FN7___2 = 3447,
	PORT248_FN7___2 = 3448,
	PORT249_FN7___2 = 3449,
	PORT250_FN7___2 = 3450,
	PORT251_FN7 = 3451,
	PORT252_FN7 = 3452,
	PORT253_FN7 = 3453,
	PORT254_FN7 = 3454,
	PORT255_FN7 = 3455,
	PORT256_FN7___2 = 3456,
	PORT257_FN7___2 = 3457,
	PORT258_FN7___2 = 3458,
	PORT259_FN7___2 = 3459,
	PORT260_FN7___2 = 3460,
	PORT261_FN7___2 = 3461,
	PORT262_FN7___2 = 3462,
	PORT263_FN7___2 = 3463,
	PORT264_FN7___2 = 3464,
	PORT265_FN7___2 = 3465,
	PORT266_FN7___2 = 3466,
	PORT267_FN7___2 = 3467,
	PORT268_FN7___2 = 3468,
	PORT269_FN7___2 = 3469,
	PORT270_FN7___2 = 3470,
	PORT271_FN7___2 = 3471,
	PORT272_FN7___2 = 3472,
	PORT273_FN7___2 = 3473,
	PORT274_FN7___2 = 3474,
	PORT275_FN7___2 = 3475,
	PORT276_FN7___2 = 3476,
	PORT277_FN7___2 = 3477,
	PORT278_FN7___2 = 3478,
	PORT279_FN7___2 = 3479,
	PORT280_FN7___2 = 3480,
	PORT281_FN7___2 = 3481,
	PORT282_FN7___2 = 3482,
	PORT288_FN7___2 = 3483,
	PORT289_FN7___2 = 3484,
	PORT290_FN7___2 = 3485,
	PORT291_FN7___2 = 3486,
	PORT292_FN7___2 = 3487,
	PORT293_FN7___2 = 3488,
	PORT294_FN7___2 = 3489,
	PORT295_FN7___2 = 3490,
	PORT296_FN7___2 = 3491,
	PORT297_FN7___2 = 3492,
	PORT298_FN7___2 = 3493,
	PORT299_FN7___2 = 3494,
	PORT300_FN7___2 = 3495,
	PORT301_FN7___2 = 3496,
	PORT302_FN7___2 = 3497,
	PORT303_FN7___2 = 3498,
	PORT304_FN7___2 = 3499,
	PORT305_FN7___2 = 3500,
	PORT306_FN7___2 = 3501,
	PORT307_FN7___2 = 3502,
	PORT308_FN7___2 = 3503,
	PORT309_FN7 = 3504,
	MSEL2CR_MSEL19_0 = 3505,
	MSEL2CR_MSEL19_1 = 3506,
	MSEL2CR_MSEL18_0 = 3507,
	MSEL2CR_MSEL18_1 = 3508,
	MSEL2CR_MSEL17_0 = 3509,
	MSEL2CR_MSEL17_1 = 3510,
	MSEL2CR_MSEL16_0 = 3511,
	MSEL2CR_MSEL16_1 = 3512,
	MSEL2CR_MSEL14_0 = 3513,
	MSEL2CR_MSEL14_1 = 3514,
	MSEL2CR_MSEL13_0 = 3515,
	MSEL2CR_MSEL13_1 = 3516,
	MSEL2CR_MSEL12_0 = 3517,
	MSEL2CR_MSEL12_1 = 3518,
	MSEL2CR_MSEL11_0 = 3519,
	MSEL2CR_MSEL11_1 = 3520,
	MSEL2CR_MSEL10_0 = 3521,
	MSEL2CR_MSEL10_1 = 3522,
	MSEL2CR_MSEL9_0 = 3523,
	MSEL2CR_MSEL9_1 = 3524,
	MSEL2CR_MSEL8_0 = 3525,
	MSEL2CR_MSEL8_1 = 3526,
	MSEL2CR_MSEL7_0 = 3527,
	MSEL2CR_MSEL7_1 = 3528,
	MSEL2CR_MSEL6_0 = 3529,
	MSEL2CR_MSEL6_1 = 3530,
	MSEL2CR_MSEL4_0 = 3531,
	MSEL2CR_MSEL4_1 = 3532,
	MSEL2CR_MSEL5_0 = 3533,
	MSEL2CR_MSEL5_1 = 3534,
	MSEL2CR_MSEL3_0 = 3535,
	MSEL2CR_MSEL3_1 = 3536,
	MSEL2CR_MSEL2_0 = 3537,
	MSEL2CR_MSEL2_1 = 3538,
	MSEL2CR_MSEL1_0 = 3539,
	MSEL2CR_MSEL1_1 = 3540,
	MSEL2CR_MSEL0_0 = 3541,
	MSEL2CR_MSEL0_1 = 3542,
	MSEL3CR_MSEL28_0 = 3543,
	MSEL3CR_MSEL28_1 = 3544,
	MSEL3CR_MSEL15_0 = 3545,
	MSEL3CR_MSEL15_1 = 3546,
	MSEL3CR_MSEL11_0 = 3547,
	MSEL3CR_MSEL11_1 = 3548,
	MSEL3CR_MSEL9_0 = 3549,
	MSEL3CR_MSEL9_1 = 3550,
	MSEL3CR_MSEL6_0 = 3551,
	MSEL3CR_MSEL6_1 = 3552,
	MSEL3CR_MSEL2_0 = 3553,
	MSEL3CR_MSEL2_1 = 3554,
	MSEL4CR_MSEL29_0 = 3555,
	MSEL4CR_MSEL29_1 = 3556,
	MSEL4CR_MSEL27_0 = 3557,
	MSEL4CR_MSEL27_1 = 3558,
	MSEL4CR_MSEL26_0 = 3559,
	MSEL4CR_MSEL26_1 = 3560,
	MSEL4CR_MSEL22_0 = 3561,
	MSEL4CR_MSEL22_1 = 3562,
	MSEL4CR_MSEL21_0 = 3563,
	MSEL4CR_MSEL21_1 = 3564,
	MSEL4CR_MSEL20_0 = 3565,
	MSEL4CR_MSEL20_1 = 3566,
	MSEL4CR_MSEL19_0 = 3567,
	MSEL4CR_MSEL19_1 = 3568,
	MSEL4CR_MSEL15_0 = 3569,
	MSEL4CR_MSEL15_1 = 3570,
	MSEL4CR_MSEL13_0 = 3571,
	MSEL4CR_MSEL13_1 = 3572,
	MSEL4CR_MSEL12_0 = 3573,
	MSEL4CR_MSEL12_1 = 3574,
	MSEL4CR_MSEL11_0 = 3575,
	MSEL4CR_MSEL11_1 = 3576,
	MSEL4CR_MSEL10_0 = 3577,
	MSEL4CR_MSEL10_1 = 3578,
	MSEL4CR_MSEL9_0 = 3579,
	MSEL4CR_MSEL9_1 = 3580,
	MSEL4CR_MSEL8_0 = 3581,
	MSEL4CR_MSEL8_1 = 3582,
	MSEL4CR_MSEL7_0 = 3583,
	MSEL4CR_MSEL7_1 = 3584,
	MSEL4CR_MSEL4_0 = 3585,
	MSEL4CR_MSEL4_1 = 3586,
	MSEL4CR_MSEL1_0 = 3587,
	MSEL4CR_MSEL1_1 = 3588,
	PINMUX_FUNCTION_END___11 = 3589,
	PINMUX_MARK_BEGIN___11 = 3590,
	VBUS_0_MARK = 3591,
	GPI0_MARK___2 = 3592,
	GPI1_MARK___2 = 3593,
	GPI2_MARK = 3594,
	GPI3_MARK = 3595,
	GPI4_MARK = 3596,
	GPI5_MARK = 3597,
	GPI6_MARK = 3598,
	GPI7_MARK = 3599,
	SCIFA7_RXD_MARK___2 = 3600,
	SCIFA7_CTS__MARK = 3601,
	GPO7_MARK = 3602,
	MFG0_OUT2_MARK = 3603,
	GPO6_MARK = 3604,
	MFG1_OUT2_MARK = 3605,
	GPO5_MARK = 3606,
	SCIFA0_SCK_MARK___4 = 3607,
	FSICOSLDT3_MARK = 3608,
	PORT16_VIO_CKOR_MARK = 3609,
	SCIFA0_TXD_MARK___6 = 3610,
	SCIFA7_TXD_MARK___2 = 3611,
	SCIFA7_RTS__MARK = 3612,
	PORT19_VIO_CKO2_MARK = 3613,
	GPO0_MARK___2 = 3614,
	GPO1_MARK___2 = 3615,
	GPO2_MARK = 3616,
	STATUS0_MARK = 3617,
	GPO3_MARK = 3618,
	STATUS1_MARK = 3619,
	GPO4_MARK = 3620,
	STATUS2_MARK = 3621,
	VINT_MARK = 3622,
	TCKON_MARK = 3623,
	XDVFS1_MARK = 3624,
	PORT27_I2C_SCL2_MARK = 3625,
	PORT27_I2C_SCL3_MARK = 3626,
	MFG0_OUT1_MARK = 3627,
	PORT27_IROUT_MARK = 3628,
	XDVFS2_MARK = 3629,
	PORT28_I2C_SDA2_MARK = 3630,
	PORT28_I2C_SDA3_MARK = 3631,
	PORT28_TPU1TO1_MARK = 3632,
	SIM_RST_MARK___3 = 3633,
	PORT29_TPU1TO1_MARK = 3634,
	SIM_CLK_MARK___3 = 3635,
	PORT30_VIO_CKOR_MARK = 3636,
	SIM_D_MARK___2 = 3637,
	PORT31_IROUT_MARK = 3638,
	SCIFA4_TXD_MARK___3 = 3639,
	SCIFA4_RXD_MARK___3 = 3640,
	XWUP_MARK = 3641,
	SCIFA4_RTS__MARK = 3642,
	SCIFA4_CTS__MARK = 3643,
	FSIBOBT_MARK___2 = 3644,
	FSIBIBT_MARK___2 = 3645,
	FSIBOLR_MARK___2 = 3646,
	FSIBILR_MARK___2 = 3647,
	FSIBOSLD_MARK___2 = 3648,
	FSIBISLD_MARK___2 = 3649,
	VACK_MARK = 3650,
	XTAL1L_MARK = 3651,
	SCIFA0_RTS__MARK = 3652,
	FSICOSLDT2_MARK = 3653,
	SCIFA0_RXD_MARK___6 = 3654,
	SCIFA0_CTS__MARK = 3655,
	FSICOSLDT1_MARK = 3656,
	FSICOBT_MARK___2 = 3657,
	FSICIBT_MARK___2 = 3658,
	FSIDOBT_MARK = 3659,
	FSIDIBT_MARK = 3660,
	FSICOLR_MARK___2 = 3661,
	FSICILR_MARK___2 = 3662,
	FSIDOLR_MARK = 3663,
	FSIDILR_MARK = 3664,
	FSICOSLD_MARK___2 = 3665,
	PORT47_FSICSPDIF_MARK = 3666,
	FSICISLD_MARK___2 = 3667,
	FSIDISLD_MARK = 3668,
	FSIACK_MARK___3 = 3669,
	PORT49_IRDA_OUT_MARK = 3670,
	PORT49_IROUT_MARK = 3671,
	FSIAOMC_MARK___3 = 3672,
	FSIAOLR_MARK___3 = 3673,
	BBIF2_TSYNC2_MARK = 3674,
	TPU2TO2_MARK = 3675,
	FSIAILR_MARK___3 = 3676,
	FSIAOBT_MARK___3 = 3677,
	BBIF2_TSCK2_MARK = 3678,
	TPU2TO3_MARK = 3679,
	FSIAIBT_MARK___3 = 3680,
	FSIAOSLD_MARK___3 = 3681,
	BBIF2_TXD2_MARK = 3682,
	FSIASPDIF_MARK___2 = 3683,
	PORT53_IRDA_IN_MARK = 3684,
	TPU3TO3_MARK = 3685,
	FSIBSPDIF_MARK = 3686,
	PORT53_FSICSPDIF_MARK = 3687,
	FSIBCK_MARK___3 = 3688,
	PORT54_IRDA_FIRSEL_MARK = 3689,
	TPU3TO2_MARK = 3690,
	FSIBOMC_MARK___2 = 3691,
	FSICCK_MARK___2 = 3692,
	FSICOMC_MARK___2 = 3693,
	FSIAISLD_MARK___2 = 3694,
	TPU0TO0_MARK___5 = 3695,
	A0_MARK___10 = 3696,
	BS__MARK = 3697,
	A12_MARK___8 = 3698,
	PORT58_KEYOUT7_MARK = 3699,
	TPU4TO2_MARK = 3700,
	A13_MARK___8 = 3701,
	PORT59_KEYOUT6_MARK = 3702,
	TPU0TO1_MARK___5 = 3703,
	A14_MARK___8 = 3704,
	KEYOUT5_MARK___3 = 3705,
	A15_MARK___8 = 3706,
	KEYOUT4_MARK___3 = 3707,
	A16_MARK___8 = 3708,
	KEYOUT3_MARK___3 = 3709,
	MSIOF0_SS1_MARK___6 = 3710,
	A17_MARK___9 = 3711,
	KEYOUT2_MARK___3 = 3712,
	MSIOF0_TSYNC_MARK___2 = 3713,
	A18_MARK___9 = 3714,
	KEYOUT1_MARK___3 = 3715,
	MSIOF0_TSCK_MARK___2 = 3716,
	A19_MARK___9 = 3717,
	KEYOUT0_MARK___3 = 3718,
	MSIOF0_TXD_MARK___7 = 3719,
	A20_MARK___9 = 3720,
	KEYIN0_MARK___2 = 3721,
	MSIOF0_RSCK_MARK___2 = 3722,
	A21_MARK___9 = 3723,
	KEYIN1_MARK___2 = 3724,
	MSIOF0_RSYNC_MARK___2 = 3725,
	A22_MARK___9 = 3726,
	KEYIN2_MARK___2 = 3727,
	MSIOF0_MCK0_MARK___2 = 3728,
	A23_MARK___9 = 3729,
	KEYIN3_MARK___2 = 3730,
	MSIOF0_MCK1_MARK___2 = 3731,
	A24_MARK___9 = 3732,
	KEYIN4_MARK___3 = 3733,
	MSIOF0_RXD_MARK___7 = 3734,
	A25_MARK___9 = 3735,
	KEYIN5_MARK___3 = 3736,
	MSIOF0_SS2_MARK___6 = 3737,
	A26_MARK___2 = 3738,
	KEYIN6_MARK___3 = 3739,
	KEYIN7_MARK___3 = 3740,
	D0_NAF0_MARK___2 = 3741,
	D1_NAF1_MARK___2 = 3742,
	D2_NAF2_MARK___2 = 3743,
	D3_NAF3_MARK___2 = 3744,
	D4_NAF4_MARK___2 = 3745,
	D5_NAF5_MARK___2 = 3746,
	D6_NAF6_MARK___2 = 3747,
	D7_NAF7_MARK___2 = 3748,
	D8_NAF8_MARK___2 = 3749,
	D9_NAF9_MARK___2 = 3750,
	D10_NAF10_MARK___2 = 3751,
	D11_NAF11_MARK___2 = 3752,
	D12_NAF12_MARK___2 = 3753,
	D13_NAF13_MARK___2 = 3754,
	D14_NAF14_MARK___2 = 3755,
	D15_NAF15_MARK___2 = 3756,
	CS4__MARK = 3757,
	CS5A__MARK = 3758,
	PORT91_RDWR_MARK = 3759,
	CS5B__MARK = 3760,
	FCE1__MARK = 3761,
	CS6B__MARK = 3762,
	DACK0_MARK___9 = 3763,
	FCE0__MARK = 3764,
	CS6A__MARK = 3765,
	WAIT__MARK = 3766,
	DREQ0_MARK___4 = 3767,
	RD__FSC_MARK = 3768,
	WE0__FWE_MARK = 3769,
	RDWR_FWE_MARK = 3770,
	WE1__MARK = 3771,
	FRB_MARK___3 = 3772,
	CKO_MARK___3 = 3773,
	NBRSTOUT__MARK = 3774,
	NBRST__MARK = 3775,
	BBIF2_TXD_MARK = 3776,
	BBIF2_RXD_MARK = 3777,
	BBIF2_SYNC_MARK = 3778,
	BBIF2_SCK_MARK = 3779,
	SCIFA3_CTS__MARK = 3780,
	MFG3_IN2_MARK = 3781,
	SCIFA3_RXD_MARK___3 = 3782,
	MFG3_IN1_MARK = 3783,
	BBIF1_SS2_MARK = 3784,
	SCIFA3_RTS__MARK = 3785,
	MFG3_OUT1_MARK = 3786,
	SCIFA3_TXD_MARK___3 = 3787,
	HSI_RX_DATA_MARK___2 = 3788,
	BBIF1_RXD_MARK___2 = 3789,
	HSI_TX_WAKE_MARK___2 = 3790,
	BBIF1_TSCK_MARK___2 = 3791,
	HSI_TX_DATA_MARK___2 = 3792,
	BBIF1_TSYNC_MARK___2 = 3793,
	HSI_TX_READY_MARK___2 = 3794,
	BBIF1_TXD_MARK___2 = 3795,
	HSI_RX_READY_MARK___2 = 3796,
	BBIF1_RSCK_MARK___2 = 3797,
	PORT115_I2C_SCL2_MARK = 3798,
	PORT115_I2C_SCL3_MARK = 3799,
	HSI_RX_WAKE_MARK___2 = 3800,
	BBIF1_RSYNC_MARK___2 = 3801,
	PORT116_I2C_SDA2_MARK = 3802,
	PORT116_I2C_SDA3_MARK = 3803,
	HSI_RX_FLAG_MARK___2 = 3804,
	BBIF1_SS1_MARK = 3805,
	BBIF1_FLOW_MARK___2 = 3806,
	HSI_TX_FLAG_MARK___2 = 3807,
	VIO_VD_MARK___2 = 3808,
	PORT128_LCD2VSYN_MARK = 3809,
	VIO2_VD_MARK = 3810,
	LCD2D0_MARK = 3811,
	VIO_HD_MARK___2 = 3812,
	PORT129_LCD2HSYN_MARK = 3813,
	PORT129_LCD2CS__MARK = 3814,
	VIO2_HD_MARK = 3815,
	LCD2D1_MARK = 3816,
	VIO_D0_MARK___2 = 3817,
	PORT130_MSIOF2_RXD_MARK = 3818,
	LCD2D10_MARK = 3819,
	VIO_D1_MARK___2 = 3820,
	PORT131_KEYOUT6_MARK = 3821,
	PORT131_MSIOF2_SS1_MARK = 3822,
	PORT131_KEYOUT11_MARK = 3823,
	LCD2D11_MARK = 3824,
	VIO_D2_MARK___2 = 3825,
	PORT132_KEYOUT7_MARK = 3826,
	PORT132_MSIOF2_SS2_MARK = 3827,
	PORT132_KEYOUT10_MARK = 3828,
	LCD2D12_MARK = 3829,
	VIO_D3_MARK___2 = 3830,
	MSIOF2_TSYNC_MARK___2 = 3831,
	LCD2D13_MARK = 3832,
	VIO_D4_MARK___2 = 3833,
	MSIOF2_TXD_MARK___6 = 3834,
	LCD2D14_MARK = 3835,
	VIO_D5_MARK___2 = 3836,
	MSIOF2_TSCK_MARK___2 = 3837,
	LCD2D15_MARK = 3838,
	VIO_D6_MARK___2 = 3839,
	PORT136_KEYOUT8_MARK = 3840,
	LCD2D16_MARK = 3841,
	VIO_D7_MARK___2 = 3842,
	PORT137_KEYOUT9_MARK = 3843,
	LCD2D17_MARK = 3844,
	VIO_D8_MARK___2 = 3845,
	PORT138_KEYOUT8_MARK = 3846,
	VIO2_D0_MARK = 3847,
	LCD2D6_MARK = 3848,
	VIO_D9_MARK___2 = 3849,
	PORT139_KEYOUT9_MARK = 3850,
	VIO2_D1_MARK = 3851,
	LCD2D7_MARK = 3852,
	VIO_D10_MARK = 3853,
	TPU0TO2_MARK___4 = 3854,
	VIO2_D2_MARK = 3855,
	LCD2D8_MARK = 3856,
	VIO_D11_MARK = 3857,
	TPU0TO3_MARK___5 = 3858,
	VIO2_D3_MARK = 3859,
	LCD2D9_MARK = 3860,
	VIO_D12_MARK = 3861,
	PORT142_KEYOUT10_MARK = 3862,
	VIO2_D4_MARK = 3863,
	LCD2D2_MARK = 3864,
	VIO_D13_MARK = 3865,
	PORT143_KEYOUT11_MARK = 3866,
	PORT143_KEYOUT6_MARK = 3867,
	VIO2_D5_MARK = 3868,
	LCD2D3_MARK = 3869,
	VIO_D14_MARK = 3870,
	PORT144_KEYOUT7_MARK = 3871,
	VIO2_D6_MARK = 3872,
	LCD2D4_MARK = 3873,
	VIO_D15_MARK = 3874,
	TPU1TO3_MARK = 3875,
	PORT145_LCD2DISP_MARK = 3876,
	PORT145_LCD2RS_MARK = 3877,
	VIO2_D7_MARK = 3878,
	LCD2D5_MARK = 3879,
	VIO_CLK_MARK___2 = 3880,
	LCD2DCK_MARK = 3881,
	PORT146_LCD2WR__MARK = 3882,
	VIO2_CLK_MARK = 3883,
	LCD2D18_MARK = 3884,
	VIO_FIELD_MARK = 3885,
	LCD2RD__MARK = 3886,
	VIO2_FIELD_MARK = 3887,
	LCD2D19_MARK = 3888,
	VIO_CKO_MARK___2 = 3889,
	A27_MARK = 3890,
	PORT149_RDWR_MARK = 3891,
	MFG0_IN1_MARK = 3892,
	PORT149_KEYOUT9_MARK = 3893,
	MFG0_IN2_MARK = 3894,
	TS_SPSYNC3_MARK = 3895,
	MSIOF2_RSCK_MARK___2 = 3896,
	TS_SDAT3_MARK = 3897,
	MSIOF2_RSYNC_MARK___2 = 3898,
	TPU1TO2_MARK = 3899,
	TS_SDEN3_MARK = 3900,
	PORT153_MSIOF2_SS1_MARK = 3901,
	SCIFA2_TXD1_MARK = 3902,
	MSIOF2_MCK0_MARK___2 = 3903,
	SCIFA2_RXD1_MARK = 3904,
	MSIOF2_MCK1_MARK___2 = 3905,
	SCIFA2_RTS1__MARK = 3906,
	PORT156_MSIOF2_SS2_MARK = 3907,
	SCIFA2_CTS1__MARK = 3908,
	PORT157_MSIOF2_RXD_MARK = 3909,
	DINT__MARK = 3910,
	SCIFA2_SCK1_MARK = 3911,
	TS_SCK3_MARK = 3912,
	PORT159_SCIFB_SCK_MARK = 3913,
	PORT159_SCIFA5_SCK_MARK = 3914,
	NMI_MARK = 3915,
	PORT160_SCIFB_TXD_MARK = 3916,
	PORT160_SCIFA5_TXD_MARK = 3917,
	PORT161_SCIFB_CTS__MARK = 3918,
	PORT161_SCIFA5_CTS__MARK = 3919,
	PORT162_SCIFB_RXD_MARK = 3920,
	PORT162_SCIFA5_RXD_MARK = 3921,
	PORT163_SCIFB_RTS__MARK = 3922,
	PORT163_SCIFA5_RTS__MARK = 3923,
	TPU3TO0_MARK = 3924,
	LCDD0_MARK___2 = 3925,
	LCDD1_MARK___2 = 3926,
	PORT193_SCIFA5_CTS__MARK = 3927,
	BBIF2_TSYNC1_MARK = 3928,
	LCDD2_MARK___2 = 3929,
	PORT194_SCIFA5_RTS__MARK = 3930,
	BBIF2_TSCK1_MARK = 3931,
	LCDD3_MARK___2 = 3932,
	PORT195_SCIFA5_RXD_MARK = 3933,
	BBIF2_TXD1_MARK = 3934,
	LCDD4_MARK___2 = 3935,
	PORT196_SCIFA5_TXD_MARK = 3936,
	LCDD5_MARK___2 = 3937,
	PORT197_SCIFA5_SCK_MARK = 3938,
	MFG2_OUT2_MARK = 3939,
	TPU2TO1_MARK = 3940,
	LCDD6_MARK___2 = 3941,
	LCDD7_MARK___2 = 3942,
	TPU4TO1_MARK = 3943,
	MFG4_OUT2_MARK = 3944,
	LCDD8_MARK___2 = 3945,
	D16_MARK___2 = 3946,
	LCDD9_MARK___2 = 3947,
	D17_MARK___2 = 3948,
	LCDD10_MARK___2 = 3949,
	D18_MARK___2 = 3950,
	LCDD11_MARK___2 = 3951,
	D19_MARK___2 = 3952,
	LCDD12_MARK___2 = 3953,
	D20_MARK___2 = 3954,
	LCDD13_MARK___2 = 3955,
	D21_MARK___2 = 3956,
	LCDD14_MARK___2 = 3957,
	D22_MARK___2 = 3958,
	LCDD15_MARK___2 = 3959,
	PORT207_MSIOF0L_SS1_MARK = 3960,
	D23_MARK___2 = 3961,
	LCDD16_MARK___2 = 3962,
	PORT208_MSIOF0L_SS2_MARK = 3963,
	D24_MARK___2 = 3964,
	LCDD17_MARK___2 = 3965,
	D25_MARK___2 = 3966,
	LCDD18_MARK___2 = 3967,
	DREQ2_MARK___3 = 3968,
	PORT210_MSIOF0L_SS1_MARK = 3969,
	D26_MARK___2 = 3970,
	LCDD19_MARK___2 = 3971,
	PORT211_MSIOF0L_SS2_MARK = 3972,
	D27_MARK___2 = 3973,
	LCDD20_MARK___2 = 3974,
	TS_SPSYNC1_MARK___3 = 3975,
	MSIOF0L_MCK0_MARK = 3976,
	D28_MARK___2 = 3977,
	LCDD21_MARK___2 = 3978,
	TS_SDAT1_MARK___3 = 3979,
	MSIOF0L_MCK1_MARK = 3980,
	D29_MARK___2 = 3981,
	LCDD22_MARK___2 = 3982,
	TS_SDEN1_MARK___3 = 3983,
	MSIOF0L_RSCK_MARK = 3984,
	D30_MARK___2 = 3985,
	LCDD23_MARK___2 = 3986,
	TS_SCK1_MARK___3 = 3987,
	MSIOF0L_RSYNC_MARK = 3988,
	D31_MARK___2 = 3989,
	LCDDCK_MARK___2 = 3990,
	LCDWR__MARK = 3991,
	LCDRD__MARK = 3992,
	DACK2_MARK___6 = 3993,
	PORT217_LCD2RS_MARK = 3994,
	MSIOF0L_TSYNC_MARK = 3995,
	VIO2_FIELD3_MARK = 3996,
	PORT217_LCD2DISP_MARK = 3997,
	LCDHSYN_MARK___2 = 3998,
	LCDCS__MARK = 3999,
	LCDCS2__MARK = 4000,
	DACK3_MARK = 4001,
	PORT218_VIO_CKOR_MARK = 4002,
	LCDDISP_MARK___2 = 4003,
	LCDRS_MARK___2 = 4004,
	PORT219_LCD2WR__MARK = 4005,
	DREQ3_MARK = 4006,
	MSIOF0L_TSCK_MARK = 4007,
	VIO2_CLK3_MARK = 4008,
	LCD2DCK_2_MARK = 4009,
	LCDVSYN_MARK___2 = 4010,
	LCDVSYN2_MARK = 4011,
	LCDLCLK_MARK___2 = 4012,
	DREQ1_MARK___4 = 4013,
	PORT221_LCD2CS__MARK = 4014,
	PWEN_MARK = 4015,
	MSIOF0L_RXD_MARK = 4016,
	VIO2_HD3_MARK = 4017,
	PORT221_LCD2HSYN_MARK = 4018,
	LCDDON_MARK___2 = 4019,
	LCDDON2_MARK = 4020,
	DACK1_MARK___8 = 4021,
	OVCN_MARK = 4022,
	MSIOF0L_TXD_MARK = 4023,
	VIO2_VD3_MARK = 4024,
	PORT222_LCD2VSYN_MARK = 4025,
	SCIFA1_TXD_MARK___6 = 4026,
	OVCN2_MARK = 4027,
	EXTLP_MARK = 4028,
	SCIFA1_SCK_MARK___6 = 4029,
	PORT226_VIO_CKO2_MARK = 4030,
	SCIFA1_RTS__MARK = 4031,
	IDIN_MARK = 4032,
	SCIFA1_RXD_MARK___6 = 4033,
	SCIFA1_CTS__MARK = 4034,
	MFG1_IN1_MARK = 4035,
	MSIOF1_TXD_MARK___6 = 4036,
	SCIFA2_TXD2_MARK = 4037,
	MSIOF1_TSYNC_MARK = 4038,
	SCIFA2_CTS2__MARK = 4039,
	MSIOF1_TSCK_MARK = 4040,
	SCIFA2_SCK2_MARK = 4041,
	MSIOF1_RXD_MARK___6 = 4042,
	SCIFA2_RXD2_MARK = 4043,
	MSIOF1_RSCK_MARK___2 = 4044,
	SCIFA2_RTS2__MARK = 4045,
	VIO2_CLK2_MARK = 4046,
	LCD2D20_MARK = 4047,
	MSIOF1_RSYNC_MARK___2 = 4048,
	MFG1_IN2_MARK = 4049,
	VIO2_VD2_MARK = 4050,
	LCD2D21_MARK = 4051,
	MSIOF1_MCK0_MARK___2 = 4052,
	PORT236_I2C_SDA2_MARK = 4053,
	MSIOF1_MCK1_MARK___2 = 4054,
	PORT237_I2C_SCL2_MARK = 4055,
	MSIOF1_SS1_MARK___5 = 4056,
	VIO2_FIELD2_MARK = 4057,
	LCD2D22_MARK = 4058,
	MSIOF1_SS2_MARK___5 = 4059,
	VIO2_HD2_MARK = 4060,
	LCD2D23_MARK = 4061,
	SCIFA6_TXD_MARK___2 = 4062,
	PORT241_IRDA_OUT_MARK = 4063,
	PORT241_IROUT_MARK = 4064,
	MFG4_OUT1_MARK = 4065,
	TPU4TO0_MARK = 4066,
	PORT242_IRDA_IN_MARK = 4067,
	MFG4_IN2_MARK = 4068,
	PORT243_IRDA_FIRSEL_MARK = 4069,
	PORT243_VIO_CKO2_MARK = 4070,
	PORT244_SCIFA5_CTS__MARK = 4071,
	MFG2_IN1_MARK = 4072,
	PORT244_SCIFB_CTS__MARK = 4073,
	MSIOF2R_RXD_MARK = 4074,
	PORT245_SCIFA5_RTS__MARK = 4075,
	MFG2_IN2_MARK = 4076,
	PORT245_SCIFB_RTS__MARK = 4077,
	MSIOF2R_TXD_MARK = 4078,
	PORT246_SCIFA5_RXD_MARK = 4079,
	MFG1_OUT1_MARK = 4080,
	PORT246_SCIFB_RXD_MARK = 4081,
	TPU1TO0_MARK___2 = 4082,
	PORT247_SCIFA5_TXD_MARK = 4083,
	MFG3_OUT2_MARK = 4084,
	PORT247_SCIFB_TXD_MARK = 4085,
	TPU3TO1_MARK = 4086,
	PORT248_SCIFA5_SCK_MARK = 4087,
	MFG2_OUT1_MARK = 4088,
	PORT248_SCIFB_SCK_MARK = 4089,
	TPU2TO0_MARK = 4090,
	PORT248_I2C_SCL3_MARK = 4091,
	MSIOF2R_TSCK_MARK = 4092,
	PORT249_IROUT_MARK = 4093,
	MFG4_IN1_MARK = 4094,
	PORT249_I2C_SDA3_MARK = 4095,
	MSIOF2R_TSYNC_MARK = 4096,
	SDHICLK0_MARK___2 = 4097,
	SDHICD0_MARK___2 = 4098,
	SDHID0_0_MARK___2 = 4099,
	SDHID0_1_MARK___2 = 4100,
	SDHID0_2_MARK___2 = 4101,
	SDHID0_3_MARK___2 = 4102,
	SDHICMD0_MARK___2 = 4103,
	SDHIWP0_MARK___2 = 4104,
	SDHICLK1_MARK___2 = 4105,
	SDHID1_0_MARK___2 = 4106,
	TS_SPSYNC2_MARK = 4107,
	SDHID1_1_MARK___2 = 4108,
	TS_SDAT2_MARK = 4109,
	SDHID1_2_MARK___2 = 4110,
	TS_SDEN2_MARK = 4111,
	SDHID1_3_MARK___2 = 4112,
	TS_SCK2_MARK = 4113,
	SDHICMD1_MARK___2 = 4114,
	SDHICLK2_MARK___2 = 4115,
	SDHID2_0_MARK___2 = 4116,
	TS_SPSYNC4_MARK = 4117,
	SDHID2_1_MARK___2 = 4118,
	TS_SDAT4_MARK = 4119,
	SDHID2_2_MARK___2 = 4120,
	TS_SDEN4_MARK = 4121,
	SDHID2_3_MARK___2 = 4122,
	TS_SCK4_MARK = 4123,
	SDHICMD2_MARK___2 = 4124,
	MMCCLK0_MARK___2 = 4125,
	MMCD0_0_MARK___2 = 4126,
	MMCD0_1_MARK___2 = 4127,
	MMCD0_2_MARK___2 = 4128,
	MMCD0_3_MARK___2 = 4129,
	MMCD0_4_MARK___2 = 4130,
	TS_SPSYNC5_MARK = 4131,
	MMCD0_5_MARK___2 = 4132,
	TS_SDAT5_MARK = 4133,
	MMCD0_6_MARK___2 = 4134,
	TS_SDEN5_MARK = 4135,
	MMCD0_7_MARK___2 = 4136,
	TS_SCK5_MARK = 4137,
	MMCCMD0_MARK___2 = 4138,
	RESETOUTS__MARK = 4139,
	EXTAL2OUT_MARK = 4140,
	MCP_WAIT__MCP_FRB_MARK = 4141,
	MCP_CKO_MARK = 4142,
	MMCCLK1_MARK___2 = 4143,
	MCP_D15_MCP_NAF15_MARK = 4144,
	MCP_D14_MCP_NAF14_MARK = 4145,
	MCP_D13_MCP_NAF13_MARK = 4146,
	MCP_D12_MCP_NAF12_MARK = 4147,
	MCP_D11_MCP_NAF11_MARK = 4148,
	MCP_D10_MCP_NAF10_MARK = 4149,
	MCP_D9_MCP_NAF9_MARK = 4150,
	MCP_D8_MCP_NAF8_MARK = 4151,
	MMCCMD1_MARK___2 = 4152,
	MCP_D7_MCP_NAF7_MARK = 4153,
	MMCD1_7_MARK___2 = 4154,
	MCP_D6_MCP_NAF6_MARK = 4155,
	MMCD1_6_MARK___2 = 4156,
	MCP_D5_MCP_NAF5_MARK = 4157,
	MMCD1_5_MARK___2 = 4158,
	MCP_D4_MCP_NAF4_MARK = 4159,
	MMCD1_4_MARK___2 = 4160,
	MCP_D3_MCP_NAF3_MARK = 4161,
	MMCD1_3_MARK___2 = 4162,
	MCP_D2_MCP_NAF2_MARK = 4163,
	MMCD1_2_MARK___2 = 4164,
	MCP_D1_MCP_NAF1_MARK = 4165,
	MMCD1_1_MARK___2 = 4166,
	MCP_D0_MCP_NAF0_MARK = 4167,
	MMCD1_0_MARK___2 = 4168,
	MCP_NBRSTOUT__MARK = 4169,
	MCP_WE0__MCP_FWE_MARK = 4170,
	MCP_RDWR_MCP_FWE_MARK = 4171,
	TSIF2_TS_XX1_MARK = 4172,
	TSIF2_TS_XX2_MARK = 4173,
	TSIF2_TS_XX3_MARK = 4174,
	TSIF2_TS_XX4_MARK = 4175,
	TSIF2_TS_XX5_MARK = 4176,
	TSIF1_TS_XX1_MARK = 4177,
	TSIF1_TS_XX2_MARK = 4178,
	TSIF1_TS_XX3_MARK = 4179,
	TSIF1_TS_XX4_MARK = 4180,
	TSIF1_TS_XX5_MARK = 4181,
	TSIF0_TS_XX1_MARK = 4182,
	TSIF0_TS_XX2_MARK = 4183,
	TSIF0_TS_XX3_MARK = 4184,
	TSIF0_TS_XX4_MARK = 4185,
	TSIF0_TS_XX5_MARK = 4186,
	MST1_TS_XX1_MARK = 4187,
	MST1_TS_XX2_MARK = 4188,
	MST1_TS_XX3_MARK = 4189,
	MST1_TS_XX4_MARK = 4190,
	MST1_TS_XX5_MARK = 4191,
	MST0_TS_XX1_MARK = 4192,
	MST0_TS_XX2_MARK = 4193,
	MST0_TS_XX3_MARK = 4194,
	MST0_TS_XX4_MARK = 4195,
	MST0_TS_XX5_MARK = 4196,
	SDHI0_VCCQ_MC0_ON_MARK = 4197,
	SDHI0_VCCQ_MC0_OFF_MARK = 4198,
	DEBUG_MON_VIO_MARK = 4199,
	DEBUG_MON_LCDD_MARK = 4200,
	LCDC_LCDC0_MARK = 4201,
	LCDC_LCDC1_MARK = 4202,
	IRQ9_MEM_INT_MARK = 4203,
	IRQ9_MCP_INT_MARK = 4204,
	A11_MARK___8 = 4205,
	KEYOUT8_MARK___2 = 4206,
	TPU4TO3_MARK = 4207,
	RESETA_N_PU_ON_MARK = 4208,
	RESETA_N_PU_OFF_MARK = 4209,
	EDBGREQ_PD_MARK = 4210,
	EDBGREQ_PU_MARK = 4211,
	PINMUX_MARK_END___11 = 4212,
};

enum {
	PORT_LAST___2 = 309,
	PIN_A11 = 310,
};

struct rza2_pinctrl_priv {
	struct device *dev;
	void *base;
	struct pinctrl_pin_desc *pins;
	struct pinctrl_desc desc;
	struct pinctrl_dev *pctl;
	struct pinctrl_gpio_range gpio_range;
	int npins;
};

enum pincfg_type {
	PINCFG_TYPE_FUNC = 0,
	PINCFG_TYPE_DAT = 1,
	PINCFG_TYPE_PUD = 2,
	PINCFG_TYPE_DRV = 3,
	PINCFG_TYPE_CON_PDN = 4,
	PINCFG_TYPE_PUD_PDN = 5,
	PINCFG_TYPE_NUM = 6,
};

enum eint_type {
	EINT_TYPE_NONE = 0,
	EINT_TYPE_GPIO = 1,
	EINT_TYPE_WKUP = 2,
	EINT_TYPE_WKUP_MUX = 3,
};

struct samsung_pin_bank_type {
	u8 fld_width[6];
	u8 reg_offset[6];
};

struct samsung_pin_bank_data {
	const struct samsung_pin_bank_type *type;
	u32 pctl_offset;
	u8 pctl_res_idx;
	u8 nr_pins;
	u8 eint_func;
	enum eint_type eint_type;
	u32 eint_mask;
	u32 eint_offset;
	const char *name;
};

struct samsung_pinctrl_drv_data;

struct exynos_irq_chip;

struct samsung_pin_bank {
	const struct samsung_pin_bank_type *type;
	void *pctl_base;
	u32 pctl_offset;
	u8 nr_pins;
	void *eint_base;
	u8 eint_func;
	enum eint_type eint_type;
	u32 eint_mask;
	u32 eint_offset;
	const char *name;
	u32 pin_base;
	void *soc_priv;
	struct device_node *of_node;
	struct samsung_pinctrl_drv_data *drvdata;
	struct irq_domain *irq_domain;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range grange;
	struct exynos_irq_chip *irq_chip;
	spinlock_t slock;
	u32 pm_save[7];
};

struct samsung_pin_group;

struct samsung_pmx_func;

struct samsung_retention_ctrl;

struct samsung_pinctrl_drv_data {
	struct list_head node;
	void *virt_base;
	struct device *dev;
	int irq;
	struct pinctrl_desc pctl;
	struct pinctrl_dev *pctl_dev;
	const struct samsung_pin_group *pin_groups;
	unsigned int nr_groups;
	const struct samsung_pmx_func *pmx_functions;
	unsigned int nr_functions;
	struct samsung_pin_bank *pin_banks;
	unsigned int nr_banks;
	unsigned int pin_base;
	unsigned int nr_pins;
	struct samsung_retention_ctrl *retention_ctrl;
	void (*suspend)(struct samsung_pinctrl_drv_data *);
	void (*resume)(struct samsung_pinctrl_drv_data *);
};

struct samsung_retention_ctrl {
	const u32 *regs;
	int nr_regs;
	u32 value;
	atomic_t *refcnt;
	void *priv;
	void (*enable)(struct samsung_pinctrl_drv_data *);
	void (*disable)(struct samsung_pinctrl_drv_data *);
};

struct samsung_retention_data {
	const u32 *regs;
	int nr_regs;
	u32 value;
	atomic_t *refcnt;
	struct samsung_retention_ctrl * (*init)(struct samsung_pinctrl_drv_data *, const struct samsung_retention_data *);
};

struct samsung_pin_ctrl {
	const struct samsung_pin_bank_data *pin_banks;
	unsigned int nr_banks;
	unsigned int nr_ext_resources;
	const struct samsung_retention_data *retention_data;
	int (*eint_gpio_init)(struct samsung_pinctrl_drv_data *);
	int (*eint_wkup_init)(struct samsung_pinctrl_drv_data *);
	void (*suspend)(struct samsung_pinctrl_drv_data *);
	void (*resume)(struct samsung_pinctrl_drv_data *);
};

struct samsung_pin_group {
	const char *name;
	const unsigned int *pins;
	u8 num_pins;
	u8 func;
};

struct samsung_pmx_func {
	const char *name;
	const char **groups;
	u8 num_groups;
	u32 val;
};

struct samsung_pinctrl_of_match_data {
	const struct samsung_pin_ctrl *ctrl;
	unsigned int num_ctrl;
};

struct pin_config {
	const char *property;
	enum pincfg_type param;
};

struct exynos_irq_chip {
	struct irq_chip chip;
	u32 eint_con;
	u32 eint_mask;
	u32 eint_pend;
	u32 *eint_wake_mask_value;
	u32 eint_wake_mask_reg;
	void (*set_eint_wakeup_mask)(struct samsung_pinctrl_drv_data *, struct exynos_irq_chip *);
};

struct exynos_weint_data {
	unsigned int irq;
	struct samsung_pin_bank *bank;
};

struct exynos_muxed_weint_data {
	unsigned int nr_banks;
	struct samsung_pin_bank *banks[0];
};

struct exynos_eint_gpio_save {
	u32 eint_con;
	u32 eint_fltcon0;
	u32 eint_fltcon1;
	u32 eint_mask;
};

struct plgpio_regs {
	u32 enb;
	u32 wdata;
	u32 dir;
	u32 rdata;
	u32 ie;
	u32 mis;
	u32 eit;
};

struct plgpio {
	spinlock_t lock;
	void *base;
	struct clk *clk;
	struct gpio_chip chip;
	int (*p2o)(int);
	int (*o2p)(int);
	u32 p2o_regs;
	struct plgpio_regs regs;
	struct plgpio_regs *csave_regs;
};

struct spear_pmx_mode {
	const char * const name;
	u16 mode;
	u16 reg;
	u16 mask;
	u32 val;
};

struct spear_muxreg {
	u16 reg;
	u32 mask;
	u32 val;
};

struct spear_gpio_pingroup {
	const unsigned int *pins;
	unsigned int npins;
	struct spear_muxreg *muxregs;
	u8 nmuxregs;
};

struct spear_modemux {
	u16 modes;
	u8 nmuxregs;
	struct spear_muxreg *muxregs;
};

struct spear_pingroup {
	const char *name;
	const unsigned int *pins;
	unsigned int npins;
	struct spear_modemux *modemuxs;
	unsigned int nmodemuxs;
};

struct spear_function {
	const char *name;
	const char * const *groups;
	unsigned int ngroups;
};

struct spear_pmx;

struct spear_pinctrl_machdata {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	struct spear_function **functions;
	unsigned int nfunctions;
	struct spear_pingroup **groups;
	unsigned int ngroups;
	struct spear_gpio_pingroup *gpio_pingroups;
	void (*gpio_request_endisable)(struct spear_pmx *, int, bool);
	unsigned int ngpio_pingroups;
	bool modes_supported;
	u16 mode;
	struct spear_pmx_mode **pmx_modes;
	unsigned int npmx_modes;
};

struct spear_pmx {
	struct device *dev;
	struct pinctrl_dev *pctl;
	struct spear_pinctrl_machdata *machdata;
	void *vbase;
};

struct stm32_desc_function {
	const char *name;
	const unsigned char num;
};

struct stm32_desc_pin {
	struct pinctrl_pin_desc pin;
	const struct stm32_desc_function *functions;
	const unsigned int pkg;
};

struct stm32_pinctrl_match_data {
	const struct stm32_desc_pin *pins;
	const unsigned int npins;
};

struct stm32_pinctrl_group {
	const char *name;
	long unsigned int config;
	unsigned int pin;
};

struct stm32_gpio_bank {
	void *base;
	struct clk *clk;
	struct reset_control *rstc;
	spinlock_t lock;
	struct gpio_chip gpio_chip;
	struct pinctrl_gpio_range range;
	struct fwnode_handle *fwnode;
	struct irq_domain *domain;
	u32 bank_nr;
	u32 bank_ioport_nr;
	u32 pin_backup[16];
	u8 irq_type[16];
};

struct stm32_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl_dev;
	struct pinctrl_desc pctl_desc;
	struct stm32_pinctrl_group *groups;
	unsigned int ngroups;
	const char **grp_names;
	struct stm32_gpio_bank *banks;
	unsigned int nbanks;
	const struct stm32_pinctrl_match_data *match_data;
	struct irq_domain *domain;
	struct regmap *regmap;
	struct regmap_field *irqmux[16];
	struct hwspinlock *hwlock;
	struct stm32_desc_pin *pins;
	u32 npins;
	u32 pkg;
	u16 irqmux_map;
	spinlock_t irqmux_lock;
};

enum sunxi_desc_bias_voltage {
	BIAS_VOLTAGE_NONE = 0,
	BIAS_VOLTAGE_GRP_CONFIG = 1,
	BIAS_VOLTAGE_PIO_POW_MODE_SEL = 2,
};

struct sunxi_desc_function {
	long unsigned int variant;
	const char *name;
	u8 muxval;
	u8 irqbank;
	u8 irqnum;
};

struct sunxi_desc_pin {
	struct pinctrl_pin_desc pin;
	long unsigned int variant;
	struct sunxi_desc_function *functions;
};

struct sunxi_pinctrl_desc {
	const struct sunxi_desc_pin *pins;
	int npins;
	unsigned int pin_base;
	unsigned int irq_banks;
	const unsigned int *irq_bank_map;
	bool irq_read_needs_mux;
	bool disable_strict_mode;
	enum sunxi_desc_bias_voltage io_bias_cfg_variant;
};

struct sunxi_pinctrl_function {
	const char *name;
	const char **groups;
	unsigned int ngroups;
};

struct sunxi_pinctrl_group {
	const char *name;
	unsigned int pin;
};

struct sunxi_pinctrl_regulator {
	struct regulator *regulator;
	refcount_t refcount;
};

struct sunxi_pinctrl {
	void *membase;
	struct gpio_chip *chip;
	const struct sunxi_pinctrl_desc *desc;
	struct device *dev;
	struct sunxi_pinctrl_regulator regulators[9];
	struct irq_domain *domain;
	struct sunxi_pinctrl_function *functions;
	unsigned int nfunctions;
	struct sunxi_pinctrl_group *groups;
	unsigned int ngroups;
	int *irq;
	unsigned int *irq_array;
	raw_spinlock_t lock;
	struct pinctrl_dev *pctl_dev;
	long unsigned int variant;
};

struct ti_iodelay_reg_data {
	u32 signature_mask;
	u32 signature_value;
	u32 lock_mask;
	u32 lock_val;
	u32 unlock_val;
	u32 binary_data_coarse_mask;
	u32 binary_data_fine_mask;
	u32 reg_refclk_offset;
	u32 refclk_period_mask;
	u32 reg_coarse_offset;
	u32 coarse_delay_count_mask;
	u32 coarse_ref_count_mask;
	u32 reg_fine_offset;
	u32 fine_delay_count_mask;
	u32 fine_ref_count_mask;
	u32 reg_global_lock_offset;
	u32 global_lock_mask;
	u32 global_unlock_val;
	u32 global_lock_val;
	u32 reg_start_offset;
	u32 reg_nr_per_pin;
	struct regmap_config *regmap_config;
};

struct ti_iodelay_reg_values {
	u16 coarse_ref_count;
	u16 coarse_delay_count;
	u16 fine_ref_count;
	u16 fine_delay_count;
	u16 ref_clk_period;
	u32 cdpe;
	u32 fdpe;
};

struct ti_iodelay_cfg {
	u16 offset;
	u16 a_delay;
	u16 g_delay;
};

struct ti_iodelay_pingroup {
	struct ti_iodelay_cfg *cfg;
	int ncfg;
	long unsigned int config;
};

struct ti_iodelay_device {
	struct device *dev;
	long unsigned int phys_base;
	void *reg_base;
	struct regmap *regmap;
	struct pinctrl_dev *pctl;
	struct pinctrl_desc desc;
	struct pinctrl_pin_desc *pa;
	const struct ti_iodelay_reg_data *reg_data;
	struct ti_iodelay_reg_values reg_init_conf_values;
};

enum uniphier_pin_drv_type {
	UNIPHIER_PIN_DRV_1BIT = 0,
	UNIPHIER_PIN_DRV_2BIT = 1,
	UNIPHIER_PIN_DRV_3BIT = 2,
	UNIPHIER_PIN_DRV_FIXED4 = 3,
	UNIPHIER_PIN_DRV_FIXED5 = 4,
	UNIPHIER_PIN_DRV_FIXED8 = 5,
	UNIPHIER_PIN_DRV_NONE = 6,
};

enum uniphier_pin_pull_dir {
	UNIPHIER_PIN_PULL_UP = 0,
	UNIPHIER_PIN_PULL_DOWN = 1,
	UNIPHIER_PIN_PULL_UP_FIXED = 2,
	UNIPHIER_PIN_PULL_DOWN_FIXED = 3,
	UNIPHIER_PIN_PULL_NONE = 4,
};

struct uniphier_pinctrl_group {
	const char *name;
	const unsigned int *pins;
	unsigned int num_pins;
	const int *muxvals;
};

struct uniphier_pinmux_function {
	const char *name;
	const char * const *groups;
	unsigned int num_groups;
};

struct uniphier_pinctrl_socdata {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct uniphier_pinctrl_group *groups;
	int groups_count;
	const struct uniphier_pinmux_function *functions;
	int functions_count;
	int (*get_gpio_muxval)(unsigned int, unsigned int);
	unsigned int caps;
};

struct uniphier_pinctrl_reg_region {
	struct list_head node;
	unsigned int base;
	unsigned int nregs;
	u32 vals[0];
};

struct uniphier_pinctrl_priv {
	struct pinctrl_desc pctldesc;
	struct pinctrl_dev *pctldev;
	struct regmap *regmap;
	const struct uniphier_pinctrl_socdata *socdata;
	struct list_head reg_regions;
};

struct mtk_eint_regs {
	unsigned int stat;
	unsigned int ack;
	unsigned int mask;
	unsigned int mask_set;
	unsigned int mask_clr;
	unsigned int sens;
	unsigned int sens_set;
	unsigned int sens_clr;
	unsigned int soft;
	unsigned int soft_set;
	unsigned int soft_clr;
	unsigned int pol;
	unsigned int pol_set;
	unsigned int pol_clr;
	unsigned int dom_en;
	unsigned int dbnc_ctrl;
	unsigned int dbnc_set;
	unsigned int dbnc_clr;
};

struct mtk_eint_hw {
	u8 port_mask;
	u8 ports;
	unsigned int ap_num;
	unsigned int db_cnt;
};

struct mtk_eint_xt {
	int (*get_gpio_n)(void *, long unsigned int, unsigned int *, struct gpio_chip **);
	int (*get_gpio_state)(void *, long unsigned int);
	int (*set_gpio_as_eint)(void *, long unsigned int);
};

struct mtk_eint {
	struct device *dev;
	void *base;
	struct irq_domain *domain;
	int irq;
	int *dual_edge;
	u32 *wake_mask;
	u32 *cur_mask;
	const struct mtk_eint_hw *hw;
	const struct mtk_eint_regs *regs;
	void *pctl;
	const struct mtk_eint_xt *gpio_xlate;
};

struct mtk_desc_function {
	const char *name;
	unsigned char muxval;
};

struct mtk_desc_eint {
	unsigned char eintmux;
	unsigned char eintnum;
};

struct mtk_desc_pin {
	struct pinctrl_pin_desc pin;
	const struct mtk_desc_eint eint;
	const struct mtk_desc_function *functions;
};

struct mtk_pinctrl_group {
	const char *name;
	long unsigned int config;
	unsigned int pin;
};

struct mtk_drv_group_desc {
	unsigned char min_drv;
	unsigned char max_drv;
	unsigned char low_bit;
	unsigned char high_bit;
	unsigned char step;
};

struct mtk_pin_drv_grp {
	short unsigned int pin;
	short unsigned int offset;
	unsigned char bit;
	unsigned char grp;
};

struct mtk_pin_spec_pupd_set_samereg {
	short unsigned int pin;
	short unsigned int offset;
	unsigned char pupd_bit;
	unsigned char r1_bit;
	unsigned char r0_bit;
};

struct mtk_pin_ies_smt_set {
	short unsigned int start;
	short unsigned int end;
	short unsigned int offset;
	unsigned char bit;
};

struct mtk_pinctrl_devdata {
	const struct mtk_desc_pin *pins;
	unsigned int npins;
	const struct mtk_drv_group_desc *grp_desc;
	unsigned int n_grp_cls;
	const struct mtk_pin_drv_grp *pin_drv_grp;
	unsigned int n_pin_drv_grps;
	int (*spec_pull_set)(struct regmap *, unsigned int, unsigned char, bool, unsigned int);
	int (*spec_ies_smt_set)(struct regmap *, unsigned int, unsigned char, int, enum pin_config_param);
	void (*spec_pinmux_set)(struct regmap *, unsigned int, unsigned int);
	void (*spec_dir_set)(unsigned int *, unsigned int);
	unsigned int dir_offset;
	unsigned int ies_offset;
	unsigned int smt_offset;
	unsigned int pullen_offset;
	unsigned int pullsel_offset;
	unsigned int drv_offset;
	unsigned int dout_offset;
	unsigned int din_offset;
	unsigned int pinmux_offset;
	short unsigned int type1_start;
	short unsigned int type1_end;
	unsigned char port_shf;
	unsigned char port_mask;
	unsigned char port_align;
	struct mtk_eint_hw eint_hw;
	struct mtk_eint_regs *eint_regs;
};

struct mtk_pinctrl {
	struct regmap *regmap1;
	struct regmap *regmap2;
	struct pinctrl_desc pctl_desc;
	struct device *dev;
	struct gpio_chip *chip;
	struct mtk_pinctrl_group *groups;
	unsigned int ngroups;
	const char **grp_names;
	struct pinctrl_dev *pctl_dev;
	const struct mtk_pinctrl_devdata *devdata;
	struct mtk_eint *eint;
};

enum {
	PINCTRL_PIN_REG_MODE = 0,
	PINCTRL_PIN_REG_DIR = 1,
	PINCTRL_PIN_REG_DI = 2,
	PINCTRL_PIN_REG_DO = 3,
	PINCTRL_PIN_REG_SR = 4,
	PINCTRL_PIN_REG_SMT = 5,
	PINCTRL_PIN_REG_PD = 6,
	PINCTRL_PIN_REG_PU = 7,
	PINCTRL_PIN_REG_E4 = 8,
	PINCTRL_PIN_REG_E8 = 9,
	PINCTRL_PIN_REG_TDSEL = 10,
	PINCTRL_PIN_REG_RDSEL = 11,
	PINCTRL_PIN_REG_DRV = 12,
	PINCTRL_PIN_REG_PUPD = 13,
	PINCTRL_PIN_REG_R0 = 14,
	PINCTRL_PIN_REG_R1 = 15,
	PINCTRL_PIN_REG_IES = 16,
	PINCTRL_PIN_REG_PULLEN = 17,
	PINCTRL_PIN_REG_PULLSEL = 18,
	PINCTRL_PIN_REG_DRV_EN = 19,
	PINCTRL_PIN_REG_DRV_E0 = 20,
	PINCTRL_PIN_REG_DRV_E1 = 21,
	PINCTRL_PIN_REG_MAX = 22,
};

enum {
	DRV_FIXED = 0,
	DRV_GRP0 = 1,
	DRV_GRP1 = 2,
	DRV_GRP2 = 3,
	DRV_GRP3 = 4,
	DRV_GRP4 = 5,
	DRV_GRP_MAX = 6,
};

struct mtk_pin_field {
	u8 index;
	u32 offset;
	u32 mask;
	u8 bitpos;
	u8 next;
};

struct mtk_pin_field_calc {
	u16 s_pin;
	u16 e_pin;
	u8 i_base;
	u32 s_addr;
	u8 x_addrs;
	u8 s_bit;
	u8 x_bits;
	u8 sz_reg;
	u8 fixed;
};

struct mtk_pin_reg_calc {
	const struct mtk_pin_field_calc *range;
	unsigned int nranges;
};

struct mtk_func_desc {
	const char *name;
	u8 muxval;
};

struct mtk_eint_desc {
	u16 eint_m;
	u16 eint_n;
};

struct mtk_pin_desc {
	unsigned int number;
	const char *name;
	struct mtk_eint_desc eint;
	u8 drv_n;
	struct mtk_func_desc *funcs;
};

struct mtk_pinctrl___2;

struct mtk_pin_soc {
	const struct mtk_pin_reg_calc *reg_cal;
	const struct mtk_pin_desc *pins;
	unsigned int npins;
	const struct group_desc *grps;
	unsigned int ngrps;
	const struct function_desc *funcs;
	unsigned int nfuncs;
	const struct mtk_eint_regs *eint_regs;
	const struct mtk_eint_hw *eint_hw;
	u8 gpio_m;
	bool ies_present;
	const char * const *base_names;
	unsigned int nbase_names;
	int (*bias_disable_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *);
	int (*bias_disable_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, int *);
	int (*bias_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool);
	int (*bias_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool, int *);
	int (*bias_set_combo)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32, u32);
	int (*bias_get_combo)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32 *, u32 *);
	int (*drive_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32);
	int (*drive_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, int *);
	int (*adv_pull_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool, u32);
	int (*adv_pull_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, bool, u32 *);
	int (*adv_drive_set)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32);
	int (*adv_drive_get)(struct mtk_pinctrl___2 *, const struct mtk_pin_desc *, u32 *);
	void *driver_data;
};

struct mtk_pinctrl___2 {
	struct pinctrl_dev *pctrl;
	void **base;
	u8 nbase;
	struct device *dev;
	struct gpio_chip chip;
	const struct mtk_pin_soc *soc;
	struct mtk_eint *eint;
	struct mtk_pinctrl_group *groups;
	const char **grp_names;
};

struct mtk_drive_desc {
	u8 min;
	u8 max;
	u8 step;
	u8 scal;
};

struct mtk_spec_pinmux_set {
	short unsigned int pin;
	short unsigned int offset;
	unsigned char bit;
};

struct mtk_spec_pull_set {
	unsigned char pin;
	unsigned char pupd_bit;
	short unsigned int pupd_offset;
	short unsigned int r0_offset;
	short unsigned int r1_offset;
	unsigned char r0_bit;
	unsigned char r1_bit;
};

struct gpio_pin_range {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_gpio_range range;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc *desc[0];
};

struct gpio_array {
	struct gpio_desc **desc;
	unsigned int size;
	struct gpio_chip *chip;
	long unsigned int *get_mask;
	long unsigned int *set_mask;
	long unsigned int invert_mask[0];
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	long unsigned int lflags;
	int dflags;
};

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct acpi_device;

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	unsigned int debounce;
	unsigned int quirks;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

struct devres;

struct of_reconfig_data {
	struct device_node *dn;
	struct property *prop;
	struct property *old_prop;
};

enum of_reconfig_change {
	OF_RECONFIG_NO_CHANGE = 0,
	OF_RECONFIG_CHANGE_ADD = 1,
	OF_RECONFIG_CHANGE_REMOVE = 2,
};

enum of_gpio_flags {
	OF_GPIO_ACTIVE_LOW = 1,
	OF_GPIO_SINGLE_ENDED = 2,
	OF_GPIO_OPEN_DRAIN = 4,
	OF_GPIO_TRANSITORY = 8,
	OF_GPIO_PULL_UP = 16,
	OF_GPIO_PULL_DOWN = 32,
};

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME = 2048,
};

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

struct gpioline_info {
	__u32 line_offset;
	__u32 flags;
	char name[32];
	char consumer[32];
};

struct gpioline_info_changed {
	struct gpioline_info info;
	__u64 timestamp;
	__u32 event_type;
	__u32 padding[5];
};

struct gpiohandle_request {
	__u32 lineoffsets[64];
	__u32 flags;
	__u8 default_values[64];
	char consumer_label[32];
	__u32 lines;
	int fd;
};

struct gpiohandle_config {
	__u32 flags;
	__u8 default_values[64];
	__u32 padding[4];
};

struct gpiohandle_data {
	__u8 values[64];
};

struct gpioevent_request {
	__u32 lineoffset;
	__u32 handleflags;
	__u32 eventflags;
	char consumer_label[32];
	int fd;
};

struct gpioevent_data {
	__u64 timestamp;
	__u32 id;
	int: 32;
};

struct linehandle_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *descs[64];
	u32 num_descs;
};

struct linereq;

struct line {
	struct gpio_desc *desc;
	struct linereq *req;
	unsigned int irq;
	int: 32;
	u64 eflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
	int: 32;
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	u32 event_buffer_size;
	int: 32;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		int: 32;
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct lineevent_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *desc;
	u32 eflags;
	int irq;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpioevent_data *type;
			const struct gpioevent_data *const_type;
			char (*rectype)[0];
			struct gpioevent_data *ptr;
			const struct gpioevent_data *ptr_const;
		};
		int: 32;
		struct gpioevent_data buf[16];
	} events;
	u64 timestamp;
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		int: 32;
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	long unsigned int *watched_lines;
	atomic_t watch_abi_version;
	int: 32;
};

struct bgpio_pdata {
	const char *label;
	int base;
	int ngpio;
};

struct aspeed_sgpio {
	struct gpio_chip chip;
	struct clk *pclk;
	spinlock_t lock;
	void *base;
	int irq;
	int n_sgpio;
};

struct aspeed_sgpio_bank {
	uint16_t val_regs;
	uint16_t rdata_reg;
	uint16_t irq_regs;
	const char names[12];
};

enum aspeed_sgpio_reg {
	reg_val = 0,
	reg_rdata = 1,
	reg_irq_enable = 2,
	reg_irq_type0 = 3,
	reg_irq_type1 = 4,
	reg_irq_type2 = 5,
	reg_irq_status = 6,
};

struct bcm_kona_gpio_bank;

struct bcm_kona_gpio {
	void *reg_base;
	int num_bank;
	raw_spinlock_t lock;
	struct gpio_chip gpio_chip;
	struct irq_domain *irq_domain;
	struct bcm_kona_gpio_bank *banks;
	struct platform_device *pdev;
};

struct bcm_kona_gpio_bank {
	int id;
	int irq;
	struct bcm_kona_gpio *kona_gpio;
};

struct iproc_gpio_chip {
	struct irq_chip irqchip;
	struct gpio_chip gc;
	spinlock_t lock;
	struct device *dev;
	void *base;
	void *intr;
};

enum gio_reg_index {
	GIO_REG_ODEN = 0,
	GIO_REG_DATA = 1,
	GIO_REG_IODIR = 2,
	GIO_REG_EC = 3,
	GIO_REG_EI = 4,
	GIO_REG_MASK = 5,
	GIO_REG_LEVEL = 6,
	GIO_REG_STAT = 7,
	NUMBER_OF_GIO_REGISTERS = 8,
};

struct brcmstb_gpio_priv;

struct brcmstb_gpio_bank {
	struct list_head node;
	int id;
	struct gpio_chip gc;
	struct brcmstb_gpio_priv *parent_priv;
	u32 width;
	u32 wake_active;
	u32 saved_regs[7];
};

struct brcmstb_gpio_priv {
	struct list_head bank_list;
	void *reg_base;
	struct platform_device *pdev;
	struct irq_domain *irq_domain;
	struct irq_chip irq_chip;
	int parent_irq;
	int gpio_base;
	int num_gpios;
	int parent_wake_irq;
};

struct davinci_gpio_platform_data {
	bool no_auto_base;
	u32 base;
	u32 ngpio;
	u32 gpio_unbanked;
};

struct davinci_gpio_regs {
	u32 dir;
	u32 out_data;
	u32 set_data;
	u32 clr_data;
	u32 in_data;
	u32 set_rising;
	u32 clr_rising;
	u32 set_falling;
	u32 clr_falling;
	u32 intstat;
};

typedef struct irq_chip * (*gpio_get_irq_chip_cb_t)(unsigned int);

struct davinci_gpio_controller;

struct davinci_gpio_irq_data {
	void *regs;
	struct davinci_gpio_controller *chip;
	int bank_num;
};

struct davinci_gpio_controller {
	struct gpio_chip chip;
	struct irq_domain *irq_domain;
	spinlock_t lock;
	void *regs[5];
	int gpio_unbanked;
	int irqs[32];
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct dwapb_port_property {
	struct fwnode_handle *fwnode;
	unsigned int idx;
	unsigned int ngpio;
	unsigned int gpio_base;
	int irq[32];
	bool irq_shared;
};

struct dwapb_platform_data {
	struct dwapb_port_property *properties;
	unsigned int nports;
};

struct dwapb_context {
	u32 data;
	u32 dir;
	u32 ext;
	u32 int_en;
	u32 int_mask;
	u32 int_type;
	u32 int_pol;
	u32 int_deb;
	u32 wake_en;
};

struct dwapb_gpio_port_irqchip {
	struct irq_chip irqchip;
	unsigned int nr_irqs;
	unsigned int irq[32];
};

struct dwapb_gpio;

struct dwapb_gpio_port {
	struct gpio_chip gc;
	struct dwapb_gpio_port_irqchip *pirq;
	struct dwapb_gpio *gpio;
	struct dwapb_context *ctx;
	unsigned int idx;
};

struct dwapb_gpio {
	struct device *dev;
	void *regs;
	struct dwapb_gpio_port *ports;
	unsigned int nr_ports;
	unsigned int flags;
	struct reset_control *rst;
	struct clk_bulk_data clks[2];
};

struct em_gio_priv {
	void *base0;
	void *base1;
	spinlock_t sense_lock;
	struct platform_device *pdev;
	struct gpio_chip gpio_chip;
	struct irq_chip irq_chip;
	struct irq_domain *irq_domain;
};

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
	int: 32;
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	long unsigned int flags;
	unsigned int hwpwm;
	unsigned int pwm;
	struct pwm_chip *chip;
	void *chip_data;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device *dev;
	const struct pwm_ops *ops;
	int base;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	unsigned int of_pwm_n_cells;
	struct list_head list;
	struct pwm_device *pwms;
};

struct pwm_capture;

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	void (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
	struct module *owner;
	int (*config)(struct pwm_chip *, struct pwm_device *, int, int);
	int (*set_polarity)(struct pwm_chip *, struct pwm_device *, enum pwm_polarity);
	int (*enable)(struct pwm_chip *, struct pwm_device *);
	void (*disable)(struct pwm_chip *, struct pwm_device *);
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

struct mvebu_gpio_chip;

struct mvebu_pwm {
	struct regmap *regs;
	long unsigned int clk_rate;
	struct gpio_desc *gpiod;
	struct pwm_chip chip;
	spinlock_t lock;
	struct mvebu_gpio_chip *mvchip;
	u32 blink_select;
	u32 blink_on_duration;
	u32 blink_off_duration;
};

struct mvebu_gpio_chip {
	struct gpio_chip chip;
	struct regmap *regs;
	u32 offset;
	struct regmap *percpu_regs;
	int irqbase;
	struct irq_domain *domain;
	int soc_variant;
	struct clk *clk;
	struct mvebu_pwm *mvpwm;
	u32 out_reg;
	u32 io_conf_reg;
	u32 blink_en_reg;
	u32 in_pol_reg;
	u32 edge_mask_regs[4];
	u32 level_mask_regs[4];
};

struct mxc_gpio_hwdata {
	unsigned int dr_reg;
	unsigned int gdir_reg;
	unsigned int psr_reg;
	unsigned int icr1_reg;
	unsigned int icr2_reg;
	unsigned int imr_reg;
	unsigned int isr_reg;
	int edge_sel_reg;
	unsigned int low_level;
	unsigned int high_level;
	unsigned int rise_edge;
	unsigned int fall_edge;
};

struct mxc_gpio_reg_saved {
	u32 icr1;
	u32 icr2;
	u32 imr;
	u32 gdir;
	u32 edge_sel;
	u32 dr;
};

struct mxc_gpio_port {
	struct list_head node;
	void *base;
	struct clk *clk;
	int irq;
	int irq_high;
	struct irq_domain *domain;
	struct gpio_chip gc;
	struct device *dev;
	u32 both_edges;
	struct mxc_gpio_reg_saved gpio_saved_reg;
	bool power_off;
	const struct mxc_gpio_hwdata *hwdata;
};

struct omap_gpio_reg_offs {
	u16 revision;
	u16 direction;
	u16 datain;
	u16 dataout;
	u16 set_dataout;
	u16 clr_dataout;
	u16 irqstatus;
	u16 irqstatus2;
	u16 irqstatus_raw0;
	u16 irqstatus_raw1;
	u16 irqenable;
	u16 irqenable2;
	u16 set_irqenable;
	u16 clr_irqenable;
	u16 debounce;
	u16 debounce_en;
	u16 ctrl;
	u16 wkup_en;
	u16 leveldetect0;
	u16 leveldetect1;
	u16 risingdetect;
	u16 fallingdetect;
	u16 irqctrl;
	u16 edgectrl1;
	u16 edgectrl2;
	u16 pinctrl;
	bool irqenable_inv;
};

struct omap_gpio_platform_data {
	int bank_type;
	int bank_width;
	int bank_stride;
	bool dbck_flag;
	bool loses_context;
	bool is_mpuio;
	u32 non_wakeup_gpios;
	const struct omap_gpio_reg_offs *regs;
	int (*get_context_loss_count)(struct device *);
};

struct gpio_regs {
	u32 irqenable1;
	u32 irqenable2;
	u32 wake_en;
	u32 ctrl;
	u32 oe;
	u32 leveldetect0;
	u32 leveldetect1;
	u32 risingdetect;
	u32 fallingdetect;
	u32 dataout;
	u32 debounce;
	u32 debounce_en;
};

struct gpio_bank {
	void *base;
	const struct omap_gpio_reg_offs *regs;
	int irq;
	u32 non_wakeup_gpios;
	u32 enabled_non_wakeup_gpios;
	struct gpio_regs context;
	u32 saved_datain;
	u32 level_mask;
	u32 toggle_mask;
	raw_spinlock_t lock;
	raw_spinlock_t wa_lock;
	struct gpio_chip chip;
	struct clk *dbck;
	struct notifier_block nb;
	unsigned int is_suspended: 1;
	unsigned int needs_resume: 1;
	u32 mod_usage;
	u32 irq_usage;
	u32 dbck_enable_mask;
	bool dbck_enabled;
	bool is_mpuio;
	bool dbck_flag;
	bool loses_context;
	bool context_valid;
	int stride;
	u32 width;
	int context_loss_count;
	void (*set_dataout)(struct gpio_bank *, unsigned int, int);
	int (*get_context_loss_count)(struct device *);
};

struct palmas_adc_wakeup_property {
	int adc_channel_number;
	int adc_high_threshold;
	int adc_low_threshold;
};

struct palmas_gpadc_platform_data {
	int ch3_current;
	int ch0_current;
	bool extended_delay;
	int bat_removal;
	int start_polarity;
	int auto_conversion_period_ms;
	struct palmas_adc_wakeup_property *adc_wakeup1_data;
	struct palmas_adc_wakeup_property *adc_wakeup2_data;
};

struct palmas_usb_platform_data {
	int wakeup;
};

struct palmas_resource_platform_data {
	int regen1_mode_sleep;
	int regen2_mode_sleep;
	int sysen1_mode_sleep;
	int sysen2_mode_sleep;
	u8 nsleep_res;
	u8 nsleep_smps;
	u8 nsleep_ldo1;
	u8 nsleep_ldo2;
	u8 enable1_res;
	u8 enable1_smps;
	u8 enable1_ldo1;
	u8 enable1_ldo2;
	u8 enable2_res;
	u8 enable2_smps;
	u8 enable2_ldo1;
	u8 enable2_ldo2;
};

struct palmas_clk_platform_data {
	int clk32kg_mode_sleep;
	int clk32kgaudio_mode_sleep;
};

struct palmas_platform_data {
	int irq_flags;
	int gpio_base;
	u8 power_ctrl;
	int mux_from_pdata;
	u8 pad1;
	u8 pad2;
	bool pm_off;
	struct palmas_pmic_platform_data *pmic_pdata;
	struct palmas_gpadc_platform_data *gpadc_pdata;
	struct palmas_usb_platform_data *usb_pdata;
	struct palmas_resource_platform_data *resource_pdata;
	struct palmas_clk_platform_data *clk_pdata;
};

enum palmas_irqs {
	PALMAS_CHARG_DET_N_VBUS_OVV_IRQ = 0,
	PALMAS_PWRON_IRQ = 1,
	PALMAS_LONG_PRESS_KEY_IRQ = 2,
	PALMAS_RPWRON_IRQ = 3,
	PALMAS_PWRDOWN_IRQ = 4,
	PALMAS_HOTDIE_IRQ = 5,
	PALMAS_VSYS_MON_IRQ = 6,
	PALMAS_VBAT_MON_IRQ = 7,
	PALMAS_RTC_ALARM_IRQ = 8,
	PALMAS_RTC_TIMER_IRQ = 9,
	PALMAS_WDT_IRQ = 10,
	PALMAS_BATREMOVAL_IRQ = 11,
	PALMAS_RESET_IN_IRQ = 12,
	PALMAS_FBI_BB_IRQ = 13,
	PALMAS_SHORT_IRQ = 14,
	PALMAS_VAC_ACOK_IRQ = 15,
	PALMAS_GPADC_AUTO_0_IRQ = 16,
	PALMAS_GPADC_AUTO_1_IRQ = 17,
	PALMAS_GPADC_EOC_SW_IRQ = 18,
	PALMAS_GPADC_EOC_RT_IRQ = 19,
	PALMAS_ID_OTG_IRQ = 20,
	PALMAS_ID_IRQ = 21,
	PALMAS_VBUS_OTG_IRQ = 22,
	PALMAS_VBUS_IRQ = 23,
	PALMAS_GPIO_0_IRQ = 24,
	PALMAS_GPIO_1_IRQ = 25,
	PALMAS_GPIO_2_IRQ = 26,
	PALMAS_GPIO_3_IRQ = 27,
	PALMAS_GPIO_4_IRQ = 28,
	PALMAS_GPIO_5_IRQ = 29,
	PALMAS_GPIO_6_IRQ = 30,
	PALMAS_GPIO_7_IRQ = 31,
	PALMAS_NUM_IRQ = 32,
};

struct palmas_gpio {
	struct gpio_chip gpio_chip;
	struct palmas *palmas;
};

struct palmas_device_data {
	int ngpio;
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);
	int (*probe_new)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct property_entry *properties;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct pca953x_platform_data {
	unsigned int gpio_base;
	u32 invert;
	int irq_base;
	void *context;
	int (*setup)(struct i2c_client *, unsigned int, unsigned int, void *);
	int (*teardown)(struct i2c_client *, unsigned int, unsigned int, void *);
	const char * const *names;
};

struct pca953x_reg_config {
	int direction;
	int output;
	int input;
	int invert;
};

struct pca953x_chip {
	unsigned int gpio_start;
	struct mutex i2c_lock;
	struct regmap *regmap;
	struct mutex irq_lock;
	long unsigned int irq_mask[2];
	long unsigned int irq_stat[2];
	long unsigned int irq_trig_raise[2];
	long unsigned int irq_trig_fall[2];
	struct irq_chip irq_chip;
	atomic_t wakeup_path;
	struct i2c_client *client;
	struct gpio_chip gpio_chip;
	const char * const *names;
	long unsigned int driver_data;
	struct regulator *regulator;
	const struct pca953x_reg_config *regs;
};

struct pcf857x_platform_data {
	unsigned int gpio_base;
	unsigned int n_latch;
	int (*setup)(struct i2c_client *, int, unsigned int, void *);
	int (*teardown)(struct i2c_client *, int, unsigned int, void *);
	void *context;
};

struct pcf857x {
	struct gpio_chip chip;
	struct irq_chip irqchip;
	struct i2c_client *client;
	struct mutex lock;
	unsigned int out;
	unsigned int status;
	unsigned int irq_enabled;
	int (*write)(struct i2c_client *, unsigned int);
	int (*read)(struct i2c_client *);
};

struct amba_id {
	unsigned int id;
	unsigned int mask;
	void *data;
};

struct amba_cs_uci_id {
	unsigned int devarch;
	unsigned int devarch_mask;
	unsigned int devtype;
	void *data;
};

struct amba_device {
	struct device dev;
	struct resource res;
	struct clk *pclk;
	struct device_dma_parameters dma_parms;
	unsigned int periphid;
	unsigned int cid;
	struct amba_cs_uci_id uci;
	unsigned int irq[9];
	char *driver_override;
	int: 32;
};

struct amba_driver {
	struct device_driver drv;
	int (*probe)(struct amba_device *, const struct amba_id *);
	int (*remove)(struct amba_device *);
	void (*shutdown)(struct amba_device *);
	const struct amba_id *id_table;
};

struct pl061_context_save_regs {
	u8 gpio_data;
	u8 gpio_dir;
	u8 gpio_is;
	u8 gpio_ibe;
	u8 gpio_iev;
	u8 gpio_ie;
};

struct pl061 {
	raw_spinlock_t lock;
	void *base;
	struct gpio_chip gc;
	struct irq_chip irq_chip;
	int parent_irq;
	struct pl061_context_save_regs csave_regs;
};

struct pxa_gpio_platform_data {
	int irq_base;
	int (*gpio_set_wake)(unsigned int, unsigned int);
};

struct pxa_gpio_bank {
	void *regbase;
	long unsigned int irq_mask;
	long unsigned int irq_edge_rise;
	long unsigned int irq_edge_fall;
	long unsigned int saved_gplr;
	long unsigned int saved_gpdr;
	long unsigned int saved_grer;
	long unsigned int saved_gfer;
};

struct pxa_gpio_chip {
	struct device *dev;
	struct gpio_chip chip;
	struct pxa_gpio_bank *banks;
	struct irq_domain *irqdomain;
	int irq0;
	int irq1;
	int (*set_wake)(unsigned int, unsigned int);
};

enum pxa_gpio_type {
	PXA25X_GPIO = 0,
	PXA26X_GPIO = 1,
	PXA27X_GPIO = 2,
	PXA3XX_GPIO = 3,
	PXA93X_GPIO = 4,
	MMP_GPIO = 16,
	MMP2_GPIO = 17,
	PXA1928_GPIO = 18,
};

struct pxa_gpio_id {
	enum pxa_gpio_type type;
	int gpio_nums;
};

enum rpi_firmware_property_tag {
	RPI_FIRMWARE_PROPERTY_END = 0,
	RPI_FIRMWARE_GET_FIRMWARE_REVISION = 1,
	RPI_FIRMWARE_SET_CURSOR_INFO = 32784,
	RPI_FIRMWARE_SET_CURSOR_STATE = 32785,
	RPI_FIRMWARE_GET_BOARD_MODEL = 65537,
	RPI_FIRMWARE_GET_BOARD_REVISION = 65538,
	RPI_FIRMWARE_GET_BOARD_MAC_ADDRESS = 65539,
	RPI_FIRMWARE_GET_BOARD_SERIAL = 65540,
	RPI_FIRMWARE_GET_ARM_MEMORY = 65541,
	RPI_FIRMWARE_GET_VC_MEMORY = 65542,
	RPI_FIRMWARE_GET_CLOCKS = 65543,
	RPI_FIRMWARE_GET_POWER_STATE = 131073,
	RPI_FIRMWARE_GET_TIMING = 131074,
	RPI_FIRMWARE_SET_POWER_STATE = 163841,
	RPI_FIRMWARE_GET_CLOCK_STATE = 196609,
	RPI_FIRMWARE_GET_CLOCK_RATE = 196610,
	RPI_FIRMWARE_GET_VOLTAGE = 196611,
	RPI_FIRMWARE_GET_MAX_CLOCK_RATE = 196612,
	RPI_FIRMWARE_GET_MAX_VOLTAGE = 196613,
	RPI_FIRMWARE_GET_TEMPERATURE = 196614,
	RPI_FIRMWARE_GET_MIN_CLOCK_RATE = 196615,
	RPI_FIRMWARE_GET_MIN_VOLTAGE = 196616,
	RPI_FIRMWARE_GET_TURBO = 196617,
	RPI_FIRMWARE_GET_MAX_TEMPERATURE = 196618,
	RPI_FIRMWARE_GET_STC = 196619,
	RPI_FIRMWARE_ALLOCATE_MEMORY = 196620,
	RPI_FIRMWARE_LOCK_MEMORY = 196621,
	RPI_FIRMWARE_UNLOCK_MEMORY = 196622,
	RPI_FIRMWARE_RELEASE_MEMORY = 196623,
	RPI_FIRMWARE_EXECUTE_CODE = 196624,
	RPI_FIRMWARE_EXECUTE_QPU = 196625,
	RPI_FIRMWARE_SET_ENABLE_QPU = 196626,
	RPI_FIRMWARE_GET_DISPMANX_RESOURCE_MEM_HANDLE = 196628,
	RPI_FIRMWARE_GET_EDID_BLOCK = 196640,
	RPI_FIRMWARE_GET_CUSTOMER_OTP = 196641,
	RPI_FIRMWARE_GET_DOMAIN_STATE = 196656,
	RPI_FIRMWARE_GET_THROTTLED = 196678,
	RPI_FIRMWARE_GET_CLOCK_MEASURED = 196679,
	RPI_FIRMWARE_NOTIFY_REBOOT = 196680,
	RPI_FIRMWARE_SET_CLOCK_STATE = 229377,
	RPI_FIRMWARE_SET_CLOCK_RATE = 229378,
	RPI_FIRMWARE_SET_VOLTAGE = 229379,
	RPI_FIRMWARE_SET_TURBO = 229385,
	RPI_FIRMWARE_SET_CUSTOMER_OTP = 229409,
	RPI_FIRMWARE_SET_DOMAIN_STATE = 229424,
	RPI_FIRMWARE_GET_GPIO_STATE = 196673,
	RPI_FIRMWARE_SET_GPIO_STATE = 229441,
	RPI_FIRMWARE_SET_SDHOST_CLOCK = 229442,
	RPI_FIRMWARE_GET_GPIO_CONFIG = 196675,
	RPI_FIRMWARE_SET_GPIO_CONFIG = 229443,
	RPI_FIRMWARE_GET_PERIPH_REG = 196677,
	RPI_FIRMWARE_SET_PERIPH_REG = 229445,
	RPI_FIRMWARE_GET_POE_HAT_VAL = 196681,
	RPI_FIRMWARE_SET_POE_HAT_VAL = 196688,
	RPI_FIRMWARE_NOTIFY_XHCI_RESET = 196696,
	RPI_FIRMWARE_FRAMEBUFFER_ALLOCATE = 262145,
	RPI_FIRMWARE_FRAMEBUFFER_BLANK = 262146,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PHYSICAL_WIDTH_HEIGHT = 262147,
	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_WIDTH_HEIGHT = 262148,
	RPI_FIRMWARE_FRAMEBUFFER_GET_DEPTH = 262149,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PIXEL_ORDER = 262150,
	RPI_FIRMWARE_FRAMEBUFFER_GET_ALPHA_MODE = 262151,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PITCH = 262152,
	RPI_FIRMWARE_FRAMEBUFFER_GET_VIRTUAL_OFFSET = 262153,
	RPI_FIRMWARE_FRAMEBUFFER_GET_OVERSCAN = 262154,
	RPI_FIRMWARE_FRAMEBUFFER_GET_PALETTE = 262155,
	RPI_FIRMWARE_FRAMEBUFFER_GET_TOUCHBUF = 262159,
	RPI_FIRMWARE_FRAMEBUFFER_GET_GPIOVIRTBUF = 262160,
	RPI_FIRMWARE_FRAMEBUFFER_RELEASE = 294913,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PHYSICAL_WIDTH_HEIGHT = 278531,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_WIDTH_HEIGHT = 278532,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_DEPTH = 278533,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PIXEL_ORDER = 278534,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_ALPHA_MODE = 278535,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VIRTUAL_OFFSET = 278537,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_OVERSCAN = 278538,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_PALETTE = 278539,
	RPI_FIRMWARE_FRAMEBUFFER_TEST_VSYNC = 278542,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PHYSICAL_WIDTH_HEIGHT = 294915,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_WIDTH_HEIGHT = 294916,
	RPI_FIRMWARE_FRAMEBUFFER_SET_DEPTH = 294917,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PIXEL_ORDER = 294918,
	RPI_FIRMWARE_FRAMEBUFFER_SET_ALPHA_MODE = 294919,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VIRTUAL_OFFSET = 294921,
	RPI_FIRMWARE_FRAMEBUFFER_SET_OVERSCAN = 294922,
	RPI_FIRMWARE_FRAMEBUFFER_SET_PALETTE = 294923,
	RPI_FIRMWARE_FRAMEBUFFER_SET_TOUCHBUF = 294943,
	RPI_FIRMWARE_FRAMEBUFFER_SET_GPIOVIRTBUF = 294944,
	RPI_FIRMWARE_FRAMEBUFFER_SET_VSYNC = 294926,
	RPI_FIRMWARE_FRAMEBUFFER_SET_BACKLIGHT = 294927,
	RPI_FIRMWARE_VCHIQ_INIT = 294928,
	RPI_FIRMWARE_GET_COMMAND_LINE = 327681,
	RPI_FIRMWARE_GET_DMA_CHANNELS = 393217,
};

struct rpi_firmware;

struct rpi_exp_gpio {
	struct gpio_chip gc;
	struct rpi_firmware *fw;
};

struct gpio_set_config {
	u32 gpio;
	u32 direction;
	u32 polarity;
	u32 term_en;
	u32 term_pull_up;
	u32 state;
};

struct gpio_get_config {
	u32 gpio;
	u32 direction;
	u32 polarity;
	u32 term_en;
	u32 term_pull_up;
};

struct gpio_get_set_state {
	u32 gpio;
	u32 state;
};

struct gpio_rcar_bank_info {
	u32 iointsel;
	u32 inoutsel;
	u32 outdt;
	u32 posneg;
	u32 edglevel;
	u32 bothedge;
	u32 intmsk;
};

struct gpio_rcar_info {
	bool has_outdtsel;
	bool has_both_edge_trigger;
};

struct gpio_rcar_priv {
	void *base;
	spinlock_t lock;
	struct device *dev;
	struct gpio_chip gpio_chip;
	struct irq_chip irq_chip;
	unsigned int irq_parent;
	atomic_t wakeup_path;
	struct gpio_rcar_info info;
	struct gpio_rcar_bank_info bank_info;
};

struct spear_spics {
	void *base;
	u32 perip_cfg;
	u32 sw_enable_bit;
	u32 cs_value_bit;
	u32 cs_enable_mask;
	u32 cs_enable_shift;
	long unsigned int use_count;
	int last_off;
	struct gpio_chip chip;
};

struct syscon_gpio_data {
	const char *compatible;
	unsigned int flags;
	unsigned int bit_count;
	unsigned int dat_bit_offset;
	unsigned int dir_bit_offset;
	void (*set)(struct gpio_chip *, unsigned int, int);
};

struct syscon_gpio_priv {
	struct gpio_chip chip;
	struct regmap *syscon;
	const struct syscon_gpio_data *data;
	u32 dreg_offset;
	u32 dir_reg_offset;
};

struct tegra_gpio_info;

struct tegra_gpio_bank {
	unsigned int bank;
	unsigned int irq;
	raw_spinlock_t lvl_lock[4];
	spinlock_t dbc_lock[4];
	u32 cnf[4];
	u32 out[4];
	u32 oe[4];
	u32 int_enb[4];
	u32 int_lvl[4];
	u32 wake_enb[4];
	u32 dbc_enb[4];
	u32 dbc_cnt[4];
	struct tegra_gpio_info *tgi;
};

struct tegra_gpio_soc_config;

struct tegra_gpio_info {
	struct device *dev;
	void *regs;
	struct irq_domain *irq_domain;
	struct tegra_gpio_bank *bank_info;
	const struct tegra_gpio_soc_config *soc;
	struct gpio_chip gc;
	struct irq_chip ic;
	u32 bank_count;
};

struct tegra_gpio_soc_config {
	bool debounce_supported;
	u32 bank_stride;
	u32 upper_offset;
};

enum {
	TPS6586X_ID_SYS = 0,
	TPS6586X_ID_SM_0 = 1,
	TPS6586X_ID_SM_1 = 2,
	TPS6586X_ID_SM_2 = 3,
	TPS6586X_ID_LDO_0 = 4,
	TPS6586X_ID_LDO_1 = 5,
	TPS6586X_ID_LDO_2 = 6,
	TPS6586X_ID_LDO_3 = 7,
	TPS6586X_ID_LDO_4 = 8,
	TPS6586X_ID_LDO_5 = 9,
	TPS6586X_ID_LDO_6 = 10,
	TPS6586X_ID_LDO_7 = 11,
	TPS6586X_ID_LDO_8 = 12,
	TPS6586X_ID_LDO_9 = 13,
	TPS6586X_ID_LDO_RTC = 14,
	TPS6586X_ID_MAX_REGULATOR = 15,
};

enum {
	TPS6586X_INT_PLDO_0 = 0,
	TPS6586X_INT_PLDO_1 = 1,
	TPS6586X_INT_PLDO_2 = 2,
	TPS6586X_INT_PLDO_3 = 3,
	TPS6586X_INT_PLDO_4 = 4,
	TPS6586X_INT_PLDO_5 = 5,
	TPS6586X_INT_PLDO_6 = 6,
	TPS6586X_INT_PLDO_7 = 7,
	TPS6586X_INT_COMP_DET = 8,
	TPS6586X_INT_ADC = 9,
	TPS6586X_INT_PLDO_8 = 10,
	TPS6586X_INT_PLDO_9 = 11,
	TPS6586X_INT_PSM_0 = 12,
	TPS6586X_INT_PSM_1 = 13,
	TPS6586X_INT_PSM_2 = 14,
	TPS6586X_INT_PSM_3 = 15,
	TPS6586X_INT_RTC_ALM1 = 16,
	TPS6586X_INT_ACUSB_OVP = 17,
	TPS6586X_INT_USB_DET = 18,
	TPS6586X_INT_AC_DET = 19,
	TPS6586X_INT_BAT_DET = 20,
	TPS6586X_INT_CHG_STAT = 21,
	TPS6586X_INT_CHG_TEMP = 22,
	TPS6586X_INT_PP = 23,
	TPS6586X_INT_RESUME = 24,
	TPS6586X_INT_LOW_SYS = 25,
	TPS6586X_INT_RTC_ALM2 = 26,
};

struct tps6586x_subdev_info {
	int id;
	const char *name;
	void *platform_data;
	struct device_node *of_node;
};

struct tps6586x_platform_data {
	int num_subdevs;
	struct tps6586x_subdev_info *subdevs;
	int gpio_base;
	int irq_base;
	bool pm_off;
	struct regulator_init_data *reg_init_data[15];
};

struct tps6586x_gpio {
	struct gpio_chip gpio_chip;
	struct device *parent;
};

struct tps65910_sleep_keepon_data {
	unsigned int therm_keepon: 1;
	unsigned int clkout32k_keepon: 1;
	unsigned int i2chs_keepon: 1;
};

struct tps65910_board {
	int gpio_base;
	int irq;
	int irq_base;
	int vmbch_threshold;
	int vmbch2_threshold;
	bool en_ck32k_xtal;
	bool en_dev_slp;
	bool pm_off;
	struct tps65910_sleep_keepon_data slp_keepon;
	bool en_gpio_sleep[9];
	long unsigned int regulator_ext_sleep_control[14];
	struct regulator_init_data *tps65910_pmic_init_data[14];
};

struct tps65910 {
	struct device *dev;
	struct i2c_client *i2c_client;
	struct regmap *regmap;
	long unsigned int id;
	struct tps65910_board *of_plat_data;
	int chip_irq;
	struct regmap_irq_chip_data *irq_data;
};

struct tps65910_gpio {
	struct gpio_chip gpio_chip;
	struct tps65910 *tps65910;
};

enum twl4030_module_ids {
	TWL4030_MODULE_AUDIO_VOICE = 9,
	TWL4030_MODULE_GPIO = 10,
	TWL4030_MODULE_INTBR = 11,
	TWL4030_MODULE_TEST = 12,
	TWL4030_MODULE_KEYPAD = 13,
	TWL4030_MODULE_MADC = 14,
	TWL4030_MODULE_INTERRUPTS = 15,
	TWL4030_MODULE_PRECHARGE = 16,
	TWL4030_MODULE_BACKUP = 17,
	TWL4030_MODULE_INT = 18,
	TWL5031_MODULE_ACCESSORY = 19,
	TWL5031_MODULE_INTERRUPTS = 20,
	TWL4030_MODULE_LAST = 21,
};

struct gpio_twl4030_priv {
	struct gpio_chip gpio_chip;
	struct mutex mutex;
	int irq_base;
	unsigned int usage_count;
	unsigned int direction;
	unsigned int out_state;
};

struct uniphier_gpio_priv {
	struct gpio_chip chip;
	struct irq_chip irq_chip;
	struct irq_domain *domain;
	void *regs;
	spinlock_t lock;
	u32 saved_vals[0];
};

struct fsl_gpio_soc_data {
	bool have_paddr;
};

struct vf610_gpio_port {
	struct gpio_chip gc;
	struct irq_chip ic;
	void *base;
	void *gpio_base;
	const struct fsl_gpio_soc_data *sdata;
	u8 irqc[32];
	struct clk *clk_port;
	struct clk *clk_gpio;
	int irq;
};

struct xgpio_instance {
	struct gpio_chip gc;
	void *regs;
	unsigned int gpio_width[2];
	u32 gpio_state[2];
	u32 gpio_dir[2];
	spinlock_t gpio_lock[2];
	struct clk *clk;
};

struct gpio_regs___2 {
	u32 datamsw[6];
	u32 datalsw[6];
	u32 dirm[6];
	u32 outen[6];
	u32 int_en[6];
	u32 int_dis[6];
	u32 int_type[6];
	u32 int_polarity[6];
	u32 int_any[6];
};

struct zynq_platform_data;

struct zynq_gpio {
	struct gpio_chip chip;
	void *base_addr;
	struct clk *clk;
	int irq;
	const struct zynq_platform_data *p_data;
	struct gpio_regs___2 context;
	spinlock_t dirlock;
};

struct zynq_platform_data {
	const char *label;
	u32 quirks;
	u16 ngpio;
	int max_bank;
	int bank_min[6];
	int bank_max[6];
};

enum {
	PWMF_REQUESTED = 1,
	PWMF_EXPORTED = 2,
};

struct pwm_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
	unsigned int period;
	enum pwm_polarity polarity;
	const char *module;
};

struct trace_event_raw_pwm {
	struct trace_entry ent;
	struct pwm_device *pwm;
	int: 32;
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	char __data[0];
};

struct trace_event_data_offsets_pwm {};

typedef void (*btf_trace_pwm_apply)(void *, struct pwm_device *, const struct pwm_state *);

typedef void (*btf_trace_pwm_get)(void *, struct pwm_device *, const struct pwm_state *);

struct pwm_export {
	struct device child;
	struct pwm_device *pwm;
	struct mutex lock;
	struct pwm_state suspend;
};

struct iproc_pwmc {
	struct pwm_chip chip;
	void *base;
	struct clk *clk;
};

struct kona_pwmc {
	struct pwm_chip chip;
	void *base;
	struct clk *clk;
};

struct bcm2835_pwm {
	struct pwm_chip chip;
	struct device *dev;
	void *base;
	struct clk *clk;
};

enum tpu_pin_state {
	TPU_PIN_INACTIVE = 0,
	TPU_PIN_PWM = 1,
	TPU_PIN_ACTIVE = 2,
};

struct tpu_device;

struct tpu_pwm_device {
	bool timer_on;
	struct tpu_device *tpu;
	unsigned int channel;
	enum pwm_polarity polarity;
	unsigned int prescaler;
	u16 period;
	u16 duty;
};

struct tpu_device {
	struct platform_device *pdev;
	struct pwm_chip chip;
	spinlock_t lock;
	void *base;
	struct clk *clk;
};

enum {
	PWMCLK_PRESCALE_LOW = 0,
	PWMCLK_PRESCALE_HIGH = 1,
	CPTCLK_PRESCALE = 2,
	PWM_OUT_EN = 3,
	PWM_CPT_EN = 4,
	PWM_CPT_INT_EN = 5,
	PWM_CPT_INT_STAT = 6,
	MAX_REGFIELDS = 7,
};

enum sti_cpt_edge {
	CPT_EDGE_DISABLED = 0,
	CPT_EDGE_RISING = 1,
	CPT_EDGE_FALLING = 2,
	CPT_EDGE_BOTH = 3,
};

struct sti_cpt_ddata {
	u32 snapshot[3];
	unsigned int index;
	struct mutex lock;
	wait_queue_head_t wait;
};

struct sti_pwm_compat_data {
	const struct reg_field *reg_fields;
	unsigned int pwm_num_devs;
	unsigned int cpt_num_devs;
	unsigned int max_pwm_cnt;
	unsigned int max_prescale;
};

struct sti_pwm_chip {
	struct device *dev;
	struct clk *pwm_clk;
	struct clk *cpt_clk;
	struct regmap *regmap;
	struct sti_pwm_compat_data *cdata;
	struct regmap_field *prescale_low;
	struct regmap_field *prescale_high;
	struct regmap_field *pwm_out_en;
	struct regmap_field *pwm_cpt_en;
	struct regmap_field *pwm_cpt_int_en;
	struct regmap_field *pwm_cpt_int_stat;
	struct pwm_chip chip;
	struct pwm_device *cur;
	long unsigned int configured;
	unsigned int en_count;
	struct mutex sti_pwm_lock;
	void *mmio;
};

struct sun4i_pwm_data {
	bool has_prescaler_bypass;
	bool has_direct_mod_clk_output;
	unsigned int npwm;
};

struct sun4i_pwm_chip {
	struct pwm_chip chip;
	struct clk *bus_clk;
	struct clk *clk;
	struct reset_control *rst;
	void *base;
	spinlock_t ctrl_lock;
	const struct sun4i_pwm_data *data;
	long unsigned int next_period[2];
};

struct tegra_pwm_soc {
	unsigned int num_channels;
	long unsigned int max_frequency;
};

struct tegra_pwm_chip {
	struct pwm_chip chip;
	struct device *dev;
	struct clk *clk;
	struct reset_control *rst;
	long unsigned int clk_rate;
	long unsigned int min_period_ns;
	void *regs;
	const struct tegra_pwm_soc *soc;
};

struct vt8500_chip {
	struct pwm_chip chip;
	void *base;
	struct clk *clk;
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

struct rcec_ea {
	u8 nextbusn;
	u8 lastbusn;
	u32 bitmap;
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

typedef u32 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, int);
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_platform_pm_ops {
	bool (*bridge_d3)(struct pci_dev *);
	bool (*is_manageable)(struct pci_dev *);
	int (*set_state)(struct pci_dev *, pci_power_t);
	pci_power_t (*get_state)(struct pci_dev *);
	void (*refresh_state)(struct pci_dev *);
	pci_power_t (*choose_state)(struct pci_dev *);
	int (*set_wakeup)(struct pci_dev *, bool);
	bool (*need_resume)(struct pci_dev *);
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct pcie_device {
	int irq;
	struct pci_dev *port;
	u32 service;
	void *priv_data;
	struct device device;
};

struct pcie_port_service_driver {
	const char *name;
	int (*probe)(struct pcie_device *);
	void (*remove)(struct pcie_device *);
	int (*suspend)(struct pcie_device *);
	int (*resume_noirq)(struct pcie_device *);
	int (*resume)(struct pcie_device *);
	int (*runtime_suspend)(struct pcie_device *);
	int (*runtime_resume)(struct pcie_device *);
	void (*error_resume)(struct pci_dev *);
	int port_type;
	u32 service;
	struct device_driver driver;
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

struct pci_vpd_ops;

struct pci_vpd {
	const struct pci_vpd_ops *ops;
	struct bin_attribute *attr;
	struct mutex lock;
	unsigned int len;
	u16 flag;
	u8 cap;
	unsigned int busy: 1;
	unsigned int valid: 1;
};

struct pci_vpd_ops {
	ssize_t (*read)(struct pci_dev *, loff_t, size_t, void *);
	ssize_t (*write)(struct pci_dev *, loff_t, size_t, const void *);
	int (*set_size)(struct pci_dev *, size_t);
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum enable_type {
	undefined = 4294967295,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct portdrv_service_data {
	struct pcie_port_service_driver *drv;
	struct device *dev;
	u32 service;
};

typedef int (*pcie_pm_callback_t)(struct pcie_device *);

struct walk_rcec_data {
	struct pci_dev *rcec;
	int (*user_callback)(struct pci_dev *, void *);
	void *user_data;
};

struct aspm_latency {
	u32 l0s;
	u32 l1;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	char: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
	struct aspm_latency latency_up;
	struct aspm_latency latency_dw;
	struct aspm_latency acceptable[8];
};

struct pcie_pme_service_data {
	spinlock_t lock;
	struct pcie_device *srv;
	struct work_struct work;
	bool noirq;
};

struct pci_filp_private {
	enum pci_mmap_state mmap_state;
	int write_combine;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct of_bus;

struct of_pci_range_parser {
	struct device_node *node;
	struct of_bus *bus;
	const __be32 *range;
	const __be32 *end;
	int na;
	int ns;
	int pna;
	bool dma;
};

struct of_pci_range {
	union {
		u64 pci_addr;
		u64 bus_addr;
	};
	u64 cpu_addr;
	u64 size;
	u32 flags;
	int: 32;
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CAP_CSS_NVM = 1,
	NVME_CAP_CSS_CSI = 64,
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
	NVME_CMBMSC_CRE = 1,
	NVME_CMBMSC_CMSE = 2,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
};

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, int);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct pci_bridge_emul_conf {
	__le16 vendor;
	__le16 device;
	__le16 command;
	__le16 status;
	__le32 class_revision;
	u8 cache_line_size;
	u8 latency_timer;
	u8 header_type;
	u8 bist;
	__le32 bar[2];
	u8 primary_bus;
	u8 secondary_bus;
	u8 subordinate_bus;
	u8 secondary_latency_timer;
	u8 iobase;
	u8 iolimit;
	__le16 secondary_status;
	__le16 membase;
	__le16 memlimit;
	__le16 pref_mem_base;
	__le16 pref_mem_limit;
	__le32 prefbaseupper;
	__le32 preflimitupper;
	__le16 iobaseupper;
	__le16 iolimitupper;
	u8 capabilities_pointer;
	u8 reserve[3];
	__le32 romaddr;
	u8 intline;
	u8 intpin;
	__le16 bridgectrl;
};

struct pci_bridge_emul_pcie_conf {
	u8 cap_id;
	u8 next;
	__le16 cap;
	__le32 devcap;
	__le16 devctl;
	__le16 devsta;
	__le32 lnkcap;
	__le16 lnkctl;
	__le16 lnksta;
	__le32 slotcap;
	__le16 slotctl;
	__le16 slotsta;
	__le16 rootctl;
	__le16 rsvd;
	__le32 rootsta;
	__le32 devcap2;
	__le16 devctl2;
	__le16 devsta2;
	__le32 lnkcap2;
	__le16 lnkctl2;
	__le16 lnksta2;
	__le32 slotcap2;
	__le16 slotctl2;
	__le16 slotsta2;
};

typedef enum {
	PCI_BRIDGE_EMUL_HANDLED = 0,
	PCI_BRIDGE_EMUL_NOT_HANDLED = 1,
} pci_bridge_emul_read_status_t;

struct pci_bridge_emul;

struct pci_bridge_emul_ops {
	pci_bridge_emul_read_status_t (*read_base)(struct pci_bridge_emul *, int, u32 *);
	pci_bridge_emul_read_status_t (*read_pcie)(struct pci_bridge_emul *, int, u32 *);
	void (*write_base)(struct pci_bridge_emul *, int, u32, u32, u32);
	void (*write_pcie)(struct pci_bridge_emul *, int, u32, u32, u32);
};

struct pci_bridge_reg_behavior;

struct pci_bridge_emul {
	struct pci_bridge_emul_conf conf;
	struct pci_bridge_emul_pcie_conf pcie_conf;
	struct pci_bridge_emul_ops *ops;
	struct pci_bridge_reg_behavior *pci_regs_behavior;
	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
	void *data;
	bool has_pcie;
};

struct pci_bridge_reg_behavior {
	u32 ro;
	u32 rw;
	u32 w1c;
};

enum {
	PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR = 1,
};

enum dmi_device_type {
	DMI_DEV_TYPE_ANY = 0,
	DMI_DEV_TYPE_OTHER = 1,
	DMI_DEV_TYPE_UNKNOWN = 2,
	DMI_DEV_TYPE_VIDEO = 3,
	DMI_DEV_TYPE_SCSI = 4,
	DMI_DEV_TYPE_ETHERNET = 5,
	DMI_DEV_TYPE_TOKENRING = 6,
	DMI_DEV_TYPE_SOUND = 7,
	DMI_DEV_TYPE_PATA = 8,
	DMI_DEV_TYPE_SATA = 9,
	DMI_DEV_TYPE_SAS = 10,
	DMI_DEV_TYPE_IPMI = 4294967295,
	DMI_DEV_TYPE_OEM_STRING = 4294967294,
	DMI_DEV_TYPE_DEV_ONBOARD = 4294967293,
	DMI_DEV_TYPE_DEV_SLOT = 4294967292,
};

struct dmi_device {
	struct list_head list;
	int type;
	const char *name;
	void *device_data;
};

struct dmi_dev_onboard {
	struct dmi_device dev;
	int instance;
	int segment;
	int bus;
	int devfn;
};

enum smbios_attr_enum {
	SMBIOS_ATTR_NONE = 0,
	SMBIOS_ATTR_LABEL_SHOW = 1,
	SMBIOS_ATTR_INSTANCE_SHOW = 2,
};

struct pci_config_window;

struct pci_ecam_ops {
	unsigned int bus_shift;
	struct pci_ops pci_ops;
	int (*init)(struct pci_config_window *);
};

struct pci_config_window {
	struct resource res;
	struct resource busr;
	void *priv;
	const struct pci_ecam_ops *ops;
	union {
		void *win;
		void **winp;
	};
	struct device *parent;
};

struct pci_epf_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum pci_interrupt_pin {
	PCI_INTERRUPT_UNKNOWN = 0,
	PCI_INTERRUPT_INTA = 1,
	PCI_INTERRUPT_INTB = 2,
	PCI_INTERRUPT_INTC = 3,
	PCI_INTERRUPT_INTD = 4,
};

enum pci_barno {
	BAR_0 = 0,
	BAR_1 = 1,
	BAR_2 = 2,
	BAR_3 = 3,
	BAR_4 = 4,
	BAR_5 = 5,
};

struct pci_epf_header {
	u16 vendorid;
	u16 deviceid;
	u8 revid;
	u8 progif_code;
	u8 subclass_code;
	u8 baseclass_code;
	u8 cache_line_size;
	u16 subsys_vendor_id;
	u16 subsys_id;
	enum pci_interrupt_pin interrupt_pin;
};

struct pci_epf;

struct pci_epf_ops {
	int (*bind)(struct pci_epf *);
	void (*unbind)(struct pci_epf *);
};

struct pci_epf_bar {
	dma_addr_t phys_addr;
	void *addr;
	size_t size;
	enum pci_barno barno;
	int flags;
};

struct pci_epc;

struct pci_epf_driver;

struct pci_epf {
	struct device dev;
	const char *name;
	struct pci_epf_header *header;
	struct pci_epf_bar bar[6];
	u8 msi_interrupts;
	u16 msix_interrupts;
	u8 func_no;
	struct pci_epc *epc;
	struct pci_epf_driver *driver;
	struct list_head list;
	struct notifier_block nb;
	struct mutex lock;
};

struct pci_epf_driver {
	int (*probe)(struct pci_epf *);
	int (*remove)(struct pci_epf *);
	struct device_driver driver;
	struct pci_epf_ops *ops;
	struct module *owner;
	struct list_head epf_group;
	const struct pci_epf_device_id *id_table;
};

struct pci_epc_ops;

struct pci_epc_mem;

struct pci_epc {
	struct device dev;
	struct list_head pci_epf;
	const struct pci_epc_ops *ops;
	struct pci_epc_mem **windows;
	struct pci_epc_mem *mem;
	unsigned int num_windows;
	u8 max_functions;
	struct config_group *group;
	struct mutex lock;
	long unsigned int function_num_map;
	struct atomic_notifier_head notifier;
};

enum pci_epc_irq_type {
	PCI_EPC_IRQ_UNKNOWN = 0,
	PCI_EPC_IRQ_LEGACY = 1,
	PCI_EPC_IRQ_MSI = 2,
	PCI_EPC_IRQ_MSIX = 3,
};

struct pci_epc_features;

struct pci_epc_ops {
	int (*write_header)(struct pci_epc *, u8, struct pci_epf_header *);
	int (*set_bar)(struct pci_epc *, u8, struct pci_epf_bar *);
	void (*clear_bar)(struct pci_epc *, u8, struct pci_epf_bar *);
	int (*map_addr)(struct pci_epc *, u8, phys_addr_t, u64, size_t);
	void (*unmap_addr)(struct pci_epc *, u8, phys_addr_t);
	int (*set_msi)(struct pci_epc *, u8, u8);
	int (*get_msi)(struct pci_epc *, u8);
	int (*set_msix)(struct pci_epc *, u8, u16, enum pci_barno, u32);
	int (*get_msix)(struct pci_epc *, u8);
	int (*raise_irq)(struct pci_epc *, u8, enum pci_epc_irq_type, u16);
	int (*start)(struct pci_epc *);
	void (*stop)(struct pci_epc *);
	const struct pci_epc_features * (*get_features)(struct pci_epc *, u8);
	struct module *owner;
};

struct pci_epc_features {
	unsigned int linkup_notifier: 1;
	unsigned int core_init_notifier: 1;
	unsigned int msi_capable: 1;
	unsigned int msix_capable: 1;
	u8 reserved_bar;
	u8 bar_fixed_64bit;
	int: 8;
	int: 32;
	u64 bar_fixed_size[6];
	size_t align;
	int: 32;
};

struct pci_epc_mem_window {
	phys_addr_t phys_base;
	size_t size;
	size_t page_size;
};

struct pci_epc_mem {
	struct pci_epc_mem_window window;
	long unsigned int *bitmap;
	int pages;
	struct mutex lock;
};

struct pci_epf_group {
	struct config_group group;
	struct pci_epf *epf;
	int index;
};

struct pci_epc_group {
	struct config_group group;
	struct pci_epc *epc;
	bool start;
};

enum pci_notify_event {
	CORE_INIT = 0,
	LINK_UP = 1,
};

struct mvebu_pcie_port;

struct mvebu_pcie {
	struct platform_device *pdev;
	struct mvebu_pcie_port *ports;
	struct resource io;
	struct resource realio;
	struct resource mem;
	struct resource busn;
	int nports;
};

struct mvebu_pcie_window {
	phys_addr_t base;
	phys_addr_t remap;
	size_t size;
};

struct mvebu_pcie_port {
	char *name;
	void *base;
	u32 port;
	u32 lane;
	int devfn;
	unsigned int mem_target;
	unsigned int mem_attr;
	unsigned int io_target;
	unsigned int io_attr;
	struct clk *clk;
	struct gpio_desc *reset_gpio;
	char *reset_name;
	struct pci_bridge_emul bridge;
	struct device_node *dn;
	struct mvebu_pcie *pcie;
	struct mvebu_pcie_window memwin;
	struct mvebu_pcie_window iowin;
	u32 saved_pcie_stat;
	struct resource regs;
};

struct tegra_msi {
	struct msi_controller chip;
	long unsigned int used[8];
	struct irq_domain *domain;
	struct mutex lock;
	void *virt;
	dma_addr_t phys;
	int irq;
};

struct tegra_pcie_port_soc {
	struct {
		u8 turnoff_bit;
		u8 ack_bit;
	} pme;
};

struct tegra_pcie_soc {
	unsigned int num_ports;
	const struct tegra_pcie_port_soc *ports;
	unsigned int msi_base_shift;
	long unsigned int afi_pex2_ctrl;
	u32 pads_pll_ctl;
	u32 tx_ref_sel;
	u32 pads_refclk_cfg0;
	u32 pads_refclk_cfg1;
	u32 update_fc_threshold;
	bool has_pex_clkreq_en;
	bool has_pex_bias_ctrl;
	bool has_intr_prsnt_sense;
	bool has_cml_clk;
	bool has_gen2;
	bool force_pca_enable;
	bool program_uphy;
	bool update_clamp_threshold;
	bool program_deskew_time;
	bool update_fc_timer;
	bool has_cache_bars;
	struct {
		struct {
			u32 rp_ectl_2_r1;
			u32 rp_ectl_4_r1;
			u32 rp_ectl_5_r1;
			u32 rp_ectl_6_r1;
			u32 rp_ectl_2_r2;
			u32 rp_ectl_4_r2;
			u32 rp_ectl_5_r2;
			u32 rp_ectl_6_r2;
		} regs;
		bool enable;
	} ectl;
};

struct tegra_pcie {
	struct device *dev;
	void *pads;
	void *afi;
	void *cfg;
	int irq;
	struct resource cs;
	struct clk *pex_clk;
	struct clk *afi_clk;
	struct clk *pll_e;
	struct clk *cml_clk;
	struct reset_control *pex_rst;
	struct reset_control *afi_rst;
	struct reset_control *pcie_xrst;
	bool legacy_phy;
	struct phy *phy;
	struct tegra_msi msi;
	struct list_head ports;
	u32 xbar_config;
	struct regulator_bulk_data *supplies;
	unsigned int num_supplies;
	const struct tegra_pcie_soc *soc;
	struct dentry *debugfs;
};

struct tegra_pcie_port {
	struct tegra_pcie *pcie;
	struct device_node *np;
	struct list_head list;
	struct resource regs;
	void *base;
	unsigned int index;
	unsigned int lanes;
	struct phy **phys;
	struct gpio_desc *reset_gpio;
};

struct rcar_pci_priv {
	struct device *dev;
	void *reg;
	struct resource mem_res;
	struct resource *cfg_res;
	int irq;
};

struct rcar_pcie {
	struct device *dev;
	void *base;
};

enum {
	RCAR_PCI_ACCESS_READ = 0,
	RCAR_PCI_ACCESS_WRITE = 1,
};

struct rcar_msi {
	long unsigned int used[1];
	struct irq_domain *domain;
	struct msi_controller chip;
	long unsigned int pages;
	struct mutex lock;
	int irq1;
	int irq2;
};

struct rcar_pcie_host {
	struct rcar_pcie pcie;
	struct phy *phy;
	struct clk *bus_clk;
	struct rcar_msi msi;
	int (*phy_init_fn)(struct rcar_pcie_host *);
};

enum iproc_pcie_type {
	IPROC_PCIE_PAXB_BCMA = 0,
	IPROC_PCIE_PAXB = 1,
	IPROC_PCIE_PAXB_V2 = 2,
	IPROC_PCIE_PAXC = 3,
	IPROC_PCIE_PAXC_V2 = 4,
};

struct iproc_pcie_ob {
	resource_size_t axi_offset;
	unsigned int nr_windows;
};

struct iproc_pcie_ib {
	unsigned int nr_regions;
};

struct iproc_pcie_ob_map;

struct iproc_pcie_ib_map;

struct iproc_msi;

struct iproc_pcie {
	struct device *dev;
	enum iproc_pcie_type type;
	u16 *reg_offsets;
	void *base;
	phys_addr_t base_addr;
	struct resource mem;
	struct phy *phy;
	int (*map_irq)(const struct pci_dev *, u8, u8);
	bool ep_is_internal;
	bool iproc_cfg_read;
	bool rej_unconfig_pf;
	bool has_apb_err_disable;
	bool fix_paxc_cap;
	bool need_ob_cfg;
	struct iproc_pcie_ob ob;
	const struct iproc_pcie_ob_map *ob_map;
	bool need_ib_cfg;
	struct iproc_pcie_ib ib;
	const struct iproc_pcie_ib_map *ib_map;
	bool need_msi_steer;
	struct iproc_msi *msi;
};

struct iproc_pcie_ob_map {
	resource_size_t window_sizes[4];
	unsigned int nr_sizes;
};

enum iproc_pcie_ib_map_type {
	IPROC_PCIE_IB_MAP_MEM = 0,
	IPROC_PCIE_IB_MAP_IO = 1,
	IPROC_PCIE_IB_MAP_INVALID = 2,
};

struct iproc_pcie_ib_map {
	enum iproc_pcie_ib_map_type type;
	unsigned int size_unit;
	resource_size_t region_sizes[9];
	unsigned int nr_sizes;
	unsigned int nr_windows;
	u16 imap_addr_offset;
	u16 imap_window_offset;
};

enum iproc_pcie_reg {
	IPROC_PCIE_CLK_CTRL = 0,
	IPROC_PCIE_MSI_GIC_MODE = 1,
	IPROC_PCIE_MSI_BASE_ADDR = 2,
	IPROC_PCIE_MSI_WINDOW_SIZE = 3,
	IPROC_PCIE_MSI_ADDR_LO = 4,
	IPROC_PCIE_MSI_ADDR_HI = 5,
	IPROC_PCIE_MSI_EN_CFG = 6,
	IPROC_PCIE_CFG_IND_ADDR = 7,
	IPROC_PCIE_CFG_IND_DATA = 8,
	IPROC_PCIE_CFG_ADDR = 9,
	IPROC_PCIE_CFG_DATA = 10,
	IPROC_PCIE_INTX_EN = 11,
	IPROC_PCIE_OARR0 = 12,
	IPROC_PCIE_OMAP0 = 13,
	IPROC_PCIE_OARR1 = 14,
	IPROC_PCIE_OMAP1 = 15,
	IPROC_PCIE_OARR2 = 16,
	IPROC_PCIE_OMAP2 = 17,
	IPROC_PCIE_OARR3 = 18,
	IPROC_PCIE_OMAP3 = 19,
	IPROC_PCIE_IARR0 = 20,
	IPROC_PCIE_IMAP0 = 21,
	IPROC_PCIE_IARR1 = 22,
	IPROC_PCIE_IMAP1 = 23,
	IPROC_PCIE_IARR2 = 24,
	IPROC_PCIE_IMAP2 = 25,
	IPROC_PCIE_IARR3 = 26,
	IPROC_PCIE_IMAP3 = 27,
	IPROC_PCIE_IARR4 = 28,
	IPROC_PCIE_IMAP4 = 29,
	IPROC_PCIE_CFG_RD_STATUS = 30,
	IPROC_PCIE_LINK_STATUS = 31,
	IPROC_PCIE_APB_ERR_EN = 32,
	IPROC_PCIE_MAX_NUM_REG = 33,
};

struct iproc_msi_grp;

struct iproc_msi {
	struct iproc_pcie *pcie;
	const u16 (*reg_offsets)[8];
	struct iproc_msi_grp *grps;
	int nr_irqs;
	int nr_cpus;
	bool has_inten_reg;
	long unsigned int *bitmap;
	struct mutex bitmap_lock;
	unsigned int nr_msi_vecs;
	struct irq_domain *inner_domain;
	struct irq_domain *msi_domain;
	unsigned int nr_eq_region;
	unsigned int nr_msi_region;
	void *eq_cpu;
	dma_addr_t eq_dma;
	phys_addr_t msi_addr;
};

enum iproc_msi_reg {
	IPROC_MSI_EQ_PAGE = 0,
	IPROC_MSI_EQ_PAGE_UPPER = 1,
	IPROC_MSI_PAGE = 2,
	IPROC_MSI_PAGE_UPPER = 3,
	IPROC_MSI_CTRL = 4,
	IPROC_MSI_EQ_HEAD = 5,
	IPROC_MSI_EQ_TAIL = 6,
	IPROC_MSI_INTS_EN = 7,
	IPROC_MSI_REG_SIZE = 8,
};

struct iproc_msi_grp {
	struct iproc_msi *msi;
	int gic_irq;
	unsigned int eq;
};

struct bcma_device_id {
	__u16 manuf;
	__u16 id;
	__u8 rev;
	__u8 class;
};

struct bcma_device;

struct bcma_chipcommon_pmu {
	struct bcma_device *core;
	u8 rev;
	u32 crystalfreq;
};

struct bcma_bus;

struct bcma_device {
	struct bcma_bus *bus;
	struct bcma_device_id id;
	int: 16;
	int: 32;
	struct device dev;
	struct device *dma_dev;
	unsigned int irq;
	bool dev_registered;
	u8 core_index;
	u8 core_unit;
	u32 addr;
	u32 addr_s[8];
	u32 wrap;
	void *io_addr;
	void *io_wrap;
	void *drvdata;
	struct list_head list;
};

struct bcma_sflash {
	bool present;
	u32 blocksize;
	u16 numblocks;
	u32 size;
};

struct bcma_drv_cc {
	struct bcma_device *core;
	u32 status;
	u32 capabilities;
	u32 capabilities_ext;
	u8 setup_done: 1;
	u8 early_setup_done: 1;
	u16 fast_pwrup_delay;
	struct bcma_chipcommon_pmu pmu;
	struct bcma_sflash sflash;
	u32 ticks_per_ms;
	struct platform_device *watchdog;
	spinlock_t gpio_lock;
	struct gpio_chip gpio;
};

struct bcma_drv_cc_b {
	struct bcma_device *core;
	u8 setup_done: 1;
	void *mii;
};

struct bcma_drv_pci {
	struct bcma_device *core;
	u8 early_setup_done: 1;
	u8 setup_done: 1;
	u8 hostmode: 1;
};

struct bcma_drv_pcie2 {
	struct bcma_device *core;
	u16 reqsize;
};

struct bcma_drv_mips {
	struct bcma_device *core;
	u8 setup_done: 1;
	u8 early_setup_done: 1;
};

struct bcma_drv_gmac_cmn {
	struct bcma_device *core;
	struct mutex phy_mutex;
};

struct ssb_sprom_core_pwr_info {
	u8 itssi_2g;
	u8 itssi_5g;
	u8 maxpwr_2g;
	u8 maxpwr_5gl;
	u8 maxpwr_5g;
	u8 maxpwr_5gh;
	u16 pa_2g[4];
	u16 pa_5gl[4];
	u16 pa_5g[4];
	u16 pa_5gh[4];
};

struct ssb_sprom {
	u8 revision;
	char: 8;
	u8 il0mac[6];
	u8 et0mac[6];
	u8 et1mac[6];
	u8 et2mac[6];
	u8 et0phyaddr;
	u8 et1phyaddr;
	u8 et2phyaddr;
	u8 et0mdcport;
	u8 et1mdcport;
	u8 et2mdcport;
	u16 dev_id;
	u16 board_rev;
	u16 board_num;
	u16 board_type;
	u8 country_code;
	char alpha2[2];
	u8 leddc_on_time;
	u8 leddc_off_time;
	u8 ant_available_a;
	u8 ant_available_bg;
	u16 pa0b0;
	u16 pa0b1;
	u16 pa0b2;
	u16 pa1b0;
	u16 pa1b1;
	u16 pa1b2;
	u16 pa1lob0;
	u16 pa1lob1;
	u16 pa1lob2;
	u16 pa1hib0;
	u16 pa1hib1;
	u16 pa1hib2;
	u8 gpio0;
	u8 gpio1;
	u8 gpio2;
	u8 gpio3;
	u8 maxpwr_bg;
	u8 maxpwr_al;
	u8 maxpwr_a;
	u8 maxpwr_ah;
	u8 itssi_a;
	u8 itssi_bg;
	u8 tri2g;
	u8 tri5gl;
	u8 tri5g;
	u8 tri5gh;
	u8 txpid2g[4];
	u8 txpid5gl[4];
	u8 txpid5g[4];
	u8 txpid5gh[4];
	s8 rxpo2g;
	s8 rxpo5g;
	u8 rssisav2g;
	u8 rssismc2g;
	u8 rssismf2g;
	u8 bxa2g;
	u8 rssisav5g;
	u8 rssismc5g;
	u8 rssismf5g;
	u8 bxa5g;
	u16 cck2gpo;
	u32 ofdm2gpo;
	u32 ofdm5glpo;
	u32 ofdm5gpo;
	u32 ofdm5ghpo;
	u32 boardflags;
	u32 boardflags2;
	u32 boardflags3;
	u16 boardflags_lo;
	u16 boardflags_hi;
	u16 boardflags2_lo;
	u16 boardflags2_hi;
	struct ssb_sprom_core_pwr_info core_pwr_info[4];
	struct {
		s8 a0;
		s8 a1;
		s8 a2;
		s8 a3;
	} antenna_gain;
	struct {
		struct {
			u8 tssipos;
			u8 extpa_gain;
			u8 pdet_range;
			u8 tr_iso;
			u8 antswlut;
		} ghz2;
		struct {
			u8 tssipos;
			u8 extpa_gain;
			u8 pdet_range;
			u8 tr_iso;
			u8 antswlut;
		} ghz5;
	} fem;
	u16 mcs2gpo[8];
	u16 mcs5gpo[8];
	u16 mcs5glpo[8];
	u16 mcs5ghpo[8];
	u8 opo;
	u8 rxgainerr2ga[3];
	u8 rxgainerr5gla[3];
	u8 rxgainerr5gma[3];
	u8 rxgainerr5gha[3];
	u8 rxgainerr5gua[3];
	u8 noiselvl2ga[3];
	u8 noiselvl5gla[3];
	u8 noiselvl5gma[3];
	u8 noiselvl5gha[3];
	u8 noiselvl5gua[3];
	u8 regrev;
	u8 txchain;
	u8 rxchain;
	u8 antswitch;
	u16 cddpo;
	u16 stbcpo;
	u16 bw40po;
	u16 bwduppo;
	u8 tempthresh;
	u8 tempoffset;
	u16 rawtempsense;
	u8 measpower;
	u8 tempsense_slope;
	u8 tempcorrx;
	u8 tempsense_option;
	u8 freqoffset_corr;
	u8 iqcal_swp_dis;
	u8 hw_iqcal_en;
	u8 elna2g;
	u8 elna5g;
	u8 phycal_tempdelta;
	u8 temps_period;
	u8 temps_hysteresis;
	u8 measpower1;
	u8 measpower2;
	u8 pcieingress_war;
	u16 cckbw202gpo;
	u16 cckbw20ul2gpo;
	u32 legofdmbw202gpo;
	u32 legofdmbw20ul2gpo;
	u32 legofdmbw205glpo;
	u32 legofdmbw20ul5glpo;
	u32 legofdmbw205gmpo;
	u32 legofdmbw20ul5gmpo;
	u32 legofdmbw205ghpo;
	u32 legofdmbw20ul5ghpo;
	u32 mcsbw202gpo;
	u32 mcsbw20ul2gpo;
	u32 mcsbw402gpo;
	u32 mcsbw205glpo;
	u32 mcsbw20ul5glpo;
	u32 mcsbw405glpo;
	u32 mcsbw205gmpo;
	u32 mcsbw20ul5gmpo;
	u32 mcsbw405gmpo;
	u32 mcsbw205ghpo;
	u32 mcsbw20ul5ghpo;
	u32 mcsbw405ghpo;
	u16 mcs32po;
	u16 legofdm40duppo;
	u8 sar2g;
	u8 sar5g;
};

enum bcma_hosttype {
	BCMA_HOSTTYPE_PCI = 0,
	BCMA_HOSTTYPE_SDIO = 1,
	BCMA_HOSTTYPE_SOC = 2,
};

struct bcma_chipinfo {
	u16 id;
	u8 rev;
	u8 pkg;
};

struct bcma_boardinfo {
	u16 vendor;
	u16 type;
};

struct bcma_host_ops {
	u8 (*read8)(struct bcma_device *, u16);
	u16 (*read16)(struct bcma_device *, u16);
	u32 (*read32)(struct bcma_device *, u16);
	void (*write8)(struct bcma_device *, u16, u8);
	void (*write16)(struct bcma_device *, u16, u16);
	void (*write32)(struct bcma_device *, u16, u32);
	u32 (*aread32)(struct bcma_device *, u16);
	void (*awrite32)(struct bcma_device *, u16, u32);
};

struct bcma_bus {
	struct device *dev;
	void *mmio;
	const struct bcma_host_ops *ops;
	enum bcma_hosttype hosttype;
	bool host_is_pcie2;
	struct pci_dev *host_pci;
	struct bcma_chipinfo chipinfo;
	struct bcma_boardinfo boardinfo;
	struct bcma_device *mapped_core;
	struct list_head cores;
	u8 nr_cores;
	u8 num;
	struct bcma_drv_cc drv_cc;
	struct bcma_drv_cc_b drv_cc_b;
	struct bcma_drv_pci drv_pci[2];
	struct bcma_drv_pcie2 drv_pcie2;
	struct bcma_drv_mips drv_mips;
	struct bcma_drv_gmac_cmn drv_gmac_cmn;
	struct ssb_sprom sprom;
};

struct bcma_driver {
	const char *name;
	const struct bcma_device_id *id_table;
	int (*probe)(struct bcma_device *);
	void (*remove)(struct bcma_device *);
	int (*suspend)(struct bcma_device *);
	int (*resume)(struct bcma_device *);
	void (*shutdown)(struct bcma_device *);
	struct device_driver drv;
};

enum dw_pcie_region_type {
	DW_PCIE_REGION_UNKNOWN = 0,
	DW_PCIE_REGION_INBOUND = 1,
	DW_PCIE_REGION_OUTBOUND = 2,
};

struct pcie_port;

struct dw_pcie_host_ops {
	int (*host_init)(struct pcie_port *);
	int (*msi_host_init)(struct pcie_port *);
};

struct pcie_port {
	bool has_msi_ctrl: 1;
	int: 31;
	int: 32;
	u64 cfg0_base;
	void *va_cfg0_base;
	u32 cfg0_size;
	resource_size_t io_base;
	phys_addr_t io_bus_addr;
	u32 io_size;
	int irq;
	const struct dw_pcie_host_ops *ops;
	int msi_irq;
	struct irq_domain *irq_domain;
	struct irq_domain *msi_domain;
	u16 msi_msg;
	dma_addr_t msi_data;
	struct irq_chip *msi_irq_chip;
	u32 num_vectors;
	u32 irq_mask[8];
	struct pci_host_bridge *bridge;
	raw_spinlock_t lock;
	long unsigned int msi_irq_in_use[8];
};

enum dw_pcie_as_type {
	DW_PCIE_AS_UNKNOWN = 0,
	DW_PCIE_AS_MEM = 1,
	DW_PCIE_AS_IO = 2,
};

struct dw_pcie_ep;

struct dw_pcie_ep_ops {
	void (*ep_init)(struct dw_pcie_ep *);
	int (*raise_irq)(struct dw_pcie_ep *, u8, enum pci_epc_irq_type, u16);
	const struct pci_epc_features * (*get_features)(struct dw_pcie_ep *);
	unsigned int (*func_conf_select)(struct dw_pcie_ep *, u8);
};

struct dw_pcie_ep {
	struct pci_epc *epc;
	struct list_head func_list;
	const struct dw_pcie_ep_ops *ops;
	phys_addr_t phys_base;
	size_t addr_size;
	size_t page_size;
	u8 bar_to_atu[6];
	phys_addr_t *outbound_addr;
	long unsigned int *ib_window_map;
	long unsigned int *ob_window_map;
	void *msi_mem;
	phys_addr_t msi_mem_phys;
	struct pci_epf_bar *epf_bar[6];
};

struct dw_pcie;

struct dw_pcie_ops {
	u64 (*cpu_addr_fixup)(struct dw_pcie *, u64);
	u32 (*read_dbi)(struct dw_pcie *, void *, u32, size_t);
	void (*write_dbi)(struct dw_pcie *, void *, u32, size_t, u32);
	void (*write_dbi2)(struct dw_pcie *, void *, u32, size_t, u32);
	int (*link_up)(struct dw_pcie *);
	int (*start_link)(struct dw_pcie *);
	void (*stop_link)(struct dw_pcie *);
};

struct dw_pcie {
	struct device *dev;
	void *dbi_base;
	void *dbi_base2;
	void *atu_base;
	size_t atu_size;
	u32 num_ib_windows;
	u32 num_ob_windows;
	int: 32;
	struct pcie_port pp;
	struct dw_pcie_ep ep;
	const struct dw_pcie_ops *ops;
	unsigned int version;
	int num_lanes;
	int link_gen;
	u8 n_fts[2];
	bool iatu_unroll_enabled: 1;
	bool io_cfg_atu_shared: 1;
	int: 14;
	int: 32;
};

struct pci_epf_msix_tbl {
	u64 msg_addr;
	u32 msg_data;
	u32 vector_ctrl;
};

struct dw_pcie_ep_func {
	struct list_head list;
	u8 func_no;
	u8 msi_cap;
	u8 msix_cap;
};

enum dw_pcie_device_mode {
	DW_PCIE_UNKNOWN_TYPE = 0,
	DW_PCIE_EP_TYPE = 1,
	DW_PCIE_LEG_EP_TYPE = 2,
	DW_PCIE_RC_TYPE = 3,
};

struct dra7xx_pcie {
	struct dw_pcie *pci;
	void *base;
	int phy_count;
	struct phy **phy;
	struct irq_domain *irq_domain;
	enum dw_pcie_device_mode mode;
};

struct dra7xx_pcie_of_data {
	enum dw_pcie_device_mode mode;
	u32 b1co_mode_sel_mask;
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedir;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[8];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc;
	struct uni_screen *vc_uni_screen;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_info;

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct backlight_device;

struct fb_deferred_io;

struct fb_ops;

struct apertures_struct;

struct fb_info {
	atomic_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct work_struct queue;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct backlight_device *bl_dev;
	struct mutex bl_curve_mutex;
	u8 bl_curve[128];
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io {
	long unsigned int delay;
	struct mutex lock;
	struct list_head pagelist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	int fb_blank;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_ops;

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	int: 32;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
	int: 32;
};

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	int (*check_fb)(struct backlight_device *, struct fb_info *);
};

enum {
	AS3711_REGULATOR_SD_1 = 0,
	AS3711_REGULATOR_SD_2 = 1,
	AS3711_REGULATOR_SD_3 = 2,
	AS3711_REGULATOR_SD_4 = 3,
	AS3711_REGULATOR_LDO_1 = 4,
	AS3711_REGULATOR_LDO_2 = 5,
	AS3711_REGULATOR_LDO_3 = 6,
	AS3711_REGULATOR_LDO_4 = 7,
	AS3711_REGULATOR_LDO_5 = 8,
	AS3711_REGULATOR_LDO_6 = 9,
	AS3711_REGULATOR_LDO_7 = 10,
	AS3711_REGULATOR_LDO_8 = 11,
	AS3711_REGULATOR_MAX = 12,
};

struct as3711 {
	struct device *dev;
	struct regmap *regmap;
};

enum as3711_su2_feedback {
	AS3711_SU2_VOLTAGE = 0,
	AS3711_SU2_CURR1 = 1,
	AS3711_SU2_CURR2 = 2,
	AS3711_SU2_CURR3 = 3,
	AS3711_SU2_CURR_AUTO = 4,
};

enum as3711_su2_fbprot {
	AS3711_SU2_LX_SD4 = 0,
	AS3711_SU2_GPIO2 = 1,
	AS3711_SU2_GPIO3 = 2,
	AS3711_SU2_GPIO4 = 3,
};

struct as3711_bl_pdata {
	bool su1_fb;
	int su1_max_uA;
	bool su2_fb;
	int su2_max_uA;
	enum as3711_su2_feedback su2_feedback;
	enum as3711_su2_fbprot su2_fbprot;
	bool su2_auto_curr1;
	bool su2_auto_curr2;
	bool su2_auto_curr3;
};

enum as3711_bl_type {
	AS3711_BL_SU1 = 0,
	AS3711_BL_SU2 = 1,
};

struct as3711_bl_data {
	bool powered;
	enum as3711_bl_type type;
	int brightness;
	struct backlight_device *bl;
};

struct as3711_bl_supply {
	struct as3711_bl_data su1;
	struct as3711_bl_data su2;
	const struct as3711_bl_pdata *pdata;
	struct as3711 *as3711;
};

struct fb_event {
	struct fb_info *info;
	void *data;
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum backlight_notification {
	BACKLIGHT_REGISTERED = 0,
	BACKLIGHT_UNREGISTERED = 1,
};

struct gpio_backlight_platform_data {
	struct device *fbdev;
};

struct gpio_backlight {
	struct device *fbdev;
	struct gpio_desc *gpiod;
};

struct platform_pwm_backlight_data {
	int pwm_id;
	unsigned int max_brightness;
	unsigned int dft_brightness;
	unsigned int lth_brightness;
	unsigned int pwm_period_ns;
	unsigned int *levels;
	unsigned int post_pwm_on_delay;
	unsigned int pwm_off_delay;
	int (*init)(struct device *);
	int (*notify)(struct device *, int);
	void (*notify_after)(struct device *, int);
	void (*exit)(struct device *);
	int (*check_fb)(struct device *, struct fb_info *);
};

struct pwm_bl_data {
	struct pwm_device *pwm;
	struct device *dev;
	unsigned int lth_brightness;
	unsigned int *levels;
	bool enabled;
	struct regulator *power_supply;
	struct gpio_desc *enable_gpio;
	unsigned int scale;
	bool legacy;
	unsigned int post_pwm_on_delay;
	unsigned int pwm_off_delay;
	int (*notify)(struct device *, int);
	void (*notify_after)(struct device *, int);
	int (*check_fb)(struct device *, struct fb_info *);
	void (*exit)(struct device *);
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct dmt_videomode {
	u32 dmt_id;
	u32 std_2byte_code;
	u32 cvt_3byte_code;
	const struct fb_videomode *mode;
};

enum display_flags {
	DISPLAY_FLAGS_HSYNC_LOW = 1,
	DISPLAY_FLAGS_HSYNC_HIGH = 2,
	DISPLAY_FLAGS_VSYNC_LOW = 4,
	DISPLAY_FLAGS_VSYNC_HIGH = 8,
	DISPLAY_FLAGS_DE_LOW = 16,
	DISPLAY_FLAGS_DE_HIGH = 32,
	DISPLAY_FLAGS_PIXDATA_POSEDGE = 64,
	DISPLAY_FLAGS_PIXDATA_NEGEDGE = 128,
	DISPLAY_FLAGS_INTERLACED = 256,
	DISPLAY_FLAGS_DOUBLESCAN = 512,
	DISPLAY_FLAGS_DOUBLECLK = 1024,
	DISPLAY_FLAGS_SYNC_POSEDGE = 2048,
	DISPLAY_FLAGS_SYNC_NEGEDGE = 4096,
};

struct videomode {
	long unsigned int pixelclock;
	u32 hactive;
	u32 hfront_porch;
	u32 hback_porch;
	u32 hsync_len;
	u32 vactive;
	u32 vfront_porch;
	u32 vback_porch;
	u32 vsync_len;
	enum display_flags flags;
};

struct broken_edid {
	u8 manufacturer[4];
	u32 model;
	u32 fix;
};

struct __fb_timings {
	u32 dclk;
	u32 hfreq;
	u32 vfreq;
	u32 hactive;
	u32 vactive;
	u32 hblank;
	u32 vblank;
	u32 htotal;
	u32 vtotal;
};

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef unsigned char u_char;

typedef short unsigned int u_short;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short scrollmode;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct timer_list cursor_timer;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	int flags;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

struct wm8505fb_info {
	struct fb_info fb;
	void *regbase;
	unsigned int contrast;
};

struct display_timings;

enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED = 0,
	V4L2_PREEMPHASIS_50_uS = 1,
	V4L2_PREEMPHASIS_75_uS = 2,
};

enum v4l2_colorspace {
	V4L2_COLORSPACE_DEFAULT = 0,
	V4L2_COLORSPACE_SMPTE170M = 1,
	V4L2_COLORSPACE_SMPTE240M = 2,
	V4L2_COLORSPACE_REC709 = 3,
	V4L2_COLORSPACE_BT878 = 4,
	V4L2_COLORSPACE_470_SYSTEM_M = 5,
	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
	V4L2_COLORSPACE_JPEG = 7,
	V4L2_COLORSPACE_SRGB = 8,
	V4L2_COLORSPACE_OPRGB = 9,
	V4L2_COLORSPACE_BT2020 = 10,
	V4L2_COLORSPACE_RAW = 11,
	V4L2_COLORSPACE_DCI_P3 = 12,
};

enum {
	RGB8 = 0,
	RGB9 = 4,
	RGB12A = 5,
	RGB12B = 6,
	RGB16 = 7,
	RGB18 = 10,
	RGB24 = 11,
	YUV422 = 15,
	SYS8A = 4096,
	SYS8B = 4097,
	SYS8C = 4098,
	SYS8D = 4099,
	SYS9 = 4100,
	SYS12 = 4101,
	SYS16A = 4103,
	SYS16B = 4104,
	SYS16C = 4105,
	SYS18 = 4106,
	SYS24 = 4107,
};

enum {
	LCDC_CHAN_DISABLED = 0,
	LCDC_CHAN_MAINLCD = 1,
	LCDC_CHAN_SUBLCD = 2,
};

enum {
	LCDC_CLK_BUS = 0,
	LCDC_CLK_PERIPHERAL = 1,
	LCDC_CLK_EXTERNAL = 2,
};

struct sh_mobile_lcdc_sys_bus_cfg {
	long unsigned int ldmt2r;
	long unsigned int ldmt3r;
	long unsigned int deferred_io_msec;
};

struct sh_mobile_lcdc_sys_bus_ops {
	void (*write_index)(void *, long unsigned int);
	void (*write_data)(void *, long unsigned int);
	long unsigned int (*read_data)(void *);
};

struct sh_mobile_lcdc_panel_cfg {
	long unsigned int width;
	long unsigned int height;
	int (*setup_sys)(void *, struct sh_mobile_lcdc_sys_bus_ops *);
	void (*start_transfer)(void *, struct sh_mobile_lcdc_sys_bus_ops *);
	void (*display_on)();
	void (*display_off)();
};

struct sh_mobile_lcdc_bl_info {
	const char *name;
	int max_brightness;
	int (*set_brightness)(int);
};

struct sh_mobile_lcdc_overlay_cfg {
	int fourcc;
	unsigned int max_xres;
	unsigned int max_yres;
};

struct sh_mobile_lcdc_chan_cfg {
	int chan;
	int fourcc;
	int colorspace;
	int interface_type;
	int clock_divider;
	long unsigned int flags;
	const struct fb_videomode *lcd_modes;
	int num_modes;
	struct sh_mobile_lcdc_panel_cfg panel_cfg;
	struct sh_mobile_lcdc_bl_info bl_info;
	struct sh_mobile_lcdc_sys_bus_cfg sys_bus_cfg;
	struct platform_device *tx_dev;
};

struct sh_mobile_lcdc_info {
	int clock_source;
	struct sh_mobile_lcdc_chan_cfg ch[2];
	struct sh_mobile_lcdc_overlay_cfg overlays[4];
};

enum {
	LDDCKPAT1R = 0,
	LDDCKPAT2R = 1,
	LDMT1R = 2,
	LDMT2R = 3,
	LDMT3R = 4,
	LDDFR = 5,
	LDSM1R = 6,
	LDSM2R = 7,
	LDSA1R = 8,
	LDSA2R = 9,
	LDMLSR = 10,
	LDHCNR = 11,
	LDHSYNR = 12,
	LDVLNR = 13,
	LDVSYNR = 14,
	LDPMR = 15,
	LDHAJR = 16,
	NR_CH_REGS = 17,
};

struct sh_mobile_lcdc_entity;

struct sh_mobile_lcdc_entity_ops {
	int (*display_on)(struct sh_mobile_lcdc_entity *);
	void (*display_off)(struct sh_mobile_lcdc_entity *);
};

struct sh_mobile_lcdc_chan;

struct sh_mobile_lcdc_entity {
	struct module *owner;
	const struct sh_mobile_lcdc_entity_ops *ops;
	struct sh_mobile_lcdc_chan *lcdc;
	struct fb_videomode def_mode;
};

struct sh_mobile_lcdc_priv;

struct sh_mobile_lcdc_format_info;

struct sh_mobile_lcdc_chan {
	struct sh_mobile_lcdc_priv *lcdc;
	struct sh_mobile_lcdc_entity *tx_dev;
	const struct sh_mobile_lcdc_chan_cfg *cfg;
	long unsigned int *reg_offs;
	long unsigned int ldmt1r_value;
	long unsigned int enabled;
	struct mutex open_lock;
	int use_count;
	void *fb_mem;
	long unsigned int fb_size;
	dma_addr_t dma_handle;
	long unsigned int pan_y_offset;
	long unsigned int frame_end;
	wait_queue_head_t frame_end_wait;
	struct completion vsync_completion;
	const struct sh_mobile_lcdc_format_info *format;
	u32 colorspace;
	unsigned int xres;
	unsigned int xres_virtual;
	unsigned int yres;
	unsigned int yres_virtual;
	unsigned int pitch;
	long unsigned int base_addr_y;
	long unsigned int base_addr_c;
	unsigned int line_size;
	struct backlight_device *bl;
	unsigned int bl_brightness;
	struct fb_info *info;
	u32 pseudo_palette[16];
	struct {
		unsigned int width;
		unsigned int height;
		struct fb_videomode mode;
	} display;
	struct fb_deferred_io defio;
	struct scatterlist *sglist;
	int blank_status;
};

enum sh_mobile_lcdc_overlay_mode {
	LCDC_OVERLAY_BLEND = 0,
	LCDC_OVERLAY_ROP3 = 1,
};

struct sh_mobile_lcdc_overlay {
	struct sh_mobile_lcdc_chan *channel;
	const struct sh_mobile_lcdc_overlay_cfg *cfg;
	struct fb_info *info;
	unsigned int index;
	long unsigned int base;
	bool enabled;
	enum sh_mobile_lcdc_overlay_mode mode;
	unsigned int alpha;
	unsigned int rop3;
	void *fb_mem;
	long unsigned int fb_size;
	dma_addr_t dma_handle;
	long unsigned int base_addr_y;
	long unsigned int base_addr_c;
	long unsigned int pan_y_offset;
	const struct sh_mobile_lcdc_format_info *format;
	unsigned int xres;
	unsigned int xres_virtual;
	unsigned int yres;
	unsigned int yres_virtual;
	unsigned int pitch;
	int pos_x;
	int pos_y;
};

struct sh_mobile_lcdc_priv {
	void *base;
	int irq;
	atomic_t hw_usecnt;
	struct device *dev;
	struct clk *dot_clk;
	long unsigned int lddckr;
	struct sh_mobile_lcdc_chan ch[2];
	struct sh_mobile_lcdc_overlay overlays[4];
	int started;
	int forced_fourcc;
};

struct sh_mobile_lcdc_format_info {
	u32 fourcc;
	unsigned int bpp;
	bool yuv;
	u32 lddfr;
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = 4294967295,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	struct mutex chan_mutex;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	int: 32;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	unsigned int slave_id;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
	struct dma_async_tx_descriptor *next;
	struct dma_async_tx_descriptor *parent;
	spinlock_t lock;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

enum ipu_channel {
	IDMAC_IC_0 = 0,
	IDMAC_IC_1 = 1,
	IDMAC_ADC_0 = 1,
	IDMAC_IC_2 = 2,
	IDMAC_ADC_1 = 2,
	IDMAC_IC_3 = 3,
	IDMAC_IC_4 = 4,
	IDMAC_IC_5 = 5,
	IDMAC_IC_6 = 6,
	IDMAC_IC_7 = 7,
	IDMAC_IC_8 = 8,
	IDMAC_IC_9 = 9,
	IDMAC_IC_10 = 10,
	IDMAC_IC_11 = 11,
	IDMAC_IC_12 = 12,
	IDMAC_IC_13 = 13,
	IDMAC_SDC_0 = 14,
	IDMAC_SDC_1 = 15,
	IDMAC_SDC_2 = 16,
	IDMAC_SDC_3 = 17,
	IDMAC_ADC_2 = 18,
	IDMAC_ADC_3 = 19,
	IDMAC_ADC_4 = 20,
	IDMAC_ADC_5 = 21,
	IDMAC_ADC_6 = 22,
	IDMAC_ADC_7 = 23,
	IDMAC_PF_0 = 24,
	IDMAC_PF_1 = 25,
	IDMAC_PF_2 = 26,
	IDMAC_PF_3 = 27,
	IDMAC_PF_4 = 28,
	IDMAC_PF_5 = 29,
	IDMAC_PF_6 = 30,
	IDMAC_PF_7 = 31,
};

enum ipu_channel_status {
	IPU_CHANNEL_FREE = 0,
	IPU_CHANNEL_INITIALIZED = 1,
	IPU_CHANNEL_READY = 2,
	IPU_CHANNEL_ENABLED = 3,
};

enum pixel_fmt {
	IPU_PIX_FMT_GENERIC = 0,
	IPU_PIX_FMT_RGB332 = 1,
	IPU_PIX_FMT_YUV420P = 2,
	IPU_PIX_FMT_YUV422P = 3,
	IPU_PIX_FMT_YUV420P2 = 4,
	IPU_PIX_FMT_YVU422P = 5,
	IPU_PIX_FMT_RGB565 = 6,
	IPU_PIX_FMT_RGB666 = 7,
	IPU_PIX_FMT_BGR666 = 8,
	IPU_PIX_FMT_YUYV = 9,
	IPU_PIX_FMT_UYVY = 10,
	IPU_PIX_FMT_RGB24 = 11,
	IPU_PIX_FMT_BGR24 = 12,
	IPU_PIX_FMT_GENERIC_32 = 13,
	IPU_PIX_FMT_RGB32 = 14,
	IPU_PIX_FMT_BGR32 = 15,
	IPU_PIX_FMT_ABGR32 = 16,
	IPU_PIX_FMT_BGRA32 = 17,
	IPU_PIX_FMT_RGBA32 = 18,
};

enum display_port {
	DISP0 = 0,
	DISP1 = 1,
	DISP2 = 2,
	DISP3 = 3,
};

struct idmac_video_param {
	short unsigned int in_width;
	short unsigned int in_height;
	uint32_t in_pixel_fmt;
	short unsigned int out_width;
	short unsigned int out_height;
	uint32_t out_pixel_fmt;
	short unsigned int out_stride;
	bool graphics_combine_en;
	bool global_alpha_en;
	bool key_color_en;
	enum display_port disp;
	short unsigned int out_left;
	short unsigned int out_top;
};

union ipu_channel_param {
	struct idmac_video_param video;
};

struct idmac_tx_desc {
	struct dma_async_tx_descriptor txd;
	struct scatterlist *sg;
	unsigned int sg_len;
	struct list_head list;
};

struct idmac_channel {
	struct dma_chan dma_chan;
	dma_cookie_t completed;
	union ipu_channel_param params;
	enum ipu_channel link;
	enum ipu_channel_status status;
	void *client;
	unsigned int n_tx_desc;
	struct idmac_tx_desc *desc;
	struct scatterlist *sg[2];
	struct list_head free_list;
	struct list_head queue;
	spinlock_t lock;
	struct mutex chan_mutex;
	bool sec_chan_en;
	int active_buffer;
	unsigned int eof_irq;
	char eof_name[16];
};

enum disp_data_mapping {
	IPU_DISP_DATA_MAPPING_RGB666 = 0,
	IPU_DISP_DATA_MAPPING_RGB565 = 1,
	IPU_DISP_DATA_MAPPING_RGB888 = 2,
};

struct mx3fb_platform_data {
	struct device *dma_dev;
	const char *name;
	const struct fb_videomode *mode;
	int num_modes;
	enum disp_data_mapping disp_data_fmt;
};

enum ipu_panel {
	IPU_PANEL_SHARP_TFT = 0,
	IPU_PANEL_TFT = 1,
};

struct ipu_di_signal_cfg {
	unsigned int datamask_en: 1;
	unsigned int clksel_en: 1;
	unsigned int clkidle_en: 1;
	unsigned int data_pol: 1;
	unsigned int clk_pol: 1;
	unsigned int enable_pol: 1;
	unsigned int Hsync_pol: 1;
	unsigned int Vsync_pol: 1;
};

struct mx3fb_data {
	struct fb_info *fbi;
	int backlight_level;
	void *reg_base;
	spinlock_t lock;
	struct device *dev;
	struct backlight_device *bl;
	uint32_t h_start_width;
	uint32_t v_start_width;
	enum disp_data_mapping disp_data_fmt;
};

struct dma_chan_request {
	struct mx3fb_data *mx3fb;
	enum ipu_channel id;
};

struct mx3fb_info {
	int blank;
	enum ipu_channel ipu_ch;
	uint32_t cur_ipu_buf;
	u32 pseudo_palette[16];
	struct completion flip_cmpl;
	struct mutex mutex;
	struct mx3fb_data *mx3fb;
	struct idmac_channel *idmac_channel;
	struct dma_async_tx_descriptor *txd;
	dma_cookie_t cookie;
	struct scatterlist sg[2];
	struct fb_var_screeninfo cur_var;
};

struct di_mapping {
	uint32_t b0;
	uint32_t b1;
	uint32_t b2;
};

struct simplefb_format {
	const char *name;
	u32 bits_per_pixel;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	u32 fourcc;
};

struct simplefb_platform_data {
	u32 width;
	u32 height;
	u32 stride;
	const char *format;
};

struct simplefb_params {
	u32 width;
	u32 height;
	u32 stride;
	struct simplefb_format *format;
};

struct simplefb_par {
	u32 palette[16];
	bool clks_enabled;
	unsigned int clk_count;
	struct clk **clks;
	bool regulators_enabled;
	u32 regulator_count;
	struct regulator **regulators;
};

struct timing_entry {
	u32 min;
	u32 typ;
	u32 max;
};

struct display_timing {
	struct timing_entry pixelclock;
	struct timing_entry hactive;
	struct timing_entry hfront_porch;
	struct timing_entry hback_porch;
	struct timing_entry hsync_len;
	struct timing_entry vactive;
	struct timing_entry vfront_porch;
	struct timing_entry vback_porch;
	struct timing_entry vsync_len;
	enum display_flags flags;
};

struct display_timings___2 {
	unsigned int num_timings;
	unsigned int native_mode;
	struct display_timing **timings;
};

struct deferred_device {
	struct amba_device *dev;
	struct resource *parent;
	struct list_head node;
};

struct find_data {
	struct amba_device *dev;
	struct device *parent;
	const char *busid;
	unsigned int id;
	unsigned int mask;
};

struct tegra_ahb {
	void *regs;
	struct device *dev;
	u32 ctx[0];
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_onecell_data {
	struct clk **clks;
	unsigned int clk_num;
};

struct clk_hw_onecell_data {
	unsigned int num;
	struct clk_hw *hws[0];
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_rate_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int min;
	long unsigned int max;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_rate_range {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_min_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_max_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_range)(void *, struct clk_core *, long unsigned int, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_notifier_devres {
	struct clk *clk;
	struct notifier_block *nb;
};

struct of_clk_provider {
	struct list_head link;
	struct device_node *node;
	struct clk * (*get)(struct of_phandle_args *, void *);
	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
	void *data;
};

struct clock_provider {
	void (*clk_init_cb)(struct device_node *);
	struct device_node *np;
	struct list_head node;
};

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

typedef void (*of_init_fn_1)(struct device_node *);

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
	long unsigned int flags;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

struct aspeed_gate_data {
	u8 clock_idx;
	s8 reset_idx;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
};

struct aspeed_clk_gate {
	struct clk_hw hw;
	struct regmap *map;
	u8 clock_idx;
	s8 reset_idx;
	u8 flags;
	spinlock_t *lock;
};

struct aspeed_reset {
	struct regmap *map;
	struct reset_controller_dev rcdev;
};

struct aspeed_clk_soc_data {
	const struct clk_div_table *div_table;
	const struct clk_div_table *eclk_div_table;
	const struct clk_div_table *mac_div_table;
	struct clk_hw * (*calc_pll)(const char *, u32);
};

struct hb_clk {
	struct clk_hw hw;
	void *reg;
	char *parent_name;
};

enum max77686_pmic_reg {
	MAX77686_REG_DEVICE_ID = 0,
	MAX77686_REG_INTSRC = 1,
	MAX77686_REG_INT1 = 2,
	MAX77686_REG_INT2 = 3,
	MAX77686_REG_INT1MSK = 4,
	MAX77686_REG_INT2MSK = 5,
	MAX77686_REG_STATUS1 = 6,
	MAX77686_REG_STATUS2 = 7,
	MAX77686_REG_PWRON = 8,
	MAX77686_REG_ONOFF_DELAY = 9,
	MAX77686_REG_MRSTB = 10,
	MAX77686_REG_BUCK1CTRL = 16,
	MAX77686_REG_BUCK1OUT = 17,
	MAX77686_REG_BUCK2CTRL1 = 18,
	MAX77686_REG_BUCK234FREQ = 19,
	MAX77686_REG_BUCK2DVS1 = 20,
	MAX77686_REG_BUCK2DVS2 = 21,
	MAX77686_REG_BUCK2DVS3 = 22,
	MAX77686_REG_BUCK2DVS4 = 23,
	MAX77686_REG_BUCK2DVS5 = 24,
	MAX77686_REG_BUCK2DVS6 = 25,
	MAX77686_REG_BUCK2DVS7 = 26,
	MAX77686_REG_BUCK2DVS8 = 27,
	MAX77686_REG_BUCK3CTRL1 = 28,
	MAX77686_REG_BUCK3DVS1 = 30,
	MAX77686_REG_BUCK3DVS2 = 31,
	MAX77686_REG_BUCK3DVS3 = 32,
	MAX77686_REG_BUCK3DVS4 = 33,
	MAX77686_REG_BUCK3DVS5 = 34,
	MAX77686_REG_BUCK3DVS6 = 35,
	MAX77686_REG_BUCK3DVS7 = 36,
	MAX77686_REG_BUCK3DVS8 = 37,
	MAX77686_REG_BUCK4CTRL1 = 38,
	MAX77686_REG_BUCK4DVS1 = 40,
	MAX77686_REG_BUCK4DVS2 = 41,
	MAX77686_REG_BUCK4DVS3 = 42,
	MAX77686_REG_BUCK4DVS4 = 43,
	MAX77686_REG_BUCK4DVS5 = 44,
	MAX77686_REG_BUCK4DVS6 = 45,
	MAX77686_REG_BUCK4DVS7 = 46,
	MAX77686_REG_BUCK4DVS8 = 47,
	MAX77686_REG_BUCK5CTRL = 48,
	MAX77686_REG_BUCK5OUT = 49,
	MAX77686_REG_BUCK6CTRL = 50,
	MAX77686_REG_BUCK6OUT = 51,
	MAX77686_REG_BUCK7CTRL = 52,
	MAX77686_REG_BUCK7OUT = 53,
	MAX77686_REG_BUCK8CTRL = 54,
	MAX77686_REG_BUCK8OUT = 55,
	MAX77686_REG_BUCK9CTRL = 56,
	MAX77686_REG_BUCK9OUT = 57,
	MAX77686_REG_LDO1CTRL1 = 64,
	MAX77686_REG_LDO2CTRL1 = 65,
	MAX77686_REG_LDO3CTRL1 = 66,
	MAX77686_REG_LDO4CTRL1 = 67,
	MAX77686_REG_LDO5CTRL1 = 68,
	MAX77686_REG_LDO6CTRL1 = 69,
	MAX77686_REG_LDO7CTRL1 = 70,
	MAX77686_REG_LDO8CTRL1 = 71,
	MAX77686_REG_LDO9CTRL1 = 72,
	MAX77686_REG_LDO10CTRL1 = 73,
	MAX77686_REG_LDO11CTRL1 = 74,
	MAX77686_REG_LDO12CTRL1 = 75,
	MAX77686_REG_LDO13CTRL1 = 76,
	MAX77686_REG_LDO14CTRL1 = 77,
	MAX77686_REG_LDO15CTRL1 = 78,
	MAX77686_REG_LDO16CTRL1 = 79,
	MAX77686_REG_LDO17CTRL1 = 80,
	MAX77686_REG_LDO18CTRL1 = 81,
	MAX77686_REG_LDO19CTRL1 = 82,
	MAX77686_REG_LDO20CTRL1 = 83,
	MAX77686_REG_LDO21CTRL1 = 84,
	MAX77686_REG_LDO22CTRL1 = 85,
	MAX77686_REG_LDO23CTRL1 = 86,
	MAX77686_REG_LDO24CTRL1 = 87,
	MAX77686_REG_LDO25CTRL1 = 88,
	MAX77686_REG_LDO26CTRL1 = 89,
	MAX77686_REG_LDO1CTRL2 = 96,
	MAX77686_REG_LDO2CTRL2 = 97,
	MAX77686_REG_LDO3CTRL2 = 98,
	MAX77686_REG_LDO4CTRL2 = 99,
	MAX77686_REG_LDO5CTRL2 = 100,
	MAX77686_REG_LDO6CTRL2 = 101,
	MAX77686_REG_LDO7CTRL2 = 102,
	MAX77686_REG_LDO8CTRL2 = 103,
	MAX77686_REG_LDO9CTRL2 = 104,
	MAX77686_REG_LDO10CTRL2 = 105,
	MAX77686_REG_LDO11CTRL2 = 106,
	MAX77686_REG_LDO12CTRL2 = 107,
	MAX77686_REG_LDO13CTRL2 = 108,
	MAX77686_REG_LDO14CTRL2 = 109,
	MAX77686_REG_LDO15CTRL2 = 110,
	MAX77686_REG_LDO16CTRL2 = 111,
	MAX77686_REG_LDO17CTRL2 = 112,
	MAX77686_REG_LDO18CTRL2 = 113,
	MAX77686_REG_LDO19CTRL2 = 114,
	MAX77686_REG_LDO20CTRL2 = 115,
	MAX77686_REG_LDO21CTRL2 = 116,
	MAX77686_REG_LDO22CTRL2 = 117,
	MAX77686_REG_LDO23CTRL2 = 118,
	MAX77686_REG_LDO24CTRL2 = 119,
	MAX77686_REG_LDO25CTRL2 = 120,
	MAX77686_REG_LDO26CTRL2 = 121,
	MAX77686_REG_BBAT_CHG = 126,
	MAX77686_REG_32KHZ = 127,
	MAX77686_REG_PMIC_END = 128,
};

enum max77802_pmic_reg {
	MAX77802_REG_DEVICE_ID = 0,
	MAX77802_REG_INTSRC = 1,
	MAX77802_REG_INT1 = 2,
	MAX77802_REG_INT2 = 3,
	MAX77802_REG_INT1MSK = 4,
	MAX77802_REG_INT2MSK = 5,
	MAX77802_REG_STATUS1 = 6,
	MAX77802_REG_STATUS2 = 7,
	MAX77802_REG_PWRON = 8,
	MAX77802_REG_MRSTB = 10,
	MAX77802_REG_EPWRHOLD = 11,
	MAX77802_REG_BOOSTCTRL = 14,
	MAX77802_REG_BOOSTOUT = 15,
	MAX77802_REG_BUCK1CTRL = 16,
	MAX77802_REG_BUCK1DVS1 = 17,
	MAX77802_REG_BUCK1DVS2 = 18,
	MAX77802_REG_BUCK1DVS3 = 19,
	MAX77802_REG_BUCK1DVS4 = 20,
	MAX77802_REG_BUCK1DVS5 = 21,
	MAX77802_REG_BUCK1DVS6 = 22,
	MAX77802_REG_BUCK1DVS7 = 23,
	MAX77802_REG_BUCK1DVS8 = 24,
	MAX77802_REG_BUCK2CTRL1 = 26,
	MAX77802_REG_BUCK2CTRL2 = 27,
	MAX77802_REG_BUCK2PHTRAN = 28,
	MAX77802_REG_BUCK2DVS1 = 29,
	MAX77802_REG_BUCK2DVS2 = 30,
	MAX77802_REG_BUCK2DVS3 = 31,
	MAX77802_REG_BUCK2DVS4 = 32,
	MAX77802_REG_BUCK2DVS5 = 33,
	MAX77802_REG_BUCK2DVS6 = 34,
	MAX77802_REG_BUCK2DVS7 = 35,
	MAX77802_REG_BUCK2DVS8 = 36,
	MAX77802_REG_BUCK3CTRL1 = 39,
	MAX77802_REG_BUCK3DVS1 = 40,
	MAX77802_REG_BUCK3DVS2 = 41,
	MAX77802_REG_BUCK3DVS3 = 42,
	MAX77802_REG_BUCK3DVS4 = 43,
	MAX77802_REG_BUCK3DVS5 = 44,
	MAX77802_REG_BUCK3DVS6 = 45,
	MAX77802_REG_BUCK3DVS7 = 46,
	MAX77802_REG_BUCK3DVS8 = 47,
	MAX77802_REG_BUCK4CTRL1 = 55,
	MAX77802_REG_BUCK4DVS1 = 56,
	MAX77802_REG_BUCK4DVS2 = 57,
	MAX77802_REG_BUCK4DVS3 = 58,
	MAX77802_REG_BUCK4DVS4 = 59,
	MAX77802_REG_BUCK4DVS5 = 60,
	MAX77802_REG_BUCK4DVS6 = 61,
	MAX77802_REG_BUCK4DVS7 = 62,
	MAX77802_REG_BUCK4DVS8 = 63,
	MAX77802_REG_BUCK5CTRL = 65,
	MAX77802_REG_BUCK5OUT = 66,
	MAX77802_REG_BUCK6CTRL = 68,
	MAX77802_REG_BUCK6DVS1 = 69,
	MAX77802_REG_BUCK6DVS2 = 70,
	MAX77802_REG_BUCK6DVS3 = 71,
	MAX77802_REG_BUCK6DVS4 = 72,
	MAX77802_REG_BUCK6DVS5 = 73,
	MAX77802_REG_BUCK6DVS6 = 74,
	MAX77802_REG_BUCK6DVS7 = 75,
	MAX77802_REG_BUCK6DVS8 = 76,
	MAX77802_REG_BUCK7CTRL = 78,
	MAX77802_REG_BUCK7OUT = 79,
	MAX77802_REG_BUCK8CTRL = 81,
	MAX77802_REG_BUCK8OUT = 82,
	MAX77802_REG_BUCK9CTRL = 84,
	MAX77802_REG_BUCK9OUT = 85,
	MAX77802_REG_BUCK10CTRL = 87,
	MAX77802_REG_BUCK10OUT = 88,
	MAX77802_REG_LDO1CTRL1 = 96,
	MAX77802_REG_LDO2CTRL1 = 97,
	MAX77802_REG_LDO3CTRL1 = 98,
	MAX77802_REG_LDO4CTRL1 = 99,
	MAX77802_REG_LDO5CTRL1 = 100,
	MAX77802_REG_LDO6CTRL1 = 101,
	MAX77802_REG_LDO7CTRL1 = 102,
	MAX77802_REG_LDO8CTRL1 = 103,
	MAX77802_REG_LDO9CTRL1 = 104,
	MAX77802_REG_LDO10CTRL1 = 105,
	MAX77802_REG_LDO11CTRL1 = 106,
	MAX77802_REG_LDO12CTRL1 = 107,
	MAX77802_REG_LDO13CTRL1 = 108,
	MAX77802_REG_LDO14CTRL1 = 109,
	MAX77802_REG_LDO15CTRL1 = 110,
	MAX77802_REG_LDO17CTRL1 = 112,
	MAX77802_REG_LDO18CTRL1 = 113,
	MAX77802_REG_LDO19CTRL1 = 114,
	MAX77802_REG_LDO20CTRL1 = 115,
	MAX77802_REG_LDO21CTRL1 = 116,
	MAX77802_REG_LDO22CTRL1 = 117,
	MAX77802_REG_LDO23CTRL1 = 118,
	MAX77802_REG_LDO24CTRL1 = 119,
	MAX77802_REG_LDO25CTRL1 = 120,
	MAX77802_REG_LDO26CTRL1 = 121,
	MAX77802_REG_LDO27CTRL1 = 122,
	MAX77802_REG_LDO28CTRL1 = 123,
	MAX77802_REG_LDO29CTRL1 = 124,
	MAX77802_REG_LDO30CTRL1 = 125,
	MAX77802_REG_LDO32CTRL1 = 127,
	MAX77802_REG_LDO33CTRL1 = 128,
	MAX77802_REG_LDO34CTRL1 = 129,
	MAX77802_REG_LDO35CTRL1 = 130,
	MAX77802_REG_LDO1CTRL2 = 144,
	MAX77802_REG_LDO2CTRL2 = 145,
	MAX77802_REG_LDO3CTRL2 = 146,
	MAX77802_REG_LDO4CTRL2 = 147,
	MAX77802_REG_LDO5CTRL2 = 148,
	MAX77802_REG_LDO6CTRL2 = 149,
	MAX77802_REG_LDO7CTRL2 = 150,
	MAX77802_REG_LDO8CTRL2 = 151,
	MAX77802_REG_LDO9CTRL2 = 152,
	MAX77802_REG_LDO10CTRL2 = 153,
	MAX77802_REG_LDO11CTRL2 = 154,
	MAX77802_REG_LDO12CTRL2 = 155,
	MAX77802_REG_LDO13CTRL2 = 156,
	MAX77802_REG_LDO14CTRL2 = 157,
	MAX77802_REG_LDO15CTRL2 = 158,
	MAX77802_REG_LDO17CTRL2 = 160,
	MAX77802_REG_LDO18CTRL2 = 161,
	MAX77802_REG_LDO19CTRL2 = 162,
	MAX77802_REG_LDO20CTRL2 = 163,
	MAX77802_REG_LDO21CTRL2 = 164,
	MAX77802_REG_LDO22CTRL2 = 165,
	MAX77802_REG_LDO23CTRL2 = 166,
	MAX77802_REG_LDO24CTRL2 = 167,
	MAX77802_REG_LDO25CTRL2 = 168,
	MAX77802_REG_LDO26CTRL2 = 169,
	MAX77802_REG_LDO27CTRL2 = 170,
	MAX77802_REG_LDO28CTRL2 = 171,
	MAX77802_REG_LDO29CTRL2 = 172,
	MAX77802_REG_LDO30CTRL2 = 173,
	MAX77802_REG_LDO32CTRL2 = 175,
	MAX77802_REG_LDO33CTRL2 = 176,
	MAX77802_REG_LDO34CTRL2 = 177,
	MAX77802_REG_LDO35CTRL2 = 178,
	MAX77802_REG_BBAT_CHG = 180,
	MAX77802_REG_32KHZ = 181,
	MAX77802_REG_PMIC_END = 182,
};

enum max77686_irq_source {
	PMIC_INT1 = 0,
	PMIC_INT2 = 1,
	RTC_INT = 2,
	MAX77686_IRQ_GROUP_NR = 3,
};

enum max77686_chip_name {
	CHIP_MAX77686 = 0,
	CHIP_MAX77802 = 1,
	CHIP_MAX77620 = 2,
};

struct max77686_hw_clk_info {
	const char *name;
	u32 clk_reg;
	u32 clk_enable_mask;
	u32 flags;
};

struct max77686_clk_init_data {
	struct regmap *regmap;
	struct clk_hw hw;
	struct clk_init_data clk_idata;
	const struct max77686_hw_clk_info *clk_info;
};

struct max77686_clk_driver_data {
	enum max77686_chip_name chip;
	struct max77686_clk_init_data *max_clk_data;
	size_t num_clks;
};

struct m10v_clk_div_factors {
	const char *name;
	const char *parent_name;
	u32 offset;
	u8 shift;
	u8 width;
	const struct clk_div_table *table;
	long unsigned int div_flags;
	int onecell_idx;
};

struct m10v_clk_div_fixed_data {
	const char *name;
	const char *parent_name;
	u8 div;
	u8 mult;
	int onecell_idx;
};

struct m10v_clk_mux_factors {
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	u32 offset;
	u8 shift;
	u8 mask;
	u32 *table;
	long unsigned int mux_flags;
	int onecell_idx;
};

struct m10v_clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
	void *write_valid_reg;
};

struct ccsr_guts {
	u32 porpllsr;
	u32 porbmsr;
	u32 porimpscr;
	u32 pordevsr;
	u32 pordbgmsr;
	u32 pordevsr2;
	u8 res018[8];
	u32 porcir;
	u8 res024[12];
	u32 gpiocr;
	u8 res034[12];
	u32 gpoutdr;
	u8 res044[12];
	u32 gpindr;
	u8 res054[12];
	u32 pmuxcr;
	u32 pmuxcr2;
	u32 dmuxcr;
	u8 res06c[4];
	u32 devdisr;
	u32 devdisr2;
	u8 res078[4];
	u32 pmjcr;
	u32 powmgtcsr;
	u32 pmrccr;
	u32 pmpdccr;
	u32 pmcdr;
	u32 mcpsumr;
	u32 rstrscr;
	u32 ectrstcr;
	u32 autorstsr;
	u32 pvr;
	u32 svr;
	u8 res0a8[8];
	u32 rstcr;
	u8 res0b4[12];
	u32 iovselsr;
	u8 res0c4[60];
	u32 rcwsr[16];
	u8 res140[228];
	u32 iodelay1;
	u32 iodelay2;
	u8 res22c[984];
	u32 pamubypenr;
	u8 res608[504];
	u32 clkdvdr;
	u8 res804[252];
	u32 ircr;
	u8 res904[4];
	u32 dmacr;
	u8 res90c[8];
	u32 elbccr;
	u8 res918[520];
	u32 ddr1clkdr;
	u32 ddr2clkdr;
	u32 ddrclkdr;
	u8 resb2c[724];
	u32 clkocr;
	u8 rese04[12];
	u32 ddrdllcr;
	u8 rese14[12];
	u32 lbcdllcr;
	u32 cpfor;
	u8 rese28[220];
	u32 srds1cr0;
	u32 srds1cr1;
	u8 resf0c[32];
	u32 itcr;
	u8 resf30[16];
	u32 srds2cr0;
	u32 srds2cr1;
};

struct clockgen_pll_div {
	struct clk *clk;
	char name[32];
};

struct clockgen_pll {
	struct clockgen_pll_div div[32];
};

struct clockgen_sourceinfo {
	u32 flags;
	int pll;
	int div;
};

struct clockgen_muxinfo {
	struct clockgen_sourceinfo clksel[16];
};

struct clockgen;

struct clockgen_chipinfo {
	const char *compat;
	const char *guts_compat;
	const struct clockgen_muxinfo *cmux_groups[2];
	const struct clockgen_muxinfo *hwaccel[5];
	void (*init_periph)(struct clockgen *);
	int cmux_to_group[9];
	u32 pll_mask;
	u32 flags;
};

struct clockgen {
	struct device_node *node;
	void *regs;
	struct clockgen_chipinfo info;
	struct clk *sysclk;
	struct clk *coreclk;
	struct clockgen_pll pll[6];
	struct clk *cmux[8];
	struct clk *hwaccel[5];
	struct clk *fman[2];
	struct ccsr_guts *guts;
};

struct mux_hwclock {
	struct clk_hw hw;
	struct clockgen *cg;
	const struct clockgen_muxinfo *info;
	u32 *reg;
	u8 parent_to_clksel[16];
	s8 clksel_to_parent[16];
	int num_parents;
};

struct stm32_mmux {
	u8 nbr_clk;
	struct clk_hw *hws[2];
};

struct stm32_clk_mmux {
	struct clk_mux mux;
	struct stm32_mmux *mmux;
};

struct stm32_mgate {
	u8 nbr_clk;
	u32 flag;
};

struct stm32_clk_mgate {
	struct clk_gate gate;
	struct stm32_mgate *mgate;
	u32 mask;
};

struct clock_config {
	u32 id;
	const char *name;
	const char *parent_name;
	const char * const *parent_names;
	int num_parents;
	long unsigned int flags;
	void *cfg;
	struct clk_hw * (*func)(struct device *, struct clk_hw_onecell_data *, void *, spinlock_t *, const struct clock_config *);
};

struct gate_cfg {
	u32 reg_off;
	u8 bit_idx;
	u8 gate_flags;
};

struct fixed_factor_cfg {
	unsigned int mult;
	unsigned int div;
};

struct div_cfg {
	u32 reg_off;
	u8 shift;
	u8 width;
	u8 div_flags;
	const struct clk_div_table *table;
};

struct mux_cfg {
	u32 reg_off;
	u8 shift;
	u8 width;
	u8 mux_flags;
	u32 *table;
};

struct stm32_gate_cfg {
	struct gate_cfg *gate;
	struct stm32_mgate *mgate;
	const struct clk_ops *ops;
};

struct stm32_div_cfg {
	struct div_cfg *div;
	const struct clk_ops *ops;
};

struct stm32_mux_cfg {
	struct mux_cfg *mux;
	struct stm32_mmux *mmux;
	const struct clk_ops *ops;
};

struct stm32_composite_cfg {
	const struct stm32_gate_cfg *gate;
	const struct stm32_div_cfg *div;
	const struct stm32_mux_cfg *mux;
};

struct stm32_pll_obj {
	spinlock_t *lock;
	void *reg;
	struct clk_hw hw;
};

struct timer_cker {
	spinlock_t *lock;
	void *apbdiv;
	void *timpre;
	struct clk_hw hw;
};

struct stm32_pll_cfg {
	u32 offset;
};

struct stm32_cktim_cfg {
	u32 offset_apbdiv;
	u32 offset_timpre;
};

enum {
	G_SAI1 = 0,
	G_SAI2 = 1,
	G_SAI3 = 2,
	G_SAI4 = 3,
	G_SPI1 = 4,
	G_SPI2 = 5,
	G_SPI3 = 6,
	G_SPI4 = 7,
	G_SPI5 = 8,
	G_SPI6 = 9,
	G_SPDIF = 10,
	G_I2C1 = 11,
	G_I2C2 = 12,
	G_I2C3 = 13,
	G_I2C4 = 14,
	G_I2C5 = 15,
	G_I2C6 = 16,
	G_USART2 = 17,
	G_UART4 = 18,
	G_USART3 = 19,
	G_UART5 = 20,
	G_USART1 = 21,
	G_USART6 = 22,
	G_UART7 = 23,
	G_UART8 = 24,
	G_LPTIM1 = 25,
	G_LPTIM2 = 26,
	G_LPTIM3 = 27,
	G_LPTIM4 = 28,
	G_LPTIM5 = 29,
	G_LTDC = 30,
	G_DSI = 31,
	G_QSPI = 32,
	G_FMC = 33,
	G_SDMMC1 = 34,
	G_SDMMC2 = 35,
	G_SDMMC3 = 36,
	G_USBO = 37,
	G_USBPHY = 38,
	G_RNG1 = 39,
	G_RNG2 = 40,
	G_FDCAN = 41,
	G_DAC12 = 42,
	G_CEC = 43,
	G_ADC12 = 44,
	G_GPU = 45,
	G_STGEN = 46,
	G_DFSDM = 47,
	G_ADFSDM = 48,
	G_TIM2 = 49,
	G_TIM3 = 50,
	G_TIM4 = 51,
	G_TIM5 = 52,
	G_TIM6 = 53,
	G_TIM7 = 54,
	G_TIM12 = 55,
	G_TIM13 = 56,
	G_TIM14 = 57,
	G_MDIO = 58,
	G_TIM1 = 59,
	G_TIM8 = 60,
	G_TIM15 = 61,
	G_TIM16 = 62,
	G_TIM17 = 63,
	G_SYSCFG = 64,
	G_VREF = 65,
	G_TMPSENS = 66,
	G_PMBCTRL = 67,
	G_HDP = 68,
	G_IWDG2 = 69,
	G_STGENRO = 70,
	G_DMA1 = 71,
	G_DMA2 = 72,
	G_DMAMUX = 73,
	G_DCMI = 74,
	G_CRYP2 = 75,
	G_HASH2 = 76,
	G_CRC2 = 77,
	G_HSEM = 78,
	G_IPCC = 79,
	G_GPIOA = 80,
	G_GPIOB = 81,
	G_GPIOC = 82,
	G_GPIOD = 83,
	G_GPIOE = 84,
	G_GPIOF = 85,
	G_GPIOG = 86,
	G_GPIOH = 87,
	G_GPIOI = 88,
	G_GPIOJ = 89,
	G_GPIOK = 90,
	G_MDMA = 91,
	G_ETHCK = 92,
	G_ETHTX = 93,
	G_ETHRX = 94,
	G_ETHMAC = 95,
	G_CRC1 = 96,
	G_USBH = 97,
	G_ETHSTP = 98,
	G_RTCAPB = 99,
	G_TZC1 = 100,
	G_TZC2 = 101,
	G_TZPC = 102,
	G_IWDG1 = 103,
	G_BSEC = 104,
	G_GPIOZ = 105,
	G_CRYP1 = 106,
	G_HASH1 = 107,
	G_BKPSRAM = 108,
	G_DDRPERFM = 109,
	G_LAST = 110,
};

enum {
	M_SDMMC12 = 0,
	M_SDMMC3 = 1,
	M_FMC = 2,
	M_QSPI = 3,
	M_RNG1 = 4,
	M_RNG2 = 5,
	M_USBPHY = 6,
	M_USBO = 7,
	M_STGEN = 8,
	M_SPDIF = 9,
	M_SPI1 = 10,
	M_SPI23 = 11,
	M_SPI45 = 12,
	M_SPI6 = 13,
	M_CEC = 14,
	M_I2C12 = 15,
	M_I2C35 = 16,
	M_I2C46 = 17,
	M_LPTIM1 = 18,
	M_LPTIM23 = 19,
	M_LPTIM45 = 20,
	M_USART1 = 21,
	M_UART24 = 22,
	M_UART35 = 23,
	M_USART6 = 24,
	M_UART78 = 25,
	M_SAI1 = 26,
	M_SAI2 = 27,
	M_SAI3 = 28,
	M_SAI4 = 29,
	M_DSI = 30,
	M_FDCAN = 31,
	M_ADC12 = 32,
	M_ETHCK = 33,
	M_CKPER = 34,
	M_LAST = 35,
};

struct stm32_clock_match_data {
	const struct clock_config *cfg;
	unsigned int num;
	unsigned int maxbinding;
};

struct clk_device {
	struct clk_hw hw;
	void *div_reg;
	unsigned int div_mask;
	void *en_reg;
	int en_bit;
	spinlock_t *lock;
};

struct clk_pll {
	struct clk_hw hw;
	void *reg;
	spinlock_t *lock;
	int type;
};

struct pmc_data {
	unsigned int ncore;
	struct clk_hw **chws;
	unsigned int nsystem;
	struct clk_hw **shws;
	unsigned int nperiph;
	struct clk_hw **phws;
	unsigned int ngck;
	struct clk_hw **ghws;
	unsigned int npck;
	struct clk_hw **pchws;
	struct clk_hw *hwtable[0];
};

struct clk_range {
	long unsigned int min;
	long unsigned int max;
};

struct clk_slow_bits {
	u32 cr_rcen;
	u32 cr_osc32en;
	u32 cr_osc32byp;
	u32 cr_oscsel;
};

struct clk_slow_osc {
	struct clk_hw hw;
	void *sckcr;
	const struct clk_slow_bits *bits;
	long unsigned int startup_usec;
};

struct clk_sama5d4_slow_osc {
	struct clk_hw hw;
	void *sckcr;
	const struct clk_slow_bits *bits;
	long unsigned int startup_usec;
	bool prepared;
};

struct clk_slow_rc_osc {
	struct clk_hw hw;
	void *sckcr;
	const struct clk_slow_bits *bits;
	long unsigned int frequency;
	long unsigned int accuracy;
	long unsigned int startup_usec;
};

struct clk_sam9x5_slow {
	struct clk_hw hw;
	void *sckcr;
	const struct clk_slow_bits *bits;
	u8 parent;
};

struct clk_master_layout {
	u32 offset;
	u32 mask;
	u8 pres_shift;
};

struct clk_master_characteristics {
	struct clk_range output;
	u32 divisors[5];
	u8 have_div3_pres;
};

struct clk_pll_layout {
	u32 pllr_mask;
	u32 mul_mask;
	u32 frac_mask;
	u32 div_mask;
	u32 endiv_mask;
	u8 mul_shift;
	u8 frac_shift;
	u8 div_shift;
	u8 endiv_shift;
};

struct clk_pll_characteristics {
	struct clk_range input;
	int num_output;
	const struct clk_range *output;
	u16 *icpll;
	u8 *out;
	u8 upll: 1;
};

struct clk_programmable_layout {
	u8 pres_mask;
	u8 pres_shift;
	u8 css_mask;
	u8 have_slck_mck;
	u8 is_pres_direct;
};

struct clk_pcr_layout {
	u32 offset;
	u32 cmd;
	u32 div_mask;
	u32 gckcss_mask;
	u32 pid_mask;
};

struct clk_sam9260_slow {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct clk_main_osc {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct clk_main_rc_osc {
	struct clk_hw hw;
	struct regmap *regmap;
	long unsigned int frequency;
	long unsigned int accuracy;
};

struct clk_rm9200_main {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct clk_sam9x5_main {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 parent;
};

struct clk_pll___2 {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 id;
	u8 div;
	u8 range;
	u16 mul;
	const struct clk_pll_layout *layout;
	const struct clk_pll_characteristics *characteristics;
};

struct clk_plldiv {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct clk_master {
	struct clk_hw hw;
	struct regmap *regmap;
	spinlock_t *lock;
	const struct clk_master_layout *layout;
	const struct clk_master_characteristics *characteristics;
	u32 *mux_table;
	u32 mckr;
	int chg_pid;
	u8 id;
	u8 parent;
	u8 div;
};

struct clk_system {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 id;
};

struct clk_peripheral {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 id;
};

struct clk_sam9x5_peripheral {
	struct clk_hw hw;
	struct regmap *regmap;
	struct clk_range range;
	spinlock_t *lock;
	u32 id;
	u32 div;
	const struct clk_pcr_layout *layout;
	bool auto_div;
	int chg_pid;
};

struct clk_programmable {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 *mux_table;
	u8 id;
	const struct clk_programmable_layout *layout;
};

struct clk_audio_frac {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 fracr;
	u8 nd;
};

struct clk_audio_pad {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 qdaudio;
	u8 div;
};

struct clk_audio_pmc {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 qdpmc;
};

struct clk_utmi {
	struct clk_hw hw;
	struct regmap *regmap_pmc;
	struct regmap *regmap_sfr;
};

struct at91sam9x5_clk_usb {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 usbs_mask;
	u8 num_parents;
};

struct at91rm9200_clk_usb {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 divisors[4];
};

struct at91sam9x5_clk_smd {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct clk_sama5d4_h32mx {
	struct clk_hw hw;
	struct regmap *regmap;
};

struct clk_generated {
	struct clk_hw hw;
	struct regmap *regmap;
	struct clk_range range;
	spinlock_t *lock;
	u32 *mux_table;
	u32 id;
	u32 gckdiv;
	const struct clk_pcr_layout *layout;
	u8 parent_id;
	int chg_pid;
};

struct clk_i2s_mux {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 bus_id;
};

struct artpec6_clkctrl_drvdata {
	struct clk *clk_table[20];
	void *syscon_base;
	struct clk_onecell_data clk_data;
	spinlock_t i2scfg_lock;
};

enum bcm_clk_type {
	bcm_clk_none = 0,
	bcm_clk_bus = 1,
	bcm_clk_core = 2,
	bcm_clk_peri = 3,
};

struct bcm_clk_policy {
	u32 offset;
	u32 bit;
};

struct bcm_clk_gate {
	u32 offset;
	u32 status_bit;
	u32 en_bit;
	u32 hw_sw_sel_bit;
	u32 flags;
};

struct bcm_clk_hyst {
	u32 offset;
	u32 en_bit;
	u32 val_bit;
};

struct bcm_clk_div {
	union {
		struct {
			u32 offset;
			u32 shift;
			u32 width;
			u32 frac_width;
			u64 scaled_div;
		} s;
		u32 fixed;
	} u;
	u32 flags;
	int: 32;
};

struct bcm_clk_sel {
	u32 offset;
	u32 shift;
	u32 width;
	u32 parent_count;
	u32 *parent_sel;
	u8 clk_index;
};

struct bcm_clk_trig {
	u32 offset;
	u32 bit;
	u32 flags;
};

struct peri_clk_data {
	struct bcm_clk_policy policy;
	struct bcm_clk_gate gate;
	struct bcm_clk_hyst hyst;
	struct bcm_clk_trig pre_trig;
	int: 32;
	struct bcm_clk_div pre_div;
	struct bcm_clk_trig trig;
	int: 32;
	struct bcm_clk_div div;
	struct bcm_clk_sel sel;
	const char *clocks[0];
};

struct ccu_data;

struct kona_clk {
	struct clk_hw hw;
	struct clk_init_data init_data;
	struct ccu_data *ccu;
	enum bcm_clk_type type;
	union {
		void *data;
		struct peri_clk_data *peri;
	} u;
};

struct bcm_lvm_en {
	u32 offset;
	u32 bit;
};

struct bcm_policy_ctl {
	u32 offset;
	u32 go_bit;
	u32 atl_bit;
	u32 ac_bit;
};

struct ccu_policy {
	struct bcm_lvm_en enable;
	struct bcm_policy_ctl control;
};

struct ccu_data {
	void *base;
	spinlock_t lock;
	bool write_enabled;
	struct ccu_policy policy;
	struct device_node *node;
	size_t clk_num;
	const char *name;
	u32 range;
	struct kona_clk kona_clks[0];
};

enum iproc_arm_pll_fid {
	ARM_PLL_FID_CRYSTAL_CLK = 0,
	ARM_PLL_FID_SYS_CLK = 2,
	ARM_PLL_FID_CH0_SLOW_CLK = 6,
	ARM_PLL_FID_CH1_FAST_CLK = 7,
};

struct iproc_arm_pll {
	struct clk_hw hw;
	void *base;
	long unsigned int rate;
};

struct iproc_pll_vco_param {
	long unsigned int rate;
	unsigned int ndiv_int;
	unsigned int ndiv_frac;
	unsigned int pdiv;
};

struct iproc_clk_reg_op {
	unsigned int offset;
	unsigned int shift;
	unsigned int width;
};

struct iproc_asiu_gate {
	unsigned int offset;
	unsigned int en_shift;
};

struct iproc_pll_aon_pwr_ctrl {
	unsigned int offset;
	unsigned int pwr_width;
	unsigned int pwr_shift;
	unsigned int iso_shift;
};

struct iproc_pll_reset_ctrl {
	unsigned int offset;
	unsigned int reset_shift;
	unsigned int p_reset_shift;
};

struct iproc_pll_dig_filter_ctrl {
	unsigned int offset;
	unsigned int ki_shift;
	unsigned int ki_width;
	unsigned int kp_shift;
	unsigned int kp_width;
	unsigned int ka_shift;
	unsigned int ka_width;
};

struct iproc_pll_sw_ctrl {
	unsigned int offset;
	unsigned int shift;
};

struct iproc_pll_vco_ctrl {
	unsigned int u_offset;
	unsigned int l_offset;
};

struct iproc_pll_ctrl {
	long unsigned int flags;
	struct iproc_pll_aon_pwr_ctrl aon;
	struct iproc_asiu_gate asiu;
	struct iproc_pll_reset_ctrl reset;
	struct iproc_pll_dig_filter_ctrl dig_filter;
	struct iproc_pll_sw_ctrl sw_ctrl;
	struct iproc_clk_reg_op ndiv_int;
	struct iproc_clk_reg_op ndiv_frac;
	struct iproc_clk_reg_op pdiv;
	struct iproc_pll_vco_ctrl vco_ctrl;
	struct iproc_clk_reg_op status;
	struct iproc_clk_reg_op macro_mode;
};

struct iproc_clk_enable_ctrl {
	unsigned int offset;
	unsigned int enable_shift;
	unsigned int hold_shift;
	unsigned int bypass_shift;
};

struct iproc_clk_ctrl {
	unsigned int channel;
	long unsigned int flags;
	struct iproc_clk_enable_ctrl enable;
	struct iproc_clk_reg_op mdiv;
};

enum kp_band {
	KP_BAND_MID = 0,
	KP_BAND_HIGH = 1,
	KP_BAND_HIGH_HIGH = 2,
};

enum vco_freq_range {
	VCO_LOW = 700000000,
	VCO_MID = 1200000000,
	VCO_HIGH = 2200000000,
	VCO_HIGH_HIGH = 3100000000,
	VCO_MAX = 4000000000,
};

struct iproc_pll {
	void *status_base;
	void *control_base;
	void *pwr_base;
	void *asiu_base;
	const struct iproc_pll_ctrl *ctrl;
	const struct iproc_pll_vco_param *vco_param;
	unsigned int num_vco_entries;
};

struct iproc_clk {
	struct clk_hw hw;
	struct iproc_pll *pll;
	const struct iproc_clk_ctrl *ctrl;
};

struct iproc_asiu_div {
	unsigned int offset;
	unsigned int en_shift;
	unsigned int high_shift;
	unsigned int high_width;
	unsigned int low_shift;
	unsigned int low_width;
};

struct iproc_asiu;

struct iproc_asiu_clk {
	struct clk_hw hw;
	const char *name;
	struct iproc_asiu *asiu;
	long unsigned int rate;
	struct iproc_asiu_div div;
	struct iproc_asiu_gate gate;
};

struct iproc_asiu {
	void *div_base;
	void *gate_base;
	struct clk_hw_onecell_data *clk_data;
	struct iproc_asiu_clk *clks;
};

struct reset_simple_data {
	spinlock_t lock;
	void *membase;
	struct reset_controller_dev rcdev;
	bool active_low;
	bool status_active_low;
	unsigned int reset_us;
};

struct clk_dvp {
	struct clk_hw_onecell_data *data;
	struct reset_simple_data reset;
};

struct bcm2835_cprman {
	struct device *dev;
	void *regs;
	spinlock_t regs_lock;
	unsigned int soc;
	const char *real_parent_names[7];
	struct clk_hw_onecell_data onecell;
};

struct cprman_plat_data {
	unsigned int soc;
};

struct bcm2835_pll_ana_bits;

struct bcm2835_pll_data {
	const char *name;
	u32 cm_ctrl_reg;
	u32 a2w_ctrl_reg;
	u32 frac_reg;
	u32 ana_reg_base;
	u32 reference_enable_mask;
	u32 lock_mask;
	u32 flags;
	const struct bcm2835_pll_ana_bits *ana;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int max_fb_rate;
};

struct bcm2835_pll_ana_bits {
	u32 mask0;
	u32 set0;
	u32 mask1;
	u32 set1;
	u32 mask3;
	u32 set3;
	u32 fb_prediv_mask;
};

struct bcm2835_pll_divider_data {
	const char *name;
	const char *source_pll;
	u32 cm_reg;
	u32 a2w_reg;
	u32 load_mask;
	u32 hold_mask;
	u32 fixed_divider;
	u32 flags;
};

struct bcm2835_clock_data {
	const char *name;
	const char * const *parents;
	int num_mux_parents;
	unsigned int set_rate_parent;
	u32 ctl_reg;
	u32 div_reg;
	u32 int_bits;
	u32 frac_bits;
	u32 flags;
	bool is_vpu_clock;
	bool is_mash_clock;
	bool low_jitter;
	u32 tcnt_mux;
};

struct bcm2835_gate_data {
	const char *name;
	const char *parent;
	u32 ctl_reg;
};

struct bcm2835_pll {
	struct clk_hw hw;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_pll_data *data;
};

struct bcm2835_pll_divider {
	struct clk_divider div;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_pll_divider_data *data;
};

struct bcm2835_clock {
	struct clk_hw hw;
	struct bcm2835_cprman *cprman;
	const struct bcm2835_clock_data *data;
};

struct bcm2835_clk_desc {
	struct clk_hw * (*clk_register)(struct bcm2835_cprman *, const void *);
	unsigned int supported;
	const void *data;
};

enum rpi_firmware_clk_id {
	RPI_FIRMWARE_EMMC_CLK_ID = 1,
	RPI_FIRMWARE_UART_CLK_ID = 2,
	RPI_FIRMWARE_ARM_CLK_ID = 3,
	RPI_FIRMWARE_CORE_CLK_ID = 4,
	RPI_FIRMWARE_V3D_CLK_ID = 5,
	RPI_FIRMWARE_H264_CLK_ID = 6,
	RPI_FIRMWARE_ISP_CLK_ID = 7,
	RPI_FIRMWARE_SDRAM_CLK_ID = 8,
	RPI_FIRMWARE_PIXEL_CLK_ID = 9,
	RPI_FIRMWARE_PWM_CLK_ID = 10,
	RPI_FIRMWARE_HEVC_CLK_ID = 11,
	RPI_FIRMWARE_EMMC2_CLK_ID = 12,
	RPI_FIRMWARE_M2MC_CLK_ID = 13,
	RPI_FIRMWARE_PIXEL_BVB_CLK_ID = 14,
	RPI_FIRMWARE_NUM_CLK_ID = 15,
};

struct raspberrypi_clk {
	struct device *dev;
	struct rpi_firmware *firmware;
	struct platform_device *cpufreq;
};

struct raspberrypi_clk_data {
	struct clk_hw hw;
	unsigned int id;
	struct raspberrypi_clk *rpi;
};

struct raspberrypi_firmware_prop {
	__le32 id;
	__le32 val;
	__le32 disable_turbo;
};

struct rpi_firmware_get_clocks_response {
	u32 parent;
	u32 id;
};

struct berlin2_avpll_vco {
	struct clk_hw hw;
	void *base;
	u8 flags;
};

struct berlin2_avpll_channel {
	struct clk_hw hw;
	void *base;
	u8 flags;
	u8 index;
};

struct berlin2_pll_map {
	const u8 vcodiv[16];
	u8 mult;
	u8 fbdiv_shift;
	u8 rfdiv_shift;
	u8 divsel_shift;
};

struct berlin2_pll {
	struct clk_hw hw;
	void *base;
	struct berlin2_pll_map map;
};

struct berlin2_div_map {
	u16 pll_select_offs;
	u16 pll_switch_offs;
	u16 div_select_offs;
	u16 div_switch_offs;
	u16 div3_switch_offs;
	u16 gate_offs;
	u8 pll_select_shift;
	u8 pll_switch_shift;
	u8 div_select_shift;
	u8 div_switch_shift;
	u8 div3_switch_shift;
	u8 gate_shift;
};

struct berlin2_div {
	struct clk_hw hw;
	void *base;
	struct berlin2_div_map map;
	spinlock_t *lock;
};

struct berlin2_div_data {
	const char *name;
	const u8 *parent_ids;
	int num_parents;
	long unsigned int flags;
	struct berlin2_div_map map;
	u8 div_flags;
};

struct berlin2_gate_data {
	const char *name;
	const char *parent_name;
	u8 bit_idx;
	long unsigned int flags;
};

enum {
	REFCLK = 0,
	VIDEO_EXT0 = 1,
	SYSPLL = 2,
	MEMPLL = 3,
	CPUPLL = 4,
	AVPLL_A1 = 5,
	AVPLL_A2 = 6,
	AVPLL_A3 = 7,
	AVPLL_A4 = 8,
	AVPLL_A5 = 9,
	AVPLL_A6 = 10,
	AVPLL_A7 = 11,
	AVPLL_A8 = 12,
	AVPLL_B1 = 13,
	AVPLL_B2 = 14,
	AVPLL_B3 = 15,
	AVPLL_B4 = 16,
	AVPLL_B5 = 17,
	AVPLL_B6 = 18,
	AVPLL_B7 = 19,
	AVPLL_B8 = 20,
	AUDIO1_PLL = 21,
	AUDIO_FAST_PLL = 22,
	VIDEO0_PLL = 23,
	VIDEO0_IN = 24,
	VIDEO1_PLL = 25,
	VIDEO1_IN = 26,
	VIDEO2_PLL = 27,
	VIDEO2_IN = 28,
};

enum {
	REFCLK___2 = 0,
	SYSPLL___2 = 1,
	CPUPLL___2 = 2,
	AVPLL_B1___2 = 3,
	AVPLL_B2___2 = 4,
	AVPLL_B3___2 = 5,
	AVPLL_B4___2 = 6,
	AVPLL_B5___2 = 7,
	AVPLL_B6___2 = 8,
	AVPLL_B7___2 = 9,
	AVPLL_B8___2 = 10,
};

struct hisi_clock_data {
	struct clk_onecell_data clk_data;
	void *base;
};

struct hisi_fixed_rate_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int fixed_rate;
};

struct hisi_fixed_factor_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int mult;
	long unsigned int div;
	long unsigned int flags;
};

struct hisi_mux_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 mux_flags;
	u32 *table;
	const char *alias;
};

struct hisi_phase_clock {
	unsigned int id;
	const char *name;
	const char *parent_names;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u32 *phase_degrees;
	u32 *phase_regvals;
	u8 phase_num;
};

struct hisi_divider_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
	const char *alias;
};

struct hi6220_divider_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u32 mask_bit;
	const char *alias;
};

struct hisi_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 bit_idx;
	u8 gate_flags;
	const char *alias;
};

struct clkgate_separated {
	struct clk_hw hw;
	void *enable;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct hi6220_clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u32 mask;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

struct clk_hisi_phase {
	struct clk_hw hw;
	void *reg;
	u32 *phase_degrees;
	u32 *phase_regvals;
	u8 phase_num;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct hisi_mmc_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	u32 clken_reg;
	u32 clken_bit;
	u32 div_reg;
	u32 div_off;
	u32 div_bits;
	u32 drv_reg;
	u32 drv_off;
	u32 drv_bits;
	u32 sam_reg;
	u32 sam_off;
	u32 sam_bits;
};

struct clk_mmc {
	struct clk_hw hw;
	u32 id;
	void *clken_reg;
	u32 clken_bit;
	void *div_reg;
	u32 div_off;
	u32 div_bits;
	void *drv_reg;
	u32 drv_off;
	u32 drv_bits;
	void *sam_reg;
	u32 sam_off;
	u32 sam_bits;
};

enum hix5hd2_clk_type {
	TYPE_COMPLEX = 0,
	TYPE_ETHER = 1,
};

struct hix5hd2_complex_clock {
	const char *name;
	const char *parent_name;
	u32 id;
	u32 ctrl_reg;
	u32 ctrl_clk_mask;
	u32 ctrl_rst_mask;
	u32 phy_reg;
	u32 phy_clk_mask;
	u32 phy_rst_mask;
	enum hix5hd2_clk_type type;
};

struct hix5hd2_clk_complex {
	struct clk_hw hw;
	u32 id;
	void *ctrl_reg;
	u32 ctrl_clk_mask;
	u32 ctrl_rst_mask;
	void *phy_reg;
	u32 phy_clk_mask;
	u32 phy_rst_mask;
};

struct hisi_crg_funcs {
	struct hisi_clock_data * (*register_clks)(struct platform_device *);
	void (*unregister_clks)(struct platform_device *);
};

struct hisi_reset_controller;

struct hisi_crg_dev {
	struct hisi_clock_data *clk_data;
	struct hisi_reset_controller *rstc;
	const struct hisi_crg_funcs *funcs;
};

struct hi3519_crg_data {
	struct hisi_clock_data *clk_data;
	struct hisi_reset_controller *rstc;
};

struct hisi_reset_controller___2 {
	spinlock_t lock;
	void *membase;
	struct reset_controller_dev rcdev;
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct mbox_chan;

struct hi6220_stub_clk {
	u32 id;
	struct device *dev;
	struct clk_hw hw;
	struct regmap *dfs_map;
	struct mbox_client cl;
	struct mbox_chan *mbox;
};

struct hi6220_mbox_msg {
	unsigned char type;
	unsigned char cmd;
	unsigned char obj;
	unsigned char src;
	unsigned char para[4];
};

union hi6220_mbox_data {
	unsigned int data[8];
	struct hi6220_mbox_msg msg;
};

struct hi3660_stub_clk_chan {
	struct mbox_client cl;
	struct mbox_chan *mbox;
};

struct hi3660_stub_clk {
	unsigned int id;
	struct clk_hw hw;
	unsigned int cmd;
	unsigned int msg[8];
	unsigned int rate;
};

struct clk_busy_divider {
	struct clk_divider div;
	const struct clk_ops *div_ops;
	void *reg;
	u8 shift;
};

struct clk_busy_mux {
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	void *reg;
	u8 shift;
};

struct clk_cpu {
	struct clk_hw hw;
	struct clk *div;
	struct clk *mux;
	struct clk *pll;
	struct clk *step;
};

struct clk_divider_gate {
	struct clk_divider divider;
	u32 cached_val;
};

struct clk_fixup_div {
	struct clk_divider divider;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

struct clk_fixup_mux {
	struct clk_mux mux;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

struct clk_frac_pll {
	struct clk_hw hw;
	void *base;
};

struct clk_gate2 {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 cgr_val;
	u8 cgr_mask;
	u8 flags;
	spinlock_t *lock;
	unsigned int *share_count;
};

struct clk_gate_exclusive {
	struct clk_gate gate;
	u32 exclusive_mask;
};

struct clk_pfd {
	struct clk_hw hw;
	void *reg;
	u8 idx;
};

struct clk_pfdv2 {
	struct clk_hw hw;
	void *reg;
	u8 gate_bit;
	u8 vld_bit;
	u8 frac_off;
};

enum imx_pllv1_type {
	IMX_PLLV1_IMX1 = 0,
	IMX_PLLV1_IMX21 = 1,
	IMX_PLLV1_IMX25 = 2,
	IMX_PLLV1_IMX27 = 3,
	IMX_PLLV1_IMX31 = 4,
	IMX_PLLV1_IMX35 = 5,
};

struct clk_pllv1 {
	struct clk_hw hw;
	void *base;
	enum imx_pllv1_type type;
};

struct clk_pllv2 {
	struct clk_hw hw;
	void *base;
};

enum imx_pllv3_type {
	IMX_PLLV3_GENERIC = 0,
	IMX_PLLV3_SYS = 1,
	IMX_PLLV3_USB = 2,
	IMX_PLLV3_USB_VF610 = 3,
	IMX_PLLV3_AV = 4,
	IMX_PLLV3_ENET = 5,
	IMX_PLLV3_ENET_IMX7 = 6,
	IMX_PLLV3_SYS_VF610 = 7,
	IMX_PLLV3_DDR_IMX7 = 8,
	IMX_PLLV3_AV_IMX7 = 9,
};

struct clk_pllv3 {
	struct clk_hw hw;
	void *base;
	u32 power_bit;
	bool powerup_set;
	u32 div_mask;
	u32 div_shift;
	long unsigned int ref_clock;
	u32 num_offset;
	u32 denom_offset;
};

struct clk_pllv3_vf610_mf {
	u32 mfi;
	u32 mfn;
	u32 mfd;
};

struct clk_pllv4 {
	struct clk_hw hw;
	void *base;
};

enum imx_pll14xx_type {
	PLL_1416X = 0,
	PLL_1443X = 1,
};

struct imx_pll14xx_rate_table {
	unsigned int rate;
	unsigned int pdiv;
	unsigned int mdiv;
	unsigned int sdiv;
	unsigned int kdiv;
};

struct imx_pll14xx_clk {
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
	int flags;
};

struct clk_pll14xx {
	struct clk_hw hw;
	void *base;
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
};

struct clk_sscg_pll_setup {
	int divr1;
	int divf1;
	int divr2;
	int divf2;
	int divq;
	int bypass;
	uint64_t vco1;
	uint64_t vco2;
	uint64_t fout;
	uint64_t ref;
	uint64_t ref_div1;
	uint64_t ref_div2;
	uint64_t fout_request;
	int fout_error;
	int: 32;
};

struct clk_sscg_pll {
	struct clk_hw hw;
	const struct clk_ops ops;
	void *base;
	int: 32;
	struct clk_sscg_pll_setup setup;
	u8 parent;
	u8 bypass1;
	u8 bypass2;
	int: 8;
	int: 32;
};

struct clk_pll_data {
	bool has_pllctrl;
	u32 phy_pllm;
	u32 phy_pll_ctl0;
	void *pllm;
	void *pllod;
	void *pll_ctl0;
	u32 pllm_lower_mask;
	u32 pllm_upper_mask;
	u32 pllm_upper_shift;
	u32 plld_mask;
	u32 clkod_mask;
	u32 clkod_shift;
	u32 postdiv;
};

struct clk_pll___3 {
	struct clk_hw hw;
	struct clk_pll_data *pll_data;
};

struct clk_psc_data {
	void *control_base;
	void *domain_base;
	u32 domain_id;
};

struct clk_psc {
	struct clk_hw hw;
	struct clk_psc_data *psc_data;
	spinlock_t *lock;
};

struct ti_syscon_gate_clk_priv {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 idx;
};

struct ti_syscon_gate_clk_data {
	char *name;
	u32 offset;
	u32 bit_idx;
};

struct mtk_fixed_clk {
	int id;
	const char *name;
	const char *parent;
	long unsigned int rate;
};

struct mtk_fixed_factor {
	int id;
	const char *name;
	const char *parent_name;
	int mult;
	int div;
};

struct mtk_composite {
	int id;
	const char *name;
	const char * const *parent_names;
	const char *parent;
	unsigned int flags;
	uint32_t mux_reg;
	uint32_t divider_reg;
	uint32_t gate_reg;
	signed char mux_shift;
	signed char mux_width;
	signed char gate_shift;
	signed char divider_shift;
	signed char divider_width;
	u8 mux_flags;
	signed char num_parents;
};

struct mtk_gate_regs {
	u32 sta_ofs;
	u32 clr_ofs;
	u32 set_ofs;
};

struct mtk_gate {
	int id;
	const char *name;
	const char *parent_name;
	const struct mtk_gate_regs *regs;
	int shift;
	const struct clk_ops *ops;
	long unsigned int flags;
};

struct mtk_clk_divider {
	int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	u32 div_reg;
	unsigned char div_shift;
	unsigned char div_width;
	unsigned char clk_divider_flags;
	const struct clk_div_table *clk_div_table;
};

struct mtk_pll_div_table {
	u32 div;
	long unsigned int freq;
};

struct mtk_pll_data {
	int id;
	const char *name;
	uint32_t reg;
	uint32_t pwr_reg;
	uint32_t en_mask;
	uint32_t pd_reg;
	uint32_t tuner_reg;
	uint32_t tuner_en_reg;
	uint8_t tuner_en_bit;
	int pd_shift;
	unsigned int flags;
	const struct clk_ops *ops;
	u32 rst_bar_mask;
	long unsigned int fmin;
	long unsigned int fmax;
	int pcwbits;
	int pcwibits;
	uint32_t pcw_reg;
	int pcw_shift;
	uint32_t pcw_chg_reg;
	const struct mtk_pll_div_table *div_table;
	const char *parent_name;
};

struct mtk_clk_pll {
	struct clk_hw hw;
	void *base_addr;
	void *pd_addr;
	void *pwr_addr;
	void *tuner_addr;
	void *tuner_en_addr;
	void *pcw_addr;
	void *pcw_chg_addr;
	const struct mtk_pll_data *data;
};

struct mtk_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	int set_ofs;
	int clr_ofs;
	int sta_ofs;
	u8 bit;
};

struct mtk_ref2usb_tx {
	struct clk_hw hw;
	void *base_addr;
};

struct mtk_clk_cpumux {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 mask;
	u8 shift;
};

struct mtk_reset {
	struct regmap *regmap;
	int regofs;
	struct reset_controller_dev rcdev;
};

struct mtk_mux;

struct mtk_clk_mux {
	struct clk_hw hw;
	struct regmap *regmap;
	const struct mtk_mux *data;
	spinlock_t *lock;
};

struct mtk_mux {
	int id;
	const char *name;
	const char * const *parent_names;
	unsigned int flags;
	u32 mux_ofs;
	u32 set_ofs;
	u32 clr_ofs;
	u32 upd_ofs;
	u8 mux_shift;
	u8 mux_width;
	u8 gate_shift;
	s8 upd_shift;
	const struct clk_ops *ops;
	signed char num_parents;
};

struct mtk_clk_usb {
	int id;
	const char *name;
	const char *parent;
	u32 reg_ofs;
};

struct clk_mt8173_mm_driver_data {
	const struct mtk_gate *gates_clk;
	int gates_num;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

struct clk_regmap {
	struct clk_hw hw;
	struct regmap *map;
	void *data;
};

struct parm {
	u16 reg_off;
	u8 shift;
	u8 width;
};

struct meson_clk_mpll_data {
	struct parm sdm;
	struct parm sdm_en;
	struct parm n2;
	struct parm ssen;
	struct parm misc;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	spinlock_t *lock;
	u8 flags;
};

struct pll_params_table {
	unsigned int m;
	unsigned int n;
};

struct pll_mult_range {
	unsigned int min;
	unsigned int max;
};

struct meson_clk_pll_data {
	struct parm en;
	struct parm m;
	struct parm n;
	struct parm frac;
	struct parm l;
	struct parm rst;
	const struct reg_sequence *init_regs;
	unsigned int init_count;
	const struct pll_params_table *table;
	const struct pll_mult_range *range;
	u8 flags;
};

struct clk_regmap_gate_data {
	unsigned int offset;
	u8 bit_idx;
	u8 flags;
};

struct clk_regmap_div_data {
	unsigned int offset;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
};

struct clk_regmap_mux_data {
	unsigned int offset;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
};

struct meson8b_clk_reset {
	struct reset_controller_dev reset;
	struct regmap *regmap;
};

struct meson8b_clk_reset_line {
	u32 reg;
	u8 bit_idx;
	bool active_low;
};

struct meson8b_nb_data {
	struct notifier_block nb;
	struct clk_hw *cpu_clk;
};

struct clk_apbc {
	struct clk_hw hw;
	void *base;
	unsigned int delay;
	unsigned int flags;
	spinlock_t *lock;
};

struct clk_apmu {
	struct clk_hw hw;
	void *base;
	u32 rst_mask;
	u32 enable_mask;
	spinlock_t *lock;
};

struct mmp_clk_factor_masks {
	unsigned int factor;
	unsigned int num_mask;
	unsigned int den_mask;
	unsigned int num_shift;
	unsigned int den_shift;
	unsigned int enable_mask;
};

struct mmp_clk_factor_tbl {
	unsigned int num;
	unsigned int den;
};

struct mmp_clk_factor {
	struct clk_hw hw;
	void *base;
	struct mmp_clk_factor_masks *masks;
	struct mmp_clk_factor_tbl *ftbl;
	unsigned int ftbl_cnt;
	spinlock_t *lock;
};

enum {
	MMP_CLK_MIX_TYPE_V1 = 0,
	MMP_CLK_MIX_TYPE_V2 = 1,
	MMP_CLK_MIX_TYPE_V3 = 2,
};

struct mmp_clk_mix_reg_info {
	void *reg_clk_ctrl;
	void *reg_clk_sel;
	u8 width_div;
	u8 shift_div;
	u8 width_mux;
	u8 shift_mux;
	u8 bit_fc;
};

struct mmp_clk_mix_clk_table {
	long unsigned int rate;
	u8 parent_index;
	unsigned int divisor;
	unsigned int valid;
};

struct mmp_clk_mix_config {
	struct mmp_clk_mix_reg_info reg_info;
	struct mmp_clk_mix_clk_table *table;
	unsigned int table_size;
	u32 *mux_table;
	struct clk_div_table *div_table;
	u8 div_flags;
	u8 mux_flags;
};

struct mmp_clk_mix {
	struct clk_hw hw;
	struct mmp_clk_mix_reg_info reg_info;
	struct mmp_clk_mix_clk_table *table;
	u32 *mux_table;
	struct clk_div_table *div_table;
	unsigned int table_size;
	u8 div_flags;
	u8 mux_flags;
	unsigned int type;
	spinlock_t *lock;
};

struct mmp_clk_gate {
	struct clk_hw hw;
	void *reg;
	u32 mask;
	u32 val_enable;
	u32 val_disable;
	unsigned int flags;
	spinlock_t *lock;
};

struct mmp_clk_unit {
	unsigned int nr_clks;
	struct clk **clk_table;
	struct clk_onecell_data clk_data;
};

struct mmp_param_fixed_rate_clk {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int fixed_rate;
};

struct mmp_param_fixed_factor_clk {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int mult;
	long unsigned int div;
	long unsigned int flags;
};

struct mmp_param_general_gate_clk {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 bit_idx;
	u8 gate_flags;
	spinlock_t *lock;
};

struct mmp_param_gate_clk {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u32 mask;
	u32 val_enable;
	u32 val_disable;
	unsigned int gate_flags;
	spinlock_t *lock;
};

struct mmp_param_mux_clk {
	unsigned int id;
	char *name;
	const char * const *parent_name;
	u8 num_parents;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 mux_flags;
	spinlock_t *lock;
};

struct mmp_param_div_clk {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 div_flags;
	spinlock_t *lock;
};

struct mmp_clk_reset_cell {
	unsigned int clk_id;
	void *reg;
	u32 bits;
	unsigned int flags;
	spinlock_t *lock;
};

struct mmp_clk_reset_unit {
	struct reset_controller_dev rcdev;
	struct mmp_clk_reset_cell *cells;
};

struct mmp_param_pll_clk {
	unsigned int id;
	char *name;
	long unsigned int default_rate;
	long unsigned int enable_offset;
	u32 enable;
	long unsigned int offset;
	u8 shift;
	long unsigned int input_rate;
	long unsigned int postdiv_offset;
	long unsigned int postdiv_shift;
};

enum mmp2_clk_model {
	CLK_MODEL_MMP2 = 0,
	CLK_MODEL_MMP3 = 1,
};

struct mmp2_clk_unit {
	struct mmp_clk_unit unit;
	enum mmp2_clk_model model;
	struct genpd_onecell_data pd_data;
	struct generic_pm_domain *pm_domains[3];
	void *mpmu_base;
	void *apmu_base;
	void *apbc_base;
};

struct mmp_clk_pll {
	struct clk_hw hw;
	long unsigned int default_rate;
	void *enable_reg;
	u32 enable;
	void *reg;
	u8 shift;
	long unsigned int input_rate;
	void *postdiv_reg;
	u8 postdiv_shift;
};

struct mmp_pm_domain {
	struct generic_pm_domain genpd;
	void *reg;
	spinlock_t *lock;
	u32 power_on;
	u32 reset;
	u32 clock_enable;
	unsigned int flags;
};

struct pxa1928_clk_unit {
	struct mmp_clk_unit unit;
	void *mpmu_base;
	void *apmu_base;
	void *apbc_base;
	void *apbcp_base;
};

struct coreclk_ratio {
	int id;
	const char *name;
};

struct coreclk_soc_desc {
	u32 (*get_tclk_freq)(void *);
	u32 (*get_cpu_freq)(void *);
	void (*get_clk_ratio)(void *, int, int *, int *);
	u32 (*get_refclk_freq)(void *);
	bool (*is_sscg_enabled)(void *);
	u32 (*fix_sscg_deviation)(u32);
	const struct coreclk_ratio *ratios;
	int num_ratios;
};

struct clk_gating_soc_desc {
	const char *name;
	const char *parent;
	int bit_idx;
	long unsigned int flags;
};

struct clk_gating_ctrl {
	spinlock_t *lock;
	struct clk **gates;
	int num_gates;
	void *base;
	u32 saved_reg;
};

struct cpu_clk {
	struct clk_hw hw;
	int cpu;
	const char *clk_name;
	const char *parent_name;
	void *reg_base;
	void *pmu_dfs;
};

struct clk_corediv_desc {
	unsigned int mask;
	unsigned int offset;
	unsigned int fieldbit;
};

struct clk_corediv_soc_desc {
	const struct clk_corediv_desc *descs;
	unsigned int ndescs;
	const struct clk_ops ops;
	u32 ratio_reload;
	u32 enable_bit_offset;
	u32 ratio_offset;
};

struct clk_corediv {
	struct clk_hw hw;
	void *reg;
	const struct clk_corediv_desc *desc;
	const struct clk_corediv_soc_desc *soc_desc;
	spinlock_t lock;
};

enum {
	A370_CPU_TO_NBCLK = 0,
	A370_CPU_TO_HCLK = 1,
	A370_CPU_TO_DRAMCLK = 2,
};

enum {
	A375_CPU_TO_DDR = 0,
	A375_CPU_TO_L2 = 1,
};

enum {
	A380_CPU_TO_DDR = 0,
	A380_CPU_TO_L2 = 1,
};

enum {
	A390_CPU_TO_NBCLK = 0,
	A390_CPU_TO_HCLK = 1,
	A390_CPU_TO_DCLK = 2,
};

enum {
	AXP_CPU_TO_NBCLK = 0,
	AXP_CPU_TO_HCLK = 1,
	AXP_CPU_TO_DRAMCLK = 2,
};

enum {
	MV98DX3236_CPU_TO_DDR = 0,
	MV98DX3236_CPU_TO_MPLL = 1,
};

enum {
	DOVE_CPU_TO_L2 = 0,
	DOVE_CPU_TO_DDR = 1,
};

struct dove_clk {
	const char *name;
	struct clk_hw hw;
	void *base;
	spinlock_t *lock;
	u8 div_bit_start;
	u8 div_bit_end;
	u8 div_bit_load;
	u8 div_bit_size;
	u32 *divider_table;
};

enum {
	DIV_CTRL0 = 0,
	DIV_CTRL1 = 4,
	DIV_CTRL1_N_RESET_MASK = 1024,
};

struct clk_regmap___2;

struct qcom_reset_map;

struct gdsc;

struct qcom_cc_desc {
	const struct regmap_config *config;
	struct clk_regmap___2 **clks;
	size_t num_clks;
	const struct qcom_reset_map *resets;
	size_t num_resets;
	struct gdsc **gdscs;
	size_t num_gdscs;
	struct clk_hw **clk_hws;
	size_t num_clk_hws;
};

struct clk_regmap___2 {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int enable_reg;
	unsigned int enable_mask;
	bool enable_is_inverted;
};

struct qcom_reset_map {
	unsigned int reg;
	u8 bit;
};

struct gdsc {
	struct generic_pm_domain pd;
	struct generic_pm_domain *parent;
	struct regmap *regmap;
	unsigned int gdscr;
	unsigned int gds_hw_ctrl;
	unsigned int clamp_io_ctrl;
	unsigned int *cxcs;
	unsigned int cxc_count;
	const u8 pwrsts;
	const u8 flags;
	struct reset_controller_dev *rcdev;
	unsigned int *resets;
	unsigned int reset_count;
	const char *supply;
	struct regulator *rsupply;
	int: 32;
};

struct parent_map {
	u8 src;
	u8 cfg;
};

struct freq_tbl {
	long unsigned int freq;
	u8 src;
	u8 pre_div;
	u16 m;
	u16 n;
};

struct qcom_reset_controller {
	const struct qcom_reset_map *reset_map;
	struct regmap *regmap;
	struct reset_controller_dev rcdev;
};

struct gdsc_desc {
	struct device *dev;
	struct gdsc **scs;
	size_t num;
};

struct qcom_cc {
	struct qcom_reset_controller reset;
	struct clk_regmap___2 **rclks;
	size_t num_rclks;
};

enum {
	CLK_ALPHA_PLL_TYPE_DEFAULT = 0,
	CLK_ALPHA_PLL_TYPE_HUAYRA = 1,
	CLK_ALPHA_PLL_TYPE_BRAMMO = 2,
	CLK_ALPHA_PLL_TYPE_FABIA = 3,
	CLK_ALPHA_PLL_TYPE_TRION = 4,
	CLK_ALPHA_PLL_TYPE_LUCID = 4,
	CLK_ALPHA_PLL_TYPE_AGERA = 5,
	CLK_ALPHA_PLL_TYPE_MAX = 6,
};

enum {
	PLL_OFF_L_VAL = 0,
	PLL_OFF_CAL_L_VAL = 1,
	PLL_OFF_ALPHA_VAL = 2,
	PLL_OFF_ALPHA_VAL_U = 3,
	PLL_OFF_USER_CTL = 4,
	PLL_OFF_USER_CTL_U = 5,
	PLL_OFF_USER_CTL_U1 = 6,
	PLL_OFF_CONFIG_CTL = 7,
	PLL_OFF_CONFIG_CTL_U = 8,
	PLL_OFF_CONFIG_CTL_U1 = 9,
	PLL_OFF_TEST_CTL = 10,
	PLL_OFF_TEST_CTL_U = 11,
	PLL_OFF_TEST_CTL_U1 = 12,
	PLL_OFF_STATUS = 13,
	PLL_OFF_OPMODE = 14,
	PLL_OFF_FRAC = 15,
	PLL_OFF_CAL_VAL = 16,
	PLL_OFF_MAX_REGS = 17,
};

struct pll_vco {
	long unsigned int min_freq;
	long unsigned int max_freq;
	u32 val;
};

struct clk_alpha_pll {
	u32 offset;
	const u8 *regs;
	const struct pll_vco *vco_table;
	size_t num_vco;
	u8 flags;
	struct clk_regmap___2 clkr;
};

struct clk_alpha_pll_postdiv {
	u32 offset;
	u8 width;
	const u8 *regs;
	struct clk_regmap___2 clkr;
	int post_div_shift;
	const struct clk_div_table *post_div_table;
	size_t num_post_div;
};

struct alpha_pll_config {
	u32 l;
	u32 alpha;
	u32 alpha_hi;
	u32 config_ctl_val;
	u32 config_ctl_hi_val;
	u32 config_ctl_hi1_val;
	u32 user_ctl_val;
	u32 user_ctl_hi_val;
	u32 user_ctl_hi1_val;
	u32 test_ctl_val;
	u32 test_ctl_hi_val;
	u32 test_ctl_hi1_val;
	u32 main_output_mask;
	u32 aux_output_mask;
	u32 aux2_output_mask;
	u32 early_output_mask;
	u32 alpha_en_mask;
	u32 alpha_mode_mask;
	u32 pre_div_val;
	u32 pre_div_mask;
	u32 post_div_val;
	u32 post_div_mask;
	u32 vco_val;
	u32 vco_mask;
};

struct pll_freq_tbl {
	long unsigned int freq;
	u16 l;
	u16 m;
	u16 n;
	u32 ibits;
};

struct clk_pll___4 {
	u32 l_reg;
	u32 m_reg;
	u32 n_reg;
	u32 config_reg;
	u32 mode_reg;
	u32 status_reg;
	u8 status_bit;
	u8 post_div_width;
	u8 post_div_shift;
	const struct pll_freq_tbl *freq_tbl;
	struct clk_regmap___2 clkr;
};

struct pll_config {
	u16 l;
	u32 m;
	u32 n;
	u32 vco_val;
	u32 vco_mask;
	u32 pre_div_val;
	u32 pre_div_mask;
	u32 post_div_val;
	u32 post_div_mask;
	u32 mn_ena_mask;
	u32 main_output_mask;
	u32 aux_output_mask;
};

struct mn {
	u8 mnctr_en_bit;
	u8 mnctr_reset_bit;
	u8 mnctr_mode_shift;
	u8 n_val_shift;
	u8 m_val_shift;
	u8 width;
	bool reset_in_cc;
};

struct pre_div {
	u8 pre_div_shift;
	u8 pre_div_width;
};

struct src_sel {
	u8 src_sel_shift;
	const struct parent_map *parent_map;
};

struct clk_rcg {
	u32 ns_reg;
	u32 md_reg;
	struct mn mn;
	struct pre_div p;
	struct src_sel s;
	const struct freq_tbl *freq_tbl;
	struct clk_regmap___2 clkr;
};

struct clk_dyn_rcg {
	u32 ns_reg[2];
	u32 md_reg[2];
	u32 bank_reg;
	u8 mux_sel_bit;
	struct mn mn[2];
	struct pre_div p[2];
	struct src_sel s[2];
	const struct freq_tbl *freq_tbl;
	struct clk_regmap___2 clkr;
};

struct frac_entry {
	int num;
	int den;
};

struct clk_rcg2 {
	u32 cmd_rcgr;
	u8 mnd_width;
	u8 hid_width;
	u8 safe_src_index;
	const struct parent_map *parent_map;
	const struct freq_tbl *freq_tbl;
	struct clk_regmap___2 clkr;
	u8 cfg_off;
};

struct clk_rcg_dfs_data {
	struct clk_rcg2 *rcg;
	struct clk_init_data *init;
};

enum freq_policy {
	FLOOR = 0,
	CEIL = 1,
};

struct clk_branch {
	u32 hwcg_reg;
	u32 halt_reg;
	u8 hwcg_bit;
	u8 halt_bit;
	u8 halt_check;
	struct clk_regmap___2 clkr;
};

struct clk_regmap_div {
	u32 reg;
	u32 shift;
	u32 width;
	struct clk_regmap___2 clkr;
};

struct clk_regmap_mux {
	u32 reg;
	u32 shift;
	u32 width;
	const struct parent_map *parent_map;
	struct clk_regmap___2 clkr;
};

struct clk_regmap_mux_div {
	u32 reg_offset;
	u32 hid_width;
	u32 hid_shift;
	u32 src_width;
	u32 src_shift;
	u32 div;
	u32 src;
	const u32 *parent_map;
	struct clk_regmap___2 clkr;
	struct clk *pclk;
	struct notifier_block clk_nb;
};

struct hfpll_data {
	u32 mode_reg;
	u32 l_reg;
	u32 m_reg;
	u32 n_reg;
	u32 user_reg;
	u32 droop_reg;
	u32 config_reg;
	u32 status_reg;
	u8 lock_bit;
	u32 droop_val;
	u32 config_val;
	u32 user_val;
	u32 user_vco_mask;
	long unsigned int low_vco_max_rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
};

struct clk_hfpll {
	const struct hfpll_data *d;
	int init_done;
	struct clk_regmap___2 clkr;
	spinlock_t lock;
};

enum gdsc_status {
	GDSC_OFF = 0,
	GDSC_ON = 1,
};

enum {
	P_XO = 0,
	P_GPLL0 = 1,
	P_GPLL1 = 2,
	P_GPLL4 = 3,
	P_PCIE_0_1_PIPE_CLK = 4,
	P_SATA_ASIC0_CLK = 5,
	P_SATA_RX_CLK = 6,
	P_SLEEP_CLK = 7,
};

enum {
	P_XO___2 = 0,
	P_MMPLL0 = 1,
	P_EDPLINK = 2,
	P_MMPLL1 = 3,
	P_HDMIPLL = 4,
	P_GPLL0___2 = 5,
	P_EDPVCO = 6,
	P_MMPLL4 = 7,
	P_DSI0PLL = 8,
	P_DSI0PLL_BYTE = 9,
	P_MMPLL2 = 10,
	P_MMPLL3 = 11,
	P_GPLL1___2 = 12,
	P_DSI1PLL = 13,
	P_DSI1PLL_BYTE = 14,
	P_MMSLEEP = 15,
};

enum {
	P_PXO = 0,
	P_PLL8 = 1,
	P_CXO = 2,
};

enum {
	P_PXO___2 = 0,
	P_PLL8___2 = 1,
	P_PLL3 = 2,
	P_CXO___2 = 3,
};

enum {
	P_XO___3 = 0,
	P_GPLL0___3 = 1,
	P_GPLL1___3 = 2,
	P_GPLL4___2 = 3,
};

enum {
	P_PXO___3 = 0,
	P_PLL8___3 = 1,
	P_PLL2 = 2,
	P_PLL3___2 = 3,
	P_PLL15 = 4,
	P_HDMI_PLL = 5,
	P_DSI1_PLL_DSICLK = 6,
	P_DSI2_PLL_DSICLK = 7,
	P_DSI1_PLL_BYTECLK = 8,
	P_DSI2_PLL_BYTECLK = 9,
};

struct clk_pix_rdi {
	u32 s_reg;
	u32 s_mask;
	u32 s2_reg;
	u32 s2_mask;
	struct clk_regmap___2 clkr;
};

enum {
	P_XO___4 = 0,
	P_MMPLL0___2 = 1,
	P_EDPLINK___2 = 2,
	P_MMPLL1___2 = 3,
	P_HDMIPLL___2 = 4,
	P_GPLL0___4 = 5,
	P_EDPVCO___2 = 6,
	P_GPLL1___4 = 7,
	P_DSI0PLL___2 = 8,
	P_DSI0PLL_BYTE___2 = 9,
	P_MMPLL2___2 = 10,
	P_MMPLL3___2 = 11,
	P_DSI1PLL___2 = 12,
	P_DSI1PLL_BYTE___2 = 13,
};

struct qcom_rpm;

struct rpm_cc;

struct clk_rpm {
	const int rpm_clk_id;
	const int xo_offset;
	const bool active_only;
	long unsigned int rate;
	bool enabled;
	bool branch;
	struct clk_rpm *peer;
	struct clk_hw hw;
	struct qcom_rpm *rpm;
	struct rpm_cc *rpm_cc;
};

struct rpm_cc {
	struct qcom_rpm *rpm;
	struct clk_rpm **clks;
	size_t num_clks;
	u32 xo_buffer_value;
	struct mutex xo_lock;
};

struct rpm_clk_desc {
	struct clk_rpm **clks;
	size_t num_clks;
};

struct rz_cpg {
	struct clk_onecell_data data;
	void *reg;
};

struct cpg_core_clk {
	const char *name;
	unsigned int id;
	unsigned int type;
	unsigned int parent;
	unsigned int div;
	unsigned int mult;
	unsigned int offset;
};

enum clk_types {
	CLK_TYPE_IN = 0,
	CLK_TYPE_FF = 1,
	CLK_TYPE_DIV6P1 = 2,
	CLK_TYPE_DIV6_RO = 3,
	CLK_TYPE_FR = 4,
	CLK_TYPE_CUSTOM = 5,
};

struct mssr_mod_clk {
	const char *name;
	unsigned int id;
	unsigned int parent;
};

enum clk_reg_layout {
	CLK_REG_LAYOUT_RCAR_GEN2_AND_GEN3 = 0,
	CLK_REG_LAYOUT_RZ_A = 1,
	CLK_REG_LAYOUT_RCAR_V3U = 2,
};

struct cpg_mssr_info {
	const struct cpg_core_clk *early_core_clks;
	unsigned int num_early_core_clks;
	const struct mssr_mod_clk *early_mod_clks;
	unsigned int num_early_mod_clks;
	const struct cpg_core_clk *core_clks;
	unsigned int num_core_clks;
	unsigned int last_dt_core_clk;
	unsigned int num_total_core_clks;
	enum clk_reg_layout reg_layout;
	const struct mssr_mod_clk *mod_clks;
	unsigned int num_mod_clks;
	unsigned int num_hw_mod_clks;
	const unsigned int *crit_mod_clks;
	unsigned int num_crit_mod_clks;
	const unsigned int *core_pm_clks;
	unsigned int num_core_pm_clks;
	int (*init)(struct device *);
	struct clk * (*cpg_clk_register)(struct device *, const struct cpg_core_clk *, const struct cpg_mssr_info *, struct clk **, void *, struct raw_notifier_head *);
};

enum rz_clk_types {
	CLK_TYPE_RZA_MAIN = 5,
	CLK_TYPE_RZA_PLL = 6,
};

enum clk_ids {
	LAST_DT_CORE_CLK = 5,
	CLK_EXTAL = 6,
	CLK_MAIN = 7,
	CLK_PLL = 8,
	MOD_CLK_BASE = 9,
};

struct r8a73a4_cpg {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct div4_clk {
	const char *name;
	unsigned int reg;
	unsigned int shift;
};

struct r8a7740_cpg {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct div4_clk___2 {
	const char *name;
	unsigned int reg;
	unsigned int shift;
	int flags;
};

enum rcar_gen2_clk_types {
	CLK_TYPE_GEN2_MAIN = 5,
	CLK_TYPE_GEN2_PLL0 = 6,
	CLK_TYPE_GEN2_PLL1 = 7,
	CLK_TYPE_GEN2_PLL3 = 8,
	CLK_TYPE_GEN2_Z = 9,
	CLK_TYPE_GEN2_LB = 10,
	CLK_TYPE_GEN2_ADSP = 11,
	CLK_TYPE_GEN2_SDH = 12,
	CLK_TYPE_GEN2_SD0 = 13,
	CLK_TYPE_GEN2_SD1 = 14,
	CLK_TYPE_GEN2_QSPI = 15,
	CLK_TYPE_GEN2_RCAN = 16,
};

struct rcar_gen2_cpg_pll_config {
	u8 extal_div;
	u8 pll1_mult;
	u8 pll3_mult;
	u8 pll0_mult;
};

enum clk_ids___2 {
	LAST_DT_CORE_CLK___2 = 29,
	CLK_EXTAL___2 = 30,
	CLK_USB_EXTAL = 31,
	CLK_MAIN___2 = 32,
	CLK_PLL0 = 33,
	CLK_PLL1 = 34,
	CLK_PLL3 = 35,
	CLK_PLL1_DIV2 = 36,
	MOD_CLK_BASE___2 = 37,
};

enum clk_ids___3 {
	LAST_DT_CORE_CLK___3 = 30,
	CLK_EXTAL___3 = 31,
	CLK_USB_EXTAL___2 = 32,
	CLK_MAIN___3 = 33,
	CLK_PLL0___2 = 34,
	CLK_PLL1___2 = 35,
	CLK_PLL3___2 = 36,
	CLK_PLL1_DIV2___2 = 37,
	MOD_CLK_BASE___3 = 38,
};

enum clk_ids___4 {
	LAST_DT_CORE_CLK___4 = 23,
	CLK_EXTAL___4 = 24,
	CLK_USB_EXTAL___3 = 25,
	CLK_MAIN___4 = 26,
	CLK_PLL0___3 = 27,
	CLK_PLL1___3 = 28,
	CLK_PLL3___3 = 29,
	CLK_PLL1_DIV2___3 = 30,
	MOD_CLK_BASE___4 = 31,
};

struct r8a7778_cpg {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct r8a7779_cpg {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct cpg_clk_config {
	unsigned int z_mult;
	unsigned int z_div;
	unsigned int zs_and_s_div;
	unsigned int s1_div;
	unsigned int p_div;
	unsigned int b_and_out_div;
};

enum clk_ids___5 {
	LAST_DT_CORE_CLK___5 = 34,
	CLK_EXTAL___5 = 35,
	CLK_USB_EXTAL___4 = 36,
	CLK_MAIN___5 = 37,
	CLK_PLL0___4 = 38,
	CLK_PLL1___4 = 39,
	CLK_PLL3___4 = 40,
	CLK_PLL1_DIV2___4 = 41,
	MOD_CLK_BASE___5 = 42,
};

enum clk_ids___6 {
	LAST_DT_CORE_CLK___6 = 25,
	CLK_EXTAL___6 = 26,
	CLK_MAIN___6 = 27,
	CLK_PLL0___5 = 28,
	CLK_PLL1___5 = 29,
	CLK_PLL3___5 = 30,
	CLK_PLL1_DIV2___5 = 31,
	MOD_CLK_BASE___6 = 32,
};

struct r9a06g032_gate {
	u16 gate;
	u16 reset;
	u16 ready;
	u16 midle;
	u16 scon;
	u16 mirack;
	u16 mistat;
};

struct r9a06g032_clkdesc {
	const char *name;
	uint32_t managed: 1;
	uint32_t type: 3;
	uint32_t index: 8;
	uint32_t source: 8;
	union {
		struct r9a06g032_gate gate;
		struct {
			unsigned int div_min: 10;
			unsigned int div_max: 10;
			unsigned int reg: 10;
			u16 div_table[4];
		};
		struct {
			u16 div;
			u16 mul;
		};
		unsigned int factor;
		unsigned int frequency;
		struct {
			uint16_t group: 1;
			uint16_t index: 3;
			u16 sel;
			u16 g1;
			u16 r1;
			u16 g2;
			u16 r2;
		} dual;
	};
};

enum {
	K_GATE = 0,
	K_FFC = 1,
	K_DIV = 2,
	K_BITSEL = 3,
	K_DUALGATE = 4,
};

struct r9a06g032_priv {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct r9a06g032_clk_gate {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	struct r9a06g032_gate gate;
};

struct r9a06g032_clk_div {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	u16 reg;
	u16 min;
	u16 max;
	u8 table_size;
	u16 table[8];
};

struct r9a06g032_clk_bitsel {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	u16 selector;
};

struct r9a06g032_clk_dualgate {
	struct clk_hw hw;
	struct r9a06g032_priv *clocks;
	u16 index;
	u16 selector;
	struct r9a06g032_gate gate[2];
};

struct sh73a0_cpg {
	struct clk_onecell_data data;
	spinlock_t lock;
	void *reg;
};

struct div4_clk___3 {
	const char *name;
	const char *parent;
	unsigned int reg;
	unsigned int shift;
};

struct cpg_z_clk {
	struct clk_hw hw;
	void *reg;
	void *kick_reg;
};

struct mssr_mod_reparent {
	unsigned int clk;
	unsigned int parent;
};

struct cpg_mssr_priv {
	struct reset_controller_dev rcdev;
	struct device *dev;
	void *base;
	enum clk_reg_layout reg_layout;
	spinlock_t rmw_lock;
	struct device_node *np;
	unsigned int num_core_clks;
	unsigned int num_mod_clks;
	unsigned int last_dt_core_clk;
	struct raw_notifier_head notifiers;
	const u16 *status_regs;
	const u16 *control_regs;
	const u16 *reset_regs;
	const u16 *reset_clear_regs;
	struct {
		u32 mask;
		u32 val;
	} smstpcr_saved[15];
	struct clk *clks[0];
};

struct mstp_clock {
	struct clk_hw hw;
	u32 index;
	struct cpg_mssr_priv *priv;
};

struct cpg_mssr_clk_domain {
	struct generic_pm_domain genpd;
	unsigned int num_core_pm_clks;
	unsigned int core_pm_clks[0];
	int: 32;
};

struct mstp_clock_group {
	struct clk_onecell_data data;
	void *smstpcr;
	void *mstpsr;
	spinlock_t lock;
	bool width_8bit;
	struct clk *clks[0];
};

struct mstp_clock___2 {
	struct clk_hw hw;
	u32 bit_index;
	struct mstp_clock_group *group;
};

struct div6_clock {
	struct clk_hw hw;
	void *reg;
	unsigned int div;
	u32 src_shift;
	u32 src_width;
	struct notifier_block nb;
	u8 parents[0];
};

enum rockchip_pll_type {
	pll_rk3036 = 0,
	pll_rk3066 = 1,
	pll_rk3328 = 2,
	pll_rk3399 = 3,
};

struct rockchip_clk_provider {
	void *reg_base;
	struct clk_onecell_data clk_data;
	struct device_node *cru_node;
	struct regmap *grf;
	spinlock_t lock;
};

struct rockchip_pll_rate_table {
	long unsigned int rate;
	unsigned int nr;
	unsigned int nf;
	unsigned int no;
	unsigned int nb;
	unsigned int fbdiv;
	unsigned int postdiv1;
	unsigned int refdiv;
	unsigned int postdiv2;
	unsigned int dsmpd;
	unsigned int frac;
};

struct rockchip_pll_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	int con_offset;
	int mode_offset;
	int mode_shift;
	int lock_shift;
	enum rockchip_pll_type type;
	u8 pll_flags;
	struct rockchip_pll_rate_table *rate_table;
};

struct rockchip_cpuclk_clksel {
	int reg;
	u32 val;
};

struct rockchip_cpuclk_rate_table {
	long unsigned int prate;
	struct rockchip_cpuclk_clksel divs[2];
};

struct rockchip_cpuclk_reg_data {
	int core_reg;
	u8 div_core_shift;
	u32 div_core_mask;
	u8 mux_core_alt;
	u8 mux_core_main;
	u8 mux_core_shift;
	u32 mux_core_mask;
};

enum rockchip_clk_branch_type {
	branch_composite = 0,
	branch_mux = 1,
	branch_muxgrf = 2,
	branch_divider = 3,
	branch_fraction_divider = 4,
	branch_gate = 5,
	branch_mmc = 6,
	branch_inverter = 7,
	branch_factor = 8,
	branch_ddrclk = 9,
	branch_half_divider = 10,
};

struct rockchip_clk_branch {
	unsigned int id;
	enum rockchip_clk_branch_type branch_type;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	int muxdiv_offset;
	u8 mux_shift;
	u8 mux_width;
	u8 mux_flags;
	int div_offset;
	u8 div_shift;
	u8 div_width;
	u8 div_flags;
	struct clk_div_table *div_table;
	int gate_offset;
	u8 gate_shift;
	u8 gate_flags;
	struct rockchip_clk_branch *child;
};

struct rockchip_clk_frac {
	struct notifier_block clk_nb;
	struct clk_fractional_divider div;
	struct clk_gate gate;
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	int mux_frac_idx;
	bool rate_change_remuxed;
	int rate_change_idx;
};

struct rockchip_clk_pll {
	struct clk_hw hw;
	struct clk_mux pll_mux;
	const struct clk_ops *pll_mux_ops;
	struct notifier_block clk_nb;
	void *reg_base;
	int lock_offset;
	unsigned int lock_shift;
	enum rockchip_pll_type type;
	u8 flags;
	const struct rockchip_pll_rate_table *rate_table;
	unsigned int rate_count;
	spinlock_t *lock;
	struct rockchip_clk_provider *ctx;
};

struct rockchip_cpuclk {
	struct clk_hw hw;
	struct clk_mux cpu_mux;
	const struct clk_ops *cpu_mux_ops;
	struct clk *alt_parent;
	void *reg_base;
	struct notifier_block clk_nb;
	unsigned int rate_count;
	struct rockchip_cpuclk_rate_table *rate_table;
	const struct rockchip_cpuclk_reg_data *reg_data;
	spinlock_t *lock;
};

struct rockchip_inv_clock {
	struct clk_hw hw;
	void *reg;
	int shift;
	int flags;
	spinlock_t *lock;
};

struct rockchip_mmc_clock {
	struct clk_hw hw;
	void *reg;
	int id;
	int shift;
	int cached_phase;
	struct notifier_block clk_rate_change_nb;
};

struct rockchip_muxgrf_clock {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 reg;
	u32 shift;
	u32 width;
	int flags;
};

struct rockchip_ddrclk {
	struct clk_hw hw;
	void *reg_base;
	int mux_offset;
	int mux_shift;
	int mux_width;
	int div_shift;
	int div_width;
	int ddr_flag;
	spinlock_t *lock;
};

struct rockchip_softrst {
	struct reset_controller_dev rcdev;
	void *reg_base;
	int num_regs;
	int num_per_reg;
	u8 flags;
	spinlock_t lock;
};

enum rv1108_plls {
	apll = 0,
	dpll = 1,
	gpll = 2,
};

enum rk3036_plls {
	apll___2 = 0,
	dpll___2 = 1,
	gpll___2 = 2,
};

enum rk3128_plls {
	apll___3 = 0,
	dpll___3 = 1,
	cpll = 2,
	gpll___3 = 3,
};

enum rk3188_plls {
	apll___4 = 0,
	cpll___2 = 1,
	dpll___4 = 2,
	gpll___4 = 3,
};

enum rk3228_plls {
	apll___5 = 0,
	dpll___5 = 1,
	cpll___3 = 2,
	gpll___5 = 3,
};

enum rk3288_variant {
	RK3288_CRU = 0,
	RK3288W_CRU = 1,
};

enum rk3288_plls {
	apll___6 = 0,
	dpll___6 = 1,
	cpll___4 = 2,
	gpll___6 = 3,
	npll = 4,
};

enum samsung_pll_type {
	pll_2126 = 0,
	pll_3000 = 1,
	pll_35xx = 2,
	pll_36xx = 3,
	pll_2550 = 4,
	pll_2650 = 5,
	pll_4500 = 6,
	pll_4502 = 7,
	pll_4508 = 8,
	pll_4600 = 9,
	pll_4650 = 10,
	pll_4650c = 11,
	pll_6552 = 12,
	pll_6552_s3c2416 = 13,
	pll_6553 = 14,
	pll_s3c2410_mpll = 15,
	pll_s3c2410_upll = 16,
	pll_s3c2440_mpll = 17,
	pll_2550x = 18,
	pll_2550xx = 19,
	pll_2650x = 20,
	pll_2650xx = 21,
	pll_1450x = 22,
	pll_1451x = 23,
	pll_1452x = 24,
	pll_1460x = 25,
};

struct samsung_pll_rate_table {
	unsigned int rate;
	unsigned int pdiv;
	unsigned int mdiv;
	unsigned int sdiv;
	unsigned int kdiv;
	unsigned int afc;
	unsigned int mfr;
	unsigned int mrr;
	unsigned int vsel;
};

struct samsung_clk_provider {
	void *reg_base;
	struct device *dev;
	spinlock_t lock;
	struct clk_hw_onecell_data clk_data;
};

struct samsung_clock_alias {
	unsigned int id;
	const char *dev_name;
	const char *alias;
};

struct samsung_fixed_rate_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int fixed_rate;
};

struct samsung_fixed_factor_clock {
	unsigned int id;
	char *name;
	const char *parent_name;
	long unsigned int mult;
	long unsigned int div;
	long unsigned int flags;
};

struct samsung_mux_clock {
	unsigned int id;
	const char *name;
	const char * const *parent_names;
	u8 num_parents;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 mux_flags;
};

struct samsung_div_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 shift;
	u8 width;
	u8 div_flags;
	struct clk_div_table *table;
};

struct samsung_gate_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	long unsigned int offset;
	u8 bit_idx;
	u8 gate_flags;
};

struct samsung_clk_reg_dump {
	u32 offset;
	u32 value;
};

struct samsung_pll_clock {
	unsigned int id;
	const char *name;
	const char *parent_name;
	long unsigned int flags;
	int con_offset;
	int lock_offset;
	enum samsung_pll_type type;
	const struct samsung_pll_rate_table *rate_table;
};

struct samsung_clock_reg_cache {
	struct list_head node;
	void *reg_base;
	struct samsung_clk_reg_dump *rdump;
	unsigned int rd_num;
	const struct samsung_clk_reg_dump *rsuspend;
	unsigned int rsuspend_num;
};

struct samsung_cmu_info {
	const struct samsung_pll_clock *pll_clks;
	unsigned int nr_pll_clks;
	const struct samsung_mux_clock *mux_clks;
	unsigned int nr_mux_clks;
	const struct samsung_div_clock *div_clks;
	unsigned int nr_div_clks;
	const struct samsung_gate_clock *gate_clks;
	unsigned int nr_gate_clks;
	const struct samsung_fixed_rate_clock *fixed_clks;
	unsigned int nr_fixed_clks;
	const struct samsung_fixed_factor_clock *fixed_factor_clks;
	unsigned int nr_fixed_factor_clks;
	unsigned int nr_clk_ids;
	const long unsigned int *clk_regs;
	unsigned int nr_clk_regs;
	const struct samsung_clk_reg_dump *suspend_regs;
	unsigned int nr_suspend_regs;
	const char *clk_name;
};

struct samsung_clk_pll {
	struct clk_hw hw;
	void *lock_reg;
	void *con_reg;
	short unsigned int enable_offs;
	short unsigned int lock_offs;
	enum samsung_pll_type type;
	unsigned int rate_count;
	const struct samsung_pll_rate_table *rate_table;
};

struct exynos_cpuclk_cfg_data {
	long unsigned int prate;
	long unsigned int div0;
	long unsigned int div1;
};

struct exynos_cpuclk {
	struct clk_hw hw;
	const struct clk_hw *alt_parent;
	void *ctrl_base;
	spinlock_t *lock;
	const struct exynos_cpuclk_cfg_data *cfg;
	const long unsigned int num_cfgs;
	struct notifier_block clk_nb;
	long unsigned int flags;
};

enum exynos4_soc {
	EXYNOS4210 = 0,
	EXYNOS4X12 = 1,
};

enum exynos4_plls {
	apll___7 = 0,
	mpll = 1,
	epll = 2,
	vpll = 3,
	nr_plls = 4,
};

struct exynos5_subcmu_reg_dump {
	u32 offset;
	u32 value;
	u32 mask;
	u32 save;
};

struct exynos5_subcmu_info {
	const struct samsung_div_clock *div_clks;
	unsigned int nr_div_clks;
	const struct samsung_gate_clock *gate_clks;
	unsigned int nr_gate_clks;
	struct exynos5_subcmu_reg_dump *suspend_regs;
	unsigned int nr_suspend_regs;
	const char *pd_name;
};

enum exynos5250_plls {
	apll___8 = 0,
	mpll___2 = 1,
	cpll___5 = 2,
	epll___2 = 3,
	vpll___2 = 4,
	gpll___7 = 5,
	bpll = 6,
	nr_plls___2 = 7,
};

enum exynos5410_plls {
	apll___9 = 0,
	cpll___6 = 1,
	epll___3 = 2,
	mpll___3 = 3,
	bpll___2 = 4,
	kpll = 5,
	nr_plls___3 = 6,
};

enum exynos5x_soc {
	EXYNOS5420 = 0,
	EXYNOS5800 = 1,
};

enum exynos5x_plls {
	apll___10 = 0,
	cpll___7 = 1,
	dpll___7 = 2,
	epll___4 = 3,
	rpll = 4,
	ipll = 5,
	spll = 6,
	vpll___3 = 7,
	mpll___4 = 8,
	bpll___3 = 9,
	kpll___2 = 10,
	nr_plls___4 = 11,
};

struct exynos_audss_clk_drvdata {
	unsigned int has_adma_clk: 1;
	unsigned int has_mst_clk: 1;
	unsigned int enable_epll: 1;
	unsigned int num_clks;
};

struct exynos_clkout {
	struct clk_gate gate;
	struct clk_mux mux;
	spinlock_t slock;
	void *reg;
	struct device_node *np;
	u32 pmu_debug_save;
	struct clk_hw_onecell_data data;
};

struct exynos_clkout_variant {
	u32 mux_mask;
};

struct clk_pll___5 {
	struct clk_hw hw;
	short unsigned int regofs;
};

struct clk_dmn {
	struct clk_hw hw;
	signed char enable_bit;
	short unsigned int regofs;
};

struct clk_std {
	struct clk_hw hw;
	signed char enable_bit;
};

enum prima2_clk_index {
	rtc = 0,
	osc = 1,
	pll1 = 2,
	pll2 = 3,
	pll3 = 4,
	mem = 5,
	sys = 6,
	security = 7,
	dsp = 8,
	gps = 9,
	mf = 10,
	io = 11,
	cpu = 12,
	uart0 = 13,
	uart1 = 14,
	uart2 = 15,
	tsc = 16,
	i2c0 = 17,
	i2c1 = 18,
	spi0 = 19,
	spi1 = 20,
	pwmc = 21,
	efuse = 22,
	pulse = 23,
	dmac0 = 24,
	dmac1 = 25,
	nand = 26,
	audio = 27,
	usp0 = 28,
	usp1 = 29,
	usp2 = 30,
	vip = 31,
	gfx = 32,
	mm = 33,
	lcd = 34,
	vpp = 35,
	mmc01 = 36,
	mmc23 = 37,
	mmc45 = 38,
	usbpll = 39,
	usb0 = 40,
	usb1 = 41,
	cphif = 42,
	maxclk = 43,
};

enum atlas6_clk_index {
	rtc___2 = 0,
	osc___2 = 1,
	pll1___2 = 2,
	pll2___2 = 3,
	pll3___2 = 4,
	mem___2 = 5,
	sys___2 = 6,
	security___2 = 7,
	dsp___2 = 8,
	gps___2 = 9,
	mf___2 = 10,
	io___2 = 11,
	cpu___2 = 12,
	uart0___2 = 13,
	uart1___2 = 14,
	uart2___2 = 15,
	tsc___2 = 16,
	i2c0___2 = 17,
	i2c1___2 = 18,
	spi0___2 = 19,
	spi1___2 = 20,
	pwmc___2 = 21,
	efuse___2 = 22,
	pulse___2 = 23,
	dmac0___2 = 24,
	dmac1___2 = 25,
	nand___2 = 26,
	audio___2 = 27,
	usp0___2 = 28,
	usp1___2 = 29,
	usp2___2 = 30,
	vip___2 = 31,
	gfx___2 = 32,
	gfx2d = 33,
	lcd___2 = 34,
	vpp___2 = 35,
	mmc01___2 = 36,
	mmc23___2 = 37,
	mmc45___2 = 38,
	usbpll___2 = 39,
	usb0___2 = 40,
	usb1___2 = 41,
	cphif___2 = 42,
	maxclk___2 = 43,
};

struct clk_pll___6 {
	struct clk_hw hw;
	u16 regofs;
};

struct clk_dto {
	struct clk_hw hw;
	u16 inc_offset;
	u16 src_offset;
};

enum clk_unit_type {
	CLK_UNIT_NOC_OTHER = 0,
	CLK_UNIT_NOC_CLOCK = 1,
	CLK_UNIT_NOC_SOCKET = 2,
};

struct clk_unit {
	struct clk_hw hw;
	u16 regofs;
	u16 bit;
	u32 type;
	u8 idle_bit;
	spinlock_t *lock;
};

struct atlas7_div_init_data {
	const char *div_name;
	const char *parent_name;
	const char *gate_name;
	long unsigned int flags;
	u8 divider_flags;
	u8 gate_flags;
	u32 div_offset;
	u8 shift;
	u8 width;
	u32 gate_offset;
	u8 gate_bit;
	spinlock_t *lock;
};

struct atlas7_mux_init_data {
	const char *mux_name;
	const char * const *parent_names;
	u8 parent_num;
	long unsigned int flags;
	u8 mux_flags;
	u32 mux_offset;
	u8 shift;
	u8 width;
};

struct atlas7_unit_init_data {
	u32 index;
	const char *unit_name;
	const char *parent_name;
	long unsigned int flags;
	u32 regofs;
	u8 bit;
	u32 type;
	u8 idle_bit;
	spinlock_t *lock;
};

struct atlas7_reset_desc {
	const char *name;
	u32 clk_ofs;
	u8 clk_bit;
	u32 rst_ofs;
	u8 rst_bit;
	spinlock_t *lock;
};

struct socfpga_gate_clk {
	struct clk_gate hw;
	char *parent_name;
	u32 fixed_div;
	void *div_reg;
	void *bypass_reg;
	struct regmap *sys_mgr_base_addr;
	u32 width;
	u32 shift;
	u32 bypass_shift;
	u32 clk_phase[2];
};

struct socfpga_pll {
	struct clk_gate hw;
};

struct socfpga_periph_clk {
	struct clk_gate hw;
	char *parent_name;
	u32 fixed_div;
	void *div_reg;
	void *bypass_reg;
	u32 width;
	u32 shift;
	u32 bypass_shift;
};

typedef long unsigned int (*clk_calc_rate)(struct clk_hw *, long unsigned int, int);

struct aux_clk_masks {
	u32 eq_sel_mask;
	u32 eq_sel_shift;
	u32 eq1_mask;
	u32 eq2_mask;
	u32 xscale_sel_mask;
	u32 xscale_sel_shift;
	u32 yscale_sel_mask;
	u32 yscale_sel_shift;
	u32 enable_bit;
};

struct aux_rate_tbl {
	u16 xscale;
	u16 yscale;
	u8 eq;
};

struct clk_aux {
	struct clk_hw hw;
	void *reg;
	const struct aux_clk_masks *masks;
	struct aux_rate_tbl *rtbl;
	u8 rtbl_cnt;
	spinlock_t *lock;
};

struct frac_rate_tbl {
	u32 div;
};

struct clk_frac {
	struct clk_hw hw;
	void *reg;
	struct frac_rate_tbl *rtbl;
	u8 rtbl_cnt;
	spinlock_t *lock;
};

struct gpt_rate_tbl {
	u16 mscale;
	u16 nscale;
};

struct clk_gpt {
	struct clk_hw hw;
	void *reg;
	struct gpt_rate_tbl *rtbl;
	u8 rtbl_cnt;
	spinlock_t *lock;
};

struct pll_rate_tbl {
	u8 mode;
	u16 m;
	u8 n;
	u8 p;
};

struct clk_vco {
	struct clk_hw hw;
	void *mode_reg;
	void *cfg_reg;
	struct pll_rate_tbl *rtbl;
	u8 rtbl_cnt;
	spinlock_t *lock;
};

struct clk_pll___7 {
	struct clk_hw hw;
	struct clk_vco *vco;
	const char *parent[1];
	spinlock_t *lock;
};

struct clkgen_mux_data {
	u32 offset;
	u8 shift;
	u8 width;
	spinlock_t *lock;
	long unsigned int clk_flags;
	u8 mux_flags;
};

struct clkgen_field {
	unsigned int offset;
	unsigned int mask;
	unsigned int shift;
};

struct clkgen_pll_data {
	struct clkgen_field pdn_status;
	struct clkgen_field pdn_ctrl;
	struct clkgen_field locked_status;
	struct clkgen_field mdiv;
	struct clkgen_field ndiv;
	struct clkgen_field pdiv;
	struct clkgen_field idf;
	struct clkgen_field ldf;
	struct clkgen_field cp;
	unsigned int num_odfs;
	struct clkgen_field odf[4];
	struct clkgen_field odf_gate[4];
	bool switch2pll_en;
	struct clkgen_field switch2pll;
	spinlock_t *lock;
	const struct clk_ops *ops;
};

struct clkgen_pll {
	struct clk_hw hw;
	struct clkgen_pll_data *data;
	void *regs_base;
	spinlock_t *lock;
	u32 ndiv;
	u32 idf;
	u32 odf;
	u32 cp;
};

struct stm_pll {
	long unsigned int mdiv;
	long unsigned int ndiv;
	long unsigned int pdiv;
	long unsigned int odf;
	long unsigned int idf;
	long unsigned int ldf;
	long unsigned int cp;
};

struct stm_fs {
	long unsigned int ndiv;
	long unsigned int mdiv;
	long unsigned int pe;
	long unsigned int sdiv;
	long unsigned int nsdiv;
};

struct clkgen_quadfs_data {
	bool reset_present;
	bool bwfilter_present;
	bool lockstatus_present;
	bool powerup_polarity;
	bool standby_polarity;
	bool nsdiv_present;
	bool nrst_present;
	struct clkgen_field ndiv;
	struct clkgen_field ref_bw;
	struct clkgen_field nreset;
	struct clkgen_field npda;
	struct clkgen_field lock_status;
	struct clkgen_field nrst[4];
	struct clkgen_field nsb[4];
	struct clkgen_field en[4];
	struct clkgen_field mdiv[4];
	struct clkgen_field pe[4];
	struct clkgen_field sdiv[4];
	struct clkgen_field nsdiv[4];
	const struct clk_ops *pll_ops;
	int (*get_params)(long unsigned int, long unsigned int, struct stm_fs *);
	int (*get_rate)(long unsigned int, const struct stm_fs *, long unsigned int *);
};

struct st_clk_quadfs_pll {
	struct clk_hw hw;
	void *regs_base;
	spinlock_t *lock;
	struct clkgen_quadfs_data *data;
	u32 ndiv;
};

struct st_clk_quadfs_fsynth {
	struct clk_hw hw;
	void *regs_base;
	spinlock_t *lock;
	struct clkgen_quadfs_data *data;
	u32 chan;
	u32 md;
	u32 pe;
	u32 sdiv;
	u32 nsdiv;
};

struct clkgen_data {
	long unsigned int flags;
	bool mode;
};

struct flexgen {
	struct clk_hw hw;
	struct clk_mux mux;
	struct clk_gate pgate;
	struct clk_divider pdiv;
	struct clk_gate fgate;
	struct clk_divider fdiv;
	struct clk_gate sync;
	bool control_mode;
};

struct clk_factors_config {
	u8 nshift;
	u8 nwidth;
	u8 kshift;
	u8 kwidth;
	u8 mshift;
	u8 mwidth;
	u8 pshift;
	u8 pwidth;
	u8 n_start;
};

struct factors_request {
	long unsigned int rate;
	long unsigned int parent_rate;
	u8 parent_index;
	u8 n;
	u8 k;
	u8 m;
	u8 p;
};

struct factors_data {
	int enable;
	int mux;
	int muxmask;
	const struct clk_factors_config *table;
	void (*getter)(struct factors_request *);
	void (*recalc)(struct factors_request *);
	const char *name;
};

struct clk_factors {
	struct clk_hw hw;
	void *reg;
	const struct clk_factors_config *config;
	void (*get_factors)(struct factors_request *);
	void (*recalc)(struct factors_request *);
	spinlock_t *lock;
	struct clk_mux *mux;
	struct clk_gate *gate;
};

struct mux_data {
	u8 shift;
};

struct div_data {
	u8 shift;
	u8 pow;
	u8 width;
	const struct clk_div_table *table;
};

struct divs_data {
	const struct factors_data *factors;
	int ndivs;
	struct {
		u8 self;
		u8 fixed;
		struct clk_div_table *table;
		u8 shift;
		u8 pow;
		u8 gate;
		bool critical;
	} div[4];
};

struct ve_reset_data {
	void *reg;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
};

struct mmc_phase {
	struct clk_hw hw;
	u8 offset;
	void *reg;
	spinlock_t *lock;
};

struct sun4i_a10_display_clk_data {
	bool has_div;
	u8 num_rst;
	u8 parents;
	u8 offset_en;
	u8 offset_div;
	u8 offset_mux;
	u8 offset_rst;
	u8 width_div;
	u8 width_mux;
	u32 flags;
};

struct reset_data {
	void *reg;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
	u8 offset;
};

struct tcon_ch1_clk {
	struct clk_hw hw;
	spinlock_t lock;
	void *reg;
};

enum {
	AHB1 = 0,
	AHB2 = 1,
	APB1 = 2,
	APB2 = 3,
	PARENT_MAX = 4,
};

struct sun9i_mmc_clk_data {
	spinlock_t lock;
	void *membase;
	struct clk *clk;
	struct reset_control *reset;
	struct clk_onecell_data clk_data;
	struct reset_controller_dev rcdev;
};

struct usb_reset_data {
	void *reg;
	spinlock_t *lock;
	struct clk *clk;
	struct reset_controller_dev rcdev;
};

struct usb_clk_data {
	u32 clk_mask;
	u32 reset_mask;
	bool reset_needs_clk;
};

struct sun9i_a80_cpus_clk {
	struct clk_hw hw;
	void *reg;
};

struct gates_data {
	long unsigned int mask[1];
};

struct ccu_common {
	void *base;
	u16 reg;
	u16 lock_reg;
	u32 prediv;
	long unsigned int features;
	spinlock_t *lock;
	struct clk_hw hw;
};

struct ccu_reset_map;

struct sunxi_ccu_desc {
	struct ccu_common **ccu_clks;
	long unsigned int num_ccu_clks;
	struct clk_hw_onecell_data *hw_clks;
	struct ccu_reset_map *resets;
	long unsigned int num_resets;
};

struct ccu_reset_map {
	u16 reg;
	u32 bit;
};

struct ccu_pll_nb {
	struct notifier_block clk_nb;
	struct ccu_common *common;
	u32 enable;
	u32 lock;
};

struct ccu_reset {
	void *base;
	struct ccu_reset_map *reset_map;
	spinlock_t *lock;
	struct reset_controller_dev rcdev;
};

struct ccu_mux_fixed_prediv {
	u8 index;
	u16 div;
};

struct ccu_mux_var_prediv {
	u8 index;
	u8 shift;
	u8 width;
};

struct ccu_mux_internal {
	u8 shift;
	u8 width;
	const u8 *table;
	const struct ccu_mux_fixed_prediv *fixed_predivs;
	u8 n_predivs;
	const struct ccu_mux_var_prediv *var_predivs;
	u8 n_var_predivs;
};

struct ccu_div_internal {
	u8 shift;
	u8 width;
	u32 max;
	u32 offset;
	u32 flags;
	struct clk_div_table *table;
};

struct ccu_div {
	u32 enable;
	struct ccu_div_internal div;
	struct ccu_mux_internal mux;
	struct ccu_common common;
	unsigned int fixed_post_div;
};

struct ccu_frac_internal {
	u32 enable;
	u32 select;
	long unsigned int rates[2];
};

struct ccu_gate {
	u32 enable;
	struct ccu_common common;
};

struct ccu_mux {
	u16 reg;
	u32 enable;
	struct ccu_mux_internal mux;
	struct ccu_common common;
};

struct ccu_mux_nb {
	struct notifier_block clk_nb;
	struct ccu_common *common;
	struct ccu_mux_internal *cm;
	u32 delay_us;
	u8 bypass_index;
	u8 original_index;
};

struct ccu_mult_internal {
	u8 offset;
	u8 shift;
	u8 width;
	u8 min;
	u8 max;
};

struct ccu_mult {
	u32 enable;
	u32 lock;
	struct ccu_frac_internal frac;
	struct ccu_mult_internal mult;
	struct ccu_mux_internal mux;
	struct ccu_common common;
};

struct _ccu_mult {
	long unsigned int mult;
	long unsigned int min;
	long unsigned int max;
};

struct ccu_phase {
	u8 shift;
	u8 width;
	struct ccu_common common;
};

struct ccu_sdm_setting {
	long unsigned int rate;
	u32 pattern;
	u32 m;
	u32 n;
};

struct ccu_sdm_internal {
	struct ccu_sdm_setting *table;
	u32 table_size;
	u32 enable;
	u32 tuning_enable;
	u16 tuning_reg;
};

struct ccu_nk {
	u16 reg;
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct _ccu_nk {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int k;
	long unsigned int min_k;
	long unsigned int max_k;
};

struct ccu_nkm {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	struct ccu_div_internal m;
	struct ccu_mux_internal mux;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct _ccu_nkm {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int k;
	long unsigned int min_k;
	long unsigned int max_k;
	long unsigned int m;
	long unsigned int min_m;
	long unsigned int max_m;
};

struct ccu_nkmp {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_mult_internal k;
	struct ccu_div_internal m;
	struct ccu_div_internal p;
	unsigned int fixed_post_div;
	unsigned int max_rate;
	struct ccu_common common;
};

struct _ccu_nkmp {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int k;
	long unsigned int min_k;
	long unsigned int max_k;
	long unsigned int m;
	long unsigned int min_m;
	long unsigned int max_m;
	long unsigned int p;
	long unsigned int min_p;
	long unsigned int max_p;
};

struct ccu_nm {
	u32 enable;
	u32 lock;
	struct ccu_mult_internal n;
	struct ccu_div_internal m;
	struct ccu_frac_internal frac;
	struct ccu_sdm_internal sdm;
	unsigned int fixed_post_div;
	unsigned int min_rate;
	unsigned int max_rate;
	struct ccu_common common;
};

struct _ccu_nm {
	long unsigned int n;
	long unsigned int min_n;
	long unsigned int max_n;
	long unsigned int m;
	long unsigned int min_m;
	long unsigned int max_m;
};

struct ccu_mp {
	u32 enable;
	struct ccu_div_internal m;
	struct ccu_div_internal p;
	struct ccu_mux_internal mux;
	unsigned int fixed_post_div;
	struct ccu_common common;
};

struct tegra_clk_periph_regs {
	u32 enb_reg;
	u32 enb_set_reg;
	u32 enb_clr_reg;
	u32 rst_reg;
	u32 rst_set_reg;
	u32 rst_clr_reg;
};

struct tegra_clk_init_table {
	unsigned int clk_id;
	unsigned int parent_id;
	long unsigned int rate;
	int state;
};

struct tegra_clk_duplicate {
	int clk_id;
	struct clk_lookup lookup;
};

struct tegra_clk {
	int dt_id;
	bool present;
};

struct tegra_devclk {
	int dt_id;
	char *dev_id;
	char *con_id;
};

typedef void (*tegra_clk_apply_init_table_func)();

struct tegra_clk_sync_source {
	struct clk_hw hw;
	long unsigned int rate;
	long unsigned int max_rate;
};

struct rail_alignment {
	int offset_uv;
	int step_uv;
};

struct cvb_coefficients {
	int c0;
	int c1;
	int c2;
};

struct cvb_table_freq_entry {
	long unsigned int freq;
	struct cvb_coefficients coefficients;
};

struct cvb_cpu_dfll_data {
	u32 tune0_low;
	u32 tune0_high;
	u32 tune1;
	unsigned int tune_high_min_millivolts;
};

struct cvb_table {
	int speedo_id;
	int process_id;
	int min_millivolts;
	int max_millivolts;
	int speedo_scale;
	int voltage_scale;
	struct cvb_table_freq_entry entries[40];
	struct cvb_cpu_dfll_data cpu_dfll_data;
};

struct tegra_dfll_soc_data {
	struct device *dev;
	long unsigned int max_freq;
	const struct cvb_table *cvb;
	struct rail_alignment alignment;
	void (*init_clock_trimmers)();
	void (*set_clock_trimmers_high)();
	void (*set_clock_trimmers_low)();
};

enum dfll_ctrl_mode {
	DFLL_UNINITIALIZED = 0,
	DFLL_DISABLED = 1,
	DFLL_OPEN_LOOP = 2,
	DFLL_CLOSED_LOOP = 3,
};

enum dfll_tune_range {
	DFLL_TUNE_UNINITIALIZED = 0,
	DFLL_TUNE_LOW = 1,
};

enum tegra_dfll_pmu_if {
	TEGRA_DFLL_PMU_I2C = 0,
	TEGRA_DFLL_PMU_PWM = 1,
};

struct dfll_rate_req {
	long unsigned int rate;
	long unsigned int dvco_target_rate;
	int lut_index;
	u8 mult_bits;
	u8 scale_bits;
};

struct tegra_dfll {
	struct device *dev;
	struct tegra_dfll_soc_data *soc;
	void *base;
	void *i2c_base;
	void *i2c_controller_base;
	void *lut_base;
	struct regulator *vdd_reg;
	struct clk *soc_clk;
	struct clk *ref_clk;
	struct clk *i2c_clk;
	struct clk *dfll_clk;
	struct reset_control *dvco_rst;
	long unsigned int ref_rate;
	long unsigned int i2c_clk_rate;
	long unsigned int dvco_rate_min;
	enum dfll_ctrl_mode mode;
	enum dfll_tune_range tune_range;
	struct dentry *debugfs_dir;
	struct clk_hw dfll_clk_hw;
	const char *output_clock_name;
	struct dfll_rate_req last_req;
	long unsigned int last_unrounded_rate;
	u32 droop_ctrl;
	u32 sample_rate;
	u32 force_mode;
	u32 cf;
	u32 ci;
	u32 cg;
	bool cg_scale;
	u32 i2c_fs_rate;
	u32 i2c_reg;
	u32 i2c_slave_addr;
	unsigned int lut[33];
	long unsigned int lut_uv[33];
	int lut_size;
	u8 lut_bottom;
	u8 lut_min;
	u8 lut_max;
	u8 lut_safe;
	enum tegra_dfll_pmu_if pmu_if;
	long unsigned int pwm_rate;
	struct pinctrl *pwm_pin;
	struct pinctrl_state *pwm_enable_state;
	struct pinctrl_state *pwm_disable_state;
	u32 reg_init_uV;
};

struct tegra_clk_frac_div {
	struct clk_hw hw;
	void *reg;
	u8 flags;
	u8 shift;
	u8 width;
	u8 frac_width;
	spinlock_t *lock;
};

struct tegra_clk_periph_gate {
	u32 magic;
	struct clk_hw hw;
	void *clk_base;
	u8 flags;
	int clk_num;
	int *enable_refcnt;
	const struct tegra_clk_periph_regs *regs;
};

struct tegra_clk_periph {
	u32 magic;
	struct clk_hw hw;
	struct clk_mux mux;
	struct tegra_clk_frac_div divider;
	struct tegra_clk_periph_gate gate;
	const struct clk_ops *mux_ops;
	const struct clk_ops *div_ops;
	const struct clk_ops *gate_ops;
};

struct tegra_periph_init_data {
	const char *name;
	int clk_id;
	union {
		const char * const *parent_names;
		const char *parent_name;
	} p;
	int num_parents;
	struct tegra_clk_periph periph;
	u32 offset;
	const char *con_id;
	const char *dev_id;
	long unsigned int flags;
};

struct tegra_clk_periph_fixed {
	struct clk_hw hw;
	void *base;
	const struct tegra_clk_periph_regs *regs;
	unsigned int mul;
	unsigned int div;
	unsigned int num;
};

struct tegra_clk_pll_freq_table {
	long unsigned int input_rate;
	long unsigned int output_rate;
	u32 n;
	u32 m;
	u8 p;
	u8 cpcon;
	u16 sdm_data;
};

struct pdiv_map {
	u8 pdiv;
	u8 hw_val;
};

struct div_nmp {
	u8 divn_shift;
	u8 divn_width;
	u8 divm_shift;
	u8 divm_width;
	u8 divp_shift;
	u8 divp_width;
	u8 override_divn_shift;
	u8 override_divm_shift;
	u8 override_divp_shift;
};

struct tegra_clk_pll;

struct tegra_clk_pll_params {
	long unsigned int input_min;
	long unsigned int input_max;
	long unsigned int cf_min;
	long unsigned int cf_max;
	long unsigned int vco_min;
	long unsigned int vco_max;
	u32 base_reg;
	u32 misc_reg;
	u32 lock_reg;
	u32 lock_mask;
	u32 lock_enable_bit_idx;
	u32 iddq_reg;
	u32 iddq_bit_idx;
	u32 reset_reg;
	u32 reset_bit_idx;
	u32 sdm_din_reg;
	u32 sdm_din_mask;
	u32 sdm_ctrl_reg;
	u32 sdm_ctrl_en_mask;
	u32 ssc_ctrl_reg;
	u32 ssc_ctrl_en_mask;
	u32 aux_reg;
	u32 dyn_ramp_reg;
	u32 ext_misc_reg[6];
	u32 pmc_divnm_reg;
	u32 pmc_divp_reg;
	u32 flags;
	int stepa_shift;
	int stepb_shift;
	int lock_delay;
	int max_p;
	bool defaults_set;
	const struct pdiv_map *pdiv_tohw;
	struct div_nmp *div_nmp;
	struct tegra_clk_pll_freq_table *freq_table;
	long unsigned int fixed_rate;
	u16 mdiv_default;
	u32 (*round_p_to_pdiv)(u32, u32 *);
	void (*set_gain)(struct tegra_clk_pll_freq_table *);
	int (*calc_rate)(struct clk_hw *, struct tegra_clk_pll_freq_table *, long unsigned int, long unsigned int);
	long unsigned int (*adjust_vco)(struct tegra_clk_pll_params *, long unsigned int);
	void (*set_defaults)(struct tegra_clk_pll *);
	int (*dyn_ramp)(struct tegra_clk_pll *, struct tegra_clk_pll_freq_table *);
	int (*pre_rate_change)();
	void (*post_rate_change)();
};

struct tegra_clk_pll {
	struct clk_hw hw;
	void *clk_base;
	void *pmc;
	spinlock_t *lock;
	struct tegra_clk_pll_params *params;
};

struct utmi_clk_param {
	u32 osc_frequency;
	u8 enable_delay_count;
	u8 stable_count;
	u8 active_delay_count;
	u8 xtal_freq_count;
};

struct tegra_clk_pll_out {
	struct clk_hw hw;
	void *reg;
	u8 enb_bit_idx;
	u8 rst_bit_idx;
	spinlock_t *lock;
	u8 flags;
};

struct tegra_sdmmc_mux {
	struct clk_hw hw;
	void *reg;
	spinlock_t *lock;
	const struct clk_ops *gate_ops;
	struct tegra_clk_periph_gate gate;
	u8 div_flags;
};

struct tegra_clk_super_mux {
	struct clk_hw hw;
	void *reg;
	struct tegra_clk_frac_div frac_div;
	const struct clk_ops *div_ops;
	u8 width;
	u8 flags;
	u8 div2_index;
	u8 pllx_index;
	spinlock_t *lock;
};

struct tegra_audio_clk_info {
	char *name;
	struct tegra_clk_pll_params *pll_params;
	int clk_id;
	char *parent;
};

enum clk_id {
	tegra_clk_actmon = 0,
	tegra_clk_adx = 1,
	tegra_clk_adx1 = 2,
	tegra_clk_afi = 3,
	tegra_clk_amx = 4,
	tegra_clk_amx1 = 5,
	tegra_clk_apb2ape = 6,
	tegra_clk_ahbdma = 7,
	tegra_clk_apbdma = 8,
	tegra_clk_apbif = 9,
	tegra_clk_ape = 10,
	tegra_clk_audio0 = 11,
	tegra_clk_audio0_2x = 12,
	tegra_clk_audio0_mux = 13,
	tegra_clk_audio1 = 14,
	tegra_clk_audio1_2x = 15,
	tegra_clk_audio1_mux = 16,
	tegra_clk_audio2 = 17,
	tegra_clk_audio2_2x = 18,
	tegra_clk_audio2_mux = 19,
	tegra_clk_audio3 = 20,
	tegra_clk_audio3_2x = 21,
	tegra_clk_audio3_mux = 22,
	tegra_clk_audio4 = 23,
	tegra_clk_audio4_2x = 24,
	tegra_clk_audio4_mux = 25,
	tegra_clk_bsea = 26,
	tegra_clk_bsev = 27,
	tegra_clk_cclk_g = 28,
	tegra_clk_cclk_lp = 29,
	tegra_clk_cilab = 30,
	tegra_clk_cilcd = 31,
	tegra_clk_cile = 32,
	tegra_clk_clk_32k = 33,
	tegra_clk_clk72Mhz = 34,
	tegra_clk_clk72Mhz_8 = 35,
	tegra_clk_clk_m = 36,
	tegra_clk_osc = 37,
	tegra_clk_osc_div2 = 38,
	tegra_clk_osc_div4 = 39,
	tegra_clk_cml0 = 40,
	tegra_clk_cml1 = 41,
	tegra_clk_csi = 42,
	tegra_clk_csite = 43,
	tegra_clk_csite_8 = 44,
	tegra_clk_csus = 45,
	tegra_clk_cve = 46,
	tegra_clk_dam0 = 47,
	tegra_clk_dam1 = 48,
	tegra_clk_dam2 = 49,
	tegra_clk_d_audio = 50,
	tegra_clk_dbgapb = 51,
	tegra_clk_dds = 52,
	tegra_clk_dfll_ref = 53,
	tegra_clk_dfll_soc = 54,
	tegra_clk_disp1 = 55,
	tegra_clk_disp1_8 = 56,
	tegra_clk_disp2 = 57,
	tegra_clk_disp2_8 = 58,
	tegra_clk_dp2 = 59,
	tegra_clk_dpaux = 60,
	tegra_clk_dpaux1 = 61,
	tegra_clk_dsialp = 62,
	tegra_clk_dsia_mux = 63,
	tegra_clk_dsiblp = 64,
	tegra_clk_dsib_mux = 65,
	tegra_clk_dtv = 66,
	tegra_clk_emc = 67,
	tegra_clk_entropy = 68,
	tegra_clk_entropy_8 = 69,
	tegra_clk_epp = 70,
	tegra_clk_epp_8 = 71,
	tegra_clk_extern1 = 72,
	tegra_clk_extern2 = 73,
	tegra_clk_extern3 = 74,
	tegra_clk_fuse = 75,
	tegra_clk_fuse_burn = 76,
	tegra_clk_gpu = 77,
	tegra_clk_gr2d = 78,
	tegra_clk_gr2d_8 = 79,
	tegra_clk_gr3d = 80,
	tegra_clk_gr3d_8 = 81,
	tegra_clk_hclk = 82,
	tegra_clk_hda = 83,
	tegra_clk_hda_8 = 84,
	tegra_clk_hda2codec_2x = 85,
	tegra_clk_hda2codec_2x_8 = 86,
	tegra_clk_hda2hdmi = 87,
	tegra_clk_hdmi = 88,
	tegra_clk_hdmi_audio = 89,
	tegra_clk_host1x = 90,
	tegra_clk_host1x_8 = 91,
	tegra_clk_host1x_9 = 92,
	tegra_clk_hsic_trk = 93,
	tegra_clk_i2c1 = 94,
	tegra_clk_i2c2 = 95,
	tegra_clk_i2c3 = 96,
	tegra_clk_i2c4 = 97,
	tegra_clk_i2c5 = 98,
	tegra_clk_i2c6 = 99,
	tegra_clk_i2cslow = 100,
	tegra_clk_i2s0 = 101,
	tegra_clk_i2s0_sync = 102,
	tegra_clk_i2s1 = 103,
	tegra_clk_i2s1_sync = 104,
	tegra_clk_i2s2 = 105,
	tegra_clk_i2s2_sync = 106,
	tegra_clk_i2s3 = 107,
	tegra_clk_i2s3_sync = 108,
	tegra_clk_i2s4 = 109,
	tegra_clk_i2s4_sync = 110,
	tegra_clk_isp = 111,
	tegra_clk_isp_8 = 112,
	tegra_clk_isp_9 = 113,
	tegra_clk_ispb = 114,
	tegra_clk_kbc = 115,
	tegra_clk_kfuse = 116,
	tegra_clk_la = 117,
	tegra_clk_maud = 118,
	tegra_clk_mipi = 119,
	tegra_clk_mipibif = 120,
	tegra_clk_mipi_cal = 121,
	tegra_clk_mpe = 122,
	tegra_clk_mselect = 123,
	tegra_clk_msenc = 124,
	tegra_clk_ndflash = 125,
	tegra_clk_ndflash_8 = 126,
	tegra_clk_ndspeed = 127,
	tegra_clk_ndspeed_8 = 128,
	tegra_clk_nor = 129,
	tegra_clk_nvdec = 130,
	tegra_clk_nvenc = 131,
	tegra_clk_nvjpg = 132,
	tegra_clk_owr = 133,
	tegra_clk_owr_8 = 134,
	tegra_clk_pcie = 135,
	tegra_clk_pclk = 136,
	tegra_clk_pll_a = 137,
	tegra_clk_pll_a_out0 = 138,
	tegra_clk_pll_a1 = 139,
	tegra_clk_pll_c = 140,
	tegra_clk_pll_c2 = 141,
	tegra_clk_pll_c3 = 142,
	tegra_clk_pll_c4 = 143,
	tegra_clk_pll_c4_out0 = 144,
	tegra_clk_pll_c4_out1 = 145,
	tegra_clk_pll_c4_out2 = 146,
	tegra_clk_pll_c4_out3 = 147,
	tegra_clk_pll_c_out1 = 148,
	tegra_clk_pll_d = 149,
	tegra_clk_pll_d2 = 150,
	tegra_clk_pll_d2_out0 = 151,
	tegra_clk_pll_d_out0 = 152,
	tegra_clk_pll_dp = 153,
	tegra_clk_pll_e_out0 = 154,
	tegra_clk_pll_g_ref = 155,
	tegra_clk_pll_m = 156,
	tegra_clk_pll_m_out1 = 157,
	tegra_clk_pll_mb = 158,
	tegra_clk_pll_p = 159,
	tegra_clk_pll_p_out1 = 160,
	tegra_clk_pll_p_out2 = 161,
	tegra_clk_pll_p_out2_int = 162,
	tegra_clk_pll_p_out3 = 163,
	tegra_clk_pll_p_out4 = 164,
	tegra_clk_pll_p_out4_cpu = 165,
	tegra_clk_pll_p_out5 = 166,
	tegra_clk_pll_p_out_hsio = 167,
	tegra_clk_pll_p_out_xusb = 168,
	tegra_clk_pll_p_out_cpu = 169,
	tegra_clk_pll_p_out_adsp = 170,
	tegra_clk_pll_ref = 171,
	tegra_clk_pll_re_out = 172,
	tegra_clk_pll_re_vco = 173,
	tegra_clk_pll_u = 174,
	tegra_clk_pll_u_out = 175,
	tegra_clk_pll_u_out1 = 176,
	tegra_clk_pll_u_out2 = 177,
	tegra_clk_pll_u_12m = 178,
	tegra_clk_pll_u_480m = 179,
	tegra_clk_pll_u_48m = 180,
	tegra_clk_pll_u_60m = 181,
	tegra_clk_pll_x = 182,
	tegra_clk_pll_x_out0 = 183,
	tegra_clk_pwm = 184,
	tegra_clk_qspi = 185,
	tegra_clk_rtc = 186,
	tegra_clk_sata = 187,
	tegra_clk_sata_8 = 188,
	tegra_clk_sata_cold = 189,
	tegra_clk_sata_oob = 190,
	tegra_clk_sata_oob_8 = 191,
	tegra_clk_sbc1 = 192,
	tegra_clk_sbc1_8 = 193,
	tegra_clk_sbc1_9 = 194,
	tegra_clk_sbc2 = 195,
	tegra_clk_sbc2_8 = 196,
	tegra_clk_sbc2_9 = 197,
	tegra_clk_sbc3 = 198,
	tegra_clk_sbc3_8 = 199,
	tegra_clk_sbc3_9 = 200,
	tegra_clk_sbc4 = 201,
	tegra_clk_sbc4_8 = 202,
	tegra_clk_sbc4_9 = 203,
	tegra_clk_sbc5 = 204,
	tegra_clk_sbc5_8 = 205,
	tegra_clk_sbc6 = 206,
	tegra_clk_sbc6_8 = 207,
	tegra_clk_sclk = 208,
	tegra_clk_sdmmc_legacy = 209,
	tegra_clk_sdmmc1 = 210,
	tegra_clk_sdmmc1_8 = 211,
	tegra_clk_sdmmc1_9 = 212,
	tegra_clk_sdmmc2 = 213,
	tegra_clk_sdmmc2_8 = 214,
	tegra_clk_sdmmc3 = 215,
	tegra_clk_sdmmc3_8 = 216,
	tegra_clk_sdmmc3_9 = 217,
	tegra_clk_sdmmc4 = 218,
	tegra_clk_sdmmc4_8 = 219,
	tegra_clk_se = 220,
	tegra_clk_se_10 = 221,
	tegra_clk_soc_therm = 222,
	tegra_clk_soc_therm_8 = 223,
	tegra_clk_sor0 = 224,
	tegra_clk_sor0_out = 225,
	tegra_clk_sor1 = 226,
	tegra_clk_sor1_out = 227,
	tegra_clk_spdif = 228,
	tegra_clk_spdif_2x = 229,
	tegra_clk_spdif_in = 230,
	tegra_clk_spdif_in_8 = 231,
	tegra_clk_spdif_in_sync = 232,
	tegra_clk_spdif_mux = 233,
	tegra_clk_spdif_out = 234,
	tegra_clk_timer = 235,
	tegra_clk_trace = 236,
	tegra_clk_tsec = 237,
	tegra_clk_tsec_8 = 238,
	tegra_clk_tsecb = 239,
	tegra_clk_tsensor = 240,
	tegra_clk_tvdac = 241,
	tegra_clk_tvo = 242,
	tegra_clk_uarta = 243,
	tegra_clk_uarta_8 = 244,
	tegra_clk_uartb = 245,
	tegra_clk_uartb_8 = 246,
	tegra_clk_uartc = 247,
	tegra_clk_uartc_8 = 248,
	tegra_clk_uartd = 249,
	tegra_clk_uartd_8 = 250,
	tegra_clk_uarte = 251,
	tegra_clk_uarte_8 = 252,
	tegra_clk_uartape = 253,
	tegra_clk_usb2 = 254,
	tegra_clk_usb2_hsic_trk = 255,
	tegra_clk_usb2_trk = 256,
	tegra_clk_usb3 = 257,
	tegra_clk_usbd = 258,
	tegra_clk_vcp = 259,
	tegra_clk_vde = 260,
	tegra_clk_vde_8 = 261,
	tegra_clk_vfir = 262,
	tegra_clk_vi = 263,
	tegra_clk_vi_8 = 264,
	tegra_clk_vi_9 = 265,
	tegra_clk_vi_10 = 266,
	tegra_clk_vi_i2c = 267,
	tegra_clk_vic03 = 268,
	tegra_clk_vic03_8 = 269,
	tegra_clk_vim2_clk = 270,
	tegra_clk_vimclk_sync = 271,
	tegra_clk_vi_sensor = 272,
	tegra_clk_vi_sensor_8 = 273,
	tegra_clk_vi_sensor_9 = 274,
	tegra_clk_vi_sensor2 = 275,
	tegra_clk_vi_sensor2_8 = 276,
	tegra_clk_xusb_dev = 277,
	tegra_clk_xusb_dev_src = 278,
	tegra_clk_xusb_dev_src_8 = 279,
	tegra_clk_xusb_falcon_src = 280,
	tegra_clk_xusb_falcon_src_8 = 281,
	tegra_clk_xusb_fs_src = 282,
	tegra_clk_xusb_gate = 283,
	tegra_clk_xusb_host = 284,
	tegra_clk_xusb_host_src = 285,
	tegra_clk_xusb_host_src_8 = 286,
	tegra_clk_xusb_hs_src = 287,
	tegra_clk_xusb_hs_src_4 = 288,
	tegra_clk_xusb_ss = 289,
	tegra_clk_xusb_ss_src = 290,
	tegra_clk_xusb_ss_src_8 = 291,
	tegra_clk_xusb_ss_div2 = 292,
	tegra_clk_xusb_ssp_src = 293,
	tegra_clk_sclk_mux = 294,
	tegra_clk_sor_safe = 295,
	tegra_clk_cec = 296,
	tegra_clk_ispa = 297,
	tegra_clk_dmic1 = 298,
	tegra_clk_dmic2 = 299,
	tegra_clk_dmic3 = 300,
	tegra_clk_dmic1_sync_clk = 301,
	tegra_clk_dmic2_sync_clk = 302,
	tegra_clk_dmic3_sync_clk = 303,
	tegra_clk_dmic1_sync_clk_mux = 304,
	tegra_clk_dmic2_sync_clk_mux = 305,
	tegra_clk_dmic3_sync_clk_mux = 306,
	tegra_clk_iqc1 = 307,
	tegra_clk_iqc2 = 308,
	tegra_clk_pll_a_out_adsp = 309,
	tegra_clk_pll_a_out0_out_adsp = 310,
	tegra_clk_adsp = 311,
	tegra_clk_adsp_neon = 312,
	tegra_clk_max = 313,
};

struct tegra_sync_source_initdata {
	char *name;
	long unsigned int rate;
	long unsigned int max_rate;
	int clk_id;
};

struct tegra_audio_clk_initdata {
	char *gate_name;
	char *mux_name;
	u32 offset;
	int gate_clk_id;
	int mux_clk_id;
};

struct tegra_audio2x_clk_initdata {
	char *parent;
	char *gate_name;
	char *name_2x;
	char *div_name;
	int clk_id;
	int clk_num;
	u8 div_offset;
};

struct pll_out_data {
	char *div_name;
	char *pll_out_name;
	u32 offset;
	int clk_id;
	u8 div_shift;
	u8 div_flags;
	u8 rst_shift;
	spinlock_t *lock;
};

enum tegra_super_gen {
	gen4 = 4,
	gen5 = 5,
};

struct tegra_super_gen_info {
	enum tegra_super_gen gen;
	const char **sclk_parents;
	const char **cclk_g_parents;
	const char **cclk_lp_parents;
	int num_sclk_parents;
	int num_cclk_g_parents;
	int num_cclk_lp_parents;
};

struct cpu_clk_suspend_context {
	u32 pllx_misc;
	u32 pllx_base;
	u32 cpu_burst;
	u32 clk_csite_src;
	u32 cclk_divider;
};

typedef long int tegra20_clk_emc_round_cb(long unsigned int, long unsigned int, long unsigned int, void *);

struct tegra_clk_emc {
	struct clk_hw hw;
	void *reg;
	bool mc_same_freq;
	bool want_low_jitter;
	tegra20_clk_emc_round_cb *round_cb;
	void *cb_arg;
};

struct cpu_clk_suspend_context___2 {
	u32 clk_csite_src;
	u32 cclkg_burst;
	u32 cclkg_divider;
};

enum tegra_revision {
	TEGRA_REVISION_UNKNOWN = 0,
	TEGRA_REVISION_A01 = 1,
	TEGRA_REVISION_A02 = 2,
	TEGRA_REVISION_A03 = 3,
	TEGRA_REVISION_A03p = 4,
	TEGRA_REVISION_A04 = 5,
	TEGRA_REVISION_MAX = 6,
};

struct tegra_sku_info {
	int sku_id;
	int cpu_process_id;
	int cpu_speedo_id;
	int cpu_speedo_value;
	int cpu_iddq_value;
	int soc_process_id;
	int soc_speedo_id;
	int soc_speedo_value;
	int gpu_process_id;
	int gpu_speedo_id;
	int gpu_speedo_value;
	enum tegra_revision revision;
};

struct dfll_fcpu_data {
	const long unsigned int *cpu_max_freq_table;
	unsigned int cpu_max_freq_table_size;
	const struct cvb_table *cpu_cvb_tables;
	unsigned int cpu_cvb_tables_size;
};

struct emc_timing {
	long unsigned int rate;
	long unsigned int parent_rate;
	u8 parent_index;
	struct clk *parent;
	u32 ram_code;
};

struct tegra_emc;

struct tegra_clk_emc___2 {
	struct clk_hw hw;
	void *clk_regs;
	struct clk *prev_parent;
	bool changing_timing;
	struct device_node *emc_node;
	struct tegra_emc *emc;
	int num_timings;
	struct emc_timing *timings;
	spinlock_t *lock;
};

enum {
	DOWN___2 = 0,
	UP___2 = 1,
};

struct ti_dt_clk {
	struct clk_lookup lk;
	char *node_name;
};

typedef void (*ti_of_clk_init_cb_t)(void *, struct device_node *);

struct clk_iomap {
	struct regmap *regmap;
	void *mem;
};

struct clk_init_item {
	struct device_node *node;
	void *user;
	ti_of_clk_init_cb_t func;
	struct list_head link;
};

struct clk_ti_autoidle {
	struct clk_omap_reg reg;
	u8 shift;
	u8 flags;
	const char *name;
	struct list_head node;
};

enum {
	CLK_COMPONENT_TYPE_GATE = 0,
	CLK_COMPONENT_TYPE_DIVIDER = 1,
	CLK_COMPONENT_TYPE_MUX = 2,
	CLK_COMPONENT_TYPE_MAX = 3,
};

struct component_clk {
	int num_parents;
	const char **parent_names;
	struct device_node *node;
	int type;
	struct clk_hw *hw;
	struct list_head link;
};

struct clk_hw_omap_comp {
	struct clk_hw hw;
	struct device_node *comp_nodes[3];
	struct component_clk *comp_clks[3];
};

struct clk_omap_divider {
	struct clk_hw hw;
	struct clk_omap_reg reg;
	u8 shift;
	u8 flags;
	s8 latch;
	u16 min;
	u16 max;
	u16 mask;
	const struct clk_div_table *table;
	u32 context;
};

struct clk_omap_mux {
	struct clk_hw hw;
	struct clk_omap_reg reg;
	u32 *table;
	u32 mask;
	u8 shift;
	s8 latch;
	u8 flags;
	u8 saved_parent;
};

struct ti_clk_mux {
	u8 bit_shift;
	int num_parents;
	u16 reg;
	u8 module;
	const char * const *parents;
	u16 flags;
};

enum {
	TI_CLK_FIXED = 0,
	TI_CLK_MUX = 1,
	TI_CLK_DIVIDER = 2,
	TI_CLK_COMPOSITE = 3,
	TI_CLK_FIXED_FACTOR = 4,
	TI_CLK_GATE = 5,
	TI_CLK_DPLL = 6,
};

struct omap_clkctrl_div_data {
	const int *dividers;
	int max_div;
	u32 flags;
};

struct omap_clkctrl_bit_data {
	u8 bit;
	u8 type;
	const char * const *parents;
	const void *data;
};

struct omap_clkctrl_reg_data {
	u16 offset;
	const struct omap_clkctrl_bit_data *bit_data;
	u16 flags;
	const char *parent;
	const char *clkdm_name;
};

struct omap_clkctrl_data {
	u32 addr;
	const struct omap_clkctrl_reg_data *regs;
};

struct omap_clkctrl_provider {
	void *base;
	struct list_head clocks;
	char *clkdm_name;
};

struct omap_clkctrl_clk {
	struct clk_hw *clk;
	u16 reg_offset;
	int bit_offset;
	struct list_head node;
};

union omap4_timeout {
	u32 cycles;
	ktime_t start;
};

struct omap3_dpll5_settings {
	unsigned int rate;
	unsigned int m;
	unsigned int n;
};

struct fapll_data {
	struct clk_hw hw;
	void *base;
	const char *name;
	struct clk *clk_ref;
	struct clk *clk_bypass;
	struct clk_onecell_data outputs;
	bool bypass_bit_inverted;
};

struct fapll_synth {
	struct clk_hw hw;
	struct fapll_data *fd;
	int index;
	void *freq;
	void *div;
	const char *name;
	struct clk *clk_pll;
};

enum {
	OMAP3_SOC_AM35XX = 0,
	OMAP3_SOC_OMAP3430_ES1 = 1,
	OMAP3_SOC_OMAP3430_ES2_PLUS = 2,
	OMAP3_SOC_OMAP3630 = 3,
};

struct dra7_atl_clock_info;

struct dra7_atl_desc {
	struct clk *clk;
	struct clk_hw hw;
	struct dra7_atl_clock_info *cinfo;
	int id;
	bool probed;
	bool valid;
	bool enabled;
	u32 bws;
	u32 aws;
	u32 divider;
};

struct dra7_atl_clock_info {
	struct device *dev;
	void *iobase;
	struct dra7_atl_desc *cdesc;
};

enum ti_adpll_clocks {
	TI_ADPLL_DCO = 0,
	TI_ADPLL_DCO_GATE = 1,
	TI_ADPLL_N2 = 2,
	TI_ADPLL_M2 = 3,
	TI_ADPLL_M2_GATE = 4,
	TI_ADPLL_BYPASS = 5,
	TI_ADPLL_HIF = 6,
	TI_ADPLL_DIV2 = 7,
	TI_ADPLL_CLKOUT = 8,
	TI_ADPLL_CLKOUT2 = 9,
	TI_ADPLL_M3 = 10,
};

enum ti_adpll_inputs {
	TI_ADPLL_CLKINP = 0,
	TI_ADPLL_CLKINPULOW = 1,
	TI_ADPLL_CLKINPHIF = 2,
};

enum ti_adpll_s_outputs {
	TI_ADPLL_S_DCOCLKLDO = 0,
	TI_ADPLL_S_CLKOUT = 1,
	TI_ADPLL_S_CLKOUTX2 = 2,
	TI_ADPLL_S_CLKOUTHIF = 3,
};

enum ti_adpll_lj_outputs {
	TI_ADPLL_LJ_CLKDCOLDO = 0,
	TI_ADPLL_LJ_CLKOUT = 1,
	TI_ADPLL_LJ_CLKOUTLDO = 2,
};

struct ti_adpll_platform_data {
	const bool is_type_s;
	const int nr_max_inputs;
	const int nr_max_outputs;
	const int output_index;
};

struct ti_adpll_clock {
	struct clk *clk;
	struct clk_lookup *cl;
	void (*unregister)(struct clk *);
};

struct ti_adpll_dco_data {
	struct clk_hw hw;
};

struct ti_adpll_data;

struct ti_adpll_clkout_data {
	struct ti_adpll_data *adpll;
	struct clk_gate gate;
	struct clk_hw hw;
};

struct ti_adpll_data {
	struct device *dev;
	const struct ti_adpll_platform_data *c;
	struct device_node *np;
	long unsigned int pa;
	void *iobase;
	void *regs;
	spinlock_t lock;
	const char *parent_names[3];
	struct clk *parent_clocks[3];
	struct ti_adpll_clock *clocks;
	struct clk_onecell_data outputs;
	struct ti_adpll_dco_data dco;
};

enum uniphier_clk_type {
	UNIPHIER_CLK_TYPE_CPUGEAR = 0,
	UNIPHIER_CLK_TYPE_FIXED_FACTOR = 1,
	UNIPHIER_CLK_TYPE_FIXED_RATE = 2,
	UNIPHIER_CLK_TYPE_GATE = 3,
	UNIPHIER_CLK_TYPE_MUX = 4,
};

struct uniphier_clk_cpugear_data {
	const char *parent_names[16];
	unsigned int num_parents;
	unsigned int regbase;
	unsigned int mask;
};

struct uniphier_clk_fixed_factor_data {
	const char *parent_name;
	unsigned int mult;
	unsigned int div;
};

struct uniphier_clk_fixed_rate_data {
	long unsigned int fixed_rate;
};

struct uniphier_clk_gate_data {
	const char *parent_name;
	unsigned int reg;
	unsigned int bit;
};

struct uniphier_clk_mux_data {
	const char *parent_names[8];
	unsigned int num_parents;
	unsigned int reg;
	unsigned int masks[8];
	unsigned int vals[8];
};

struct uniphier_clk_data {
	const char *name;
	enum uniphier_clk_type type;
	int idx;
	union {
		struct uniphier_clk_cpugear_data cpugear;
		struct uniphier_clk_fixed_factor_data factor;
		struct uniphier_clk_fixed_rate_data rate;
		struct uniphier_clk_gate_data gate;
		struct uniphier_clk_mux_data mux;
	} data;
};

struct uniphier_clk_cpugear {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int regbase;
	unsigned int mask;
};

struct uniphier_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int reg;
	unsigned int bit;
};

struct uniphier_clk_mux {
	struct clk_hw hw;
	struct regmap *regmap;
	unsigned int reg;
	const unsigned int *masks;
	const unsigned int *vals;
};

struct clk_prcc {
	struct clk_hw hw;
	void *base;
	u32 cg_sel;
	int is_enabled;
};

struct clk_prcmu {
	struct clk_hw hw;
	u8 cg_sel;
	int is_prepared;
	int is_enabled;
	int opp_requested;
};

struct clk_sysctrl {
	struct clk_hw hw;
	struct device *dev;
	u8 parent_index;
	u16 reg_sel[4];
	u8 reg_mask[4];
	u8 reg_bits[4];
	long unsigned int rate;
	long unsigned int enable_delay_us;
};

struct prcmu_fw_version {
	u32 project;
	u8 api_version;
	u8 func_version;
	u8 errata;
	char project_name[20];
};

enum clkrst_index {
	CLKRST1_INDEX = 0,
	CLKRST2_INDEX = 1,
	CLKRST3_INDEX = 2,
	CLKRST5_INDEX = 3,
	CLKRST6_INDEX = 4,
	CLKRST_MAX = 5,
};

struct icst_params {
	long unsigned int ref;
	long unsigned int vco_max;
	long unsigned int vco_min;
	short unsigned int vd_min;
	short unsigned int vd_max;
	unsigned char rd_min;
	unsigned char rd_max;
	const unsigned char *s2div;
	const unsigned char *idx2s;
};

struct icst_vco {
	short unsigned int v;
	unsigned char r;
	unsigned char s;
};

enum icst_control_type {
	ICST_VERSATILE = 0,
	ICST_INTEGRATOR_AP_CM = 1,
	ICST_INTEGRATOR_AP_SYS = 2,
	ICST_INTEGRATOR_AP_PCI = 3,
	ICST_INTEGRATOR_CP_CM_CORE = 4,
	ICST_INTEGRATOR_CP_CM_MEM = 5,
	ICST_INTEGRATOR_IM_PD1 = 6,
};

struct clk_icst_desc {
	const struct icst_params *params;
	u32 vco_offset;
	u32 lock_offset;
};

struct clk_icst {
	struct clk_hw hw;
	struct regmap *map;
	u32 vcoreg_off;
	u32 lockreg_off;
	struct icst_params *params;
	long unsigned int rate;
	enum icst_control_type ctype;
};

struct clk_sp810;

struct clk_sp810_timerclken {
	struct clk_hw hw;
	struct clk *clk;
	struct clk_sp810 *sp810;
	int channel;
};

struct clk_sp810 {
	struct device_node *node;
	void *base;
	spinlock_t lock;
	struct clk_sp810_timerclken timerclken[4];
};

struct vexpress_osc {
	struct regmap *reg;
	struct clk_hw hw;
	long unsigned int rate_min;
	long unsigned int rate_max;
};

enum zynq_clk {
	armpll = 0,
	ddrpll = 1,
	iopll = 2,
	cpu_6or4x = 3,
	cpu_3or2x = 4,
	cpu_2x = 5,
	cpu_1x = 6,
	ddr2x = 7,
	ddr3x = 8,
	dci = 9,
	lqspi = 10,
	smc = 11,
	pcap = 12,
	gem0 = 13,
	gem1 = 14,
	fclk0 = 15,
	fclk1 = 16,
	fclk2 = 17,
	fclk3 = 18,
	can0 = 19,
	can1 = 20,
	sdio0 = 21,
	sdio1 = 22,
	uart0___3 = 23,
	uart1___3 = 24,
	spi0___3 = 25,
	spi1___3 = 26,
	dma = 27,
	usb0_aper = 28,
	usb1_aper = 29,
	gem0_aper = 30,
	gem1_aper = 31,
	sdio0_aper = 32,
	sdio1_aper = 33,
	spi0_aper = 34,
	spi1_aper = 35,
	can0_aper = 36,
	can1_aper = 37,
	i2c0_aper = 38,
	i2c1_aper = 39,
	uart0_aper = 40,
	uart1_aper = 41,
	gpio_aper = 42,
	lqspi_aper = 43,
	smc_aper = 44,
	swdt = 45,
	dbg_trc = 46,
	dbg_apb = 47,
	clk_max = 48,
};

struct zynq_pll {
	struct clk_hw hw;
	void *pll_ctrl;
	void *pll_status;
	spinlock_t *lock;
	u8 lockbit;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct of_dma {
	struct list_head of_dma_controllers;
	struct device_node *of_node;
	struct dma_chan * (*of_dma_xlate)(struct of_phandle_args *, struct of_dma *);
	void * (*of_dma_route_allocate)(struct of_phandle_args *, struct of_dma *);
	struct dma_router *dma_router;
	void *of_dma_data;
};

struct of_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct at_dma_platform_data {
	unsigned int nr_channels;
	dma_cap_mask_t cap_mask;
};

struct at_dma_slave {
	struct device *dma_dev;
	u32 cfg;
};

struct at_lli {
	dma_addr_t saddr;
	dma_addr_t daddr;
	u32 ctrla;
	u32 ctrlb;
	dma_addr_t dscr;
};

struct at_desc {
	struct at_lli lli;
	struct list_head tx_list;
	struct dma_async_tx_descriptor txd;
	struct list_head desc_node;
	size_t len;
	size_t total_len;
	size_t boundary;
	size_t dst_hole;
	size_t src_hole;
	bool memset_buffer;
	dma_addr_t memset_paddr;
	int *memset_vaddr;
};

enum atc_status {
	ATC_IS_ERROR = 0,
	ATC_IS_PAUSED = 1,
	ATC_IS_CYCLIC = 24,
};

struct at_dma;

struct at_dma_chan {
	struct dma_chan chan_common;
	struct at_dma *device;
	void *ch_regs;
	u8 mask;
	u8 per_if;
	u8 mem_if;
	long unsigned int status;
	struct tasklet_struct tasklet;
	u32 save_cfg;
	u32 save_dscr;
	struct dma_slave_config dma_sconfig;
	spinlock_t lock;
	struct list_head active_list;
	struct list_head queue;
	struct list_head free_list;
};

struct dma_pool___2;

struct at_dma {
	struct dma_device dma_common;
	void *regs;
	struct clk *clk;
	u32 save_imr;
	u8 all_chan_mask;
	struct dma_pool___2 *dma_desc_pool;
	struct dma_pool___2 *memset_pool;
	struct at_dma_chan chan[0];
};

enum atc_status___2 {
	AT_XDMAC_CHAN_IS_CYCLIC = 0,
	AT_XDMAC_CHAN_IS_PAUSED = 1,
};

struct at_xdmac_layout {
	u8 grs;
	u8 gws;
	u8 grws;
	u8 grwr;
	u8 gswr;
	u8 gsws;
	u8 gswf;
	u8 chan_cc_reg_base;
	bool sdif;
	bool axi_config;
};

struct at_xdmac_chan {
	struct dma_chan chan;
	void *ch_regs;
	u32 mask;
	u32 cfg;
	u8 perid;
	u8 perif;
	u8 memif;
	u32 save_cc;
	u32 save_cim;
	u32 save_cnda;
	u32 save_cndc;
	u32 irq_status;
	long unsigned int status;
	struct tasklet_struct tasklet;
	struct dma_slave_config sconfig;
	spinlock_t lock;
	struct list_head xfers_list;
	struct list_head free_descs_list;
};

struct at_xdmac {
	struct dma_device dma;
	void *regs;
	int irq;
	struct clk *clk;
	u32 save_gim;
	struct dma_pool___2 *at_xdmac_desc_pool;
	const struct at_xdmac_layout *layout;
	struct at_xdmac_chan chan[0];
};

struct at_xdmac_lld {
	dma_addr_t mbr_nda;
	u32 mbr_ubc;
	dma_addr_t mbr_sa;
	dma_addr_t mbr_da;
	u32 mbr_cfg;
	u32 mbr_bc;
	u32 mbr_ds;
	u32 mbr_sus;
	u32 mbr_dus;
};

struct at_xdmac_desc {
	struct at_xdmac_lld lld;
	enum dma_transfer_direction direction;
	struct dma_async_tx_descriptor tx_dma_desc;
	struct list_head desc_node;
	bool active_xfer;
	unsigned int xfer_size;
	struct list_head descs_list;
	struct list_head xfer_node;
	int: 32;
};

struct bcm2835_dmadev {
	struct dma_device ddev;
	void *base;
	dma_addr_t zero_page;
};

struct bcm2835_dma_cb {
	uint32_t info;
	uint32_t src;
	uint32_t dst;
	uint32_t length;
	uint32_t stride;
	uint32_t next;
	uint32_t pad[2];
};

struct bcm2835_cb_entry {
	struct bcm2835_dma_cb *cb;
	dma_addr_t paddr;
};

struct bcm2835_desc;

struct bcm2835_chan {
	struct virt_dma_chan vc;
	struct dma_slave_config cfg;
	unsigned int dreq;
	int ch;
	struct bcm2835_desc *desc;
	struct dma_pool___2 *cb_pool;
	void *chan_base;
	int irq_number;
	unsigned int irq_flags;
	bool is_lite_channel;
};

struct bcm2835_desc {
	struct bcm2835_chan *c;
	struct virt_dma_desc vd;
	enum dma_transfer_direction dir;
	unsigned int frames;
	size_t size;
	bool cyclic;
	struct bcm2835_cb_entry cb_list[0];
};

struct sun4i_dma_vchan;

struct sun4i_dma_pchan {
	void *base;
	struct sun4i_dma_vchan *vchan;
	int is_dedicated;
};

struct sun4i_dma_promise;

struct sun4i_dma_contract;

struct sun4i_dma_vchan {
	struct virt_dma_chan vc;
	struct dma_slave_config cfg;
	struct sun4i_dma_pchan *pchan;
	struct sun4i_dma_promise *processing;
	struct sun4i_dma_contract *contract;
	u8 endpoint;
	int is_dedicated;
};

struct sun4i_dma_promise {
	u32 cfg;
	u32 para;
	dma_addr_t src;
	dma_addr_t dst;
	size_t len;
	struct list_head list;
};

struct sun4i_dma_contract {
	struct virt_dma_desc vd;
	struct list_head demands;
	struct list_head completed_demands;
	int is_cyclic;
};

struct sun4i_dma_dev {
	long unsigned int pchans_used[1];
	struct dma_device slave;
	struct sun4i_dma_pchan *pchans;
	struct sun4i_dma_vchan *vchans;
	void *base;
	struct clk *clk;
	int irq;
	spinlock_t lock;
};

struct sun6i_dma_dev;

struct sun6i_dma_config {
	u32 nr_max_channels;
	u32 nr_max_requests;
	u32 nr_max_vchans;
	void (*clock_autogate_enable)(struct sun6i_dma_dev *);
	void (*set_burst_length)(u32 *, s8, s8);
	void (*set_drq)(u32 *, s8, s8);
	void (*set_mode)(u32 *, s8, s8);
	u32 src_burst_lengths;
	u32 dst_burst_lengths;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	bool has_mbus_clk;
};

struct sun6i_pchan;

struct sun6i_vchan;

struct sun6i_dma_dev {
	struct dma_device slave;
	void *base;
	struct clk *clk;
	struct clk *clk_mbus;
	int irq;
	spinlock_t lock;
	struct reset_control *rstc;
	struct tasklet_struct task;
	atomic_t tasklet_shutdown;
	struct list_head pending;
	struct dma_pool___2 *pool;
	struct sun6i_pchan *pchans;
	struct sun6i_vchan *vchans;
	const struct sun6i_dma_config *cfg;
	u32 num_pchans;
	u32 num_vchans;
	u32 max_request;
};

struct sun6i_dma_lli {
	u32 cfg;
	u32 src;
	u32 dst;
	u32 len;
	u32 para;
	u32 p_lli_next;
	struct sun6i_dma_lli *v_lli_next;
};

struct sun6i_desc {
	struct virt_dma_desc vd;
	dma_addr_t p_lli;
	struct sun6i_dma_lli *v_lli;
};

struct sun6i_pchan {
	u32 idx;
	void *base;
	struct sun6i_vchan *vchan;
	struct sun6i_desc *desc;
	struct sun6i_desc *done;
};

struct sun6i_vchan {
	struct virt_dma_chan vc;
	struct list_head node;
	struct dma_slave_config cfg;
	struct sun6i_pchan *phy;
	u8 port;
	u8 irq_type;
	bool cyclic;
};

struct dw_dma_slave {
	struct device *dma_dev;
	u8 src_id;
	u8 dst_id;
	u8 m_master;
	u8 p_master;
	u8 channels;
	bool hs_polarity;
};

struct dw_dma_platform_data {
	unsigned int nr_channels;
	unsigned char chan_allocation_order;
	unsigned char chan_priority;
	unsigned int block_size;
	unsigned char nr_masters;
	unsigned char data_width[4];
	unsigned char multi_block[8];
	u32 max_burst[8];
	unsigned char protctl;
};

struct dw_dma;

struct dw_dma_chip {
	struct device *dev;
	int id;
	int irq;
	void *regs;
	struct clk *clk;
	struct dw_dma *dw;
	const struct dw_dma_platform_data *pdata;
};

struct dw_dma_chan;

struct dw_dma {
	struct dma_device dma;
	char name[20];
	void *regs;
	struct dma_pool___2 *desc_pool;
	struct tasklet_struct tasklet;
	struct dw_dma_chan *chan;
	u8 all_chan_mask;
	u8 in_use;
	void (*initialize_chan)(struct dw_dma_chan *);
	void (*suspend_chan)(struct dw_dma_chan *, bool);
	void (*resume_chan)(struct dw_dma_chan *, bool);
	u32 (*prepare_ctllo)(struct dw_dma_chan *);
	void (*encode_maxburst)(struct dw_dma_chan *, u32 *);
	u32 (*bytes2block)(struct dw_dma_chan *, size_t, unsigned int, size_t *);
	size_t (*block2bytes)(struct dw_dma_chan *, u32, u32);
	void (*set_device_name)(struct dw_dma *, int);
	void (*disable)(struct dw_dma *);
	void (*enable)(struct dw_dma *);
	struct dw_dma_platform_data *pdata;
};

enum dw_dma_fc {
	DW_DMA_FC_D_M2M = 0,
	DW_DMA_FC_D_M2P = 1,
	DW_DMA_FC_D_P2M = 2,
	DW_DMA_FC_D_P2P = 3,
	DW_DMA_FC_P_P2M = 4,
	DW_DMA_FC_SP_P2P = 5,
	DW_DMA_FC_P_M2P = 6,
	DW_DMA_FC_DP_P2P = 7,
};

struct dw_dma_chan_regs {
	u32 SAR;
	u32 __pad_SAR;
	u32 DAR;
	u32 __pad_DAR;
	u32 LLP;
	u32 __pad_LLP;
	u32 CTL_LO;
	u32 CTL_HI;
	u32 SSTAT;
	u32 __pad_SSTAT;
	u32 DSTAT;
	u32 __pad_DSTAT;
	u32 SSTATAR;
	u32 __pad_SSTATAR;
	u32 DSTATAR;
	u32 __pad_DSTATAR;
	u32 CFG_LO;
	u32 CFG_HI;
	u32 SGR;
	u32 __pad_SGR;
	u32 DSR;
	u32 __pad_DSR;
};

struct dw_dma_irq_regs {
	u32 XFER;
	u32 __pad_XFER;
	u32 BLOCK;
	u32 __pad_BLOCK;
	u32 SRC_TRAN;
	u32 __pad_SRC_TRAN;
	u32 DST_TRAN;
	u32 __pad_DST_TRAN;
	u32 ERROR;
	u32 __pad_ERROR;
};

struct dw_dma_regs {
	struct dw_dma_chan_regs CHAN[8];
	struct dw_dma_irq_regs RAW;
	struct dw_dma_irq_regs STATUS;
	struct dw_dma_irq_regs MASK;
	struct dw_dma_irq_regs CLEAR;
	u32 STATUS_INT;
	u32 __pad_STATUS_INT;
	u32 REQ_SRC;
	u32 __pad_REQ_SRC;
	u32 REQ_DST;
	u32 __pad_REQ_DST;
	u32 SGL_REQ_SRC;
	u32 __pad_SGL_REQ_SRC;
	u32 SGL_REQ_DST;
	u32 __pad_SGL_REQ_DST;
	u32 LAST_SRC;
	u32 __pad_LAST_SRC;
	u32 LAST_DST;
	u32 __pad_LAST_DST;
	u32 CFG;
	u32 __pad_CFG;
	u32 CH_EN;
	u32 __pad_CH_EN;
	u32 ID;
	u32 __pad_ID;
	u32 TEST;
	u32 __pad_TEST;
	u32 CLASS_PRIORITY0;
	u32 __pad_CLASS_PRIORITY0;
	u32 CLASS_PRIORITY1;
	u32 __pad_CLASS_PRIORITY1;
	u32 __reserved;
	u32 DWC_PARAMS[8];
	u32 MULTI_BLK_TYPE;
	u32 MAX_BLK_SIZE;
	u32 DW_PARAMS;
	u32 COMP_TYPE;
	u32 COMP_VERSION;
	u32 FIFO_PARTITION0;
	u32 __pad_FIFO_PARTITION0;
	u32 FIFO_PARTITION1;
	u32 __pad_FIFO_PARTITION1;
	u32 SAI_ERR;
	u32 __pad_SAI_ERR;
	u32 GLOBAL_CFG;
	u32 __pad_GLOBAL_CFG;
};

enum dw_dmac_flags {
	DW_DMA_IS_CYCLIC = 0,
	DW_DMA_IS_SOFT_LLP = 1,
	DW_DMA_IS_PAUSED = 2,
	DW_DMA_IS_INITIALIZED = 3,
};

struct dw_dma_chan {
	struct dma_chan chan;
	void *ch_regs;
	u8 mask;
	u8 priority;
	enum dma_transfer_direction direction;
	struct list_head *tx_node_active;
	spinlock_t lock;
	long unsigned int flags;
	struct list_head active_list;
	struct list_head queue;
	unsigned int descs_allocated;
	unsigned int block_size;
	bool nollp;
	u32 max_burst;
	struct dw_dma_slave dws;
	struct dma_slave_config dma_sconfig;
};

struct dw_lli {
	__le32 sar;
	__le32 dar;
	__le32 llp;
	__le32 ctllo;
	__le32 ctlhi;
	__le32 sstat;
	__le32 dstat;
};

struct dw_desc {
	struct dw_lli lli;
	struct list_head desc_node;
	struct list_head tx_list;
	struct dma_async_tx_descriptor txd;
	size_t len;
	size_t total_len;
	u32 residue;
};

struct dw_dma_chip_pdata {
	const struct dw_dma_platform_data *pdata;
	int (*probe)(struct dw_dma_chip *);
	int (*remove)(struct dw_dma_chip *);
	struct dw_dma_chip *chip;
};

enum fsl_edma_pm_state {
	RUNNING = 0,
	SUSPENDED = 1,
};

struct fsl_edma_hw_tcd {
	__le32 saddr;
	__le16 soff;
	__le16 attr;
	__le32 nbytes;
	__le32 slast;
	__le32 daddr;
	__le16 doff;
	__le16 citer;
	__le32 dlast_sga;
	__le16 csr;
	__le16 biter;
};

struct edma_regs {
	void *cr;
	void *es;
	void *erqh;
	void *erql;
	void *eeih;
	void *eeil;
	void *seei;
	void *ceei;
	void *serq;
	void *cerq;
	void *cint;
	void *cerr;
	void *ssrt;
	void *cdne;
	void *inth;
	void *intl;
	void *errh;
	void *errl;
	struct fsl_edma_hw_tcd *tcd;
};

struct fsl_edma_sw_tcd {
	dma_addr_t ptcd;
	struct fsl_edma_hw_tcd *vtcd;
};

struct fsl_edma_engine;

struct fsl_edma_desc;

struct fsl_edma_chan {
	struct virt_dma_chan vchan;
	enum dma_status status;
	enum fsl_edma_pm_state pm_state;
	bool idle;
	u32 slave_id;
	struct fsl_edma_engine *edma;
	struct fsl_edma_desc *edesc;
	struct dma_slave_config cfg;
	u32 attr;
	struct dma_pool___2 *tcd_pool;
	dma_addr_t dma_dev_addr;
	u32 dma_dev_size;
	enum dma_data_direction dma_dir;
	char chan_name[16];
};

struct fsl_edma_drvdata;

struct fsl_edma_engine {
	struct dma_device dma_dev;
	void *membase;
	void *muxbase[2];
	struct clk *muxclk[2];
	struct clk *dmaclk;
	struct mutex fsl_edma_mutex;
	const struct fsl_edma_drvdata *drvdata;
	u32 n_chans;
	int txirq;
	int errirq;
	bool big_endian;
	struct edma_regs regs;
	struct fsl_edma_chan chans[0];
};

struct fsl_edma_desc {
	struct virt_dma_desc vdesc;
	struct fsl_edma_chan *echan;
	bool iscyclic;
	enum dma_transfer_direction dirn;
	unsigned int n_tcds;
	struct fsl_edma_sw_tcd tcd[0];
};

enum edma_version {
	v1 = 0,
	v2 = 1,
	v3 = 2,
};

struct fsl_edma_drvdata {
	enum edma_version version;
	u32 dmamuxs;
	bool has_dmaclk;
	bool mux_swap;
	int (*setup_irq)(struct platform_device *, struct fsl_edma_engine *);
};

enum sdma_peripheral_type {
	IMX_DMATYPE_SSI = 0,
	IMX_DMATYPE_SSI_SP = 1,
	IMX_DMATYPE_MMC = 2,
	IMX_DMATYPE_SDHC = 3,
	IMX_DMATYPE_UART = 4,
	IMX_DMATYPE_UART_SP = 5,
	IMX_DMATYPE_FIRI = 6,
	IMX_DMATYPE_CSPI = 7,
	IMX_DMATYPE_CSPI_SP = 8,
	IMX_DMATYPE_SIM = 9,
	IMX_DMATYPE_ATA = 10,
	IMX_DMATYPE_CCM = 11,
	IMX_DMATYPE_EXT = 12,
	IMX_DMATYPE_MSHC = 13,
	IMX_DMATYPE_MSHC_SP = 14,
	IMX_DMATYPE_DSP = 15,
	IMX_DMATYPE_MEMORY = 16,
	IMX_DMATYPE_FIFO_MEMORY = 17,
	IMX_DMATYPE_SPDIF = 18,
	IMX_DMATYPE_IPU_MEMORY = 19,
	IMX_DMATYPE_ASRC = 20,
	IMX_DMATYPE_ESAI = 21,
	IMX_DMATYPE_SSI_DUAL = 22,
	IMX_DMATYPE_ASRC_SP = 23,
	IMX_DMATYPE_SAI = 24,
};

struct imx_dma_data {
	int dma_request;
	int dma_request2;
	enum sdma_peripheral_type peripheral_type;
	int priority;
};

enum imxdma_prep_type {
	IMXDMA_DESC_MEMCPY = 0,
	IMXDMA_DESC_INTERLEAVED = 1,
	IMXDMA_DESC_SLAVE_SG = 2,
	IMXDMA_DESC_CYCLIC = 3,
};

struct imx_dma_2d_config {
	u16 xsr;
	u16 ysr;
	u16 wsr;
	int count;
};

struct imxdma_desc {
	struct list_head node;
	struct dma_async_tx_descriptor desc;
	enum dma_status status;
	dma_addr_t src;
	dma_addr_t dest;
	size_t len;
	enum dma_transfer_direction direction;
	enum imxdma_prep_type type;
	unsigned int config_port;
	unsigned int config_mem;
	unsigned int x;
	unsigned int y;
	unsigned int w;
	struct scatterlist *sg;
	unsigned int sgcount;
};

struct imxdma_engine;

struct imxdma_channel {
	int hw_chaining;
	struct timer_list watchdog;
	struct imxdma_engine *imxdma;
	unsigned int channel;
	struct tasklet_struct dma_tasklet;
	struct list_head ld_free;
	struct list_head ld_queue;
	struct list_head ld_active;
	int descs_allocated;
	enum dma_slave_buswidth word_size;
	dma_addr_t per_address;
	u32 watermark_level;
	struct dma_chan chan;
	struct dma_async_tx_descriptor desc;
	enum dma_status status;
	int dma_request;
	struct scatterlist *sg_list;
	u32 ccr_from_device;
	u32 ccr_to_device;
	bool enabled_2d;
	int slot_2d;
	unsigned int irq;
	struct dma_slave_config config;
};

enum imx_dma_type {
	IMX1_DMA = 0,
	IMX21_DMA = 1,
	IMX27_DMA = 2,
};

struct imxdma_engine {
	struct device *dev;
	struct dma_device dma_device;
	void *base;
	struct clk *dma_ahb;
	struct clk *dma_ipg;
	spinlock_t lock;
	struct imx_dma_2d_config slots_2d[2];
	struct imxdma_channel channel[16];
	enum imx_dma_type devtype;
	unsigned int irq;
	unsigned int irq_err;
};

struct imxdma_filter_data {
	struct imxdma_engine *imxdma;
	int request;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct sdma_script_start_addrs {
	s32 ap_2_ap_addr;
	s32 ap_2_bp_addr;
	s32 ap_2_ap_fixed_addr;
	s32 bp_2_ap_addr;
	s32 loopback_on_dsp_side_addr;
	s32 mcu_interrupt_only_addr;
	s32 firi_2_per_addr;
	s32 firi_2_mcu_addr;
	s32 per_2_firi_addr;
	s32 mcu_2_firi_addr;
	s32 uart_2_per_addr;
	s32 uart_2_mcu_addr;
	s32 per_2_app_addr;
	s32 mcu_2_app_addr;
	s32 per_2_per_addr;
	s32 uartsh_2_per_addr;
	s32 uartsh_2_mcu_addr;
	s32 per_2_shp_addr;
	s32 mcu_2_shp_addr;
	s32 ata_2_mcu_addr;
	s32 mcu_2_ata_addr;
	s32 app_2_per_addr;
	s32 app_2_mcu_addr;
	s32 shp_2_per_addr;
	s32 shp_2_mcu_addr;
	s32 mshc_2_mcu_addr;
	s32 mcu_2_mshc_addr;
	s32 spdif_2_mcu_addr;
	s32 mcu_2_spdif_addr;
	s32 asrc_2_mcu_addr;
	s32 ext_mem_2_ipu_addr;
	s32 descrambler_addr;
	s32 dptc_dvfs_addr;
	s32 utra_addr;
	s32 ram_code_start_addr;
	s32 mcu_2_ssish_addr;
	s32 ssish_2_mcu_addr;
	s32 hdmi_dma_addr;
	s32 zcanfd_2_mcu_addr;
	s32 zqspi_2_mcu_addr;
	s32 mcu_2_ecspi_addr;
	s32 mcu_2_zqspi_addr;
};

struct sdma_platform_data {
	char *fw_name;
	struct sdma_script_start_addrs *script_addrs;
};

enum imx_dma_prio {
	DMA_PRIO_HIGH = 0,
	DMA_PRIO_MEDIUM = 1,
	DMA_PRIO_LOW = 2,
};

struct sdma_mode_count {
	u32 count: 16;
	u32 status: 8;
	u32 command: 8;
};

struct sdma_buffer_descriptor {
	struct sdma_mode_count mode;
	u32 buffer_addr;
	u32 ext_buffer_addr;
};

struct sdma_channel_control {
	u32 current_bd_ptr;
	u32 base_bd_ptr;
	u32 unused[2];
};

struct sdma_state_registers {
	u32 pc: 14;
	u32 unused1: 1;
	u32 t: 1;
	u32 rpc: 14;
	u32 unused0: 1;
	u32 sf: 1;
	u32 spc: 14;
	u32 unused2: 1;
	u32 df: 1;
	u32 epc: 14;
	u32 lm: 2;
};

struct sdma_context_data {
	struct sdma_state_registers channel_state;
	u32 gReg[8];
	u32 mda;
	u32 msa;
	u32 ms;
	u32 md;
	u32 pda;
	u32 psa;
	u32 ps;
	u32 pd;
	u32 ca;
	u32 cs;
	u32 dda;
	u32 dsa;
	u32 ds;
	u32 dd;
	u32 scratch0;
	u32 scratch1;
	u32 scratch2;
	u32 scratch3;
	u32 scratch4;
	u32 scratch5;
	u32 scratch6;
	u32 scratch7;
};

struct sdma_channel;

struct sdma_desc {
	struct virt_dma_desc vd;
	unsigned int num_bd;
	dma_addr_t bd_phys;
	unsigned int buf_tail;
	unsigned int buf_ptail;
	unsigned int period_len;
	unsigned int chn_real_count;
	unsigned int chn_count;
	struct sdma_channel *sdmac;
	struct sdma_buffer_descriptor *bd;
};

struct sdma_engine;

struct sdma_channel {
	struct virt_dma_chan vc;
	struct sdma_desc *desc;
	struct sdma_engine *sdma;
	unsigned int channel;
	enum dma_transfer_direction direction;
	struct dma_slave_config slave_config;
	enum sdma_peripheral_type peripheral_type;
	unsigned int event_id0;
	unsigned int event_id1;
	enum dma_slave_buswidth word_size;
	unsigned int pc_from_device;
	unsigned int pc_to_device;
	unsigned int device_to_device;
	unsigned int pc_to_pc;
	long unsigned int flags;
	dma_addr_t per_address;
	dma_addr_t per_address2;
	long unsigned int event_mask[2];
	long unsigned int watermark_level;
	u32 shp_addr;
	u32 per_addr;
	enum dma_status status;
	bool context_loaded;
	struct imx_dma_data data;
	struct work_struct terminate_worker;
};

struct sdma_driver_data;

struct sdma_engine {
	struct device *dev;
	struct sdma_channel channel[32];
	struct sdma_channel_control *channel_control;
	void *regs;
	struct sdma_context_data *context;
	dma_addr_t context_phys;
	struct dma_device dma_device;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	spinlock_t channel_0_lock;
	u32 script_number;
	struct sdma_script_start_addrs *script_addrs;
	const struct sdma_driver_data *drvdata;
	u32 spba_start_addr;
	u32 spba_end_addr;
	unsigned int irq;
	dma_addr_t bd0_phys;
	struct sdma_buffer_descriptor *bd0;
	bool clk_ratio;
};

struct sdma_firmware_header {
	u32 magic;
	u32 version_major;
	u32 version_minor;
	u32 script_addrs_start;
	u32 num_script_addrs;
	u32 ram_code_start;
	u32 ram_code_size;
};

struct sdma_driver_data {
	int chnenbl0;
	int num_events;
	struct sdma_script_start_addrs *script_addrs;
	bool check_ratio;
};

struct mv_xor_channel_data {
	dma_cap_mask_t cap_mask;
};

struct mv_xor_platform_data {
	struct mv_xor_channel_data *channels;
};

struct mv_xor_chan;

struct mv_xor_device {
	void *xor_base;
	void *xor_high_base;
	struct clk *clk;
	struct mv_xor_chan *channels[2];
	int xor_type;
	u32 win_start[8];
	u32 win_end[8];
};

struct mv_xor_chan {
	int pending;
	spinlock_t lock;
	void *mmr_base;
	void *mmr_high_base;
	unsigned int idx;
	int irq;
	struct list_head chain;
	struct list_head free_slots;
	struct list_head allocated_slots;
	struct list_head completed_slots;
	dma_addr_t dma_desc_pool;
	void *dma_desc_pool_virt;
	size_t pool_size;
	struct dma_device dmadev;
	struct dma_chan dmachan;
	int slots_allocated;
	struct tasklet_struct irq_tasklet;
	int op_in_desc;
	char dummy_src[128];
	char dummy_dst[128];
	dma_addr_t dummy_src_addr;
	dma_addr_t dummy_dst_addr;
	u32 saved_config_reg;
	u32 saved_int_mask_reg;
	struct mv_xor_device *xordev;
};

struct mv_xor_desc_slot {
	struct list_head node;
	struct list_head sg_tx_list;
	enum dma_transaction_type type;
	void *hw_desc;
	u16 idx;
	struct dma_async_tx_descriptor async_tx;
};

struct mv_xor_desc {
	u32 status;
	u32 crc32_result;
	u32 desc_command;
	u32 phy_next_desc;
	u32 byte_count;
	u32 phy_dest_addr;
	u32 phy_src_addr[8];
	u32 reserved0;
	u32 reserved1;
};

enum mv_xor_type {
	XOR_ORION = 0,
	XOR_ARMADA_38X = 1,
	XOR_ARMADA_37XX = 2,
};

enum mv_xor_mode {
	XOR_MODE_IN_REG = 0,
	XOR_MODE_IN_DESC = 1,
};

struct mxs_dma_ccw {
	u32 next;
	u16 bits;
	u16 xfer_bytes;
	u32 bufaddr;
	u32 pio_words[16];
};

struct mxs_dma_engine;

struct mxs_dma_chan {
	struct mxs_dma_engine *mxs_dma;
	struct dma_chan chan;
	struct dma_async_tx_descriptor desc;
	struct tasklet_struct tasklet;
	unsigned int chan_irq;
	struct mxs_dma_ccw *ccw;
	dma_addr_t ccw_phys;
	int desc_count;
	enum dma_status status;
	unsigned int flags;
	bool reset;
};

enum mxs_dma_id {
	IMX23_DMA = 0,
	IMX28_DMA = 1,
};

enum mxs_dma_devtype {
	MXS_DMA_APBH = 0,
	MXS_DMA_APBX = 1,
};

struct mxs_dma_engine {
	enum mxs_dma_id dev_id;
	enum mxs_dma_devtype type;
	void *base;
	struct clk *clk;
	struct dma_device dma_device;
	struct mxs_dma_chan mxs_chans[16];
	struct platform_device *pdev;
	unsigned int nr_channels;
};

struct mxs_dma_type {
	enum mxs_dma_id id;
	enum mxs_dma_devtype type;
};

struct mxs_dma_filter_param {
	unsigned int chan_id;
};

struct idmac {
	struct dma_device dma;
};

struct ipu {
	void *reg_ipu;
	void *reg_ic;
	unsigned int irq_fn;
	unsigned int irq_err;
	unsigned int irq_base;
	long unsigned int channel_init_mask;
	spinlock_t lock;
	struct clk *ipu_clk;
	struct device *dev;
	struct idmac idmac;
	struct idmac_channel channel[32];
	struct tasklet_struct tasklet;
};

struct ipu_irq_bank {
	unsigned int control;
	unsigned int status;
	struct ipu *ipu;
};

struct ipu_irq_map {
	unsigned int irq;
	int source;
	struct ipu_irq_bank *bank;
	struct ipu *ipu;
};

enum ipu_color_space {
	IPU_COLORSPACE_RGB = 0,
	IPU_COLORSPACE_YCBCR = 1,
	IPU_COLORSPACE_YUV = 2,
};

enum ipu_rotate_mode {
	IPU_ROTATE_NONE = 0,
	IPU_ROTATE_VERT_FLIP = 1,
	IPU_ROTATE_HORIZ_FLIP = 2,
	IPU_ROTATE_180 = 3,
	IPU_ROTATE_90_RIGHT = 4,
	IPU_ROTATE_90_RIGHT_VFLIP = 5,
	IPU_ROTATE_90_RIGHT_HFLIP = 6,
	IPU_ROTATE_90_LEFT = 7,
};

struct chan_param_mem_planar {
	u32 xv: 10;
	u32 yv: 10;
	u32 xb: 12;
	u32 yb: 12;
	u32 res1: 2;
	u32 nsb: 1;
	u32 lnpb: 6;
	u32 ubo_l: 11;
	u32 ubo_h: 15;
	u32 vbo_l: 17;
	u32 vbo_h: 9;
	u32 res2: 3;
	u32 fw: 12;
	u32 fh_l: 8;
	u32 fh_h: 4;
	u32 res3: 28;
	u32 eba0;
	u32 eba1;
	u32 bpp: 3;
	u32 sl: 14;
	u32 pfs: 3;
	u32 bam: 3;
	u32 res4: 2;
	u32 npb: 6;
	u32 res5: 1;
	u32 sat: 2;
	u32 res6: 30;
};

struct chan_param_mem_interleaved {
	u32 xv: 10;
	u32 yv: 10;
	u32 xb: 12;
	u32 yb: 12;
	u32 sce: 1;
	u32 res1: 1;
	u32 nsb: 1;
	u32 lnpb: 6;
	u32 sx: 10;
	u32 sy_l: 1;
	u32 sy_h: 9;
	u32 ns: 10;
	u32 sm: 10;
	u32 sdx_l: 3;
	u32 sdx_h: 2;
	u32 sdy: 5;
	u32 sdrx: 1;
	u32 sdry: 1;
	u32 sdr1: 1;
	u32 res2: 2;
	u32 fw: 12;
	u32 fh_l: 8;
	u32 fh_h: 4;
	u32 res3: 28;
	u32 eba0;
	u32 eba1;
	u32 bpp: 3;
	u32 sl: 14;
	u32 pfs: 3;
	u32 bam: 3;
	u32 res4: 2;
	u32 npb: 6;
	u32 res5: 1;
	u32 sat: 2;
	u32 scc: 1;
	u32 ofs0: 5;
	u32 ofs1: 5;
	u32 ofs2: 5;
	u32 ofs3: 5;
	u32 wid0: 3;
	u32 wid1: 3;
	u32 wid2: 3;
	u32 wid3: 3;
	u32 dec_sel: 1;
	u32 res6: 28;
};

union chan_param_mem {
	struct chan_param_mem_planar pp;
	struct chan_param_mem_interleaved ip;
};

enum pl330_cachectrl {
	CCTRL0 = 0,
	CCTRL1 = 1,
	CCTRL2 = 2,
	CCTRL3 = 3,
	INVALID1 = 4,
	INVALID2 = 5,
	CCTRL6 = 6,
	CCTRL7 = 7,
};

enum pl330_byteswap {
	SWAP_NO = 0,
	SWAP_2 = 1,
	SWAP_4 = 2,
	SWAP_8 = 3,
	SWAP_16 = 4,
};

struct pl330_config {
	u32 periph_id;
	unsigned int mode;
	unsigned int data_bus_width: 10;
	unsigned int data_buf_dep: 11;
	unsigned int num_chan: 4;
	unsigned int num_peri: 6;
	u32 peri_ns;
	unsigned int num_events: 6;
	u32 irq_ns;
};

struct pl330_reqcfg {
	unsigned int dst_inc: 1;
	unsigned int src_inc: 1;
	bool nonsecure;
	bool privileged;
	bool insnaccess;
	unsigned int brst_len: 5;
	unsigned int brst_size: 3;
	enum pl330_cachectrl dcctl;
	enum pl330_cachectrl scctl;
	enum pl330_byteswap swap;
	struct pl330_config *pcfg;
};

struct pl330_xfer {
	u32 src_addr;
	u32 dst_addr;
	u32 bytes;
};

enum pl330_op_err {
	PL330_ERR_NONE = 0,
	PL330_ERR_ABORT = 1,
	PL330_ERR_FAIL = 2,
};

enum dmamov_dst {
	SAR = 0,
	CCR___2 = 1,
	DAR = 2,
};

enum pl330_cond {
	SINGLE = 0,
	BURST = 1,
	ALWAYS = 2,
};

struct dma_pl330_desc;

struct _pl330_req {
	u32 mc_bus;
	void *mc_cpu;
	struct dma_pl330_desc *desc;
};

enum desc_status {
	FREE = 0,
	PREP = 1,
	BUSY = 2,
	DONE___2 = 3,
};

struct dma_pl330_chan;

struct dma_pl330_desc {
	struct list_head node;
	struct dma_async_tx_descriptor txd;
	struct pl330_xfer px;
	struct pl330_reqcfg rqcfg;
	enum desc_status status;
	int bytes_requested;
	bool last;
	struct dma_pl330_chan *pchan;
	enum dma_transfer_direction rqtype;
	unsigned int peri: 5;
	struct list_head rqd;
};

struct _pl330_tbd {
	bool reset_dmac;
	bool reset_mngr;
	u8 reset_chan;
};

struct pl330_dmac;

struct pl330_thread {
	u8 id;
	int ev;
	bool free;
	struct pl330_dmac *dmac;
	struct _pl330_req req[2];
	unsigned int lstenq;
	int req_running;
};

enum pl330_dmac_state {
	UNINIT = 0,
	INIT = 1,
	DYING = 2,
};

struct pl330_dmac {
	struct dma_device ddma;
	struct list_head desc_pool;
	spinlock_t pool_lock;
	unsigned int mcbufsz;
	void *base;
	struct pl330_config pcfg;
	spinlock_t lock;
	int events[32];
	dma_addr_t mcode_bus;
	void *mcode_cpu;
	struct pl330_thread *channels;
	struct pl330_thread *manager;
	struct tasklet_struct tasks;
	struct _pl330_tbd dmac_tbd;
	enum pl330_dmac_state state;
	struct list_head req_done;
	unsigned int num_peripherals;
	struct dma_pl330_chan *peripherals;
	int quirks;
	struct reset_control *rstc;
	struct reset_control *rstc_ocp;
};

struct dma_pl330_chan {
	struct tasklet_struct task;
	struct dma_chan chan;
	struct list_head submitted_list;
	struct list_head work_list;
	struct list_head completed_list;
	struct pl330_dmac *dmac;
	spinlock_t lock;
	struct pl330_thread *thread;
	int burst_sz;
	int burst_len;
	phys_addr_t fifo_addr;
	dma_addr_t fifo_dma;
	enum dma_data_direction dir;
	struct dma_slave_config slave_config;
	bool cyclic;
	bool active;
};

struct pl330_of_quirks {
	char *quirk;
	int id;
};

struct _xfer_spec {
	u32 ccr;
	struct dma_pl330_desc *desc;
};

struct _arg_LPEND {
	enum pl330_cond cond;
	bool forever;
	unsigned int loop;
	u8 bjump;
};

struct _arg_GO {
	u8 chan;
	u32 addr;
	unsigned int ns;
};

struct rcar_dmac_xfer_chunk {
	struct list_head node;
	dma_addr_t src_addr;
	dma_addr_t dst_addr;
	u32 size;
};

struct rcar_dmac_hw_desc {
	u32 sar;
	u32 dar;
	u32 tcr;
	u32 reserved;
};

struct rcar_dmac_desc {
	struct dma_async_tx_descriptor async_tx;
	enum dma_transfer_direction direction;
	unsigned int xfer_shift;
	u32 chcr;
	struct list_head node;
	struct list_head chunks;
	struct rcar_dmac_xfer_chunk *running;
	unsigned int nchunks;
	struct {
		bool use;
		struct rcar_dmac_hw_desc *mem;
		dma_addr_t dma;
		size_t size;
	} hwdescs;
	unsigned int size;
	bool cyclic;
};

struct rcar_dmac_desc_page {
	struct list_head node;
	union {
		struct rcar_dmac_desc descs[0];
		struct rcar_dmac_xfer_chunk chunks[0];
	};
};

struct rcar_dmac_chan_slave {
	phys_addr_t slave_addr;
	unsigned int xfer_size;
};

struct rcar_dmac_chan_map {
	dma_addr_t addr;
	enum dma_data_direction dir;
	struct rcar_dmac_chan_slave slave;
};

struct rcar_dmac_chan {
	struct dma_chan chan;
	void *iomem;
	unsigned int index;
	int irq;
	struct rcar_dmac_chan_slave src;
	struct rcar_dmac_chan_slave dst;
	struct rcar_dmac_chan_map map;
	int mid_rid;
	spinlock_t lock;
	struct {
		struct list_head free;
		struct list_head pending;
		struct list_head active;
		struct list_head done;
		struct list_head wait;
		struct rcar_dmac_desc *running;
		struct list_head chunks_free;
		struct list_head pages;
	} desc;
};

struct rcar_dmac {
	struct dma_device engine;
	struct device *dev;
	void *iomem;
	unsigned int n_channels;
	struct rcar_dmac_chan *channels;
	u32 channels_mask;
	long unsigned int modules[8];
};

struct rcar_dmac_of_data {
	u32 chan_offset_base;
	u32 chan_offset_stride;
};

struct sirfsoc_dma_desc {
	struct dma_async_tx_descriptor desc;
	struct list_head node;
	int xlen;
	int ylen;
	int width;
	int dir;
	bool cyclic;
	bool chain;
	u32 addr;
	int: 32;
	u64 chain_table[256];
};

struct sirfsoc_dma_chan {
	struct dma_chan chan;
	struct list_head free;
	struct list_head prepared;
	struct list_head queued;
	struct list_head active;
	struct list_head completed;
	long unsigned int happened_cyclic;
	long unsigned int completed_cyclic;
	spinlock_t lock;
	int mode;
};

struct sirfsoc_dma_regs {
	u32 ctrl[16];
	u32 interrupt_en;
};

struct sirfsoc_dma {
	struct dma_device dma;
	struct tasklet_struct tasklet;
	struct sirfsoc_dma_chan channels[16];
	void *base;
	int irq;
	struct clk *clk;
	int type;
	void (*exec_desc)(struct sirfsoc_dma_desc *, int, int, void *);
	struct sirfsoc_dma_regs regs_save;
};

struct sirfsoc_dmadata {
	void (*exec)(struct sirfsoc_dma_desc *, int, int, void *);
	int type;
};

enum amba_vendor {
	AMBA_VENDOR_ARM = 65,
	AMBA_VENDOR_ST = 128,
	AMBA_VENDOR_QCOM = 81,
	AMBA_VENDOR_LSI = 182,
	AMBA_VENDOR_LINUX = 254,
};

enum stedma40_mode {
	STEDMA40_MODE_LOGICAL = 0,
	STEDMA40_MODE_PHYSICAL = 1,
	STEDMA40_MODE_OPERATION = 2,
};

enum stedma40_mode_opt {
	STEDMA40_PCHAN_BASIC_MODE = 0,
	STEDMA40_LCHAN_SRC_LOG_DST_LOG = 0,
	STEDMA40_PCHAN_MODULO_MODE = 1,
	STEDMA40_PCHAN_DOUBLE_DST_MODE = 2,
	STEDMA40_LCHAN_SRC_PHY_DST_LOG = 3,
	STEDMA40_LCHAN_SRC_LOG_DST_PHY = 4,
};

enum stedma40_flow_ctrl {
	STEDMA40_NO_FLOW_CTRL = 0,
	STEDMA40_FLOW_CTRL = 1,
};

struct stedma40_half_channel_info {
	bool big_endian;
	enum dma_slave_buswidth data_width;
	int psize;
	enum stedma40_flow_ctrl flow_ctrl;
};

struct stedma40_chan_cfg {
	enum dma_transfer_direction dir;
	bool high_priority;
	bool realtime;
	enum stedma40_mode mode;
	enum stedma40_mode_opt mode_opt;
	int dev_type;
	struct stedma40_half_channel_info src_info;
	struct stedma40_half_channel_info dst_info;
	bool use_fixed_channel;
	int phy_channel;
};

struct stedma40_platform_data {
	int disabled_channels[32];
	int *soft_lli_chans;
	int num_of_soft_lli_chans;
	bool use_esram_lcla;
	int num_of_memcpy_chans;
	int num_of_phy_chans;
};

struct d40_phy_lli {
	u32 reg_cfg;
	u32 reg_elt;
	u32 reg_ptr;
	u32 reg_lnk;
};

struct d40_phy_lli_bidir {
	struct d40_phy_lli *src;
	struct d40_phy_lli *dst;
};

struct d40_log_lli {
	u32 lcsp02;
	u32 lcsp13;
};

struct d40_log_lli_bidir {
	struct d40_log_lli *src;
	struct d40_log_lli *dst;
};

struct d40_log_lli_full {
	u32 lcsp0;
	u32 lcsp1;
	u32 lcsp2;
	u32 lcsp3;
};

struct d40_def_lcsp {
	u32 lcsp3;
	u32 lcsp1;
};

enum d40_lli_flags {
	LLI_ADDR_INC = 1,
	LLI_TERM_INT = 2,
	LLI_CYCLIC = 4,
	LLI_LAST_LINK = 8,
};

enum d40_command {
	D40_DMA_STOP = 0,
	D40_DMA_RUN = 1,
	D40_DMA_SUSPEND_REQ = 2,
	D40_DMA_SUSPENDED = 3,
};

enum d40_events {
	D40_DEACTIVATE_EVENTLINE = 0,
	D40_ACTIVATE_EVENTLINE = 1,
	D40_SUSPEND_REQ_EVENTLINE = 2,
	D40_ROUND_EVENTLINE = 3,
};

struct d40_interrupt_lookup {
	u32 src;
	u32 clr;
	bool is_error;
	int offset;
};

struct d40_reg_val {
	unsigned int reg;
	unsigned int val;
};

struct d40_lli_pool {
	void *base;
	int size;
	dma_addr_t dma_addr;
	u8 pre_alloc_lli[48];
};

struct d40_desc {
	struct d40_phy_lli_bidir lli_phy;
	struct d40_log_lli_bidir lli_log;
	struct d40_lli_pool lli_pool;
	int lli_len;
	int lli_current;
	int lcla_alloc;
	struct dma_async_tx_descriptor txd;
	struct list_head node;
	bool is_in_client_list;
	bool cyclic;
};

struct d40_lcla_pool {
	void *base;
	dma_addr_t dma_addr;
	void *base_unaligned;
	int pages;
	spinlock_t lock;
	struct d40_desc **alloc_map;
};

struct d40_phy_res {
	spinlock_t lock;
	bool reserved;
	int num;
	u32 allocated_src;
	u32 allocated_dst;
	bool use_soft_lli;
};

struct d40_base;

struct d40_chan {
	spinlock_t lock;
	int log_num;
	int pending_tx;
	bool busy;
	struct d40_phy_res *phy_chan;
	struct dma_chan chan;
	struct tasklet_struct tasklet;
	struct list_head client;
	struct list_head pending_queue;
	struct list_head active;
	struct list_head done;
	struct list_head queue;
	struct list_head prepare_queue;
	struct stedma40_chan_cfg dma_cfg;
	struct dma_slave_config slave_config;
	bool configured;
	struct d40_base *base;
	u32 src_def_cfg;
	u32 dst_def_cfg;
	struct d40_def_lcsp log_def;
	struct d40_log_lli_full *lcpa;
	dma_addr_t runtime_addr;
	enum dma_transfer_direction runtime_direction;
};

struct d40_gen_dmac {
	u32 *backup;
	u32 backup_size;
	u32 realtime_en;
	u32 realtime_clear;
	u32 high_prio_en;
	u32 high_prio_clear;
	u32 interrupt_en;
	u32 interrupt_clear;
	struct d40_interrupt_lookup *il;
	u32 il_size;
	struct d40_reg_val *init_reg;
	u32 init_reg_size;
};

struct d40_base {
	spinlock_t interrupt_lock;
	spinlock_t execmd_lock;
	struct device *dev;
	void *virtbase;
	u8 rev: 4;
	struct clk *clk;
	phys_addr_t phy_start;
	resource_size_t phy_size;
	int irq;
	int num_memcpy_chans;
	int num_phy_chans;
	int num_log_chans;
	struct dma_device dma_both;
	struct dma_device dma_slave;
	struct dma_device dma_memcpy;
	struct d40_chan *phy_chans;
	struct d40_chan *log_chans;
	struct d40_chan **lookup_log_chans;
	struct d40_chan **lookup_phy_chans;
	struct stedma40_platform_data *plat_data;
	struct regulator *lcpa_regulator;
	struct d40_phy_res *phy_res;
	struct d40_lcla_pool lcla_pool;
	void *lcpa_base;
	dma_addr_t phy_lcpa;
	resource_size_t lcpa_size;
	struct kmem_cache *desc_slab;
	u32 reg_val_backup[6];
	u32 reg_val_backup_v4[20];
	u32 *reg_val_backup_chan;
	u32 *regs_interrupt;
	u16 gcc_pwr_off_mask;
	struct d40_gen_dmac gen_dmac;
};

enum stm32_dma_width {
	STM32_DMA_BYTE = 0,
	STM32_DMA_HALF_WORD = 1,
	STM32_DMA_WORD = 2,
};

enum stm32_dma_burst_size {
	STM32_DMA_BURST_SINGLE = 0,
	STM32_DMA_BURST_INCR4 = 1,
	STM32_DMA_BURST_INCR8 = 2,
	STM32_DMA_BURST_INCR16 = 3,
};

struct stm32_dma_cfg {
	u32 channel_id;
	u32 request_line;
	u32 stream_config;
	u32 features;
};

struct stm32_dma_chan_reg {
	u32 dma_lisr;
	u32 dma_hisr;
	u32 dma_lifcr;
	u32 dma_hifcr;
	u32 dma_scr;
	u32 dma_sndtr;
	u32 dma_spar;
	u32 dma_sm0ar;
	u32 dma_sm1ar;
	u32 dma_sfcr;
};

struct stm32_dma_sg_req {
	u32 len;
	struct stm32_dma_chan_reg chan_reg;
};

struct stm32_dma_desc {
	struct virt_dma_desc vdesc;
	bool cyclic;
	u32 num_sgs;
	struct stm32_dma_sg_req sg_req[0];
};

struct stm32_dma_chan {
	struct virt_dma_chan vchan;
	bool config_init;
	bool busy;
	u32 id;
	u32 irq;
	struct stm32_dma_desc *desc;
	u32 next_sg;
	struct dma_slave_config dma_sconfig;
	struct stm32_dma_chan_reg chan_reg;
	u32 threshold;
	u32 mem_burst;
	u32 mem_width;
};

struct stm32_dma_device {
	struct dma_device ddev;
	void *base;
	struct clk *clk;
	bool mem2mem;
	struct stm32_dma_chan chan[8];
};

struct stm32_dmamux {
	u32 master;
	u32 request;
	u32 chan_id;
};

struct stm32_dmamux_data {
	struct dma_router dmarouter;
	struct clk *clk;
	void *iomem;
	u32 dma_requests;
	u32 dmamux_requests;
	spinlock_t lock;
	long unsigned int *dma_inuse;
	u32 ccr[32];
	u32 dma_reqs[0];
};

enum stm32_mdma_trigger_mode {
	STM32_MDMA_BUFFER = 0,
	STM32_MDMA_BLOCK = 1,
	STM32_MDMA_BLOCK_REP = 2,
	STM32_MDMA_LINKED_LIST = 3,
};

enum stm32_mdma_inc_mode {
	STM32_MDMA_FIXED = 0,
	STM32_MDMA_INC = 2,
	STM32_MDMA_DEC = 3,
};

struct stm32_mdma_chan_config {
	u32 request;
	u32 priority_level;
	u32 transfer_config;
	u32 mask_addr;
	u32 mask_data;
};

struct stm32_mdma_hwdesc {
	u32 ctcr;
	u32 cbndtr;
	u32 csar;
	u32 cdar;
	u32 cbrur;
	u32 clar;
	u32 ctbr;
	u32 dummy;
	u32 cmar;
	u32 cmdr;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct stm32_mdma_desc_node {
	struct stm32_mdma_hwdesc *hwdesc;
	dma_addr_t hwdesc_phys;
};

struct stm32_mdma_desc {
	struct virt_dma_desc vdesc;
	u32 ccr;
	bool cyclic;
	u32 count;
	struct stm32_mdma_desc_node node[0];
};

struct stm32_mdma_chan {
	struct virt_dma_chan vchan;
	struct dma_pool___2 *desc_pool;
	u32 id;
	struct stm32_mdma_desc *desc;
	u32 curr_hwdesc;
	struct dma_slave_config dma_config;
	struct stm32_mdma_chan_config chan_config;
	bool busy;
	u32 mem_burst;
	u32 mem_width;
};

struct stm32_mdma_device {
	struct dma_device ddev;
	void *base;
	struct clk *clk;
	int irq;
	u32 nr_channels;
	u32 nr_requests;
	u32 nr_ahb_addr_masks;
	struct stm32_mdma_chan chan[63];
	u32 ahb_addr_masks[0];
};

struct trace_event_raw_tegra_dma_tx_status {
	struct trace_entry ent;
	u32 __data_loc_chan;
	dma_cookie_t cookie;
	__u32 residue;
	char __data[0];
};

struct trace_event_raw_tegra_dma_complete_cb {
	struct trace_entry ent;
	u32 __data_loc_chan;
	int count;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_tegra_dma_isr {
	struct trace_entry ent;
	u32 __data_loc_chan;
	int irq;
	char __data[0];
};

struct trace_event_data_offsets_tegra_dma_tx_status {
	u32 chan;
};

struct trace_event_data_offsets_tegra_dma_complete_cb {
	u32 chan;
};

struct trace_event_data_offsets_tegra_dma_isr {
	u32 chan;
};

typedef void (*btf_trace_tegra_dma_tx_status)(void *, struct dma_chan *, dma_cookie_t, struct dma_tx_state *);

typedef void (*btf_trace_tegra_dma_complete_cb)(void *, struct dma_chan *, int, void *);

typedef void (*btf_trace_tegra_dma_isr)(void *, struct dma_chan *, int);

struct tegra_dma_chip_data {
	unsigned int nr_channels;
	unsigned int channel_reg_size;
	unsigned int max_dma_count;
	bool support_channel_pause;
	bool support_separate_wcount_reg;
};

struct tegra_dma_channel_regs {
	u32 csr;
	u32 ahb_ptr;
	u32 apb_ptr;
	u32 ahb_seq;
	u32 apb_seq;
	u32 wcount;
};

struct tegra_dma_desc;

struct tegra_dma_sg_req {
	struct tegra_dma_channel_regs ch_regs;
	unsigned int req_len;
	bool configured;
	bool last_sg;
	struct list_head node;
	struct tegra_dma_desc *dma_desc;
	unsigned int words_xferred;
};

struct tegra_dma_desc {
	struct dma_async_tx_descriptor txd;
	unsigned int bytes_requested;
	unsigned int bytes_transferred;
	enum dma_status dma_status;
	struct list_head node;
	struct list_head tx_list;
	struct list_head cb_node;
	unsigned int cb_count;
};

struct tegra_dma_channel;

typedef void (*dma_isr_handler)(struct tegra_dma_channel *, bool);

struct tegra_dma;

struct tegra_dma_channel {
	struct dma_chan dma_chan;
	char name[12];
	bool config_init;
	unsigned int id;
	void *chan_addr;
	spinlock_t lock;
	bool busy;
	struct tegra_dma *tdma;
	bool cyclic;
	struct list_head free_sg_req;
	struct list_head pending_sg_req;
	struct list_head free_dma_desc;
	struct list_head cb_desc;
	dma_isr_handler isr_handler;
	struct tasklet_struct tasklet;
	unsigned int slave_id;
	struct dma_slave_config dma_sconfig;
	struct tegra_dma_channel_regs channel_reg;
	struct wait_queue_head wq;
};

struct tegra_dma {
	struct dma_device dma_dev;
	struct device *dev;
	struct clk *dma_clk;
	struct reset_control *rst;
	spinlock_t global_lock;
	void *base_addr;
	const struct tegra_dma_chip_data *chip_data;
	u32 global_pause_count;
	struct tegra_dma_channel channels[0];
};

struct uniphier_mdmac_desc {
	struct virt_dma_desc vd;
	struct scatterlist *sgl;
	unsigned int sg_len;
	unsigned int sg_cur;
	enum dma_transfer_direction dir;
};

struct uniphier_mdmac_device;

struct uniphier_mdmac_chan {
	struct virt_dma_chan vc;
	struct uniphier_mdmac_device *mdev;
	struct uniphier_mdmac_desc *md;
	void *reg_ch_base;
	unsigned int chan_id;
};

struct uniphier_mdmac_device {
	struct dma_device ddev;
	struct clk *clk;
	void *reg_base;
	struct uniphier_mdmac_chan channels[0];
};

struct bam_desc_hw {
	__le32 addr;
	__le16 size;
	__le16 flags;
};

struct bam_async_desc {
	struct virt_dma_desc vd;
	u32 num_desc;
	u32 xfer_len;
	u16 flags;
	struct bam_desc_hw *curr_desc;
	struct list_head desc_node;
	enum dma_transfer_direction dir;
	size_t length;
	struct bam_desc_hw desc[0];
};

enum bam_reg {
	BAM_CTRL = 0,
	BAM_REVISION = 1,
	BAM_NUM_PIPES = 2,
	BAM_DESC_CNT_TRSHLD = 3,
	BAM_IRQ_SRCS = 4,
	BAM_IRQ_SRCS_MSK = 5,
	BAM_IRQ_SRCS_UNMASKED = 6,
	BAM_IRQ_STTS = 7,
	BAM_IRQ_CLR = 8,
	BAM_IRQ_EN = 9,
	BAM_CNFG_BITS = 10,
	BAM_IRQ_SRCS_EE = 11,
	BAM_IRQ_SRCS_MSK_EE = 12,
	BAM_P_CTRL = 13,
	BAM_P_RST = 14,
	BAM_P_HALT = 15,
	BAM_P_IRQ_STTS = 16,
	BAM_P_IRQ_CLR = 17,
	BAM_P_IRQ_EN = 18,
	BAM_P_EVNT_DEST_ADDR = 19,
	BAM_P_EVNT_REG = 20,
	BAM_P_SW_OFSTS = 21,
	BAM_P_DATA_FIFO_ADDR = 22,
	BAM_P_DESC_FIFO_ADDR = 23,
	BAM_P_EVNT_GEN_TRSHLD = 24,
	BAM_P_FIFO_SIZES = 25,
};

struct reg_offset_data {
	u32 base_offset;
	unsigned int pipe_mult;
	unsigned int evnt_mult;
	unsigned int ee_mult;
};

struct bam_device;

struct bam_chan {
	struct virt_dma_chan vc;
	struct bam_device *bdev;
	u32 id;
	struct dma_slave_config slave;
	struct bam_desc_hw *fifo_virt;
	dma_addr_t fifo_phys;
	short unsigned int head;
	short unsigned int tail;
	unsigned int initialized;
	unsigned int paused;
	unsigned int reconfigure;
	struct list_head desc_list;
	struct list_head node;
};

struct bam_device {
	void *regs;
	struct device *dev;
	struct dma_device common;
	struct bam_chan *channels;
	u32 num_channels;
	u32 num_ees;
	u32 ee;
	bool controlled_remotely;
	const struct reg_offset_data *layout;
	struct clk *bamclk;
	int irq;
	struct tasklet_struct task;
};

enum dma_event_q {
	EVENTQ_0 = 0,
	EVENTQ_1 = 1,
	EVENTQ_2 = 2,
	EVENTQ_3 = 3,
	EVENTQ_DEFAULT = 4294967295,
};

struct edma_rsv_info {
	const s16 (*rsv_chans)[2];
	const s16 (*rsv_slots)[2];
};

struct edma_soc_info {
	enum dma_event_q default_queue;
	struct edma_rsv_info *rsv;
	s32 *memcpy_channels;
	s8 (*queue_priority_mapping)[2];
	const s16 (*xbar_chans)[2];
	const struct dma_slave_map *slave_map;
	int slavecnt;
};

struct edmacc_param {
	u32 opt;
	u32 src;
	u32 a_b_cnt;
	u32 dst;
	u32 src_dst_bidx;
	u32 link_bcntrld;
	u32 src_dst_cidx;
	u32 ccnt;
};

struct edma_pset {
	u32 len;
	dma_addr_t addr;
	struct edmacc_param param;
};

struct edma_chan;

struct edma_desc {
	struct virt_dma_desc vdesc;
	struct list_head node;
	enum dma_transfer_direction direction;
	int cyclic;
	bool polled;
	int absync;
	int pset_nr;
	struct edma_chan *echan;
	int processed;
	int processed_stat;
	u32 sg_len;
	u32 residue;
	u32 residue_stat;
	struct edma_pset pset[0];
};

struct edma_cc;

struct edma_tc;

struct edma_chan {
	struct virt_dma_chan vchan;
	struct list_head node;
	struct edma_desc *edesc;
	struct edma_cc *ecc;
	struct edma_tc *tc;
	int ch_num;
	bool alloced;
	bool hw_triggered;
	int slot[20];
	int missed;
	struct dma_slave_config cfg;
};

struct edma_tc {
	struct device_node *node;
	u16 id;
};

struct edma_cc {
	struct device *dev;
	struct edma_soc_info *info;
	void *base;
	int id;
	bool legacy_mode;
	unsigned int num_channels;
	unsigned int num_qchannels;
	unsigned int num_region;
	unsigned int num_slots;
	unsigned int num_tc;
	bool chmap_exist;
	enum dma_event_q default_queue;
	unsigned int ccint;
	unsigned int ccerrint;
	long unsigned int *slot_inuse;
	long unsigned int *channels_mask;
	struct dma_device dma_slave;
	struct dma_device *dma_memcpy;
	struct edma_chan *slave_chans;
	struct edma_tc *tc_list;
	int dummy_slot;
};

struct omap_dma_config {
	int lch_end;
	unsigned int rw_priority: 1;
	unsigned int needs_busy_check: 1;
	unsigned int may_lose_context: 1;
	unsigned int needs_lch_clear: 1;
};

struct omap_dma_context {
	u32 irqenable_l0;
	u32 irqenable_l1;
	u32 ocp_sysconfig;
	u32 gcr;
};

struct omap_chan;

struct omap_dmadev {
	struct dma_device ddev;
	spinlock_t lock;
	void *base;
	const struct omap_dma_reg *reg_map;
	struct omap_system_dma_plat_info *plat;
	const struct omap_dma_config *cfg;
	struct notifier_block nb;
	struct omap_dma_context context;
	int lch_count;
	long unsigned int lch_bitmap[1];
	struct mutex lch_lock;
	bool legacy;
	bool ll123_supported;
	struct dma_pool___2 *desc_pool;
	unsigned int dma_requests;
	spinlock_t irq_lock;
	uint32_t irq_enable_mask;
	struct omap_chan **lch_map;
};

struct omap_desc;

struct omap_chan {
	struct virt_dma_chan vc;
	void *channel_base;
	const struct omap_dma_reg *reg_map;
	uint32_t ccr;
	struct dma_slave_config cfg;
	unsigned int dma_sig;
	bool cyclic;
	bool paused;
	bool running;
	int dma_ch;
	struct omap_desc *desc;
	unsigned int sgidx;
};

struct omap_type2_desc;

struct omap_sg {
	dma_addr_t addr;
	uint32_t en;
	uint32_t fn;
	int32_t fi;
	int16_t ei;
	struct omap_type2_desc *t2_desc;
	dma_addr_t t2_desc_paddr;
};

struct omap_desc {
	struct virt_dma_desc vd;
	bool using_ll;
	enum dma_transfer_direction dir;
	dma_addr_t dev_addr;
	bool polled;
	int32_t fi;
	int16_t ei;
	uint8_t es;
	uint32_t ccr;
	uint16_t clnk_ctrl;
	uint16_t cicr;
	uint32_t csdp;
	unsigned int sglen;
	struct omap_sg sg[0];
};

struct omap_type2_desc {
	uint32_t next_desc;
	uint32_t en;
	uint32_t addr;
	uint16_t fn;
	uint16_t cicr;
	int16_t cdei;
	int16_t csei;
	int32_t cdfi;
	int32_t csfi;
};

enum {
	CAPS_0_SUPPORT_LL123 = 1048576,
	CAPS_0_SUPPORT_LL4 = 2097152,
	CCR_FS = 32,
	CCR_READ_PRIORITY = 64,
	CCR_ENABLE = 128,
	CCR_AUTO_INIT = 256,
	CCR_REPEAT = 512,
	CCR_OMAP31_DISABLE = 1024,
	CCR_SUSPEND_SENSITIVE = 256,
	CCR_RD_ACTIVE = 512,
	CCR_WR_ACTIVE = 1024,
	CCR_SRC_AMODE_CONSTANT = 0,
	CCR_SRC_AMODE_POSTINC = 4096,
	CCR_SRC_AMODE_SGLIDX = 8192,
	CCR_SRC_AMODE_DBLIDX = 12288,
	CCR_DST_AMODE_CONSTANT = 0,
	CCR_DST_AMODE_POSTINC = 16384,
	CCR_DST_AMODE_SGLIDX = 32768,
	CCR_DST_AMODE_DBLIDX = 49152,
	CCR_CONSTANT_FILL = 65536,
	CCR_TRANSPARENT_COPY = 131072,
	CCR_BS = 262144,
	CCR_SUPERVISOR = 4194304,
	CCR_PREFETCH = 8388608,
	CCR_TRIGGER_SRC = 16777216,
	CCR_BUFFERING_DISABLE = 33554432,
	CCR_WRITE_PRIORITY = 67108864,
	CCR_SYNC_ELEMENT = 0,
	CCR_SYNC_FRAME = 32,
	CCR_SYNC_BLOCK = 262144,
	CCR_SYNC_PACKET = 262176,
	CSDP_DATA_TYPE_8 = 0,
	CSDP_DATA_TYPE_16 = 1,
	CSDP_DATA_TYPE_32 = 2,
	CSDP_SRC_PORT_EMIFF = 0,
	CSDP_SRC_PORT_EMIFS = 4,
	CSDP_SRC_PORT_OCP_T1 = 8,
	CSDP_SRC_PORT_TIPB = 12,
	CSDP_SRC_PORT_OCP_T2 = 16,
	CSDP_SRC_PORT_MPUI = 20,
	CSDP_SRC_PACKED = 64,
	CSDP_SRC_BURST_1 = 0,
	CSDP_SRC_BURST_16 = 128,
	CSDP_SRC_BURST_32 = 256,
	CSDP_SRC_BURST_64 = 384,
	CSDP_DST_PORT_EMIFF = 0,
	CSDP_DST_PORT_EMIFS = 512,
	CSDP_DST_PORT_OCP_T1 = 1024,
	CSDP_DST_PORT_TIPB = 1536,
	CSDP_DST_PORT_OCP_T2 = 2048,
	CSDP_DST_PORT_MPUI = 2560,
	CSDP_DST_PACKED = 8192,
	CSDP_DST_BURST_1 = 0,
	CSDP_DST_BURST_16 = 16384,
	CSDP_DST_BURST_32 = 32768,
	CSDP_DST_BURST_64 = 49152,
	CSDP_WRITE_NON_POSTED = 0,
	CSDP_WRITE_POSTED = 65536,
	CSDP_WRITE_LAST_NON_POSTED = 131072,
	CICR_TOUT_IE = 1,
	CICR_DROP_IE = 2,
	CICR_HALF_IE = 4,
	CICR_FRAME_IE = 8,
	CICR_LAST_IE = 16,
	CICR_BLOCK_IE = 32,
	CICR_PKT_IE = 128,
	CICR_TRANS_ERR_IE = 256,
	CICR_SUPERVISOR_ERR_IE = 1024,
	CICR_MISALIGNED_ERR_IE = 2048,
	CICR_DRAIN_IE = 4096,
	CICR_SUPER_BLOCK_IE = 16384,
	CLNK_CTRL_ENABLE_LNK = 32768,
	CDP_DST_VALID_INC = 0,
	CDP_DST_VALID_RELOAD = 1,
	CDP_DST_VALID_REUSE = 2,
	CDP_SRC_VALID_INC = 0,
	CDP_SRC_VALID_RELOAD = 4,
	CDP_SRC_VALID_REUSE = 8,
	CDP_NTYPE_TYPE1 = 16,
	CDP_NTYPE_TYPE2 = 32,
	CDP_NTYPE_TYPE3 = 48,
	CDP_TMODE_NORMAL = 0,
	CDP_TMODE_LLIST = 256,
	CDP_FAST = 1024,
};

struct ti_am335x_xbar_data {
	void *iomem;
	struct dma_router dmarouter;
	u32 xbar_events;
	u32 dma_requests;
};

struct ti_am335x_xbar_map {
	u16 dma_line;
	u8 mux_val;
};

struct ti_dra7_xbar_data {
	void *iomem;
	struct dma_router dmarouter;
	struct mutex mutex;
	long unsigned int *dma_inuse;
	u16 safe_val;
	u32 xbar_requests;
	u32 dma_requests;
	u32 dma_offset;
};

struct ti_dra7_xbar_map {
	u16 xbar_in;
	int xbar_out;
};

struct xilinx_vdma_config {
	int frm_dly;
	int gen_lock;
	int master;
	int frm_cnt_en;
	int park;
	int park_frm;
	int coalesc;
	int delay;
	int reset;
	int ext_fsync;
	bool vflip_en;
};

struct xilinx_vdma_desc_hw {
	u32 next_desc;
	u32 pad1;
	u32 buf_addr;
	u32 buf_addr_msb;
	u32 vsize;
	u32 hsize;
	u32 stride;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_axidma_desc_hw {
	u32 next_desc;
	u32 next_desc_msb;
	u32 buf_addr;
	u32 buf_addr_msb;
	u32 reserved1;
	u32 reserved2;
	u32 control;
	u32 status;
	u32 app[5];
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_aximcdma_desc_hw {
	u32 next_desc;
	u32 next_desc_msb;
	u32 buf_addr;
	u32 buf_addr_msb;
	u32 rsvd;
	u32 control;
	u32 status;
	u32 sideband_status;
	u32 app[5];
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_cdma_desc_hw {
	u32 next_desc;
	u32 next_desc_msb;
	u32 src_addr;
	u32 src_addr_msb;
	u32 dest_addr;
	u32 dest_addr_msb;
	u32 control;
	u32 status;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_vdma_tx_segment {
	struct xilinx_vdma_desc_hw hw;
	struct list_head node;
	dma_addr_t phys;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_axidma_tx_segment {
	struct xilinx_axidma_desc_hw hw;
	struct list_head node;
	dma_addr_t phys;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_aximcdma_tx_segment {
	struct xilinx_aximcdma_desc_hw hw;
	struct list_head node;
	dma_addr_t phys;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_cdma_tx_segment {
	struct xilinx_cdma_desc_hw hw;
	struct list_head node;
	dma_addr_t phys;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xilinx_dma_tx_descriptor {
	struct dma_async_tx_descriptor async_tx;
	struct list_head segments;
	struct list_head node;
	bool cyclic;
	bool err;
	u32 residue;
};

struct xilinx_dma_device;

struct xilinx_dma_chan {
	struct xilinx_dma_device *xdev;
	u32 ctrl_offset;
	u32 desc_offset;
	spinlock_t lock;
	struct list_head pending_list;
	struct list_head active_list;
	struct list_head done_list;
	struct list_head free_seg_list;
	struct dma_chan common;
	struct dma_pool___2 *desc_pool;
	struct device *dev;
	int irq;
	int id;
	enum dma_transfer_direction direction;
	int num_frms;
	bool has_sg;
	bool cyclic;
	bool genlock;
	bool err;
	bool idle;
	struct tasklet_struct tasklet;
	struct xilinx_vdma_config config;
	bool flush_on_fsync;
	u32 desc_pendingcount;
	bool ext_addr;
	u32 desc_submitcount;
	struct xilinx_axidma_tx_segment *seg_v;
	struct xilinx_aximcdma_tx_segment *seg_mv;
	dma_addr_t seg_p;
	struct xilinx_axidma_tx_segment *cyclic_seg_v;
	dma_addr_t cyclic_seg_p;
	void (*start_transfer)(struct xilinx_dma_chan *);
	int (*stop_transfer)(struct xilinx_dma_chan *);
	u16 tdest;
	bool has_vflip;
};

struct xilinx_dma_config;

struct xilinx_dma_device {
	void *regs;
	struct device *dev;
	struct dma_device common;
	struct xilinx_dma_chan *chan[32];
	u32 flush_on_fsync;
	bool ext_addr;
	struct platform_device *pdev;
	const struct xilinx_dma_config *dma_config;
	struct clk *axi_clk;
	struct clk *tx_clk;
	struct clk *txs_clk;
	struct clk *rx_clk;
	struct clk *rxs_clk;
	u32 s2mm_chan_id;
	u32 mm2s_chan_id;
	u32 max_buffer_len;
};

enum xdma_ip_type {
	XDMA_TYPE_AXIDMA = 0,
	XDMA_TYPE_CDMA = 1,
	XDMA_TYPE_VDMA = 2,
	XDMA_TYPE_AXIMCDMA = 3,
};

struct xilinx_dma_config {
	enum xdma_ip_type dmatype;
	int (*clk_init)(struct platform_device *, struct clk **, struct clk **, struct clk **, struct clk **, struct clk **);
	irqreturn_t (*irq_handler)(int, void *);
	const int max_channels;
};

struct at91_soc {
	u32 cidr_match;
	u32 exid_match;
	const char *name;
	const char *family;
};

struct bcm2835_pm {
	struct device *dev;
	void *base;
	void *asb;
};

struct bcm2835_power;

struct bcm2835_power_domain {
	struct generic_pm_domain base;
	struct bcm2835_power *power;
	u32 domain;
	struct clk *clk;
	int: 32;
};

struct bcm2835_power {
	struct device *dev;
	void *base;
	void *asb;
	struct genpd_onecell_data pd_xlate;
	struct bcm2835_power_domain domains[13];
	struct reset_controller_dev reset;
	int: 32;
};

struct rpi_power_domain {
	u32 domain;
	bool enabled;
	bool old_interface;
	struct generic_pm_domain base;
	struct rpi_firmware *fw;
	int: 32;
};

struct rpi_power_domains {
	bool has_new_interface;
	struct genpd_onecell_data xlate;
	struct rpi_firmware *fw;
	int: 32;
	struct rpi_power_domain domains[23];
};

struct rpi_power_domain_packet {
	u32 domain;
	u32 on;
};

enum cpubiuctrl_regs {
	CPU_CREDIT_REG = 0,
	CPU_MCP_FLOW_REG = 1,
	CPU_WRITEBACK_CTRL_REG = 2,
	RAC_CONFIG0_REG = 3,
	RAC_CONFIG1_REG = 4,
	NUM_CPU_BIUCTRL_REGS = 5,
};

enum {
	S3_FLAG_LOAD_RANDKEY = 1,
	S3_FLAG_SCRATCH_BUFFER_TABLE = 2,
	S3_FLAG_NO_MEM_VERIFY = 4,
	S3_FLAG_PSCI_BOOT = 8,
	S3_FLAG_BOOTED64 = 16,
};

struct brcmstb_bootloader_dtu_table {
	uint32_t dtu_state_map[8192];
	uint32_t dtu_config[512];
};

struct brcmstb_s3_params {
	uint8_t scratch[64];
	uint32_t magic;
	uint64_t reentry;
	uint32_t hash[4];
	uint32_t desc_offset_2;
	uint64_t buffer_table;
	uint32_t spare[70];
	uint8_t descriptors[2048];
	struct brcmstb_bootloader_dtu_table dtu[2];
};

struct brcmstb_memc {
	void *ddr_phy_base;
	void *ddr_shimphy_base;
	void *ddr_ctrl;
};

struct brcmstb_pm_control {
	void *aon_ctrl_base;
	void *aon_sram;
	struct brcmstb_memc memcs[3];
	void *boot_sram;
	size_t boot_sram_len;
	bool support_warm_boot;
	size_t pll_status_offset;
	int num_memc;
	struct brcmstb_s3_params *s3_params;
	dma_addr_t s3_params_pa;
	int s3entry_method;
	u32 warm_boot_offset;
	u32 phy_a_standby_ctrl_offs;
	u32 phy_b_standby_ctrl_offs;
	bool needs_ddr_pad;
	struct platform_device *pdev;
};

enum bsp_initiate_command {
	BSP_CLOCK_STOP = 0,
	BSP_GEN_RANDOM_KEY = 74,
	BSP_RESTORE_RANDOM_KEY = 85,
	BSP_GEN_FIXED_KEY = 99,
};

struct ddr_phy_ofdata {
	bool supports_warm_boot;
	size_t pll_status_offset;
	int s3entry_method;
	u32 warm_boot_offset;
	u32 phy_a_standby_ctrl_offs;
	u32 phy_b_standby_ctrl_offs;
};

struct ddr_seq_ofdata {
	bool needs_ddr_pad;
	u32 warm_boot_offset;
};

struct dove_pmu_domain_initdata {
	u32 pwr_mask;
	u32 rst_mask;
	u32 iso_mask;
	const char *name;
};

struct dove_pmu_initdata {
	void *pmc_base;
	void *pmu_base;
	int irq;
	int irq_domain_start;
	const struct dove_pmu_domain_initdata *domains;
};

struct pmu_data {
	spinlock_t lock;
	struct device_node *of_node;
	void *pmc_base;
	void *pmu_base;
	struct irq_chip_generic *irq_gc;
	struct irq_domain *irq_domain;
	struct reset_controller_dev reset;
};

struct pmu_domain {
	struct pmu_data *pmu;
	u32 pwr_mask;
	u32 rst_mask;
	u32 iso_mask;
	struct generic_pm_domain base;
};

struct guts {
	struct ccsr_guts *regs;
	bool little_endian;
};

struct fsl_soc_die_attr {
	char *die;
	u32 svr;
	u32 mask;
};

struct imx_pm_domain {
	struct generic_pm_domain base;
	struct regmap *regmap;
	struct regulator *supply;
	struct clk *clk[7];
	int num_clks;
	unsigned int reg_offs;
	signed char cntr_pdn_bit;
	unsigned int ipg_rate_mhz;
	int: 32;
};

struct imx_gpc_dt_data {
	int num_domains;
	bool err009619_present;
	bool err006287_present;
};

struct imx_pgc_domain {
	struct generic_pm_domain genpd;
	struct regmap *regmap;
	struct regulator *regulator;
	struct clk *clk[6];
	int num_clks;
	unsigned int pgc;
	const struct {
		u32 pxx;
		u32 map;
		u32 hsk;
	} bits;
	const int voltage;
	struct device *dev;
	int: 32;
};

struct imx_pgc_domain_data {
	const struct imx_pgc_domain *domains;
	size_t domains_num;
	const struct regmap_access_table *reg_access_table;
};

enum clk_id___2 {
	CLK_NONE = 0,
	CLK_MM = 1,
	CLK_MFG = 2,
	CLK_VENC = 3,
	CLK_VENC_LT = 4,
	CLK_ETHIF = 5,
	CLK_VDEC = 6,
	CLK_HIFSEL = 7,
	CLK_JPGDEC = 8,
	CLK_AUDIO = 9,
	CLK_MAX = 10,
};

struct scp_domain_data {
	const char *name;
	u32 sta_mask;
	int ctl_offs;
	u32 sram_pdn_bits;
	u32 sram_pdn_ack_bits;
	u32 bus_prot_mask;
	enum clk_id___2 clk_id[3];
	u8 caps;
};

struct scp;

struct scp_domain {
	struct generic_pm_domain genpd;
	struct scp *scp;
	struct clk *clk[3];
	const struct scp_domain_data *data;
	struct regulator *supply;
};

struct scp_ctrl_reg {
	int pwr_sta_offs;
	int pwr_sta2nd_offs;
};

struct scp {
	struct scp_domain *domains;
	struct genpd_onecell_data pd_data;
	struct device *dev;
	void *base;
	struct regmap *infracfg;
	struct scp_ctrl_reg ctrl_reg;
	bool bus_prot_reg_update;
};

struct scp_subdomain {
	int origin;
	int subdomain;
};

struct scp_soc_data {
	const struct scp_domain_data *domains;
	int num_domains;
	const struct scp_subdomain *subdomains;
	int num_subdomains;
	const struct scp_ctrl_reg regs;
	bool bus_prot_reg_update;
};

struct scpsys_bus_prot_data {
	u32 bus_prot_mask;
	u32 bus_prot_set;
	u32 bus_prot_clr;
	u32 bus_prot_sta;
	bool bus_prot_reg_update;
	bool ignore_clr_ack;
};

struct scpsys_domain_data {
	u32 sta_mask;
	int ctl_offs;
	u32 sram_pdn_bits;
	u32 sram_pdn_ack_bits;
	u8 caps;
	const struct scpsys_bus_prot_data bp_infracfg[5];
	const struct scpsys_bus_prot_data bp_smi[5];
};

struct scpsys_soc_data {
	const struct scpsys_domain_data *domains_data;
	int num_domains;
	int pwr_sta_offs;
	int pwr_sta2nd_offs;
};

struct scpsys;

struct scpsys_domain {
	struct generic_pm_domain genpd;
	const struct scpsys_domain_data *data;
	struct scpsys *scpsys;
	int num_clks;
	struct clk_bulk_data *clks;
	int num_subsys_clks;
	struct clk_bulk_data *subsys_clks;
	struct regmap *infracfg;
	struct regmap *smi;
};

struct scpsys {
	struct device *dev;
	struct regmap *base;
	const struct scpsys_soc_data *soc_data;
	struct genpd_onecell_data pd_data;
	struct generic_pm_domain *domains[0];
};

enum mtk_ddp_comp_id {
	DDP_COMPONENT_AAL0 = 0,
	DDP_COMPONENT_AAL1 = 1,
	DDP_COMPONENT_BLS = 2,
	DDP_COMPONENT_CCORR = 3,
	DDP_COMPONENT_COLOR0 = 4,
	DDP_COMPONENT_COLOR1 = 5,
	DDP_COMPONENT_DITHER = 6,
	DDP_COMPONENT_DPI0 = 7,
	DDP_COMPONENT_DPI1 = 8,
	DDP_COMPONENT_DSI0 = 9,
	DDP_COMPONENT_DSI1 = 10,
	DDP_COMPONENT_DSI2 = 11,
	DDP_COMPONENT_DSI3 = 12,
	DDP_COMPONENT_GAMMA = 13,
	DDP_COMPONENT_OD0 = 14,
	DDP_COMPONENT_OD1 = 15,
	DDP_COMPONENT_OVL0 = 16,
	DDP_COMPONENT_OVL_2L0 = 17,
	DDP_COMPONENT_OVL_2L1 = 18,
	DDP_COMPONENT_OVL1 = 19,
	DDP_COMPONENT_PWM0 = 20,
	DDP_COMPONENT_PWM1 = 21,
	DDP_COMPONENT_PWM2 = 22,
	DDP_COMPONENT_RDMA0 = 23,
	DDP_COMPONENT_RDMA1 = 24,
	DDP_COMPONENT_RDMA2 = 25,
	DDP_COMPONENT_UFOE = 26,
	DDP_COMPONENT_WDMA0 = 27,
	DDP_COMPONENT_WDMA1 = 28,
	DDP_COMPONENT_ID_MAX = 29,
};

struct mtk_mmsys_driver_data {
	const char *clk_driver;
};

struct meson_msr;

struct meson_msr_id {
	struct meson_msr *priv;
	unsigned int id;
	const char *name;
};

struct meson_msr {
	struct regmap *regmap;
	struct meson_msr_id msr_table[128];
};

struct meson_gx_pwrc_vpu {
	struct generic_pm_domain genpd;
	struct regmap *regmap_ao;
	struct regmap *regmap_hhi;
	struct reset_control *rstc;
	struct clk *vpu_clk;
	struct clk *vapb_clk;
	int: 32;
};

struct meson_ee_pwrc_mem_domain {
	unsigned int reg;
	unsigned int mask;
};

struct meson_ee_pwrc_top_domain {
	unsigned int sleep_reg;
	unsigned int sleep_mask;
	unsigned int iso_reg;
	unsigned int iso_mask;
};

struct meson_ee_pwrc_domain;

struct meson_ee_pwrc_domain_desc {
	char *name;
	unsigned int reset_names_count;
	unsigned int clk_names_count;
	struct meson_ee_pwrc_top_domain *top_pd;
	unsigned int mem_pd_count;
	struct meson_ee_pwrc_mem_domain *mem_pd;
	bool (*get_power)(struct meson_ee_pwrc_domain *);
};

struct meson_ee_pwrc;

struct meson_ee_pwrc_domain {
	struct generic_pm_domain base;
	bool enabled;
	struct meson_ee_pwrc *pwrc;
	struct meson_ee_pwrc_domain_desc desc;
	struct clk_bulk_data *clks;
	int num_clks;
	struct reset_control *rstc;
	int num_rstc;
	int: 32;
};

struct meson_ee_pwrc_domain_data {
	unsigned int count;
	struct meson_ee_pwrc_domain_desc *domains;
};

struct meson_ee_pwrc {
	struct regmap *regmap_ao;
	struct regmap *regmap_hhi;
	struct meson_ee_pwrc_domain *domains;
	struct genpd_onecell_data xlate;
};

enum cmd_db_hw_type {
	CMD_DB_HW_INVALID = 0,
	CMD_DB_HW_MIN = 3,
	CMD_DB_HW_ARC = 3,
	CMD_DB_HW_VRM = 4,
	CMD_DB_HW_BCM = 5,
	CMD_DB_HW_MAX = 5,
	CMD_DB_HW_ALL = 255,
};

struct entry_header {
	u8 id[8];
	__le32 priority[2];
	__le32 addr;
	__le16 len;
	__le16 offset;
};

struct rsc_hdr {
	__le16 slv_id;
	__le16 header_offset;
	__le16 data_offset;
	__le16 cnt;
	__le16 version;
	__le16 reserved[3];
};

struct cmd_db_header {
	__le32 version;
	u8 magic[4];
	struct rsc_hdr header[8];
	__le32 checksum;
	__le32 reserved;
	u8 data[0];
};

struct crci_config {
	u32 num_rows;
	const u32 (*array)[12];
};

struct gsbi_info {
	struct clk *hclk;
	u32 mode;
	u32 crci;
	struct regmap *tcsr;
};

struct renesas_family {
	const char name[16];
	u32 reg;
};

struct renesas_soc {
	const struct renesas_family *family;
	u8 id;
};

struct rcar_sysc_area {
	const char *name;
	u16 chan_offs;
	u8 chan_bit;
	u8 isr_bit;
	int parent;
	unsigned int flags;
};

struct rcar_sysc_info {
	int (*init)();
	const struct rcar_sysc_area *areas;
	unsigned int num_areas;
	u32 extmask_offs;
	u32 extmask_val;
};

struct rst_config {
	unsigned int modemr;
	int (*configure)(void *);
};

struct rcar_sysc_ch {
	u16 chan_offs;
	u8 chan_bit;
	u8 isr_bit;
};

struct rcar_sysc_pd {
	struct generic_pm_domain genpd;
	struct rcar_sysc_ch ch;
	unsigned int flags;
	char name[0];
};

struct rcar_pm_domains {
	struct genpd_onecell_data onecell_data;
	struct generic_pm_domain *domains[33];
};

struct rmobile_pm_domain {
	struct generic_pm_domain genpd;
	struct dev_power_governor *gov;
	int (*suspend)();
	void *base;
	unsigned int bit_shift;
};

enum pd_types {
	PD_NORMAL = 0,
	PD_CPU = 1,
	PD_CONSOLE = 2,
	PD_DEBUG = 3,
	PD_MEMCTL = 4,
};

struct special_pd {
	struct device_node *pd;
	enum pd_types type;
};

struct rockchip_grf_value {
	const char *desc;
	u32 reg;
	u32 val;
};

struct rockchip_grf_info {
	const struct rockchip_grf_value *values;
	int num_values;
};

struct pre_voltage_change_data {
	long unsigned int old_uV;
	long unsigned int min_uV;
	long unsigned int max_uV;
};

struct rockchip_iodomain;

struct rockchip_iodomain_soc_data {
	int grf_offset;
	const char *supply_names[16];
	void (*init)(struct rockchip_iodomain *);
};

struct rockchip_iodomain_supply {
	struct rockchip_iodomain *iod;
	struct regulator *reg;
	struct notifier_block nb;
	int idx;
};

struct rockchip_iodomain {
	struct device *dev;
	struct regmap *grf;
	const struct rockchip_iodomain_soc_data *soc_data;
	struct rockchip_iodomain_supply supplies[16];
};

struct rockchip_domain_info {
	int pwr_mask;
	int status_mask;
	int req_mask;
	int idle_mask;
	int ack_mask;
	bool active_wakeup;
	int pwr_w_mask;
	int req_w_mask;
};

struct rockchip_pmu_info {
	u32 pwr_offset;
	u32 status_offset;
	u32 req_offset;
	u32 idle_offset;
	u32 ack_offset;
	u32 core_pwrcnt_offset;
	u32 gpu_pwrcnt_offset;
	unsigned int core_power_transition_time;
	unsigned int gpu_power_transition_time;
	int num_domains;
	const struct rockchip_domain_info *domain_info;
};

struct rockchip_pmu;

struct rockchip_pm_domain {
	struct generic_pm_domain genpd;
	const struct rockchip_domain_info *info;
	struct rockchip_pmu *pmu;
	int num_qos;
	struct regmap **qos_regmap;
	u32 *qos_save_regs[5];
	int num_clks;
	struct clk_bulk_data *clks;
	int: 32;
};

struct rockchip_pmu {
	struct device *dev;
	struct regmap *regmap;
	const struct rockchip_pmu_info *info;
	struct mutex mutex;
	struct genpd_onecell_data genpd_data;
	struct generic_pm_domain *domains[0];
};

struct exynos_asv_table {
	unsigned int num_rows;
	unsigned int num_cols;
	u32 *buf;
};

struct exynos_asv;

struct exynos_asv_subsys {
	struct exynos_asv *asv;
	const char *cpu_dt_compat;
	int id;
	struct exynos_asv_table table;
	unsigned int base_volt;
	unsigned int offset_volt_h;
	unsigned int offset_volt_l;
};

struct exynos_asv {
	struct device *dev;
	struct regmap *chipid_regmap;
	struct exynos_asv_subsys subsys[2];
	int (*opp_get_voltage)(const struct exynos_asv_subsys *, int, unsigned int);
	unsigned int group;
	unsigned int table;
	bool use_sg;
	int of_bin;
};

struct asv_limit_entry {
	unsigned int hpm;
	unsigned int ids;
};

enum {
	EXYNOS_ASV_SUBSYS_ID_ARM = 0,
	EXYNOS_ASV_SUBSYS_ID_KFC = 1,
	EXYNOS_ASV_SUBSYS_ID_MAX = 2,
};

struct exynos_soc_id {
	const char *name;
	unsigned int id;
};

struct mfd_cell_acpi_match;

struct mfd_cell {
	const char *name;
	int id;
	int level;
	int (*enable)(struct platform_device *);
	int (*disable)(struct platform_device *);
	int (*suspend)(struct platform_device *);
	int (*resume)(struct platform_device *);
	void *platform_data;
	size_t pdata_size;
	const struct property_entry *properties;
	const char *of_compatible;
	int: 32;
	const u64 of_reg;
	bool use_of_reg;
	const struct mfd_cell_acpi_match *acpi_match;
	int num_resources;
	const struct resource *resources;
	bool ignore_resource_conflicts;
	bool pm_runtime_no_callbacks;
	const char * const *parent_supplies;
	int num_parent_supplies;
	int: 32;
};

struct mfd_cell_acpi_match {
	const char *pnpid;
	int: 32;
	const long long unsigned int adr;
};

struct exynos_pmu_conf {
	unsigned int offset;
	u8 val[3];
};

struct exynos_pmu_data {
	const struct exynos_pmu_conf *pmu_config;
	void (*pmu_init)();
	void (*powerdown_conf)(enum sys_powerdown);
	void (*powerdown_conf_extra)(enum sys_powerdown);
};

struct exynos_pmu_context {
	struct device *dev;
	const struct exynos_pmu_data *pmu_data;
};

struct exynos_pm_domain_config {
	u32 local_pwr_cfg;
};

struct exynos_pm_domain {
	void *base;
	bool is_off;
	struct generic_pm_domain pd;
	u32 local_pwr_cfg;
	int: 32;
};

struct regulator_coupler {
	struct list_head list;
	int (*attach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*detach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*balance_voltage)(struct regulator_coupler *, struct regulator_dev *, suspend_state_t);
};

struct sunxi_sram_func {
	char *func;
	u8 val;
	u32 reg_val;
};

struct sunxi_sram_data {
	char *name;
	u8 reg;
	u8 offset;
	u8 width;
	struct sunxi_sram_func *func;
	struct list_head list;
};

struct sunxi_sram_desc {
	struct sunxi_sram_data data;
	bool claimed;
};

struct sunxi_sramc_variant {
	bool has_emac_clock;
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	struct gpio_desc *wp_gpio;
	const struct nvmem_cell_info *cells;
	int ncells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct tegra_fuse;

struct tegra_fuse_info {
	u32 (*read)(struct tegra_fuse *, unsigned int);
	unsigned int size;
	unsigned int spare;
};

struct nvmem_device;

struct tegra_fuse_soc;

struct tegra_fuse {
	struct device *dev;
	void *base;
	phys_addr_t phys;
	struct clk *clk;
	u32 (*read_early)(struct tegra_fuse *, unsigned int);
	u32 (*read)(struct tegra_fuse *, unsigned int);
	const struct tegra_fuse_soc *soc;
	struct {
		struct mutex lock;
		struct completion wait;
		struct dma_chan *chan;
		struct dma_slave_config config;
		dma_addr_t phys;
		u32 *virt;
	} apbdma;
	struct nvmem_device *nvmem;
	struct nvmem_cell_lookup *lookups;
};

struct tegra_fuse_soc {
	void (*init)(struct tegra_fuse *);
	void (*speedo_init)(struct tegra_sku_info *);
	int (*probe)(struct tegra_fuse *);
	const struct tegra_fuse_info *info;
	const struct nvmem_cell_lookup *lookups;
	unsigned int num_lookups;
	const struct attribute_group *soc_attr_group;
};

enum {
	SPEEDO_ID_0 = 0,
	SPEEDO_ID_1 = 1,
	SPEEDO_ID_2 = 2,
	SPEEDO_ID_COUNT = 3,
};

enum {
	THRESHOLD_INDEX_0 = 0,
	THRESHOLD_INDEX_1 = 1,
	THRESHOLD_INDEX_2 = 2,
	THRESHOLD_INDEX_3 = 3,
	THRESHOLD_INDEX_4 = 4,
	THRESHOLD_INDEX_5 = 5,
	THRESHOLD_INDEX_6 = 6,
	THRESHOLD_INDEX_7 = 7,
	THRESHOLD_INDEX_8 = 8,
	THRESHOLD_INDEX_9 = 9,
	THRESHOLD_INDEX_10 = 10,
	THRESHOLD_INDEX_11 = 11,
	THRESHOLD_INDEX_COUNT = 12,
};

enum {
	THRESHOLD_INDEX_0___2 = 0,
	THRESHOLD_INDEX_1___2 = 1,
	THRESHOLD_INDEX_COUNT___2 = 2,
};

enum tegra_io_pad {
	TEGRA_IO_PAD_AUDIO = 0,
	TEGRA_IO_PAD_AUDIO_HV = 1,
	TEGRA_IO_PAD_BB = 2,
	TEGRA_IO_PAD_CAM = 3,
	TEGRA_IO_PAD_COMP = 4,
	TEGRA_IO_PAD_CONN = 5,
	TEGRA_IO_PAD_CSIA = 6,
	TEGRA_IO_PAD_CSIB = 7,
	TEGRA_IO_PAD_CSIC = 8,
	TEGRA_IO_PAD_CSID = 9,
	TEGRA_IO_PAD_CSIE = 10,
	TEGRA_IO_PAD_CSIF = 11,
	TEGRA_IO_PAD_CSIG = 12,
	TEGRA_IO_PAD_CSIH = 13,
	TEGRA_IO_PAD_DAP3 = 14,
	TEGRA_IO_PAD_DAP5 = 15,
	TEGRA_IO_PAD_DBG = 16,
	TEGRA_IO_PAD_DEBUG_NONAO = 17,
	TEGRA_IO_PAD_DMIC = 18,
	TEGRA_IO_PAD_DMIC_HV = 19,
	TEGRA_IO_PAD_DP = 20,
	TEGRA_IO_PAD_DSI = 21,
	TEGRA_IO_PAD_DSIB = 22,
	TEGRA_IO_PAD_DSIC = 23,
	TEGRA_IO_PAD_DSID = 24,
	TEGRA_IO_PAD_EDP = 25,
	TEGRA_IO_PAD_EMMC = 26,
	TEGRA_IO_PAD_EMMC2 = 27,
	TEGRA_IO_PAD_EQOS = 28,
	TEGRA_IO_PAD_GPIO = 29,
	TEGRA_IO_PAD_GP_PWM2 = 30,
	TEGRA_IO_PAD_GP_PWM3 = 31,
	TEGRA_IO_PAD_HDMI = 32,
	TEGRA_IO_PAD_HDMI_DP0 = 33,
	TEGRA_IO_PAD_HDMI_DP1 = 34,
	TEGRA_IO_PAD_HDMI_DP2 = 35,
	TEGRA_IO_PAD_HDMI_DP3 = 36,
	TEGRA_IO_PAD_HSIC = 37,
	TEGRA_IO_PAD_HV = 38,
	TEGRA_IO_PAD_LVDS = 39,
	TEGRA_IO_PAD_MIPI_BIAS = 40,
	TEGRA_IO_PAD_NAND = 41,
	TEGRA_IO_PAD_PEX_BIAS = 42,
	TEGRA_IO_PAD_PEX_CLK_BIAS = 43,
	TEGRA_IO_PAD_PEX_CLK1 = 44,
	TEGRA_IO_PAD_PEX_CLK2 = 45,
	TEGRA_IO_PAD_PEX_CLK3 = 46,
	TEGRA_IO_PAD_PEX_CLK_2_BIAS = 47,
	TEGRA_IO_PAD_PEX_CLK_2 = 48,
	TEGRA_IO_PAD_PEX_CNTRL = 49,
	TEGRA_IO_PAD_PEX_CTL2 = 50,
	TEGRA_IO_PAD_PEX_L0_RST_N = 51,
	TEGRA_IO_PAD_PEX_L1_RST_N = 52,
	TEGRA_IO_PAD_PEX_L5_RST_N = 53,
	TEGRA_IO_PAD_PWR_CTL = 54,
	TEGRA_IO_PAD_SDMMC1 = 55,
	TEGRA_IO_PAD_SDMMC1_HV = 56,
	TEGRA_IO_PAD_SDMMC2 = 57,
	TEGRA_IO_PAD_SDMMC2_HV = 58,
	TEGRA_IO_PAD_SDMMC3 = 59,
	TEGRA_IO_PAD_SDMMC3_HV = 60,
	TEGRA_IO_PAD_SDMMC4 = 61,
	TEGRA_IO_PAD_SOC_GPIO10 = 62,
	TEGRA_IO_PAD_SOC_GPIO12 = 63,
	TEGRA_IO_PAD_SOC_GPIO13 = 64,
	TEGRA_IO_PAD_SOC_GPIO53 = 65,
	TEGRA_IO_PAD_SPI = 66,
	TEGRA_IO_PAD_SPI_HV = 67,
	TEGRA_IO_PAD_SYS_DDC = 68,
	TEGRA_IO_PAD_UART = 69,
	TEGRA_IO_PAD_UART4 = 70,
	TEGRA_IO_PAD_UART5 = 71,
	TEGRA_IO_PAD_UFS = 72,
	TEGRA_IO_PAD_USB0 = 73,
	TEGRA_IO_PAD_USB1 = 74,
	TEGRA_IO_PAD_USB2 = 75,
	TEGRA_IO_PAD_USB3 = 76,
	TEGRA_IO_PAD_USB_BIAS = 77,
	TEGRA_IO_PAD_AO_HV = 78,
};

struct pmc_clk {
	struct clk_hw hw;
	long unsigned int offs;
	u32 mux_shift;
	u32 force_en_shift;
};

struct pmc_clk_gate {
	struct clk_hw hw;
	long unsigned int offs;
	u32 shift;
};

struct pmc_clk_init_data {
	char *name;
	const char * const *parents;
	int num_parents;
	int clk_id;
	u8 mux_shift;
	u8 force_en_shift;
};

struct tegra_pmc;

struct tegra_powergate {
	struct generic_pm_domain genpd;
	struct tegra_pmc *pmc;
	unsigned int id;
	struct clk **clks;
	unsigned int num_clks;
	struct reset_control *reset;
	int: 32;
};

struct tegra_pmc_soc;

struct tegra_pmc {
	struct device *dev;
	void *base;
	void *wake;
	void *aotag;
	void *scratch;
	struct clk *clk;
	struct dentry *debugfs;
	const struct tegra_pmc_soc *soc;
	bool tz_only;
	long unsigned int rate;
	enum tegra_suspend_mode suspend_mode;
	u32 cpu_good_time;
	u32 cpu_off_time;
	u32 core_osc_time;
	u32 core_pmu_time;
	u32 core_off_time;
	bool corereq_high;
	bool sysclkreq_high;
	bool combined_req;
	bool cpu_pwr_good_en;
	u32 lp0_vec_phys;
	u32 lp0_vec_size;
	long unsigned int powergates_available[1];
	struct mutex powergates_lock;
	struct pinctrl_dev *pctl_dev;
	struct irq_domain *domain;
	struct irq_chip irq;
	struct notifier_block clk_nb;
};

struct tegra_io_pad_soc {
	enum tegra_io_pad id;
	unsigned int dpd;
	unsigned int voltage;
	const char *name;
};

struct tegra_pmc_regs {
	unsigned int scratch0;
	unsigned int dpd_req;
	unsigned int dpd_status;
	unsigned int dpd2_req;
	unsigned int dpd2_status;
	unsigned int rst_status;
	unsigned int rst_source_shift;
	unsigned int rst_source_mask;
	unsigned int rst_level_shift;
	unsigned int rst_level_mask;
};

struct tegra_wake_event {
	const char *name;
	unsigned int id;
	unsigned int irq;
	struct {
		unsigned int instance;
		unsigned int pin;
	} gpio;
};

struct tegra_pmc_soc {
	unsigned int num_powergates;
	const char * const *powergates;
	unsigned int num_cpu_powergates;
	const u8 *cpu_powergates;
	bool has_tsense_reset;
	bool has_gpu_clamps;
	bool needs_mbist_war;
	bool has_impl_33v_pwr;
	bool maybe_tz_only;
	const struct tegra_io_pad_soc *io_pads;
	unsigned int num_io_pads;
	const struct pinctrl_pin_desc *pin_descs;
	unsigned int num_pin_descs;
	const struct tegra_pmc_regs *regs;
	void (*init)(struct tegra_pmc *);
	void (*setup_irq_polarity)(struct tegra_pmc *, struct device_node *, bool);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	const char * const *reset_sources;
	unsigned int num_reset_sources;
	const char * const *reset_levels;
	unsigned int num_reset_levels;
	const struct tegra_wake_event *wake_events;
	unsigned int num_wake_events;
	const struct pmc_clk_init_data *pmc_clks_data;
	unsigned int num_pmc_clks;
	bool has_blink_output;
};

struct tegra_regulator_coupler {
	struct regulator_coupler coupler;
	struct regulator_dev *core_rdev;
	struct regulator_dev *cpu_rdev;
	struct regulator_dev *rtc_rdev;
	int core_min_uV;
};

struct tegra_regulator_coupler___2 {
	struct regulator_coupler coupler;
	struct regulator_dev *core_rdev;
	struct regulator_dev *cpu_rdev;
	int core_min_uV;
};

struct gpd_timing_data {
	s64 suspend_latency_ns;
	s64 resume_latency_ns;
	s64 effective_constraint_ns;
	bool constraint_changed;
	bool cached_suspend_ok;
	int: 16;
	int: 32;
};

struct generic_pm_domain_data {
	struct pm_domain_data base;
	int: 32;
	struct gpd_timing_data td;
	struct notifier_block nb;
	struct notifier_block *power_nb;
	int cpu;
	unsigned int performance_state;
	void *data;
	int: 32;
};

enum omap_prm_domain_mode {
	OMAP_PRMD_OFF = 0,
	OMAP_PRMD_RETENTION = 1,
	OMAP_PRMD_ON_INACTIVE = 2,
	OMAP_PRMD_ON_ACTIVE = 3,
};

struct omap_prm_domain_map {
	unsigned int usable_modes;
	long unsigned int statechange: 1;
	long unsigned int logicretstate: 1;
};

struct omap_prm;

struct omap_prm_domain {
	struct device *dev;
	struct omap_prm *prm;
	struct generic_pm_domain pd;
	u16 pwrstctrl;
	u16 pwrstst;
	const struct omap_prm_domain_map *cap;
	u32 pwrstctrl_saved;
	unsigned int uses_pm_clk: 1;
};

struct omap_prm_data;

struct omap_prm {
	const struct omap_prm_data *data;
	void *base;
	struct omap_prm_domain *prmd;
};

struct omap_rst_map {
	s8 rst;
	s8 st;
};

struct omap_prm_data {
	u32 base;
	const char *name;
	const char *clkdm_name;
	u16 pwrstctrl;
	u16 pwrstst;
	const struct omap_prm_domain_map *dmap;
	u16 rstctrl;
	u16 rstst;
	const struct omap_rst_map *rstmap;
	u8 flags;
};

struct omap_reset_data {
	struct reset_controller_dev rcdev;
	struct omap_prm *prm;
	u32 mask;
	spinlock_t lock;
	struct clockdomain *clkdm;
	struct device *dev;
};

struct dbx500_asic_id {
	u16 partnumber;
	u8 revision;
	u8 process;
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

typedef struct vring_desc vring_desc_t;

typedef struct vring_avail vring_avail_t;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 next;
	u16 last;
};

struct vring_desc_extra_packed {
	dma_addr_t addr;
	u32 len;
	u16 flags;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	union {
		struct {
			struct vring vring;
			u16 avail_flags_shadow;
			u16 avail_idx_shadow;
			struct vring_desc_state_split *desc_state;
			dma_addr_t queue_dma_addr;
			size_t queue_size_in_bytes;
		} split;
		struct {
			struct {
				unsigned int num;
				struct vring_packed_desc *desc;
				struct vring_packed_desc_event *driver;
				struct vring_packed_desc_event *device;
			} vring;
			bool avail_wrap_counter;
			bool used_wrap_counter;
			u16 avail_used_flags;
			u16 next_avail_idx;
			u16 event_flags_shadow;
			struct vring_desc_state_packed *desc_state;
			struct vring_desc_extra_packed *desc_extra;
			dma_addr_t ring_dma_addr;
			dma_addr_t driver_event_dma_addr;
			dma_addr_t device_event_dma_addr;
			size_t ring_size_in_bytes;
			size_t event_size_in_bytes;
		} packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct virtio_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct virtio_pci_common_cfg {
	__le32 device_feature_select;
	__le32 device_feature;
	__le32 guest_feature_select;
	__le32 guest_feature;
	__le16 msix_config;
	__le16 num_queues;
	__u8 device_status;
	__u8 config_generation;
	__le16 queue_select;
	__le16 queue_size;
	__le16 queue_msix_vector;
	__le16 queue_enable;
	__le16 queue_notify_off;
	__le32 queue_desc_lo;
	__le32 queue_desc_hi;
	__le32 queue_avail_lo;
	__le32 queue_avail_hi;
	__le32 queue_used_lo;
	__le32 queue_used_hi;
};

struct virtio_pci_vq_info {
	struct virtqueue *vq;
	struct list_head node;
	unsigned int msix_vector;
};

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
	u8 *isr;
	struct virtio_pci_common_cfg *common;
	void *device;
	void *notify_base;
	size_t notify_len;
	size_t device_len;
	int notify_map_cap;
	u32 notify_offset_multiplier;
	int modern_bars;
	void *ioaddr;
	spinlock_t lock;
	struct list_head virtqueues;
	struct virtio_pci_vq_info **vqs;
	int msix_enabled;
	int intx_enabled;
	cpumask_var_t *msix_affinity_masks;
	char (*msix_names)[256];
	unsigned int msix_vectors;
	unsigned int msix_used_vectors;
	bool per_vq_vectors;
	struct virtqueue * (*setup_vq)(struct virtio_pci_device *, struct virtio_pci_vq_info *, unsigned int, void (*)(struct virtqueue *), const char *, bool, u16);
	void (*del_vq)(struct virtio_pci_vq_info *);
	u16 (*config_vector)(struct virtio_pci_device *, u16);
	int: 32;
};

enum {
	VP_MSIX_CONFIG_VECTOR = 0,
	VP_MSIX_VQ_VECTOR = 1,
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct regulator_voltage {
	int min_uV;
	int max_uV;
};

struct regulator {
	struct device *dev;
	struct list_head list;
	unsigned int always_on: 1;
	unsigned int bypass: 1;
	unsigned int device_link: 1;
	int uA_load;
	unsigned int enable_count;
	unsigned int deferred_disables;
	struct regulator_voltage voltage[5];
	const char *supply_name;
	struct device_attribute dev_attr;
	struct regulator_dev *rdev;
	struct dentry *debugfs;
};

enum regulator_status {
	REGULATOR_STATUS_OFF = 0,
	REGULATOR_STATUS_ON = 1,
	REGULATOR_STATUS_ERROR = 2,
	REGULATOR_STATUS_FAST = 3,
	REGULATOR_STATUS_NORMAL = 4,
	REGULATOR_STATUS_IDLE = 5,
	REGULATOR_STATUS_STANDBY = 6,
	REGULATOR_STATUS_BYPASS = 7,
	REGULATOR_STATUS_UNDEFINED = 8,
};

struct regulator_enable_gpio {
	struct list_head list;
	struct gpio_desc *gpiod;
	u32 enable_count;
	u32 request_count;
};

enum regulator_active_discharge {
	REGULATOR_ACTIVE_DISCHARGE_DEFAULT = 0,
	REGULATOR_ACTIVE_DISCHARGE_DISABLE = 1,
	REGULATOR_ACTIVE_DISCHARGE_ENABLE = 2,
};

struct trace_event_raw_regulator_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regulator_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	int min;
	int max;
	char __data[0];
};

struct trace_event_raw_regulator_value {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int val;
	char __data[0];
};

struct trace_event_data_offsets_regulator_basic {
	u32 name;
};

struct trace_event_data_offsets_regulator_range {
	u32 name;
};

struct trace_event_data_offsets_regulator_value {
	u32 name;
};

typedef void (*btf_trace_regulator_enable)(void *, const char *);

typedef void (*btf_trace_regulator_enable_delay)(void *, const char *);

typedef void (*btf_trace_regulator_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_disable)(void *, const char *);

typedef void (*btf_trace_regulator_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_set_voltage)(void *, const char *, int, int);

typedef void (*btf_trace_regulator_set_voltage_complete)(void *, const char *, unsigned int);

enum regulator_get_type {
	NORMAL_GET = 0,
	EXCLUSIVE_GET = 1,
	OPTIONAL_GET = 2,
	MAX_GET_TYPE = 3,
};

struct regulator_map {
	struct list_head list;
	const char *dev_name;
	const char *supply;
	struct regulator_dev *regulator;
};

struct regulator_supply_alias {
	struct list_head list;
	struct device *src_dev;
	const char *src_supply;
	struct device *alias_dev;
	const char *alias_supply;
};

struct summary_data {
	struct seq_file *s;
	struct regulator_dev *parent;
	int level;
};

struct summary_lock_data {
	struct ww_acquire_ctx *ww_ctx;
	struct regulator_dev **new_contended_rdev;
	struct regulator_dev **old_contended_rdev;
};

struct fixed_voltage_config {
	const char *supply_name;
	const char *input_supply;
	int microvolts;
	unsigned int startup_delay;
	unsigned int off_on_delay;
	unsigned int enabled_at_boot: 1;
	struct regulator_init_data *init_data;
};

struct fixed_regulator_data {
	struct fixed_voltage_config cfg;
	struct regulator_init_data init_data;
	struct platform_device pdev;
};

struct regulator_bulk_devres {
	struct regulator_bulk_data *consumers;
	int num_consumers;
};

struct regulator_supply_alias_match {
	struct device *dev;
	const char *id;
};

struct regulator_notifier_match {
	struct regulator *regulator;
	struct notifier_block *nb;
};

struct of_regulator_match {
	const char *name;
	void *driver_data;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
	const struct regulator_desc *desc;
};

struct devm_of_regulator_matches {
	struct of_regulator_match *matches;
	unsigned int num_matches;
};

struct fixed_voltage_data {
	struct regulator_desc desc;
	struct regulator_dev *dev;
	struct clk *enable_clock;
	unsigned int enable_counter;
	int performance_state;
};

struct fixed_dev_type {
	bool has_enable_clock;
	bool has_performance_state;
};

struct cpcap_regulator {
	struct regulator_desc rdesc;
	const u16 assign_reg;
	const u16 assign_mask;
};

struct cpcap_ddata {
	struct regmap *reg;
	struct device *dev;
	const struct cpcap_regulator *soc;
};

enum cpcap_regulator_id {
	CPCAP_SW1 = 0,
	CPCAP_SW2 = 1,
	CPCAP_SW3 = 2,
	CPCAP_SW4 = 3,
	CPCAP_SW5 = 4,
	CPCAP_SW6 = 5,
	CPCAP_VCAM = 6,
	CPCAP_VCSI = 7,
	CPCAP_VDAC = 8,
	CPCAP_VDIG = 9,
	CPCAP_VFUSE = 10,
	CPCAP_VHVIO = 11,
	CPCAP_VSDIO = 12,
	CPCAP_VPLL = 13,
	CPCAP_VRF1 = 14,
	CPCAP_VRF2 = 15,
	CPCAP_VRFREF = 16,
	CPCAP_VWLAN1 = 17,
	CPCAP_VWLAN2 = 18,
	CPCAP_VSIM = 19,
	CPCAP_VSIMCARD = 20,
	CPCAP_VVIB = 21,
	CPCAP_VUSB = 22,
	CPCAP_VAUDIO = 23,
	CPCAP_NR_REGULATORS = 24,
};

struct ab8500_regulator_reg_init;

struct ab8500_regulator_platform_data {
	int num_reg_init;
	struct ab8500_regulator_reg_init *reg_init;
	int num_regulator;
	struct regulator_init_data *regulator;
	int num_ext_regulator;
	struct regulator_init_data *ext_regulator;
};

enum ab8500_regulator_id {
	AB8500_LDO_AUX1 = 0,
	AB8500_LDO_AUX2 = 1,
	AB8500_LDO_AUX3 = 2,
	AB8500_LDO_INTCORE = 3,
	AB8500_LDO_TVOUT = 4,
	AB8500_LDO_AUDIO = 5,
	AB8500_LDO_ANAMIC1 = 6,
	AB8500_LDO_ANAMIC2 = 7,
	AB8500_LDO_DMIC = 8,
	AB8500_LDO_ANA = 9,
	AB8500_NUM_REGULATORS = 10,
};

struct ab8500_regulator_reg_init {
	int id;
	u8 mask;
	u8 value;
};

enum ab8500_regulator_reg {
	AB8500_REGUREQUESTCTRL2 = 0,
	AB8500_REGUREQUESTCTRL3 = 1,
	AB8500_REGUREQUESTCTRL4 = 2,
	AB8500_REGUSYSCLKREQ1HPVALID1 = 3,
	AB8500_REGUSYSCLKREQ1HPVALID2 = 4,
	AB8500_REGUHWHPREQ1VALID1 = 5,
	AB8500_REGUHWHPREQ1VALID2 = 6,
	AB8500_REGUHWHPREQ2VALID1 = 7,
	AB8500_REGUHWHPREQ2VALID2 = 8,
	AB8500_REGUSWHPREQVALID1 = 9,
	AB8500_REGUSWHPREQVALID2 = 10,
	AB8500_REGUSYSCLKREQVALID1 = 11,
	AB8500_REGUSYSCLKREQVALID2 = 12,
	AB8500_REGUMISC1 = 13,
	AB8500_VAUDIOSUPPLY = 14,
	AB8500_REGUCTRL1VAMIC = 15,
	AB8500_VPLLVANAREGU = 16,
	AB8500_VREFDDR = 17,
	AB8500_EXTSUPPLYREGU = 18,
	AB8500_VAUX12REGU = 19,
	AB8500_VRF1VAUX3REGU = 20,
	AB8500_VAUX1SEL = 21,
	AB8500_VAUX2SEL = 22,
	AB8500_VRF1VAUX3SEL = 23,
	AB8500_REGUCTRL2SPARE = 24,
	AB8500_REGUCTRLDISCH = 25,
	AB8500_REGUCTRLDISCH2 = 26,
	AB8500_NUM_REGULATOR_REGISTERS = 27,
};

struct ab8500_ext_regulator_cfg {
	bool hwreq;
};

enum ab8500_ext_regulator_id {
	AB8500_EXT_SUPPLY1 = 0,
	AB8500_EXT_SUPPLY2 = 1,
	AB8500_EXT_SUPPLY3 = 2,
	AB8500_NUM_EXT_REGULATORS = 3,
};

struct ab8500_ext_regulator_info {
	struct device *dev;
	struct regulator_desc desc;
	struct ab8500_ext_regulator_cfg *cfg;
	u8 update_bank;
	u8 update_reg;
	u8 update_mask;
	u8 update_val;
	u8 update_val_hp;
	u8 update_val_lp;
	u8 update_val_hw;
};

enum ab8505_regulator_id {
	AB8505_LDO_AUX1 = 0,
	AB8505_LDO_AUX2 = 1,
	AB8505_LDO_AUX3 = 2,
	AB8505_LDO_AUX4 = 3,
	AB8505_LDO_AUX5 = 4,
	AB8505_LDO_AUX6 = 5,
	AB8505_LDO_INTCORE = 6,
	AB8505_LDO_ADC = 7,
	AB8505_LDO_AUDIO = 8,
	AB8505_LDO_ANAMIC1 = 9,
	AB8505_LDO_ANAMIC2 = 10,
	AB8505_LDO_AUX8 = 11,
	AB8505_LDO_ANA = 12,
	AB8505_NUM_REGULATORS = 13,
};

enum ab8505_regulator_reg {
	AB8505_REGUREQUESTCTRL1 = 0,
	AB8505_REGUREQUESTCTRL2 = 1,
	AB8505_REGUREQUESTCTRL3 = 2,
	AB8505_REGUREQUESTCTRL4 = 3,
	AB8505_REGUSYSCLKREQ1HPVALID1 = 4,
	AB8505_REGUSYSCLKREQ1HPVALID2 = 5,
	AB8505_REGUHWHPREQ1VALID1 = 6,
	AB8505_REGUHWHPREQ1VALID2 = 7,
	AB8505_REGUHWHPREQ2VALID1 = 8,
	AB8505_REGUHWHPREQ2VALID2 = 9,
	AB8505_REGUSWHPREQVALID1 = 10,
	AB8505_REGUSWHPREQVALID2 = 11,
	AB8505_REGUSYSCLKREQVALID1 = 12,
	AB8505_REGUSYSCLKREQVALID2 = 13,
	AB8505_REGUVAUX4REQVALID = 14,
	AB8505_REGUMISC1 = 15,
	AB8505_VAUDIOSUPPLY = 16,
	AB8505_REGUCTRL1VAMIC = 17,
	AB8505_VSMPSAREGU = 18,
	AB8505_VSMPSBREGU = 19,
	AB8505_VSAFEREGU = 20,
	AB8505_VPLLVANAREGU = 21,
	AB8505_EXTSUPPLYREGU = 22,
	AB8505_VAUX12REGU = 23,
	AB8505_VRF1VAUX3REGU = 24,
	AB8505_VSMPSASEL1 = 25,
	AB8505_VSMPSASEL2 = 26,
	AB8505_VSMPSASEL3 = 27,
	AB8505_VSMPSBSEL1 = 28,
	AB8505_VSMPSBSEL2 = 29,
	AB8505_VSMPSBSEL3 = 30,
	AB8505_VSAFESEL1 = 31,
	AB8505_VSAFESEL2 = 32,
	AB8505_VSAFESEL3 = 33,
	AB8505_VAUX1SEL = 34,
	AB8505_VAUX2SEL = 35,
	AB8505_VRF1VAUX3SEL = 36,
	AB8505_VAUX4REQCTRL = 37,
	AB8505_VAUX4REGU = 38,
	AB8505_VAUX4SEL = 39,
	AB8505_REGUCTRLDISCH = 40,
	AB8505_REGUCTRLDISCH2 = 41,
	AB8505_REGUCTRLDISCH3 = 42,
	AB8505_CTRLVAUX5 = 43,
	AB8505_CTRLVAUX6 = 44,
	AB8505_NUM_REGULATOR_REGISTERS = 45,
};

struct ab8500_regulator_info;

struct ab8500_shared_mode {
	struct ab8500_regulator_info *shared_regulator;
	bool lp_mode_req;
};

struct ab8500_regulator_info {
	struct device *dev;
	struct regulator_desc desc;
	struct ab8500_shared_mode *shared_mode;
	int load_lp_uA;
	u8 update_bank;
	u8 update_reg;
	u8 update_mask;
	u8 update_val;
	u8 update_val_idle;
	u8 update_val_normal;
	u8 mode_bank;
	u8 mode_reg;
	u8 mode_mask;
	u8 mode_val_idle;
	u8 mode_val_normal;
	u8 voltage_bank;
	u8 voltage_reg;
	u8 voltage_mask;
};

struct ab8500_reg_init {
	u8 bank;
	u8 addr;
	u8 mask;
};

enum {
	ACT8600_ID_DCDC1 = 0,
	ACT8600_ID_DCDC2 = 1,
	ACT8600_ID_DCDC3 = 2,
	ACT8600_ID_SUDCDC4 = 3,
	ACT8600_ID_LDO5 = 4,
	ACT8600_ID_LDO6 = 5,
	ACT8600_ID_LDO7 = 6,
	ACT8600_ID_LDO8 = 7,
	ACT8600_ID_LDO9 = 8,
	ACT8600_ID_LDO10 = 9,
};

enum {
	ACT8865_ID_DCDC1 = 0,
	ACT8865_ID_DCDC2 = 1,
	ACT8865_ID_DCDC3 = 2,
	ACT8865_ID_LDO1 = 3,
	ACT8865_ID_LDO2 = 4,
	ACT8865_ID_LDO3 = 5,
	ACT8865_ID_LDO4 = 6,
	ACT8865_REG_NUM = 7,
};

enum {
	ACT8846_ID_REG1 = 0,
	ACT8846_ID_REG2 = 1,
	ACT8846_ID_REG3 = 2,
	ACT8846_ID_REG4 = 3,
	ACT8846_ID_REG5 = 4,
	ACT8846_ID_REG6 = 5,
	ACT8846_ID_REG7 = 6,
	ACT8846_ID_REG8 = 7,
	ACT8846_ID_REG9 = 8,
	ACT8846_ID_REG10 = 9,
	ACT8846_ID_REG11 = 10,
	ACT8846_ID_REG12 = 11,
	ACT8846_REG_NUM = 12,
};

enum {
	ACT8600 = 0,
	ACT8865 = 1,
	ACT8846 = 2,
};

struct act8865_regulator_data {
	int id;
	const char *name;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
};

struct act8865_platform_data {
	int num_regulators;
	struct act8865_regulator_data *regulators;
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct act8865 {
	struct regmap *regmap;
	int off_reg;
	int off_mask;
};

enum {
	ACT8945A_ID_DCDC1 = 0,
	ACT8945A_ID_DCDC2 = 1,
	ACT8945A_ID_DCDC3 = 2,
	ACT8945A_ID_LDO1 = 3,
	ACT8945A_ID_LDO2 = 4,
	ACT8945A_ID_LDO3 = 5,
	ACT8945A_ID_LDO4 = 6,
	ACT8945A_ID_MAX = 7,
};

struct act8945a_pmic {
	struct regmap *regmap;
	u32 op_mode[7];
};

struct anatop_regulator {
	u32 delay_reg;
	int delay_bit_shift;
	int delay_bit_width;
	struct regulator_desc rdesc;
	bool bypass;
	int sel;
};

struct as3711_regulator_pdata {
	struct regulator_init_data *init_data[12];
};

enum as3722_regulators_id {
	AS3722_REGULATOR_ID_SD0 = 0,
	AS3722_REGULATOR_ID_SD1 = 1,
	AS3722_REGULATOR_ID_SD2 = 2,
	AS3722_REGULATOR_ID_SD3 = 3,
	AS3722_REGULATOR_ID_SD4 = 4,
	AS3722_REGULATOR_ID_SD5 = 5,
	AS3722_REGULATOR_ID_SD6 = 6,
	AS3722_REGULATOR_ID_LDO0 = 7,
	AS3722_REGULATOR_ID_LDO1 = 8,
	AS3722_REGULATOR_ID_LDO2 = 9,
	AS3722_REGULATOR_ID_LDO3 = 10,
	AS3722_REGULATOR_ID_LDO4 = 11,
	AS3722_REGULATOR_ID_LDO5 = 12,
	AS3722_REGULATOR_ID_LDO6 = 13,
	AS3722_REGULATOR_ID_LDO7 = 14,
	AS3722_REGULATOR_ID_LDO9 = 15,
	AS3722_REGULATOR_ID_LDO10 = 16,
	AS3722_REGULATOR_ID_LDO11 = 17,
	AS3722_REGULATOR_ID_MAX = 18,
};

struct as3722_register_mapping {
	u8 regulator_id;
	const char *name;
	const char *sname;
	u8 vsel_reg;
	u8 vsel_mask;
	int n_voltages;
	u32 enable_reg;
	u8 enable_mask;
	u32 control_reg;
	u8 mode_mask;
	u32 sleep_ctrl_reg;
	u8 sleep_ctrl_mask;
};

struct as3722_regulator_config_data {
	struct regulator_init_data *reg_init;
	bool enable_tracking;
	int ext_control;
};

struct as3722_regulators {
	struct device *dev;
	struct as3722 *as3722;
	struct regulator_desc desc[18];
	struct as3722_regulator_config_data reg_config_data[18];
};

struct regmap_irq_type {
	unsigned int type_reg_offset;
	unsigned int type_reg_mask;
	unsigned int type_rising_val;
	unsigned int type_falling_val;
	unsigned int type_level_low_val;
	unsigned int type_level_high_val;
	unsigned int types_supported;
};

struct regmap_irq {
	unsigned int reg_offset;
	unsigned int mask;
	struct regmap_irq_type type;
};

struct regmap_irq_sub_irq_map {
	unsigned int num_regs;
	unsigned int *offset;
};

struct regmap_irq_chip {
	const char *name;
	unsigned int main_status;
	unsigned int num_main_status_bits;
	struct regmap_irq_sub_irq_map *sub_reg_offsets;
	int num_main_regs;
	unsigned int status_base;
	unsigned int mask_base;
	unsigned int unmask_base;
	unsigned int ack_base;
	unsigned int wake_base;
	unsigned int type_base;
	unsigned int irq_reg_stride;
	bool mask_writeonly: 1;
	bool init_ack_masked: 1;
	bool mask_invert: 1;
	bool use_ack: 1;
	bool ack_invert: 1;
	bool clear_ack: 1;
	bool wake_invert: 1;
	bool runtime_pm: 1;
	bool type_invert: 1;
	bool type_in_mask: 1;
	bool clear_on_unmask: 1;
	int num_regs;
	const struct regmap_irq *irqs;
	int num_irqs;
	int num_type_reg;
	unsigned int type_reg_stride;
	int (*handle_pre_irq)(void *);
	int (*handle_post_irq)(void *);
	void *irq_drv_data;
};

enum axp20x_variants {
	AXP152_ID = 0,
	AXP202_ID = 1,
	AXP209_ID = 2,
	AXP221_ID = 3,
	AXP223_ID = 4,
	AXP288_ID = 5,
	AXP803_ID = 6,
	AXP806_ID = 7,
	AXP809_ID = 8,
	AXP813_ID = 9,
	NR_AXP20X_VARIANTS = 10,
};

enum {
	AXP20X_LDO1 = 0,
	AXP20X_LDO2 = 1,
	AXP20X_LDO3 = 2,
	AXP20X_LDO4 = 3,
	AXP20X_LDO5 = 4,
	AXP20X_DCDC2 = 5,
	AXP20X_DCDC3 = 6,
	AXP20X_REG_ID_MAX = 7,
};

enum {
	AXP22X_DCDC1 = 0,
	AXP22X_DCDC2 = 1,
	AXP22X_DCDC3 = 2,
	AXP22X_DCDC4 = 3,
	AXP22X_DCDC5 = 4,
	AXP22X_DC1SW = 5,
	AXP22X_DC5LDO = 6,
	AXP22X_ALDO1 = 7,
	AXP22X_ALDO2 = 8,
	AXP22X_ALDO3 = 9,
	AXP22X_ELDO1 = 10,
	AXP22X_ELDO2 = 11,
	AXP22X_ELDO3 = 12,
	AXP22X_DLDO1 = 13,
	AXP22X_DLDO2 = 14,
	AXP22X_DLDO3 = 15,
	AXP22X_DLDO4 = 16,
	AXP22X_RTC_LDO = 17,
	AXP22X_LDO_IO0 = 18,
	AXP22X_LDO_IO1 = 19,
	AXP22X_REG_ID_MAX = 20,
};

enum {
	AXP806_DCDCA = 0,
	AXP806_DCDCB = 1,
	AXP806_DCDCC = 2,
	AXP806_DCDCD = 3,
	AXP806_DCDCE = 4,
	AXP806_ALDO1 = 5,
	AXP806_ALDO2 = 6,
	AXP806_ALDO3 = 7,
	AXP806_BLDO1 = 8,
	AXP806_BLDO2 = 9,
	AXP806_BLDO3 = 10,
	AXP806_BLDO4 = 11,
	AXP806_CLDO1 = 12,
	AXP806_CLDO2 = 13,
	AXP806_CLDO3 = 14,
	AXP806_SW = 15,
	AXP806_REG_ID_MAX = 16,
};

enum {
	AXP809_DCDC1 = 0,
	AXP809_DCDC2 = 1,
	AXP809_DCDC3 = 2,
	AXP809_DCDC4 = 3,
	AXP809_DCDC5 = 4,
	AXP809_DC1SW = 5,
	AXP809_DC5LDO = 6,
	AXP809_ALDO1 = 7,
	AXP809_ALDO2 = 8,
	AXP809_ALDO3 = 9,
	AXP809_ELDO1 = 10,
	AXP809_ELDO2 = 11,
	AXP809_ELDO3 = 12,
	AXP809_DLDO1 = 13,
	AXP809_DLDO2 = 14,
	AXP809_RTC_LDO = 15,
	AXP809_LDO_IO0 = 16,
	AXP809_LDO_IO1 = 17,
	AXP809_SW = 18,
	AXP809_REG_ID_MAX = 19,
};

enum {
	AXP803_DCDC1 = 0,
	AXP803_DCDC2 = 1,
	AXP803_DCDC3 = 2,
	AXP803_DCDC4 = 3,
	AXP803_DCDC5 = 4,
	AXP803_DCDC6 = 5,
	AXP803_DC1SW = 6,
	AXP803_ALDO1 = 7,
	AXP803_ALDO2 = 8,
	AXP803_ALDO3 = 9,
	AXP803_DLDO1 = 10,
	AXP803_DLDO2 = 11,
	AXP803_DLDO3 = 12,
	AXP803_DLDO4 = 13,
	AXP803_ELDO1 = 14,
	AXP803_ELDO2 = 15,
	AXP803_ELDO3 = 16,
	AXP803_FLDO1 = 17,
	AXP803_FLDO2 = 18,
	AXP803_RTC_LDO = 19,
	AXP803_LDO_IO0 = 20,
	AXP803_LDO_IO1 = 21,
	AXP803_REG_ID_MAX = 22,
};

enum {
	AXP813_DCDC1 = 0,
	AXP813_DCDC2 = 1,
	AXP813_DCDC3 = 2,
	AXP813_DCDC4 = 3,
	AXP813_DCDC5 = 4,
	AXP813_DCDC6 = 5,
	AXP813_DCDC7 = 6,
	AXP813_ALDO1 = 7,
	AXP813_ALDO2 = 8,
	AXP813_ALDO3 = 9,
	AXP813_DLDO1 = 10,
	AXP813_DLDO2 = 11,
	AXP813_DLDO3 = 12,
	AXP813_DLDO4 = 13,
	AXP813_ELDO1 = 14,
	AXP813_ELDO2 = 15,
	AXP813_ELDO3 = 16,
	AXP813_FLDO1 = 17,
	AXP813_FLDO2 = 18,
	AXP813_FLDO3 = 19,
	AXP813_RTC_LDO = 20,
	AXP813_LDO_IO0 = 21,
	AXP813_LDO_IO1 = 22,
	AXP813_SW = 23,
	AXP813_REG_ID_MAX = 24,
};

struct axp20x_dev {
	struct device *dev;
	int irq;
	long unsigned int irq_flags;
	struct regmap *regmap;
	struct regmap_irq_chip_data *regmap_irqc;
	long int variant;
	int nr_cells;
	const struct mfd_cell *cells;
	const struct regmap_config *regmap_cfg;
	const struct regmap_irq_chip *regmap_irq_chip;
};

struct bcm590xx {
	struct device *dev;
	struct i2c_client *i2c_pri;
	struct i2c_client *i2c_sec;
	struct regmap *regmap_pri;
	struct regmap *regmap_sec;
	unsigned int id;
};

struct bcm590xx_info {
	const char *name;
	const char *vin_name;
	u8 n_voltages;
	const unsigned int *volt_table;
	u8 n_linear_ranges;
	const struct linear_range *linear_ranges;
};

struct bcm590xx_reg {
	struct regulator_desc *desc;
	struct bcm590xx *mfd;
};

struct da9210_pdata {
	struct regulator_init_data da9210_constraints;
};

struct da9210 {
	struct regulator_dev *rdev;
	struct regmap *regmap;
};

enum db8500_regulator_id {
	DB8500_REGULATOR_VAPE = 0,
	DB8500_REGULATOR_VARM = 1,
	DB8500_REGULATOR_VMODEM = 2,
	DB8500_REGULATOR_VPLL = 3,
	DB8500_REGULATOR_VSMPS1 = 4,
	DB8500_REGULATOR_VSMPS2 = 5,
	DB8500_REGULATOR_VSMPS3 = 6,
	DB8500_REGULATOR_VRF1 = 7,
	DB8500_REGULATOR_SWITCH_SVAMMDSP = 8,
	DB8500_REGULATOR_SWITCH_SVAMMDSPRET = 9,
	DB8500_REGULATOR_SWITCH_SVAPIPE = 10,
	DB8500_REGULATOR_SWITCH_SIAMMDSP = 11,
	DB8500_REGULATOR_SWITCH_SIAMMDSPRET = 12,
	DB8500_REGULATOR_SWITCH_SIAPIPE = 13,
	DB8500_REGULATOR_SWITCH_SGA = 14,
	DB8500_REGULATOR_SWITCH_B2R2_MCDE = 15,
	DB8500_REGULATOR_SWITCH_ESRAM12 = 16,
	DB8500_REGULATOR_SWITCH_ESRAM12RET = 17,
	DB8500_REGULATOR_SWITCH_ESRAM34 = 18,
	DB8500_REGULATOR_SWITCH_ESRAM34RET = 19,
	DB8500_NUM_REGULATORS = 20,
};

struct dbx500_regulator_info {
	struct regulator_desc desc;
	bool is_enabled;
	u16 epod_id;
	bool is_ramret;
	bool exclude_from_power_state;
};

enum {
	FAN53555_VSEL_ID_0 = 0,
	FAN53555_VSEL_ID_1 = 1,
};

struct fan53555_platform_data {
	struct regulator_init_data *regulator;
	unsigned int slew_rate;
	unsigned int sleep_vsel_id;
};

enum fan53555_vendor {
	FAN53526_VENDOR_FAIRCHILD = 0,
	FAN53555_VENDOR_FAIRCHILD = 1,
	FAN53555_VENDOR_SILERGY = 2,
};

enum {
	FAN53526_CHIP_ID_01 = 1,
};

enum {
	FAN53526_CHIP_REV_08 = 8,
};

enum {
	FAN53555_CHIP_ID_00 = 0,
	FAN53555_CHIP_ID_01 = 1,
	FAN53555_CHIP_ID_02 = 2,
	FAN53555_CHIP_ID_03 = 3,
	FAN53555_CHIP_ID_04 = 4,
	FAN53555_CHIP_ID_05 = 5,
	FAN53555_CHIP_ID_08 = 8,
};

enum {
	FAN53555_CHIP_REV_00 = 3,
	FAN53555_CHIP_REV_13 = 15,
};

enum {
	SILERGY_SYR82X = 8,
	SILERGY_SYR83X = 9,
};

struct fan53555_device_info {
	enum fan53555_vendor vendor;
	struct device *dev;
	struct regulator_desc desc;
	struct regulator_init_data *regulator;
	int chip_id;
	int chip_rev;
	unsigned int vol_reg;
	unsigned int sleep_reg;
	unsigned int vsel_min;
	unsigned int vsel_step;
	unsigned int vsel_count;
	unsigned int mode_reg;
	unsigned int mode_mask;
	unsigned int sleep_vol_cache;
};

struct gpio_regulator_state {
	int value;
	int gpios;
};

struct gpio_regulator_config {
	const char *supply_name;
	unsigned int enabled_at_boot: 1;
	unsigned int startup_delay;
	enum gpiod_flags *gflags;
	int ngpios;
	struct gpio_regulator_state *states;
	int nr_states;
	enum regulator_type type;
	struct regulator_init_data *init_data;
};

struct gpio_regulator_data {
	struct regulator_desc desc;
	struct gpio_desc **gpiods;
	int nr_gpios;
	struct gpio_regulator_state *states;
	int nr_states;
	int state;
};

enum lp872x_regulator_id {
	LP8720_ID_BASE = 0,
	LP8720_ID_LDO1 = 0,
	LP8720_ID_LDO2 = 1,
	LP8720_ID_LDO3 = 2,
	LP8720_ID_LDO4 = 3,
	LP8720_ID_LDO5 = 4,
	LP8720_ID_BUCK = 5,
	LP8725_ID_BASE = 6,
	LP8725_ID_LDO1 = 6,
	LP8725_ID_LDO2 = 7,
	LP8725_ID_LDO3 = 8,
	LP8725_ID_LDO4 = 9,
	LP8725_ID_LDO5 = 10,
	LP8725_ID_LILO1 = 11,
	LP8725_ID_LILO2 = 12,
	LP8725_ID_BUCK1 = 13,
	LP8725_ID_BUCK2 = 14,
	LP872X_ID_MAX = 15,
};

enum lp872x_dvs_state {
	DVS_LOW = 0,
	DVS_HIGH = 2,
};

enum lp872x_dvs_sel {
	SEL_V1 = 0,
	SEL_V2 = 1,
};

struct lp872x_dvs {
	int gpio;
	enum lp872x_dvs_sel vsel;
	enum lp872x_dvs_state init_state;
};

struct lp872x_regulator_data {
	enum lp872x_regulator_id id;
	struct regulator_init_data *init_data;
};

struct lp872x_platform_data {
	u8 general_config;
	bool update_config;
	struct lp872x_regulator_data regulator_data[9];
	struct lp872x_dvs *dvs;
	int enable_gpio;
};

enum lp872x_id {
	LP8720 = 0,
	LP8725 = 1,
};

struct lp872x {
	struct regmap *regmap;
	struct device *dev;
	enum lp872x_id chipid;
	struct lp872x_platform_data *pdata;
	int num_regulators;
	enum lp872x_dvs_state dvs_pin;
};

struct max8907_platform_data {
	struct regulator_init_data *init_data[29];
	bool pm_off;
};

struct max8907 {
	struct device *dev;
	struct mutex irq_lock;
	struct i2c_client *i2c_gen;
	struct i2c_client *i2c_rtc;
	struct regmap *regmap_gen;
	struct regmap *regmap_rtc;
	struct regmap_irq_chip_data *irqc_chg;
	struct regmap_irq_chip_data *irqc_on_off;
	struct regmap_irq_chip_data *irqc_rtc;
};

struct max8907_regulator {
	struct regulator_desc desc[29];
};

struct max8973_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	long unsigned int control_flags;
	long unsigned int junction_temp_warning;
	bool enable_ext_control;
	int enable_gpio;
	int dvs_gpio;
	unsigned int dvs_def_state: 1;
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
	THERMAL_TREND_RAISE_FULL = 3,
	THERMAL_TREND_DROP_FULL = 4,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	int (*notify)(struct thermal_zone_device *, int, enum thermal_trip_type);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_attr;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	int trips;
	long unsigned int trips_disabled;
	int passive_delay;
	int polling_delay;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	unsigned int forced_passive;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char type[20];
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

struct thermal_zone_of_device_ops {
	int (*get_temp)(void *, int *);
	int (*get_trend)(void *, int, enum thermal_trend *);
	int (*set_trips)(void *, int, int);
	int (*set_emul_temp)(void *, int);
	int (*set_trip_temp)(void *, int, int);
};

enum device_id {
	MAX8973 = 0,
	MAX77621 = 1,
};

struct max8973_chip {
	struct device *dev;
	struct regulator_desc desc;
	struct regmap *regmap;
	bool enable_external_control;
	int dvs_gpio;
	int lru_index[2];
	int curr_vout_val[2];
	int curr_vout_reg;
	int curr_gpio_val;
	struct regulator_ops ops;
	enum device_id id;
	int junction_temp_warning;
	int irq;
	struct thermal_zone_device *tz_device;
};

enum max77686_regulators {
	MAX77686_LDO1 = 0,
	MAX77686_LDO2 = 1,
	MAX77686_LDO3 = 2,
	MAX77686_LDO4 = 3,
	MAX77686_LDO5 = 4,
	MAX77686_LDO6 = 5,
	MAX77686_LDO7 = 6,
	MAX77686_LDO8 = 7,
	MAX77686_LDO9 = 8,
	MAX77686_LDO10 = 9,
	MAX77686_LDO11 = 10,
	MAX77686_LDO12 = 11,
	MAX77686_LDO13 = 12,
	MAX77686_LDO14 = 13,
	MAX77686_LDO15 = 14,
	MAX77686_LDO16 = 15,
	MAX77686_LDO17 = 16,
	MAX77686_LDO18 = 17,
	MAX77686_LDO19 = 18,
	MAX77686_LDO20 = 19,
	MAX77686_LDO21 = 20,
	MAX77686_LDO22 = 21,
	MAX77686_LDO23 = 22,
	MAX77686_LDO24 = 23,
	MAX77686_LDO25 = 24,
	MAX77686_LDO26 = 25,
	MAX77686_BUCK1 = 26,
	MAX77686_BUCK2 = 27,
	MAX77686_BUCK3 = 28,
	MAX77686_BUCK4 = 29,
	MAX77686_BUCK5 = 30,
	MAX77686_BUCK6 = 31,
	MAX77686_BUCK7 = 32,
	MAX77686_BUCK8 = 33,
	MAX77686_BUCK9 = 34,
	MAX77686_REG_MAX = 35,
};

struct max77686_dev {
	struct device *dev;
	struct i2c_client *i2c;
	long unsigned int type;
	struct regmap *regmap;
	struct regmap_irq_chip_data *irq_data;
	int irq;
	struct mutex irqlock;
	int irq_masks_cur[3];
	int irq_masks_cache[3];
};

enum max77686_ramp_rate {
	RAMP_RATE_13P75MV = 0,
	RAMP_RATE_27P5MV = 1,
	RAMP_RATE_55MV = 2,
	RAMP_RATE_NO_CTRL = 3,
};

struct max77686_data {
	struct device *dev;
	long unsigned int gpio_enabled[2];
	unsigned int opmode[35];
};

enum max77802_regulators {
	MAX77802_BUCK1 = 0,
	MAX77802_BUCK2 = 1,
	MAX77802_BUCK3 = 2,
	MAX77802_BUCK4 = 3,
	MAX77802_BUCK5 = 4,
	MAX77802_BUCK6 = 5,
	MAX77802_BUCK7 = 6,
	MAX77802_BUCK8 = 7,
	MAX77802_BUCK9 = 8,
	MAX77802_BUCK10 = 9,
	MAX77802_LDO1 = 10,
	MAX77802_LDO2 = 11,
	MAX77802_LDO3 = 12,
	MAX77802_LDO4 = 13,
	MAX77802_LDO5 = 14,
	MAX77802_LDO6 = 15,
	MAX77802_LDO7 = 16,
	MAX77802_LDO8 = 17,
	MAX77802_LDO9 = 18,
	MAX77802_LDO10 = 19,
	MAX77802_LDO11 = 20,
	MAX77802_LDO12 = 21,
	MAX77802_LDO13 = 22,
	MAX77802_LDO14 = 23,
	MAX77802_LDO15 = 24,
	MAX77802_LDO17 = 25,
	MAX77802_LDO18 = 26,
	MAX77802_LDO19 = 27,
	MAX77802_LDO20 = 28,
	MAX77802_LDO21 = 29,
	MAX77802_LDO23 = 30,
	MAX77802_LDO24 = 31,
	MAX77802_LDO25 = 32,
	MAX77802_LDO26 = 33,
	MAX77802_LDO27 = 34,
	MAX77802_LDO28 = 35,
	MAX77802_LDO29 = 36,
	MAX77802_LDO30 = 37,
	MAX77802_LDO32 = 38,
	MAX77802_LDO33 = 39,
	MAX77802_LDO34 = 40,
	MAX77802_LDO35 = 41,
	MAX77802_REG_MAX = 42,
};

struct max77802_regulator_prv {
	unsigned int opmode[42];
};

struct request_member {
	int word;
	unsigned int mask;
	int shift;
};

struct rpm_reg_parts {
	struct request_member mV;
	struct request_member uV;
	struct request_member ip;
	struct request_member pd;
	struct request_member ia;
	struct request_member fm;
	struct request_member pm;
	struct request_member pc;
	struct request_member pf;
	struct request_member enable_state;
	struct request_member comp_mode;
	struct request_member freq;
	struct request_member freq_clk_src;
	struct request_member hpm;
	int request_len;
};

struct qcom_rpm_reg {
	struct qcom_rpm *rpm;
	struct mutex lock;
	struct device *dev;
	struct regulator_desc desc;
	const struct rpm_reg_parts *parts;
	int resource;
	u32 val[2];
	int uV;
	int is_enabled;
	bool supports_force_mode_auto;
	bool supports_force_mode_bypass;
};

struct rpm_regulator_data {
	const char *name;
	int resource;
	const struct qcom_rpm_reg *template;
	const char *supply;
};

enum tps65917_regulators {
	TPS65917_REG_SMPS1 = 0,
	TPS65917_REG_SMPS2 = 1,
	TPS65917_REG_SMPS3 = 2,
	TPS65917_REG_SMPS4 = 3,
	TPS65917_REG_SMPS5 = 4,
	TPS65917_REG_SMPS12 = 5,
	TPS65917_REG_LDO1 = 6,
	TPS65917_REG_LDO2 = 7,
	TPS65917_REG_LDO3 = 8,
	TPS65917_REG_LDO4 = 9,
	TPS65917_REG_LDO5 = 10,
	TPS65917_REG_REGEN1 = 11,
	TPS65917_REG_REGEN2 = 12,
	TPS65917_REG_REGEN3 = 13,
	TPS65917_NUM_REGS = 14,
};

enum {
	PALMAS_EXT_CONTROL_ENABLE1 = 1,
	PALMAS_EXT_CONTROL_ENABLE2 = 2,
	PALMAS_EXT_CONTROL_NSLEEP = 4,
};

enum palmas_external_requestor_id {
	PALMAS_EXTERNAL_REQSTR_ID_REGEN1 = 0,
	PALMAS_EXTERNAL_REQSTR_ID_REGEN2 = 1,
	PALMAS_EXTERNAL_REQSTR_ID_SYSEN1 = 2,
	PALMAS_EXTERNAL_REQSTR_ID_SYSEN2 = 3,
	PALMAS_EXTERNAL_REQSTR_ID_CLK32KG = 4,
	PALMAS_EXTERNAL_REQSTR_ID_CLK32KGAUDIO = 5,
	PALMAS_EXTERNAL_REQSTR_ID_REGEN3 = 6,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS12 = 7,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS3 = 8,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS45 = 9,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS6 = 10,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS7 = 11,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS8 = 12,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS9 = 13,
	PALMAS_EXTERNAL_REQSTR_ID_SMPS10 = 14,
	PALMAS_EXTERNAL_REQSTR_ID_LDO1 = 15,
	PALMAS_EXTERNAL_REQSTR_ID_LDO2 = 16,
	PALMAS_EXTERNAL_REQSTR_ID_LDO3 = 17,
	PALMAS_EXTERNAL_REQSTR_ID_LDO4 = 18,
	PALMAS_EXTERNAL_REQSTR_ID_LDO5 = 19,
	PALMAS_EXTERNAL_REQSTR_ID_LDO6 = 20,
	PALMAS_EXTERNAL_REQSTR_ID_LDO7 = 21,
	PALMAS_EXTERNAL_REQSTR_ID_LDO8 = 22,
	PALMAS_EXTERNAL_REQSTR_ID_LDO9 = 23,
	PALMAS_EXTERNAL_REQSTR_ID_LDOLN = 24,
	PALMAS_EXTERNAL_REQSTR_ID_LDOUSB = 25,
	PALMAS_EXTERNAL_REQSTR_ID_MAX = 26,
};

enum tps65917_external_requestor_id {
	TPS65917_EXTERNAL_REQSTR_ID_REGEN1 = 0,
	TPS65917_EXTERNAL_REQSTR_ID_REGEN2 = 1,
	TPS65917_EXTERNAL_REQSTR_ID_REGEN3 = 2,
	TPS65917_EXTERNAL_REQSTR_ID_SMPS1 = 3,
	TPS65917_EXTERNAL_REQSTR_ID_SMPS2 = 4,
	TPS65917_EXTERNAL_REQSTR_ID_SMPS3 = 5,
	TPS65917_EXTERNAL_REQSTR_ID_SMPS4 = 6,
	TPS65917_EXTERNAL_REQSTR_ID_SMPS5 = 7,
	TPS65917_EXTERNAL_REQSTR_ID_SMPS12 = 8,
	TPS65917_EXTERNAL_REQSTR_ID_LDO1 = 9,
	TPS65917_EXTERNAL_REQSTR_ID_LDO2 = 10,
	TPS65917_EXTERNAL_REQSTR_ID_LDO3 = 11,
	TPS65917_EXTERNAL_REQSTR_ID_LDO4 = 12,
	TPS65917_EXTERNAL_REQSTR_ID_LDO5 = 13,
	TPS65917_EXTERNAL_REQSTR_ID_MAX = 14,
};

struct pwm_continuous_reg_data {
	unsigned int min_uV_dutycycle;
	unsigned int max_uV_dutycycle;
	unsigned int dutycycle_unit;
};

struct pwm_voltages;

struct pwm_regulator_data {
	struct pwm_device *pwm;
	struct pwm_voltages *duty_cycle_table;
	struct pwm_continuous_reg_data continuous;
	struct regulator_desc desc;
	int state;
	struct gpio_desc *enb_gpio;
};

struct pwm_voltages {
	unsigned int uV;
	unsigned int dutycycle;
};

struct tps51632_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	bool enable_pwm_dvfs;
	bool dvfs_step_20mV;
	int max_voltage_uV;
	int base_voltage_uV;
};

struct tps51632_chip {
	struct device *dev;
	struct regulator_desc desc;
	struct regulator_dev *rdev;
	struct regmap *regmap;
};

struct pbias_reg_info {
	u32 enable;
	u32 enable_mask;
	u32 disable_val;
	u32 vmode;
	unsigned int enable_time;
	char *name;
	const unsigned int *pbias_volt_table;
	int n_voltages;
};

struct pbias_of_data {
	unsigned int offset;
};

enum rk808_reg {
	RK808_ID_DCDC1 = 0,
	RK808_ID_DCDC2 = 1,
	RK808_ID_DCDC3 = 2,
	RK808_ID_DCDC4 = 3,
	RK808_ID_LDO1 = 4,
	RK808_ID_LDO2 = 5,
	RK808_ID_LDO3 = 6,
	RK808_ID_LDO4 = 7,
	RK808_ID_LDO5 = 8,
	RK808_ID_LDO6 = 9,
	RK808_ID_LDO7 = 10,
	RK808_ID_LDO8 = 11,
	RK808_ID_SWITCH1 = 12,
	RK808_ID_SWITCH2 = 13,
};

enum rk818_reg {
	RK818_ID_DCDC1 = 0,
	RK818_ID_DCDC2 = 1,
	RK818_ID_DCDC3 = 2,
	RK818_ID_DCDC4 = 3,
	RK818_ID_BOOST = 4,
	RK818_ID_LDO1 = 5,
	RK818_ID_LDO2 = 6,
	RK818_ID_LDO3 = 7,
	RK818_ID_LDO4 = 8,
	RK818_ID_LDO5 = 9,
	RK818_ID_LDO6 = 10,
	RK818_ID_LDO7 = 11,
	RK818_ID_LDO8 = 12,
	RK818_ID_LDO9 = 13,
	RK818_ID_SWITCH = 14,
	RK818_ID_HDMI_SWITCH = 15,
	RK818_ID_OTG_SWITCH = 16,
};

enum rk805_reg {
	RK805_ID_DCDC1 = 0,
	RK805_ID_DCDC2 = 1,
	RK805_ID_DCDC3 = 2,
	RK805_ID_DCDC4 = 3,
	RK805_ID_LDO1 = 4,
	RK805_ID_LDO2 = 5,
	RK805_ID_LDO3 = 6,
};

enum rk817_reg_id {
	RK817_ID_DCDC1 = 0,
	RK817_ID_DCDC2 = 1,
	RK817_ID_DCDC3 = 2,
	RK817_ID_DCDC4 = 3,
	RK817_ID_LDO1 = 4,
	RK817_ID_LDO2 = 5,
	RK817_ID_LDO3 = 6,
	RK817_ID_LDO4 = 7,
	RK817_ID_LDO5 = 8,
	RK817_ID_LDO6 = 9,
	RK817_ID_LDO7 = 10,
	RK817_ID_LDO8 = 11,
	RK817_ID_LDO9 = 12,
	RK817_ID_BOOST = 13,
	RK817_ID_BOOST_OTG_SW = 14,
	RK817_NUM_REGULATORS = 15,
};

enum rk809_reg_id {
	RK809_ID_DCDC5 = 13,
	RK809_ID_SW1 = 14,
	RK809_ID_SW2 = 15,
	RK809_NUM_REGULATORS = 16,
};

enum {
	RK805_ID = 32848,
	RK808_ID = 0,
	RK809_ID = 32912,
	RK817_ID = 33136,
	RK818_ID = 33152,
};

struct rk808 {
	struct i2c_client *i2c;
	struct regmap_irq_chip_data *irq_data;
	struct regmap *regmap;
	long int variant;
	const struct regmap_config *regmap_cfg;
	const struct regmap_irq_chip *regmap_irq_chip;
};

struct rk808_regulator_data {
	struct gpio_desc *dvs_gpio[2];
};

enum {
	RN5T618_DCDC1 = 0,
	RN5T618_DCDC2 = 1,
	RN5T618_DCDC3 = 2,
	RN5T618_DCDC4 = 3,
	RN5T618_DCDC5 = 4,
	RN5T618_LDO1 = 5,
	RN5T618_LDO2 = 6,
	RN5T618_LDO3 = 7,
	RN5T618_LDO4 = 8,
	RN5T618_LDO5 = 9,
	RN5T618_LDO6 = 10,
	RN5T618_LDO7 = 11,
	RN5T618_LDO8 = 12,
	RN5T618_LDO9 = 13,
	RN5T618_LDO10 = 14,
	RN5T618_LDORTC1 = 15,
	RN5T618_LDORTC2 = 16,
	RN5T618_REG_NUM = 17,
};

enum {
	RN5T567 = 0,
	RN5T618 = 1,
	RC5T619 = 2,
};

struct rn5t618 {
	struct regmap *regmap;
	struct device *dev;
	long int variant;
	int irq;
	struct regmap_irq_chip_data *irq_data;
};

enum sec_device_type {
	S5M8751X = 0,
	S5M8763X = 1,
	S5M8767X = 2,
	S2MPA01 = 3,
	S2MPS11X = 4,
	S2MPS13X = 5,
	S2MPS14X = 6,
	S2MPS15X = 7,
	S2MPU02 = 8,
};

struct sec_platform_data;

struct sec_pmic_dev {
	struct device *dev;
	struct sec_platform_data *pdata;
	struct regmap *regmap_pmic;
	struct i2c_client *i2c;
	long unsigned int device_type;
	int irq_base;
	int irq;
	struct regmap_irq_chip_data *irq_data;
	bool wakeup;
};

struct sec_regulator_data;

struct sec_opmode_data;

struct sec_platform_data {
	struct sec_regulator_data *regulators;
	struct sec_opmode_data *opmode;
	int device_type;
	int num_regulators;
	int irq_base;
	int (*cfg_pmic_irq)();
	bool wakeup;
	bool buck_voltage_lock;
	int buck_gpios[3];
	int buck_ds[3];
	unsigned int buck2_voltage[8];
	bool buck2_gpiodvs;
	unsigned int buck3_voltage[8];
	bool buck3_gpiodvs;
	unsigned int buck4_voltage[8];
	bool buck4_gpiodvs;
	int buck_set1;
	int buck_set2;
	int buck_set3;
	int buck2_enable;
	int buck3_enable;
	int buck4_enable;
	int buck_default_idx;
	int buck2_default_idx;
	int buck3_default_idx;
	int buck4_default_idx;
	int buck_ramp_delay;
	int buck2_ramp_delay;
	int buck34_ramp_delay;
	int buck5_ramp_delay;
	int buck16_ramp_delay;
	int buck7810_ramp_delay;
	int buck9_ramp_delay;
	int buck24_ramp_delay;
	int buck3_ramp_delay;
	int buck7_ramp_delay;
	int buck8910_ramp_delay;
	bool buck1_ramp_enable;
	bool buck2_ramp_enable;
	bool buck3_ramp_enable;
	bool buck4_ramp_enable;
	bool buck6_ramp_enable;
	int buck2_init;
	int buck3_init;
	int buck4_init;
	bool manual_poweroff;
	bool disable_wrstbi;
};

struct sec_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
	struct gpio_desc *ext_control_gpiod;
};

struct sec_opmode_data {
	int id;
	unsigned int mode;
};

enum s2mps11_reg {
	S2MPS11_REG_ID = 0,
	S2MPS11_REG_INT1 = 1,
	S2MPS11_REG_INT2 = 2,
	S2MPS11_REG_INT3 = 3,
	S2MPS11_REG_INT1M = 4,
	S2MPS11_REG_INT2M = 5,
	S2MPS11_REG_INT3M = 6,
	S2MPS11_REG_ST1 = 7,
	S2MPS11_REG_ST2 = 8,
	S2MPS11_REG_OFFSRC = 9,
	S2MPS11_REG_PWRONSRC = 10,
	S2MPS11_REG_RTC_CTRL = 11,
	S2MPS11_REG_CTRL1 = 12,
	S2MPS11_REG_ETC_TEST = 13,
	S2MPS11_REG_RSVD3 = 14,
	S2MPS11_REG_BU_CHG = 15,
	S2MPS11_REG_RAMP = 16,
	S2MPS11_REG_RAMP_BUCK = 17,
	S2MPS11_REG_LDO1_8 = 18,
	S2MPS11_REG_LDO9_16 = 19,
	S2MPS11_REG_LDO17_24 = 20,
	S2MPS11_REG_LDO25_32 = 21,
	S2MPS11_REG_LDO33_38 = 22,
	S2MPS11_REG_LDO1_8_1 = 23,
	S2MPS11_REG_LDO9_16_1 = 24,
	S2MPS11_REG_LDO17_24_1 = 25,
	S2MPS11_REG_LDO25_32_1 = 26,
	S2MPS11_REG_LDO33_38_1 = 27,
	S2MPS11_REG_OTP_ADRL = 28,
	S2MPS11_REG_OTP_ADRH = 29,
	S2MPS11_REG_OTP_DATA = 30,
	S2MPS11_REG_MON1SEL = 31,
	S2MPS11_REG_MON2SEL = 32,
	S2MPS11_REG_LEE = 33,
	S2MPS11_REG_RSVD_NO = 34,
	S2MPS11_REG_UVLO = 35,
	S2MPS11_REG_LEE_NO = 36,
	S2MPS11_REG_B1CTRL1 = 37,
	S2MPS11_REG_B1CTRL2 = 38,
	S2MPS11_REG_B2CTRL1 = 39,
	S2MPS11_REG_B2CTRL2 = 40,
	S2MPS11_REG_B3CTRL1 = 41,
	S2MPS11_REG_B3CTRL2 = 42,
	S2MPS11_REG_B4CTRL1 = 43,
	S2MPS11_REG_B4CTRL2 = 44,
	S2MPS11_REG_B5CTRL1 = 45,
	S2MPS11_REG_BUCK5_SW = 46,
	S2MPS11_REG_B5CTRL2 = 47,
	S2MPS11_REG_B5CTRL3 = 48,
	S2MPS11_REG_B5CTRL4 = 49,
	S2MPS11_REG_B5CTRL5 = 50,
	S2MPS11_REG_B6CTRL1 = 51,
	S2MPS11_REG_B6CTRL2 = 52,
	S2MPS11_REG_B7CTRL1 = 53,
	S2MPS11_REG_B7CTRL2 = 54,
	S2MPS11_REG_B8CTRL1 = 55,
	S2MPS11_REG_B8CTRL2 = 56,
	S2MPS11_REG_B9CTRL1 = 57,
	S2MPS11_REG_B9CTRL2 = 58,
	S2MPS11_REG_B10CTRL1 = 59,
	S2MPS11_REG_B10CTRL2 = 60,
	S2MPS11_REG_L1CTRL = 61,
	S2MPS11_REG_L2CTRL = 62,
	S2MPS11_REG_L3CTRL = 63,
	S2MPS11_REG_L4CTRL = 64,
	S2MPS11_REG_L5CTRL = 65,
	S2MPS11_REG_L6CTRL = 66,
	S2MPS11_REG_L7CTRL = 67,
	S2MPS11_REG_L8CTRL = 68,
	S2MPS11_REG_L9CTRL = 69,
	S2MPS11_REG_L10CTRL = 70,
	S2MPS11_REG_L11CTRL = 71,
	S2MPS11_REG_L12CTRL = 72,
	S2MPS11_REG_L13CTRL = 73,
	S2MPS11_REG_L14CTRL = 74,
	S2MPS11_REG_L15CTRL = 75,
	S2MPS11_REG_L16CTRL = 76,
	S2MPS11_REG_L17CTRL = 77,
	S2MPS11_REG_L18CTRL = 78,
	S2MPS11_REG_L19CTRL = 79,
	S2MPS11_REG_L20CTRL = 80,
	S2MPS11_REG_L21CTRL = 81,
	S2MPS11_REG_L22CTRL = 82,
	S2MPS11_REG_L23CTRL = 83,
	S2MPS11_REG_L24CTRL = 84,
	S2MPS11_REG_L25CTRL = 85,
	S2MPS11_REG_L26CTRL = 86,
	S2MPS11_REG_L27CTRL = 87,
	S2MPS11_REG_L28CTRL = 88,
	S2MPS11_REG_L29CTRL = 89,
	S2MPS11_REG_L30CTRL = 90,
	S2MPS11_REG_L31CTRL = 91,
	S2MPS11_REG_L32CTRL = 92,
	S2MPS11_REG_L33CTRL = 93,
	S2MPS11_REG_L34CTRL = 94,
	S2MPS11_REG_L35CTRL = 95,
	S2MPS11_REG_L36CTRL = 96,
	S2MPS11_REG_L37CTRL = 97,
	S2MPS11_REG_L38CTRL = 98,
};

enum s2mps11_regulators {
	S2MPS11_LDO1 = 0,
	S2MPS11_LDO2 = 1,
	S2MPS11_LDO3 = 2,
	S2MPS11_LDO4 = 3,
	S2MPS11_LDO5 = 4,
	S2MPS11_LDO6 = 5,
	S2MPS11_LDO7 = 6,
	S2MPS11_LDO8 = 7,
	S2MPS11_LDO9 = 8,
	S2MPS11_LDO10 = 9,
	S2MPS11_LDO11 = 10,
	S2MPS11_LDO12 = 11,
	S2MPS11_LDO13 = 12,
	S2MPS11_LDO14 = 13,
	S2MPS11_LDO15 = 14,
	S2MPS11_LDO16 = 15,
	S2MPS11_LDO17 = 16,
	S2MPS11_LDO18 = 17,
	S2MPS11_LDO19 = 18,
	S2MPS11_LDO20 = 19,
	S2MPS11_LDO21 = 20,
	S2MPS11_LDO22 = 21,
	S2MPS11_LDO23 = 22,
	S2MPS11_LDO24 = 23,
	S2MPS11_LDO25 = 24,
	S2MPS11_LDO26 = 25,
	S2MPS11_LDO27 = 26,
	S2MPS11_LDO28 = 27,
	S2MPS11_LDO29 = 28,
	S2MPS11_LDO30 = 29,
	S2MPS11_LDO31 = 30,
	S2MPS11_LDO32 = 31,
	S2MPS11_LDO33 = 32,
	S2MPS11_LDO34 = 33,
	S2MPS11_LDO35 = 34,
	S2MPS11_LDO36 = 35,
	S2MPS11_LDO37 = 36,
	S2MPS11_LDO38 = 37,
	S2MPS11_BUCK1 = 38,
	S2MPS11_BUCK2 = 39,
	S2MPS11_BUCK3 = 40,
	S2MPS11_BUCK4 = 41,
	S2MPS11_BUCK5 = 42,
	S2MPS11_BUCK6 = 43,
	S2MPS11_BUCK7 = 44,
	S2MPS11_BUCK8 = 45,
	S2MPS11_BUCK9 = 46,
	S2MPS11_BUCK10 = 47,
	S2MPS11_REGULATOR_MAX = 48,
};

enum s2mps13_reg {
	S2MPS13_REG_ID = 0,
	S2MPS13_REG_INT1 = 1,
	S2MPS13_REG_INT2 = 2,
	S2MPS13_REG_INT3 = 3,
	S2MPS13_REG_INT1M = 4,
	S2MPS13_REG_INT2M = 5,
	S2MPS13_REG_INT3M = 6,
	S2MPS13_REG_ST1 = 7,
	S2MPS13_REG_ST2 = 8,
	S2MPS13_REG_PWRONSRC = 9,
	S2MPS13_REG_OFFSRC = 10,
	S2MPS13_REG_BU_CHG = 11,
	S2MPS13_REG_RTCCTRL = 12,
	S2MPS13_REG_CTRL1 = 13,
	S2MPS13_REG_CTRL2 = 14,
	S2MPS13_REG_RSVD1 = 15,
	S2MPS13_REG_RSVD2 = 16,
	S2MPS13_REG_RSVD3 = 17,
	S2MPS13_REG_RSVD4 = 18,
	S2MPS13_REG_RSVD5 = 19,
	S2MPS13_REG_RSVD6 = 20,
	S2MPS13_REG_CTRL3 = 21,
	S2MPS13_REG_RSVD7 = 22,
	S2MPS13_REG_RSVD8 = 23,
	S2MPS13_REG_WRSTBI = 24,
	S2MPS13_REG_B1CTRL = 25,
	S2MPS13_REG_B1OUT = 26,
	S2MPS13_REG_B2CTRL = 27,
	S2MPS13_REG_B2OUT = 28,
	S2MPS13_REG_B3CTRL = 29,
	S2MPS13_REG_B3OUT = 30,
	S2MPS13_REG_B4CTRL = 31,
	S2MPS13_REG_B4OUT = 32,
	S2MPS13_REG_B5CTRL = 33,
	S2MPS13_REG_B5OUT = 34,
	S2MPS13_REG_B6CTRL = 35,
	S2MPS13_REG_B6OUT = 36,
	S2MPS13_REG_B7CTRL = 37,
	S2MPS13_REG_B7SW = 38,
	S2MPS13_REG_B7OUT = 39,
	S2MPS13_REG_B8CTRL = 40,
	S2MPS13_REG_B8OUT = 41,
	S2MPS13_REG_B9CTRL = 42,
	S2MPS13_REG_B9OUT = 43,
	S2MPS13_REG_B10CTRL = 44,
	S2MPS13_REG_B10OUT = 45,
	S2MPS13_REG_BB1CTRL = 46,
	S2MPS13_REG_BB1OUT = 47,
	S2MPS13_REG_BUCK_RAMP1 = 48,
	S2MPS13_REG_BUCK_RAMP2 = 49,
	S2MPS13_REG_LDO_DVS1 = 50,
	S2MPS13_REG_LDO_DVS2 = 51,
	S2MPS13_REG_LDO_DVS3 = 52,
	S2MPS13_REG_B6OUT2 = 53,
	S2MPS13_REG_L1CTRL = 54,
	S2MPS13_REG_L2CTRL = 55,
	S2MPS13_REG_L3CTRL = 56,
	S2MPS13_REG_L4CTRL = 57,
	S2MPS13_REG_L5CTRL = 58,
	S2MPS13_REG_L6CTRL = 59,
	S2MPS13_REG_L7CTRL = 60,
	S2MPS13_REG_L8CTRL = 61,
	S2MPS13_REG_L9CTRL = 62,
	S2MPS13_REG_L10CTRL = 63,
	S2MPS13_REG_L11CTRL = 64,
	S2MPS13_REG_L12CTRL = 65,
	S2MPS13_REG_L13CTRL = 66,
	S2MPS13_REG_L14CTRL = 67,
	S2MPS13_REG_L15CTRL = 68,
	S2MPS13_REG_L16CTRL = 69,
	S2MPS13_REG_L17CTRL = 70,
	S2MPS13_REG_L18CTRL = 71,
	S2MPS13_REG_L19CTRL = 72,
	S2MPS13_REG_L20CTRL = 73,
	S2MPS13_REG_L21CTRL = 74,
	S2MPS13_REG_L22CTRL = 75,
	S2MPS13_REG_L23CTRL = 76,
	S2MPS13_REG_L24CTRL = 77,
	S2MPS13_REG_L25CTRL = 78,
	S2MPS13_REG_L26CTRL = 79,
	S2MPS13_REG_L27CTRL = 80,
	S2MPS13_REG_L28CTRL = 81,
	S2MPS13_REG_L29CTRL = 82,
	S2MPS13_REG_L30CTRL = 83,
	S2MPS13_REG_L31CTRL = 84,
	S2MPS13_REG_L32CTRL = 85,
	S2MPS13_REG_L33CTRL = 86,
	S2MPS13_REG_L34CTRL = 87,
	S2MPS13_REG_L35CTRL = 88,
	S2MPS13_REG_L36CTRL = 89,
	S2MPS13_REG_L37CTRL = 90,
	S2MPS13_REG_L38CTRL = 91,
	S2MPS13_REG_L39CTRL = 92,
	S2MPS13_REG_L40CTRL = 93,
	S2MPS13_REG_LDODSCH1 = 94,
	S2MPS13_REG_LDODSCH2 = 95,
	S2MPS13_REG_LDODSCH3 = 96,
	S2MPS13_REG_LDODSCH4 = 97,
	S2MPS13_REG_LDODSCH5 = 98,
};

enum s2mps13_regulators {
	S2MPS13_LDO1 = 0,
	S2MPS13_LDO2 = 1,
	S2MPS13_LDO3 = 2,
	S2MPS13_LDO4 = 3,
	S2MPS13_LDO5 = 4,
	S2MPS13_LDO6 = 5,
	S2MPS13_LDO7 = 6,
	S2MPS13_LDO8 = 7,
	S2MPS13_LDO9 = 8,
	S2MPS13_LDO10 = 9,
	S2MPS13_LDO11 = 10,
	S2MPS13_LDO12 = 11,
	S2MPS13_LDO13 = 12,
	S2MPS13_LDO14 = 13,
	S2MPS13_LDO15 = 14,
	S2MPS13_LDO16 = 15,
	S2MPS13_LDO17 = 16,
	S2MPS13_LDO18 = 17,
	S2MPS13_LDO19 = 18,
	S2MPS13_LDO20 = 19,
	S2MPS13_LDO21 = 20,
	S2MPS13_LDO22 = 21,
	S2MPS13_LDO23 = 22,
	S2MPS13_LDO24 = 23,
	S2MPS13_LDO25 = 24,
	S2MPS13_LDO26 = 25,
	S2MPS13_LDO27 = 26,
	S2MPS13_LDO28 = 27,
	S2MPS13_LDO29 = 28,
	S2MPS13_LDO30 = 29,
	S2MPS13_LDO31 = 30,
	S2MPS13_LDO32 = 31,
	S2MPS13_LDO33 = 32,
	S2MPS13_LDO34 = 33,
	S2MPS13_LDO35 = 34,
	S2MPS13_LDO36 = 35,
	S2MPS13_LDO37 = 36,
	S2MPS13_LDO38 = 37,
	S2MPS13_LDO39 = 38,
	S2MPS13_LDO40 = 39,
	S2MPS13_BUCK1 = 40,
	S2MPS13_BUCK2 = 41,
	S2MPS13_BUCK3 = 42,
	S2MPS13_BUCK4 = 43,
	S2MPS13_BUCK5 = 44,
	S2MPS13_BUCK6 = 45,
	S2MPS13_BUCK7 = 46,
	S2MPS13_BUCK8 = 47,
	S2MPS13_BUCK9 = 48,
	S2MPS13_BUCK10 = 49,
	S2MPS13_REGULATOR_MAX = 50,
};

enum s2mps14_reg {
	S2MPS14_REG_ID = 0,
	S2MPS14_REG_INT1 = 1,
	S2MPS14_REG_INT2 = 2,
	S2MPS14_REG_INT3 = 3,
	S2MPS14_REG_INT1M = 4,
	S2MPS14_REG_INT2M = 5,
	S2MPS14_REG_INT3M = 6,
	S2MPS14_REG_ST1 = 7,
	S2MPS14_REG_ST2 = 8,
	S2MPS14_REG_PWRONSRC = 9,
	S2MPS14_REG_OFFSRC = 10,
	S2MPS14_REG_BU_CHG = 11,
	S2MPS14_REG_RTCCTRL = 12,
	S2MPS14_REG_CTRL1 = 13,
	S2MPS14_REG_CTRL2 = 14,
	S2MPS14_REG_RSVD1 = 15,
	S2MPS14_REG_RSVD2 = 16,
	S2MPS14_REG_RSVD3 = 17,
	S2MPS14_REG_RSVD4 = 18,
	S2MPS14_REG_RSVD5 = 19,
	S2MPS14_REG_RSVD6 = 20,
	S2MPS14_REG_CTRL3 = 21,
	S2MPS14_REG_RSVD7 = 22,
	S2MPS14_REG_RSVD8 = 23,
	S2MPS14_REG_WRSTBI = 24,
	S2MPS14_REG_B1CTRL1 = 25,
	S2MPS14_REG_B1CTRL2 = 26,
	S2MPS14_REG_B2CTRL1 = 27,
	S2MPS14_REG_B2CTRL2 = 28,
	S2MPS14_REG_B3CTRL1 = 29,
	S2MPS14_REG_B3CTRL2 = 30,
	S2MPS14_REG_B4CTRL1 = 31,
	S2MPS14_REG_B4CTRL2 = 32,
	S2MPS14_REG_B5CTRL1 = 33,
	S2MPS14_REG_B5CTRL2 = 34,
	S2MPS14_REG_L1CTRL = 35,
	S2MPS14_REG_L2CTRL = 36,
	S2MPS14_REG_L3CTRL = 37,
	S2MPS14_REG_L4CTRL = 38,
	S2MPS14_REG_L5CTRL = 39,
	S2MPS14_REG_L6CTRL = 40,
	S2MPS14_REG_L7CTRL = 41,
	S2MPS14_REG_L8CTRL = 42,
	S2MPS14_REG_L9CTRL = 43,
	S2MPS14_REG_L10CTRL = 44,
	S2MPS14_REG_L11CTRL = 45,
	S2MPS14_REG_L12CTRL = 46,
	S2MPS14_REG_L13CTRL = 47,
	S2MPS14_REG_L14CTRL = 48,
	S2MPS14_REG_L15CTRL = 49,
	S2MPS14_REG_L16CTRL = 50,
	S2MPS14_REG_L17CTRL = 51,
	S2MPS14_REG_L18CTRL = 52,
	S2MPS14_REG_L19CTRL = 53,
	S2MPS14_REG_L20CTRL = 54,
	S2MPS14_REG_L21CTRL = 55,
	S2MPS14_REG_L22CTRL = 56,
	S2MPS14_REG_L23CTRL = 57,
	S2MPS14_REG_L24CTRL = 58,
	S2MPS14_REG_L25CTRL = 59,
	S2MPS14_REG_LDODSCH1 = 60,
	S2MPS14_REG_LDODSCH2 = 61,
	S2MPS14_REG_LDODSCH3 = 62,
};

enum s2mps14_regulators {
	S2MPS14_LDO1 = 0,
	S2MPS14_LDO2 = 1,
	S2MPS14_LDO3 = 2,
	S2MPS14_LDO4 = 3,
	S2MPS14_LDO5 = 4,
	S2MPS14_LDO6 = 5,
	S2MPS14_LDO7 = 6,
	S2MPS14_LDO8 = 7,
	S2MPS14_LDO9 = 8,
	S2MPS14_LDO10 = 9,
	S2MPS14_LDO11 = 10,
	S2MPS14_LDO12 = 11,
	S2MPS14_LDO13 = 12,
	S2MPS14_LDO14 = 13,
	S2MPS14_LDO15 = 14,
	S2MPS14_LDO16 = 15,
	S2MPS14_LDO17 = 16,
	S2MPS14_LDO18 = 17,
	S2MPS14_LDO19 = 18,
	S2MPS14_LDO20 = 19,
	S2MPS14_LDO21 = 20,
	S2MPS14_LDO22 = 21,
	S2MPS14_LDO23 = 22,
	S2MPS14_LDO24 = 23,
	S2MPS14_LDO25 = 24,
	S2MPS14_BUCK1 = 25,
	S2MPS14_BUCK2 = 26,
	S2MPS14_BUCK3 = 27,
	S2MPS14_BUCK4 = 28,
	S2MPS14_BUCK5 = 29,
	S2MPS14_REGULATOR_MAX = 30,
};

enum s2mps15_reg {
	S2MPS15_REG_ID = 0,
	S2MPS15_REG_INT1 = 1,
	S2MPS15_REG_INT2 = 2,
	S2MPS15_REG_INT3 = 3,
	S2MPS15_REG_INT1M = 4,
	S2MPS15_REG_INT2M = 5,
	S2MPS15_REG_INT3M = 6,
	S2MPS15_REG_ST1 = 7,
	S2MPS15_REG_ST2 = 8,
	S2MPS15_REG_PWRONSRC = 9,
	S2MPS15_REG_OFFSRC = 10,
	S2MPS15_REG_BU_CHG = 11,
	S2MPS15_REG_RTC_BUF = 12,
	S2MPS15_REG_CTRL1 = 13,
	S2MPS15_REG_CTRL2 = 14,
	S2MPS15_REG_RSVD1 = 15,
	S2MPS15_REG_RSVD2 = 16,
	S2MPS15_REG_RSVD3 = 17,
	S2MPS15_REG_RSVD4 = 18,
	S2MPS15_REG_RSVD5 = 19,
	S2MPS15_REG_RSVD6 = 20,
	S2MPS15_REG_CTRL3 = 21,
	S2MPS15_REG_RSVD7 = 22,
	S2MPS15_REG_RSVD8 = 23,
	S2MPS15_REG_RSVD9 = 24,
	S2MPS15_REG_B1CTRL1 = 25,
	S2MPS15_REG_B1CTRL2 = 26,
	S2MPS15_REG_B2CTRL1 = 27,
	S2MPS15_REG_B2CTRL2 = 28,
	S2MPS15_REG_B3CTRL1 = 29,
	S2MPS15_REG_B3CTRL2 = 30,
	S2MPS15_REG_B4CTRL1 = 31,
	S2MPS15_REG_B4CTRL2 = 32,
	S2MPS15_REG_B5CTRL1 = 33,
	S2MPS15_REG_B5CTRL2 = 34,
	S2MPS15_REG_B6CTRL1 = 35,
	S2MPS15_REG_B6CTRL2 = 36,
	S2MPS15_REG_B7CTRL1 = 37,
	S2MPS15_REG_B7CTRL2 = 38,
	S2MPS15_REG_B8CTRL1 = 39,
	S2MPS15_REG_B8CTRL2 = 40,
	S2MPS15_REG_B9CTRL1 = 41,
	S2MPS15_REG_B9CTRL2 = 42,
	S2MPS15_REG_B10CTRL1 = 43,
	S2MPS15_REG_B10CTRL2 = 44,
	S2MPS15_REG_BBCTRL1 = 45,
	S2MPS15_REG_BBCTRL2 = 46,
	S2MPS15_REG_BRAMP = 47,
	S2MPS15_REG_LDODVS1 = 48,
	S2MPS15_REG_LDODVS2 = 49,
	S2MPS15_REG_LDODVS3 = 50,
	S2MPS15_REG_LDODVS4 = 51,
	S2MPS15_REG_L1CTRL = 52,
	S2MPS15_REG_L2CTRL = 53,
	S2MPS15_REG_L3CTRL = 54,
	S2MPS15_REG_L4CTRL = 55,
	S2MPS15_REG_L5CTRL = 56,
	S2MPS15_REG_L6CTRL = 57,
	S2MPS15_REG_L7CTRL = 58,
	S2MPS15_REG_L8CTRL = 59,
	S2MPS15_REG_L9CTRL = 60,
	S2MPS15_REG_L10CTRL = 61,
	S2MPS15_REG_L11CTRL = 62,
	S2MPS15_REG_L12CTRL = 63,
	S2MPS15_REG_L13CTRL = 64,
	S2MPS15_REG_L14CTRL = 65,
	S2MPS15_REG_L15CTRL = 66,
	S2MPS15_REG_L16CTRL = 67,
	S2MPS15_REG_L17CTRL = 68,
	S2MPS15_REG_L18CTRL = 69,
	S2MPS15_REG_L19CTRL = 70,
	S2MPS15_REG_L20CTRL = 71,
	S2MPS15_REG_L21CTRL = 72,
	S2MPS15_REG_L22CTRL = 73,
	S2MPS15_REG_L23CTRL = 74,
	S2MPS15_REG_L24CTRL = 75,
	S2MPS15_REG_L25CTRL = 76,
	S2MPS15_REG_L26CTRL = 77,
	S2MPS15_REG_L27CTRL = 78,
	S2MPS15_REG_LDODSCH1 = 79,
	S2MPS15_REG_LDODSCH2 = 80,
	S2MPS15_REG_LDODSCH3 = 81,
	S2MPS15_REG_LDODSCH4 = 82,
};

enum s2mps15_regulators {
	S2MPS15_LDO1 = 0,
	S2MPS15_LDO2 = 1,
	S2MPS15_LDO3 = 2,
	S2MPS15_LDO4 = 3,
	S2MPS15_LDO5 = 4,
	S2MPS15_LDO6 = 5,
	S2MPS15_LDO7 = 6,
	S2MPS15_LDO8 = 7,
	S2MPS15_LDO9 = 8,
	S2MPS15_LDO10 = 9,
	S2MPS15_LDO11 = 10,
	S2MPS15_LDO12 = 11,
	S2MPS15_LDO13 = 12,
	S2MPS15_LDO14 = 13,
	S2MPS15_LDO15 = 14,
	S2MPS15_LDO16 = 15,
	S2MPS15_LDO17 = 16,
	S2MPS15_LDO18 = 17,
	S2MPS15_LDO19 = 18,
	S2MPS15_LDO20 = 19,
	S2MPS15_LDO21 = 20,
	S2MPS15_LDO22 = 21,
	S2MPS15_LDO23 = 22,
	S2MPS15_LDO24 = 23,
	S2MPS15_LDO25 = 24,
	S2MPS15_LDO26 = 25,
	S2MPS15_LDO27 = 26,
	S2MPS15_BUCK1 = 27,
	S2MPS15_BUCK2 = 28,
	S2MPS15_BUCK3 = 29,
	S2MPS15_BUCK4 = 30,
	S2MPS15_BUCK5 = 31,
	S2MPS15_BUCK6 = 32,
	S2MPS15_BUCK7 = 33,
	S2MPS15_BUCK8 = 34,
	S2MPS15_BUCK9 = 35,
	S2MPS15_BUCK10 = 36,
	S2MPS15_BUCK11 = 37,
	S2MPS15_REGULATOR_MAX = 38,
};

enum S2MPU02_reg {
	S2MPU02_REG_ID = 0,
	S2MPU02_REG_INT1 = 1,
	S2MPU02_REG_INT2 = 2,
	S2MPU02_REG_INT3 = 3,
	S2MPU02_REG_INT1M = 4,
	S2MPU02_REG_INT2M = 5,
	S2MPU02_REG_INT3M = 6,
	S2MPU02_REG_ST1 = 7,
	S2MPU02_REG_ST2 = 8,
	S2MPU02_REG_PWRONSRC = 9,
	S2MPU02_REG_OFFSRC = 10,
	S2MPU02_REG_BU_CHG = 11,
	S2MPU02_REG_RTCCTRL = 12,
	S2MPU02_REG_PMCTRL1 = 13,
	S2MPU02_REG_RSVD1 = 14,
	S2MPU02_REG_RSVD2 = 15,
	S2MPU02_REG_RSVD3 = 16,
	S2MPU02_REG_RSVD4 = 17,
	S2MPU02_REG_RSVD5 = 18,
	S2MPU02_REG_RSVD6 = 19,
	S2MPU02_REG_RSVD7 = 20,
	S2MPU02_REG_WRSTEN = 21,
	S2MPU02_REG_RSVD8 = 22,
	S2MPU02_REG_RSVD9 = 23,
	S2MPU02_REG_RSVD10 = 24,
	S2MPU02_REG_B1CTRL1 = 25,
	S2MPU02_REG_B1CTRL2 = 26,
	S2MPU02_REG_B2CTRL1 = 27,
	S2MPU02_REG_B2CTRL2 = 28,
	S2MPU02_REG_B3CTRL1 = 29,
	S2MPU02_REG_B3CTRL2 = 30,
	S2MPU02_REG_B4CTRL1 = 31,
	S2MPU02_REG_B4CTRL2 = 32,
	S2MPU02_REG_B5CTRL1 = 33,
	S2MPU02_REG_B5CTRL2 = 34,
	S2MPU02_REG_B5CTRL3 = 35,
	S2MPU02_REG_B5CTRL4 = 36,
	S2MPU02_REG_B5CTRL5 = 37,
	S2MPU02_REG_B6CTRL1 = 38,
	S2MPU02_REG_B6CTRL2 = 39,
	S2MPU02_REG_B7CTRL1 = 40,
	S2MPU02_REG_B7CTRL2 = 41,
	S2MPU02_REG_RAMP1 = 42,
	S2MPU02_REG_RAMP2 = 43,
	S2MPU02_REG_L1CTRL = 44,
	S2MPU02_REG_L2CTRL1 = 45,
	S2MPU02_REG_L2CTRL2 = 46,
	S2MPU02_REG_L2CTRL3 = 47,
	S2MPU02_REG_L2CTRL4 = 48,
	S2MPU02_REG_L3CTRL = 49,
	S2MPU02_REG_L4CTRL = 50,
	S2MPU02_REG_L5CTRL = 51,
	S2MPU02_REG_L6CTRL = 52,
	S2MPU02_REG_L7CTRL = 53,
	S2MPU02_REG_L8CTRL = 54,
	S2MPU02_REG_L9CTRL = 55,
	S2MPU02_REG_L10CTRL = 56,
	S2MPU02_REG_L11CTRL = 57,
	S2MPU02_REG_L12CTRL = 58,
	S2MPU02_REG_L13CTRL = 59,
	S2MPU02_REG_L14CTRL = 60,
	S2MPU02_REG_L15CTRL = 61,
	S2MPU02_REG_L16CTRL = 62,
	S2MPU02_REG_L17CTRL = 63,
	S2MPU02_REG_L18CTRL = 64,
	S2MPU02_REG_L19CTRL = 65,
	S2MPU02_REG_L20CTRL = 66,
	S2MPU02_REG_L21CTRL = 67,
	S2MPU02_REG_L22CTRL = 68,
	S2MPU02_REG_L23CTRL = 69,
	S2MPU02_REG_L24CTRL = 70,
	S2MPU02_REG_L25CTRL = 71,
	S2MPU02_REG_L26CTRL = 72,
	S2MPU02_REG_L27CTRL = 73,
	S2MPU02_REG_L28CTRL = 74,
	S2MPU02_REG_LDODSCH1 = 75,
	S2MPU02_REG_LDODSCH2 = 76,
	S2MPU02_REG_LDODSCH3 = 77,
	S2MPU02_REG_LDODSCH4 = 78,
	S2MPU02_REG_SELMIF = 79,
	S2MPU02_REG_RSVD11 = 80,
	S2MPU02_REG_RSVD12 = 81,
	S2MPU02_REG_RSVD13 = 82,
	S2MPU02_REG_DVSSEL = 83,
	S2MPU02_REG_DVSPTR = 84,
	S2MPU02_REG_DVSDATA = 85,
};

enum S2MPU02_regulators {
	S2MPU02_LDO1 = 0,
	S2MPU02_LDO2 = 1,
	S2MPU02_LDO3 = 2,
	S2MPU02_LDO4 = 3,
	S2MPU02_LDO5 = 4,
	S2MPU02_LDO6 = 5,
	S2MPU02_LDO7 = 6,
	S2MPU02_LDO8 = 7,
	S2MPU02_LDO9 = 8,
	S2MPU02_LDO10 = 9,
	S2MPU02_LDO11 = 10,
	S2MPU02_LDO12 = 11,
	S2MPU02_LDO13 = 12,
	S2MPU02_LDO14 = 13,
	S2MPU02_LDO15 = 14,
	S2MPU02_LDO16 = 15,
	S2MPU02_LDO17 = 16,
	S2MPU02_LDO18 = 17,
	S2MPU02_LDO19 = 18,
	S2MPU02_LDO20 = 19,
	S2MPU02_LDO21 = 20,
	S2MPU02_LDO22 = 21,
	S2MPU02_LDO23 = 22,
	S2MPU02_LDO24 = 23,
	S2MPU02_LDO25 = 24,
	S2MPU02_LDO26 = 25,
	S2MPU02_LDO27 = 26,
	S2MPU02_LDO28 = 27,
	S2MPU02_BUCK1 = 28,
	S2MPU02_BUCK2 = 29,
	S2MPU02_BUCK3 = 30,
	S2MPU02_BUCK4 = 31,
	S2MPU02_BUCK5 = 32,
	S2MPU02_BUCK6 = 33,
	S2MPU02_BUCK7 = 34,
	S2MPU02_REGULATOR_MAX = 35,
};

struct s2mps11_info {
	int ramp_delay2;
	int ramp_delay34;
	int ramp_delay5;
	int ramp_delay16;
	int ramp_delay7810;
	int ramp_delay9;
	enum sec_device_type dev_type;
	long unsigned int suspend_state[2];
	struct gpio_desc **ext_control_gpiod;
};

enum s5m8767_reg {
	S5M8767_REG_ID = 0,
	S5M8767_REG_INT1 = 1,
	S5M8767_REG_INT2 = 2,
	S5M8767_REG_INT3 = 3,
	S5M8767_REG_INT1M = 4,
	S5M8767_REG_INT2M = 5,
	S5M8767_REG_INT3M = 6,
	S5M8767_REG_STATUS1 = 7,
	S5M8767_REG_STATUS2 = 8,
	S5M8767_REG_STATUS3 = 9,
	S5M8767_REG_CTRL1 = 10,
	S5M8767_REG_CTRL2 = 11,
	S5M8767_REG_LOWBAT1 = 12,
	S5M8767_REG_LOWBAT2 = 13,
	S5M8767_REG_BUCHG = 14,
	S5M8767_REG_DVSRAMP = 15,
	S5M8767_REG_DVSTIMER2 = 16,
	S5M8767_REG_DVSTIMER3 = 17,
	S5M8767_REG_DVSTIMER4 = 18,
	S5M8767_REG_LDO1 = 19,
	S5M8767_REG_LDO2 = 20,
	S5M8767_REG_LDO3 = 21,
	S5M8767_REG_LDO4 = 22,
	S5M8767_REG_LDO5 = 23,
	S5M8767_REG_LDO6 = 24,
	S5M8767_REG_LDO7 = 25,
	S5M8767_REG_LDO8 = 26,
	S5M8767_REG_LDO9 = 27,
	S5M8767_REG_LDO10 = 28,
	S5M8767_REG_LDO11 = 29,
	S5M8767_REG_LDO12 = 30,
	S5M8767_REG_LDO13 = 31,
	S5M8767_REG_LDO14 = 32,
	S5M8767_REG_LDO15 = 33,
	S5M8767_REG_LDO16 = 34,
	S5M8767_REG_LDO17 = 35,
	S5M8767_REG_LDO18 = 36,
	S5M8767_REG_LDO19 = 37,
	S5M8767_REG_LDO20 = 38,
	S5M8767_REG_LDO21 = 39,
	S5M8767_REG_LDO22 = 40,
	S5M8767_REG_LDO23 = 41,
	S5M8767_REG_LDO24 = 42,
	S5M8767_REG_LDO25 = 43,
	S5M8767_REG_LDO26 = 44,
	S5M8767_REG_LDO27 = 45,
	S5M8767_REG_LDO28 = 46,
	S5M8767_REG_UVLO = 49,
	S5M8767_REG_BUCK1CTRL1 = 50,
	S5M8767_REG_BUCK1CTRL2 = 51,
	S5M8767_REG_BUCK2CTRL = 52,
	S5M8767_REG_BUCK2DVS1 = 53,
	S5M8767_REG_BUCK2DVS2 = 54,
	S5M8767_REG_BUCK2DVS3 = 55,
	S5M8767_REG_BUCK2DVS4 = 56,
	S5M8767_REG_BUCK2DVS5 = 57,
	S5M8767_REG_BUCK2DVS6 = 58,
	S5M8767_REG_BUCK2DVS7 = 59,
	S5M8767_REG_BUCK2DVS8 = 60,
	S5M8767_REG_BUCK3CTRL = 61,
	S5M8767_REG_BUCK3DVS1 = 62,
	S5M8767_REG_BUCK3DVS2 = 63,
	S5M8767_REG_BUCK3DVS3 = 64,
	S5M8767_REG_BUCK3DVS4 = 65,
	S5M8767_REG_BUCK3DVS5 = 66,
	S5M8767_REG_BUCK3DVS6 = 67,
	S5M8767_REG_BUCK3DVS7 = 68,
	S5M8767_REG_BUCK3DVS8 = 69,
	S5M8767_REG_BUCK4CTRL = 70,
	S5M8767_REG_BUCK4DVS1 = 71,
	S5M8767_REG_BUCK4DVS2 = 72,
	S5M8767_REG_BUCK4DVS3 = 73,
	S5M8767_REG_BUCK4DVS4 = 74,
	S5M8767_REG_BUCK4DVS5 = 75,
	S5M8767_REG_BUCK4DVS6 = 76,
	S5M8767_REG_BUCK4DVS7 = 77,
	S5M8767_REG_BUCK4DVS8 = 78,
	S5M8767_REG_BUCK5CTRL1 = 79,
	S5M8767_REG_BUCK5CTRL2 = 80,
	S5M8767_REG_BUCK5CTRL3 = 81,
	S5M8767_REG_BUCK5CTRL4 = 82,
	S5M8767_REG_BUCK5CTRL5 = 83,
	S5M8767_REG_BUCK6CTRL1 = 84,
	S5M8767_REG_BUCK6CTRL2 = 85,
	S5M8767_REG_BUCK7CTRL1 = 86,
	S5M8767_REG_BUCK7CTRL2 = 87,
	S5M8767_REG_BUCK8CTRL1 = 88,
	S5M8767_REG_BUCK8CTRL2 = 89,
	S5M8767_REG_BUCK9CTRL1 = 90,
	S5M8767_REG_BUCK9CTRL2 = 91,
	S5M8767_REG_LDO1CTRL = 92,
	S5M8767_REG_LDO2_1CTRL = 93,
	S5M8767_REG_LDO2_2CTRL = 94,
	S5M8767_REG_LDO2_3CTRL = 95,
	S5M8767_REG_LDO2_4CTRL = 96,
	S5M8767_REG_LDO3CTRL = 97,
	S5M8767_REG_LDO4CTRL = 98,
	S5M8767_REG_LDO5CTRL = 99,
	S5M8767_REG_LDO6CTRL = 100,
	S5M8767_REG_LDO7CTRL = 101,
	S5M8767_REG_LDO8CTRL = 102,
	S5M8767_REG_LDO9CTRL = 103,
	S5M8767_REG_LDO10CTRL = 104,
	S5M8767_REG_LDO11CTRL = 105,
	S5M8767_REG_LDO12CTRL = 106,
	S5M8767_REG_LDO13CTRL = 107,
	S5M8767_REG_LDO14CTRL = 108,
	S5M8767_REG_LDO15CTRL = 109,
	S5M8767_REG_LDO16CTRL = 110,
	S5M8767_REG_LDO17CTRL = 111,
	S5M8767_REG_LDO18CTRL = 112,
	S5M8767_REG_LDO19CTRL = 113,
	S5M8767_REG_LDO20CTRL = 114,
	S5M8767_REG_LDO21CTRL = 115,
	S5M8767_REG_LDO22CTRL = 116,
	S5M8767_REG_LDO23CTRL = 117,
	S5M8767_REG_LDO24CTRL = 118,
	S5M8767_REG_LDO25CTRL = 119,
	S5M8767_REG_LDO26CTRL = 120,
	S5M8767_REG_LDO27CTRL = 121,
	S5M8767_REG_LDO28CTRL = 122,
};

enum s5m8767_regulators {
	S5M8767_LDO1 = 0,
	S5M8767_LDO2 = 1,
	S5M8767_LDO3 = 2,
	S5M8767_LDO4 = 3,
	S5M8767_LDO5 = 4,
	S5M8767_LDO6 = 5,
	S5M8767_LDO7 = 6,
	S5M8767_LDO8 = 7,
	S5M8767_LDO9 = 8,
	S5M8767_LDO10 = 9,
	S5M8767_LDO11 = 10,
	S5M8767_LDO12 = 11,
	S5M8767_LDO13 = 12,
	S5M8767_LDO14 = 13,
	S5M8767_LDO15 = 14,
	S5M8767_LDO16 = 15,
	S5M8767_LDO17 = 16,
	S5M8767_LDO18 = 17,
	S5M8767_LDO19 = 18,
	S5M8767_LDO20 = 19,
	S5M8767_LDO21 = 20,
	S5M8767_LDO22 = 21,
	S5M8767_LDO23 = 22,
	S5M8767_LDO24 = 23,
	S5M8767_LDO25 = 24,
	S5M8767_LDO26 = 25,
	S5M8767_LDO27 = 26,
	S5M8767_LDO28 = 27,
	S5M8767_BUCK1 = 28,
	S5M8767_BUCK2 = 29,
	S5M8767_BUCK3 = 30,
	S5M8767_BUCK4 = 31,
	S5M8767_BUCK5 = 32,
	S5M8767_BUCK6 = 33,
	S5M8767_BUCK7 = 34,
	S5M8767_BUCK8 = 35,
	S5M8767_BUCK9 = 36,
	S5M8767_AP_EN32KHZ = 37,
	S5M8767_CP_EN32KHZ = 38,
	S5M8767_REG_MAX = 39,
};

enum s5m8767_dvs_buck_ramp_values {
	S5M8767_DVS_BUCK_RAMP_5 = 4,
	S5M8767_DVS_BUCK_RAMP_10 = 9,
	S5M8767_DVS_BUCK_RAMP_12_5 = 11,
	S5M8767_DVS_BUCK_RAMP_25 = 13,
	S5M8767_DVS_BUCK_RAMP_50 = 14,
	S5M8767_DVS_BUCK_RAMP_100 = 15,
};

struct s5m8767_info {
	struct device *dev;
	struct sec_pmic_dev *iodev;
	int num_regulators;
	struct sec_opmode_data *opmode;
	int ramp_delay;
	bool buck2_ramp;
	bool buck3_ramp;
	bool buck4_ramp;
	bool buck2_gpiodvs;
	bool buck3_gpiodvs;
	bool buck4_gpiodvs;
	u8 buck2_vol[8];
	u8 buck3_vol[8];
	u8 buck4_vol[8];
	int buck_gpios[3];
	int buck_ds[3];
	int buck_gpioindex;
};

struct sec_voltage_desc {
	int max;
	int min;
	int step;
};

enum {
	PWR_REG11 = 0,
	PWR_REG18 = 1,
	PWR_USB33 = 2,
	STM32PWR_REG_NUM_REGS = 3,
};

struct stm32_pwr_reg {
	void *base;
	u32 ready_mask;
};

struct stpmic1 {
	struct device *dev;
	struct regmap *regmap;
	int irq;
	struct regmap_irq_chip_data *irq_data;
};

struct stpmic1_regulator_cfg {
	struct regulator_desc desc;
	u8 mask_reset_reg;
	u8 mask_reset_mask;
	u8 icc_reg;
	u8 icc_mask;
};

enum {
	STPMIC1_BUCK1 = 0,
	STPMIC1_BUCK2 = 1,
	STPMIC1_BUCK3 = 2,
	STPMIC1_BUCK4 = 3,
	STPMIC1_LDO1 = 4,
	STPMIC1_LDO2 = 5,
	STPMIC1_LDO3 = 6,
	STPMIC1_LDO4 = 7,
	STPMIC1_LDO5 = 8,
	STPMIC1_LDO6 = 9,
	STPMIC1_VREF_DDR = 10,
	STPMIC1_BOOST = 11,
	STPMIC1_VBUS_OTG = 12,
	STPMIC1_SW_OUT = 13,
};

struct ti_abb_info {
	u32 opp_sel;
	u32 vset;
};

struct ti_abb_reg {
	u32 setup_off;
	u32 control_off;
	u32 sr2_wtcnt_value_mask;
	u32 fbb_sel_mask;
	u32 rbb_sel_mask;
	u32 sr2_en_mask;
	u32 opp_change_mask;
	u32 opp_sel_mask;
};

struct ti_abb {
	struct regulator_desc rdesc;
	struct clk *clk;
	void *base;
	void *setup_reg;
	void *control_reg;
	void *int_base;
	void *efuse_base;
	void *ldo_base;
	const struct ti_abb_reg *regs;
	u32 txdone_mask;
	u32 ldovbb_override_mask;
	u32 ldovbb_vset_mask;
	struct ti_abb_info *info;
	int current_info_idx;
	u32 settling_time;
};

struct tps62360_regulator_platform_data {
	struct regulator_init_data *reg_init_data;
	bool en_discharge;
	bool en_internal_pulldn;
	int vsel0_gpio;
	int vsel1_gpio;
	int vsel0_def_state;
	int vsel1_def_state;
};

enum chips {
	TPS62360 = 0,
	TPS62361 = 1,
	TPS62362 = 2,
	TPS62363 = 3,
};

struct tps62360_chip {
	struct device *dev;
	struct regulator_desc desc;
	struct regulator_dev *rdev;
	struct regmap *regmap;
	int vsel0_gpio;
	int vsel1_gpio;
	u8 voltage_reg_mask;
	bool en_internal_pulldn;
	bool en_discharge;
	bool valid_gpios;
	int lru_index[4];
	int curr_vset_vsel[4];
	int curr_vset_id;
};

enum {
	TPS65090_REGULATOR_DCDC1 = 0,
	TPS65090_REGULATOR_DCDC2 = 1,
	TPS65090_REGULATOR_DCDC3 = 2,
	TPS65090_REGULATOR_FET1 = 3,
	TPS65090_REGULATOR_FET2 = 4,
	TPS65090_REGULATOR_FET3 = 5,
	TPS65090_REGULATOR_FET4 = 6,
	TPS65090_REGULATOR_FET5 = 7,
	TPS65090_REGULATOR_FET6 = 8,
	TPS65090_REGULATOR_FET7 = 9,
	TPS65090_REGULATOR_LDO1 = 10,
	TPS65090_REGULATOR_LDO2 = 11,
	TPS65090_REGULATOR_MAX = 12,
};

struct tps65090 {
	struct device *dev;
	struct regmap *rmap;
	struct regmap_irq_chip_data *irq_data;
};

struct tps65090_regulator_plat_data {
	struct regulator_init_data *reg_init_data;
	bool enable_ext_control;
	struct gpio_desc *gpiod;
	bool overcurrent_wait_valid;
	int overcurrent_wait;
};

struct tps65090_platform_data {
	int irq_base;
	char **supplied_to;
	size_t num_supplicants;
	int enable_low_current_chrg;
	struct tps65090_regulator_plat_data *reg_pdata[12];
};

struct tps65090_regulator {
	struct device *dev;
	struct regulator_desc *desc;
	struct regulator_dev *rdev;
	bool overcurrent_wait_valid;
	int overcurrent_wait;
};

enum tps65217_regulator_id {
	TPS65217_DCDC_1 = 0,
	TPS65217_DCDC_2 = 1,
	TPS65217_DCDC_3 = 2,
	TPS65217_LDO_1 = 3,
	TPS65217_LDO_2 = 4,
	TPS65217_LDO_3 = 5,
	TPS65217_LDO_4 = 6,
};

enum tps65217_bl_isel {
	TPS65217_BL_ISET1 = 1,
	TPS65217_BL_ISET2 = 2,
};

enum tps65217_bl_fdim {
	TPS65217_BL_FDIM_100HZ = 0,
	TPS65217_BL_FDIM_200HZ = 1,
	TPS65217_BL_FDIM_500HZ = 2,
	TPS65217_BL_FDIM_1000HZ = 3,
};

struct tps65217_bl_pdata {
	enum tps65217_bl_isel isel;
	enum tps65217_bl_fdim fdim;
	int dft_brightness;
};

struct tps65217_board {
	struct regulator_init_data *tps65217_init_data[7];
	struct device_node *of_node[7];
	struct tps65217_bl_pdata *bl_pdata;
};

struct tps65217 {
	struct device *dev;
	struct tps65217_board *pdata;
	struct regulator_desc desc[7];
	struct regmap *regmap;
	u8 *strobes;
	struct irq_domain *irq_domain;
	struct mutex irq_lock;
	u8 irq_mask;
	int irq;
};

enum tps65218_regulator_id {
	TPS65218_DCDC_1 = 0,
	TPS65218_DCDC_2 = 1,
	TPS65218_DCDC_3 = 2,
	TPS65218_DCDC_4 = 3,
	TPS65218_DCDC_5 = 4,
	TPS65218_DCDC_6 = 5,
	TPS65218_LDO_1 = 6,
	TPS65218_LS_2 = 7,
	TPS65218_LS_3 = 8,
};

struct tps65218 {
	struct device *dev;
	unsigned int id;
	u8 rev;
	struct mutex tps_lock;
	int irq;
	u32 irq_mask;
	struct regmap_irq_chip_data *irq_data;
	struct regulator_desc desc[9];
	struct regmap *regmap;
	u8 *strobes;
};

struct tps6586x_settings {
	int slew_rate;
};

struct tps6586x_regulator {
	struct regulator_desc desc;
	int enable_bit[2];
	int enable_reg[2];
};

struct tps_info {
	const char *name;
	const char *vin_name;
	u8 n_voltages;
	const unsigned int *voltage_table;
	int enable_time_us;
};

struct tps65910_reg {
	struct regulator_desc *desc;
	struct tps65910 *mfd;
	struct regulator_dev **rdev;
	struct tps_info **info;
	int num_regulators;
	int mode;
	int (*get_ctrl_reg)(int);
	unsigned int *ext_sleep_control;
	unsigned int board_ext_control[14];
};

struct twlreg_info {
	u8 base;
	u8 id;
	u8 table_len;
	const u16 *table;
	u8 remap;
	struct regulator_desc desc;
	long unsigned int features;
	void *data;
};

struct twlreg_info___2 {
	u8 base;
	u8 id;
	u8 flags;
	struct regulator_desc desc;
	long unsigned int features;
	void *data;
};

struct uniphier_regulator_soc_data {
	int nclks;
	const char * const *clock_names;
	int nrsts;
	const char * const *reset_names;
	const struct regulator_desc *desc;
	const struct regmap_config *regconf;
};

struct uniphier_regulator_priv {
	struct clk_bulk_data clk[2];
	struct reset_control *rst[2];
	const struct uniphier_regulator_soc_data *data;
};

struct reset_control_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
};

struct reset_control___2 {
	struct reset_controller_dev *rcdev;
	struct list_head list;
	unsigned int id;
	struct kref refcnt;
	bool acquired;
	bool shared;
	bool array;
	atomic_t deassert_count;
	atomic_t triggered_count;
};

struct reset_control_array {
	struct reset_control___2 base;
	unsigned int num_rstcs;
	struct reset_control___2 *rstc[0];
};

enum hi6220_reset_ctrl_type {
	PERIPHERAL = 0,
	MEDIA = 1,
	AO = 2,
};

struct hi6220_reset_data {
	struct reset_controller_dev rc_dev;
	struct regmap *regmap;
};

struct hi3660_reset_controller {
	struct reset_controller_dev rst;
	struct regmap *map;
};

struct syscfg_reset_channel_data {
	const char *compatible;
	struct reg_field reset;
	struct reg_field ack;
};

struct syscfg_reset_controller_data {
	bool wait_for_ack;
	bool active_low;
	int nr_channels;
	const struct syscfg_reset_channel_data *channels;
};

struct syscfg_reset_channel {
	struct regmap_field *reset;
	struct regmap_field *ack;
};

struct syscfg_reset_controller {
	struct reset_controller_dev rst;
	bool active_low;
	struct syscfg_reset_channel *channels;
};

struct berlin_reset_priv {
	struct regmap *regmap;
	struct reset_controller_dev rcdev;
};

struct brcmstb_reset {
	void *base;
	struct reset_controller_dev rcdev;
};

struct brcm_rescal_reset {
	void *base;
	struct device *dev;
	struct reset_controller_dev rcdev;
};

struct imx7_src_signal {
	unsigned int offset;
	unsigned int bit;
};

struct imx7_src_variant {
	const struct imx7_src_signal *signals;
	unsigned int signals_num;
	struct reset_control_ops ops;
};

struct imx7_src {
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	const struct imx7_src_signal *signals;
};

enum imx7_src_registers {
	SRC_A7RCR0 = 4,
	SRC_M4RCR = 12,
	SRC_ERCR = 20,
	SRC_HSICPHY_RCR = 28,
	SRC_USBOPHY1_RCR = 32,
	SRC_USBOPHY2_RCR = 36,
	SRC_MIPIPHY_RCR = 40,
	SRC_PCIEPHY_RCR = 44,
	SRC_DDRC_RCR = 4096,
};

enum imx8mq_src_registers {
	SRC_A53RCR0 = 4,
	SRC_HDMI_RCR = 48,
	SRC_DISP_RCR = 52,
	SRC_GPU_RCR = 64,
	SRC_VPU_RCR = 68,
	SRC_PCIE2_RCR = 72,
	SRC_MIPIPHY1_RCR = 76,
	SRC_MIPIPHY2_RCR = 80,
	SRC_DDRC2_RCR = 4100,
};

enum imx8mp_src_registers {
	SRC_SUPERMIX_RCR = 24,
	SRC_AUDIOMIX_RCR = 28,
	SRC_MLMIX_RCR = 40,
	SRC_GPU2D_RCR = 56,
	SRC_GPU3D_RCR = 60,
	SRC_VPU_G1_RCR = 72,
	SRC_VPU_G2_RCR = 76,
	SRC_VPUVC8KE_RCR = 80,
	SRC_NOC_RCR = 84,
};

struct meson_reset_param {
	int reg_count;
	int level_offset;
};

struct meson_reset {
	void *reg_base;
	const struct meson_reset_param *param;
	struct reset_controller_dev rcdev;
	spinlock_t lock;
};

struct rpi_reset {
	struct reset_controller_dev rcdev;
	struct rpi_firmware *fw;
};

struct reset_simple_devdata {
	u32 reg_offset;
	u32 nr_resets;
	bool active_low;
	bool status_active_low;
};

struct stm32_reset_data {
	struct reset_controller_dev rcdev;
	void *membase;
};

struct uniphier_reset_data {
	unsigned int id;
	unsigned int reg;
	unsigned int bit;
	unsigned int flags;
};

struct uniphier_reset_priv {
	struct reset_controller_dev rcdev;
	struct device *dev;
	struct regmap *regmap;
	const struct uniphier_reset_data *data;
};

struct uniphier_glue_reset_soc_data {
	int nclks;
	const char * const *clock_names;
	int nrsts;
	const char * const *reset_names;
};

struct uniphier_glue_reset_priv {
	struct clk_bulk_data clk[2];
	struct reset_control *rst[2];
	struct reset_simple_data rdata;
	const struct uniphier_glue_reset_soc_data *data;
};

struct zynq_reset_data {
	struct regmap *slcr;
	struct reset_controller_dev rcdev;
	u32 offset;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[8];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[128];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pts_fs_info___2;

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[24];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[2];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[4];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[24];
	long unsigned int relbit[1];
	long unsigned int absbit[2];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[4];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[24];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
	int: 24;
	int: 32;
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[4];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[24];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[24];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct consolefontdesc {
	short unsigned int charcount;
	short unsigned int charheight;
	char *chardata;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	char: 1;
	unsigned char modeflags: 5;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct kbd_led_trigger {
	struct led_trigger trigger;
	unsigned int mask;
};

struct uni_pagedir {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, int);
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	__u32 padding[5];
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef unsigned int upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int timeout;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct gpio_desc *rs485_term_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	upf_t flags;
	unsigned int type;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

enum {
	PLAT8250_DEV_LEGACY = 4294967295,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct uart_8250_port;

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	short unsigned int bugs;
	bool fifo_bug;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char mcr_mask;
	unsigned char mcr_force;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	unsigned char lsr_saved_flags;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	int (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, int);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *);
	void (*rs485_stop_tx)(struct uart_8250_port *);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
	int: 31;
	int: 32;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct irq_info {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u8 dlf_size;
};

struct pciserial_board {
	unsigned int flags;
	unsigned int num_ports;
	unsigned int base_baud;
	unsigned int uart_offset;
	unsigned int reg_shift;
	unsigned int first_offset;
};

struct serial_private;

struct pci_serial_quirk {
	u32 vendor;
	u32 device;
	u32 subvendor;
	u32 subdevice;
	int (*probe)(struct pci_dev *);
	int (*init)(struct pci_dev *);
	int (*setup)(struct serial_private *, const struct pciserial_board *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct serial_private {
	struct pci_dev *dev;
	unsigned int nr;
	struct pci_serial_quirk *quirk;
	const struct pciserial_board *board;
	int line[0];
};

struct f815xxa_data {
	spinlock_t lock;
	int idx;
};

struct timedia_struct {
	int num;
	const short unsigned int *ids;
};

struct quatech_feature {
	u16 devid;
	bool amcc;
};

enum pci_board_num_t {
	pbn_default = 0,
	pbn_b0_1_115200 = 1,
	pbn_b0_2_115200 = 2,
	pbn_b0_4_115200 = 3,
	pbn_b0_5_115200 = 4,
	pbn_b0_8_115200 = 5,
	pbn_b0_1_921600 = 6,
	pbn_b0_2_921600 = 7,
	pbn_b0_4_921600 = 8,
	pbn_b0_2_1130000 = 9,
	pbn_b0_4_1152000 = 10,
	pbn_b0_4_1250000 = 11,
	pbn_b0_2_1843200 = 12,
	pbn_b0_4_1843200 = 13,
	pbn_b0_1_4000000 = 14,
	pbn_b0_bt_1_115200 = 15,
	pbn_b0_bt_2_115200 = 16,
	pbn_b0_bt_4_115200 = 17,
	pbn_b0_bt_8_115200 = 18,
	pbn_b0_bt_1_460800 = 19,
	pbn_b0_bt_2_460800 = 20,
	pbn_b0_bt_4_460800 = 21,
	pbn_b0_bt_1_921600 = 22,
	pbn_b0_bt_2_921600 = 23,
	pbn_b0_bt_4_921600 = 24,
	pbn_b0_bt_8_921600 = 25,
	pbn_b1_1_115200 = 26,
	pbn_b1_2_115200 = 27,
	pbn_b1_4_115200 = 28,
	pbn_b1_8_115200 = 29,
	pbn_b1_16_115200 = 30,
	pbn_b1_1_921600 = 31,
	pbn_b1_2_921600 = 32,
	pbn_b1_4_921600 = 33,
	pbn_b1_8_921600 = 34,
	pbn_b1_2_1250000 = 35,
	pbn_b1_bt_1_115200 = 36,
	pbn_b1_bt_2_115200 = 37,
	pbn_b1_bt_4_115200 = 38,
	pbn_b1_bt_2_921600 = 39,
	pbn_b1_1_1382400 = 40,
	pbn_b1_2_1382400 = 41,
	pbn_b1_4_1382400 = 42,
	pbn_b1_8_1382400 = 43,
	pbn_b2_1_115200 = 44,
	pbn_b2_2_115200 = 45,
	pbn_b2_4_115200 = 46,
	pbn_b2_8_115200 = 47,
	pbn_b2_1_460800 = 48,
	pbn_b2_4_460800 = 49,
	pbn_b2_8_460800 = 50,
	pbn_b2_16_460800 = 51,
	pbn_b2_1_921600 = 52,
	pbn_b2_4_921600 = 53,
	pbn_b2_8_921600 = 54,
	pbn_b2_8_1152000 = 55,
	pbn_b2_bt_1_115200 = 56,
	pbn_b2_bt_2_115200 = 57,
	pbn_b2_bt_4_115200 = 58,
	pbn_b2_bt_2_921600 = 59,
	pbn_b2_bt_4_921600 = 60,
	pbn_b3_2_115200 = 61,
	pbn_b3_4_115200 = 62,
	pbn_b3_8_115200 = 63,
	pbn_b4_bt_2_921600 = 64,
	pbn_b4_bt_4_921600 = 65,
	pbn_b4_bt_8_921600 = 66,
	pbn_panacom = 67,
	pbn_panacom2 = 68,
	pbn_panacom4 = 69,
	pbn_plx_romulus = 70,
	pbn_endrun_2_4000000 = 71,
	pbn_oxsemi = 72,
	pbn_oxsemi_1_4000000 = 73,
	pbn_oxsemi_2_4000000 = 74,
	pbn_oxsemi_4_4000000 = 75,
	pbn_oxsemi_8_4000000 = 76,
	pbn_intel_i960 = 77,
	pbn_sgi_ioc3 = 78,
	pbn_computone_4 = 79,
	pbn_computone_6 = 80,
	pbn_computone_8 = 81,
	pbn_sbsxrsio = 82,
	pbn_pasemi_1682M = 83,
	pbn_ni8430_2 = 84,
	pbn_ni8430_4 = 85,
	pbn_ni8430_8 = 86,
	pbn_ni8430_16 = 87,
	pbn_ADDIDATA_PCIe_1_3906250 = 88,
	pbn_ADDIDATA_PCIe_2_3906250 = 89,
	pbn_ADDIDATA_PCIe_4_3906250 = 90,
	pbn_ADDIDATA_PCIe_8_3906250 = 91,
	pbn_ce4100_1_115200 = 92,
	pbn_omegapci = 93,
	pbn_NETMOS9900_2s_115200 = 94,
	pbn_brcm_trumanage = 95,
	pbn_fintek_4 = 96,
	pbn_fintek_8 = 97,
	pbn_fintek_12 = 98,
	pbn_fintek_F81504A = 99,
	pbn_fintek_F81508A = 100,
	pbn_fintek_F81512A = 101,
	pbn_wch382_2 = 102,
	pbn_wch384_4 = 103,
	pbn_wch384_8 = 104,
	pbn_pericom_PI7C9X7951 = 105,
	pbn_pericom_PI7C9X7952 = 106,
	pbn_pericom_PI7C9X7954 = 107,
	pbn_pericom_PI7C9X7958 = 108,
	pbn_sunix_pci_1s = 109,
	pbn_sunix_pci_2s = 110,
	pbn_sunix_pci_4s = 111,
	pbn_sunix_pci_8s = 112,
	pbn_sunix_pci_16s = 113,
	pbn_moxa8250_2p = 114,
	pbn_moxa8250_4p = 115,
	pbn_moxa8250_8p = 116,
};

struct exar8250_platform {
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*register_gpio)(struct pci_dev *, struct uart_8250_port *);
};

struct exar8250;

struct exar8250_board {
	unsigned int num_ports;
	unsigned int reg_shift;
	int (*setup)(struct exar8250 *, struct pci_dev *, struct uart_8250_port *, int);
	void (*exit)(struct pci_dev *);
};

struct exar8250 {
	unsigned int nr;
	struct exar8250_board *board;
	void *virt;
	int line[0];
};

struct bcm2835aux_data {
	struct clk *clk;
	int line;
	u32 cntl;
};

struct dw8250_data {
	struct dw8250_port_data data;
	u8 usr_reg;
	int msr_mask_on;
	int msr_mask_off;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_notifier;
	struct work_struct clk_work;
	struct reset_control *rst;
	unsigned int skip_autocfg: 1;
	unsigned int uart_16550_compatible: 1;
};

struct serial8250_em_priv {
	struct clk *sclk;
	int line;
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

struct omap8250_priv {
	int line;
	u8 habit;
	u8 mdr1;
	u8 efr;
	u8 scr;
	u8 wer;
	u8 xon;
	u8 xoff;
	u8 delayed_restore;
	u16 quot;
	u8 tx_trigger;
	u8 rx_trigger;
	bool is_suspending;
	int wakeirq;
	int wakeups_enabled;
	u32 latency;
	u32 calc_latency;
	struct pm_qos_request pm_qos_request;
	struct work_struct qos_work;
	struct uart_8250_dma omap8250_dma;
	spinlock_t rx_dma_lock;
	bool rx_dma_broken;
	bool throttled;
};

struct omap8250_dma_params {
	u32 rx_size;
	u8 rx_trigger;
	u8 tx_trigger;
};

struct omap8250_platdata {
	struct omap8250_dma_params *dma_params;
	u8 habit;
};

enum dma_rx_status {
	DMA_RX_START = 0,
	DMA_RX_RUNNING = 1,
	DMA_RX_SHUTDOWN = 2,
};

struct mtk8250_data {
	int line;
	unsigned int rx_pos;
	unsigned int clk_count;
	struct clk *uart_clk;
	struct clk *bus_clk;
	struct uart_8250_dma *dma;
	enum dma_rx_status rx_status;
	int rx_wakeup_irq;
};

enum {
	MTK_UART_FC_NONE = 0,
	MTK_UART_FC_SW = 1,
	MTK_UART_FC_HW = 2,
};

struct uniphier8250_priv {
	int line;
	struct clk *clk;
	spinlock_t atomic_write_lock;
};

struct tegra_uart {
	struct clk *clk;
	struct reset_control *rst;
	int line;
};

struct of_serial_info {
	struct clk *clk;
	struct reset_control *rst;
	int type;
	int line;
};

struct amba_pl011_data {
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	bool dma_rx_poll_enable;
	unsigned int dma_rx_poll_rate;
	unsigned int dma_rx_poll_timeout;
	void (*init)();
	void (*exit)();
};

enum {
	REG_DR = 0,
	REG_ST_DMAWM = 1,
	REG_ST_TIMEOUT = 2,
	REG_FR = 3,
	REG_LCRH_RX = 4,
	REG_LCRH_TX = 5,
	REG_IBRD = 6,
	REG_FBRD = 7,
	REG_CR = 8,
	REG_IFLS = 9,
	REG_IMSC = 10,
	REG_RIS = 11,
	REG_MIS = 12,
	REG_ICR = 13,
	REG_DMACR = 14,
	REG_ST_XFCR = 15,
	REG_ST_XON1 = 16,
	REG_ST_XON2 = 17,
	REG_ST_XOFF1 = 18,
	REG_ST_XOFF2 = 19,
	REG_ST_ITCR = 20,
	REG_ST_ITIP = 21,
	REG_ST_ABCR = 22,
	REG_ST_ABIMSC = 23,
	REG_ARRAY_SIZE = 24,
};

struct vendor_data {
	const u16 *reg_offset;
	unsigned int ifls;
	unsigned int fr_busy;
	unsigned int fr_dsr;
	unsigned int fr_cts;
	unsigned int fr_ri;
	unsigned int inv_fr;
	bool access_32b;
	bool oversampling;
	bool dma_threshold;
	bool cts_event_workaround;
	bool always_enabled;
	bool fixed_options;
	unsigned int (*get_fifosize)(struct amba_device *);
};

struct pl011_sgbuf {
	struct scatterlist sg;
	char *buf;
};

struct pl011_dmarx_data {
	struct dma_chan *chan;
	struct completion complete;
	bool use_buf_b;
	struct pl011_sgbuf sgbuf_a;
	struct pl011_sgbuf sgbuf_b;
	dma_cookie_t cookie;
	bool running;
	struct timer_list timer;
	unsigned int last_residue;
	long unsigned int last_jiffies;
	bool auto_poll_rate;
	unsigned int poll_rate;
	unsigned int poll_timeout;
};

struct pl011_dmatx_data {
	struct dma_chan *chan;
	struct scatterlist sg;
	char *buf;
	bool queued;
};

struct uart_amba_port {
	struct uart_port port;
	const u16 *reg_offset;
	struct clk *clk;
	const struct vendor_data *vendor;
	unsigned int dmacr;
	unsigned int im;
	unsigned int old_status;
	unsigned int fifosize;
	unsigned int old_cr;
	unsigned int fixed_baud;
	char type[12];
	bool using_tx_dma;
	bool using_rx_dma;
	struct pl011_dmarx_data dmarx;
	struct pl011_dmatx_data dmatx;
	bool dma_probed;
};

struct s3c2410_uartcfg {
	unsigned char hwport;
	unsigned char unused;
	short unsigned int flags;
	upf_t uart_flags;
	unsigned int clk_sel;
	unsigned int has_fracval;
	long unsigned int ucon;
	long unsigned int ulcon;
	long unsigned int ufcon;
};

struct s3c24xx_uart_info {
	char *name;
	unsigned int type;
	unsigned int fifosize;
	long unsigned int rx_fifomask;
	long unsigned int rx_fifoshift;
	long unsigned int rx_fifofull;
	long unsigned int tx_fifomask;
	long unsigned int tx_fifoshift;
	long unsigned int tx_fifofull;
	unsigned int def_clk_sel;
	long unsigned int num_clks;
	long unsigned int clksel_mask;
	long unsigned int clksel_shift;
	unsigned int has_divslot: 1;
};

struct s3c24xx_serial_drv_data {
	struct s3c24xx_uart_info *info;
	struct s3c2410_uartcfg *def_cfg;
	unsigned int fifosize[4];
};

struct s3c24xx_uart_dma {
	unsigned int rx_chan_id;
	unsigned int tx_chan_id;
	struct dma_slave_config rx_conf;
	struct dma_slave_config tx_conf;
	struct dma_chan *rx_chan;
	struct dma_chan *tx_chan;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	char *rx_buf;
	dma_addr_t tx_transfer_addr;
	size_t rx_size;
	size_t tx_size;
	struct dma_async_tx_descriptor *tx_desc;
	struct dma_async_tx_descriptor *rx_desc;
	int tx_bytes_requested;
	int rx_bytes_requested;
};

struct s3c24xx_uart_port {
	unsigned char rx_claimed;
	unsigned char tx_claimed;
	unsigned char rx_enabled;
	unsigned char tx_enabled;
	unsigned int pm_level;
	long unsigned int baudclk_rate;
	unsigned int min_dma_size;
	unsigned int rx_irq;
	unsigned int tx_irq;
	unsigned int tx_in_progress;
	unsigned int tx_mode;
	unsigned int rx_mode;
	struct s3c24xx_uart_info *info;
	struct clk *clk;
	struct clk *baudclk;
	struct uart_port port;
	struct s3c24xx_serial_drv_data *drv_data;
	struct s3c2410_uartcfg *cfg;
	struct s3c24xx_uart_dma *dma;
};

struct samsung_early_console_data {
	u32 txfull_mask;
};

enum {
	SCIx_PROBE_REGTYPE = 0,
	SCIx_SCI_REGTYPE = 1,
	SCIx_IRDA_REGTYPE = 2,
	SCIx_SCIFA_REGTYPE = 3,
	SCIx_SCIFB_REGTYPE = 4,
	SCIx_SH2_SCIF_FIFODATA_REGTYPE = 5,
	SCIx_SH3_SCIF_REGTYPE = 6,
	SCIx_SH4_SCIF_REGTYPE = 7,
	SCIx_SH4_SCIF_BRG_REGTYPE = 8,
	SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE = 9,
	SCIx_SH4_SCIF_FIFODATA_REGTYPE = 10,
	SCIx_SH7705_SCIF_REGTYPE = 11,
	SCIx_HSCIF_REGTYPE = 12,
	SCIx_RZ_SCIFA_REGTYPE = 13,
	SCIx_NR_REGTYPES = 14,
};

struct plat_sci_port_ops {
	void (*init_pins)(struct uart_port *, unsigned int);
};

struct plat_sci_port {
	unsigned int type;
	upf_t flags;
	unsigned int sampling_rate;
	unsigned int scscr;
	unsigned char regtype;
	struct plat_sci_port_ops *ops;
};

enum {
	SCSMR = 0,
	SCBRR = 1,
	SCSCR = 2,
	SCxSR = 3,
	SCFCR = 4,
	SCFDR = 5,
	SCxTDR = 6,
	SCxRDR = 7,
	SCLSR = 8,
	SCTFDR = 9,
	SCRFDR = 10,
	SCSPTR = 11,
	HSSRR = 12,
	SCPCR = 13,
	SCPDR = 14,
	SCDL = 15,
	SCCKS = 16,
	HSRTRGR = 17,
	HSTTRGR = 18,
	SCIx_NR_REGS = 19,
};

enum {
	SCIx_ERI_IRQ = 0,
	SCIx_RXI_IRQ = 1,
	SCIx_TXI_IRQ = 2,
	SCIx_BRI_IRQ = 3,
	SCIx_DRI_IRQ = 4,
	SCIx_TEI_IRQ = 5,
	SCIx_NR_IRQS = 6,
	SCIx_MUX_IRQ = 6,
};

enum SCI_CLKS {
	SCI_FCK = 0,
	SCI_SCK = 1,
	SCI_BRG_INT = 2,
	SCI_SCIF_CLK = 3,
	SCI_NUM_CLKS = 4,
};

struct plat_sci_reg {
	u8 offset;
	u8 size;
};

struct sci_port_params {
	const struct plat_sci_reg regs[19];
	unsigned int fifosize;
	unsigned int overrun_reg;
	unsigned int overrun_mask;
	unsigned int sampling_rate_mask;
	unsigned int error_mask;
	unsigned int error_clear;
};

struct sci_port {
	struct uart_port port;
	const struct sci_port_params *params;
	const struct plat_sci_port *cfg;
	unsigned int sampling_rate_mask;
	resource_size_t reg_size;
	struct mctrl_gpios *gpios;
	struct clk *clks[4];
	long unsigned int clk_rates[4];
	int irqs[6];
	char *irqstr[6];
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_tx_saved;
	struct dma_chan *chan_rx_saved;
	dma_cookie_t cookie_tx;
	dma_cookie_t cookie_rx[2];
	dma_cookie_t active_rx;
	dma_addr_t tx_dma_addr;
	unsigned int tx_dma_len;
	struct scatterlist sg_rx[2];
	void *rx_buf[2];
	size_t buf_len_rx;
	struct work_struct work_tx;
	struct hrtimer rx_timer;
	unsigned int rx_timeout;
	unsigned int rx_frame;
	int rx_trigger;
	struct timer_list rx_fifo_timer;
	int rx_fifo_timeout;
	u16 hscif_tot;
	bool has_rtscts;
	bool autorts;
};

struct sci_irq_desc {
	const char *desc;
	irq_handler_t handler;
};

enum imx_uart_type {
	IMX1_UART = 0,
	IMX21_UART = 1,
	IMX53_UART = 2,
	IMX6Q_UART = 3,
};

struct imx_uart_data {
	unsigned int uts_reg;
	enum imx_uart_type devtype;
};

enum imx_tx_state {
	OFF = 0,
	WAIT_AFTER_RTS = 1,
	SEND = 2,
	WAIT_AFTER_SEND = 3,
};

struct imx_port {
	struct uart_port port;
	struct timer_list timer;
	unsigned int old_status;
	unsigned int have_rtscts: 1;
	unsigned int have_rtsgpio: 1;
	unsigned int dte_mode: 1;
	unsigned int inverted_tx: 1;
	unsigned int inverted_rx: 1;
	struct clk *clk_ipg;
	struct clk *clk_per;
	const struct imx_uart_data *devdata;
	struct mctrl_gpios *gpios;
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
	unsigned int ucr4;
	unsigned int ufcr;
	unsigned int dma_is_enabled: 1;
	unsigned int dma_is_rxing: 1;
	unsigned int dma_is_txing: 1;
	struct dma_chan *dma_chan_rx;
	struct dma_chan *dma_chan_tx;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	void *rx_buf;
	struct circ_buf rx_ring;
	unsigned int rx_periods;
	dma_cookie_t rx_cookie;
	unsigned int tx_bytes;
	unsigned int dma_tx_nents;
	unsigned int saved_reg[10];
	bool context_saved;
	enum imx_tx_state tx_state;
	struct hrtimer trigger_start_tx;
	struct hrtimer trigger_stop_tx;
};

struct imx_port_ucrs {
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
};

struct atmel_dma_buffer {
	unsigned char *buf;
	dma_addr_t dma_addr;
	unsigned int dma_size;
	unsigned int ofs;
};

struct atmel_uart_char {
	u16 status;
	u16 ch;
};

struct atmel_uart_port {
	struct uart_port uart;
	struct clk *clk;
	int may_wakeup;
	u32 backup_imr;
	int break_active;
	bool use_dma_rx;
	bool use_pdc_rx;
	short int pdc_rx_idx;
	struct atmel_dma_buffer pdc_rx[2];
	bool use_dma_tx;
	bool use_pdc_tx;
	struct atmel_dma_buffer pdc_tx;
	spinlock_t lock_tx;
	spinlock_t lock_rx;
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_async_tx_descriptor *desc_tx;
	struct dma_async_tx_descriptor *desc_rx;
	dma_cookie_t cookie_tx;
	dma_cookie_t cookie_rx;
	struct scatterlist sg_tx;
	struct scatterlist sg_rx;
	struct tasklet_struct tasklet_rx;
	struct tasklet_struct tasklet_tx;
	atomic_t tasklet_shutdown;
	unsigned int irq_status_prev;
	unsigned int tx_len;
	struct circ_buf rx_ring;
	struct mctrl_gpios *gpios;
	u32 backup_mode;
	u32 backup_brgr;
	unsigned int tx_done_mask;
	u32 fifo_size;
	u32 rts_high;
	u32 rts_low;
	bool ms_irq_enabled;
	u32 rtor;
	bool has_frac_baudrate;
	bool has_hw_timer;
	struct timer_list uart_timer;
	bool tx_stopped;
	bool suspended;
	unsigned int pending;
	unsigned int pending_status;
	spinlock_t lock_suspended;
	bool hd_start_rx;
	unsigned int fidi_min;
	unsigned int fidi_max;
	struct {
		u32 cr;
		u32 mr;
		u32 imr;
		u32 brgr;
		u32 rtor;
		u32 ttgr;
		u32 fmr;
		u32 fimr;
	} cache;
	int (*prepare_rx)(struct uart_port *);
	int (*prepare_tx)(struct uart_port *);
	void (*schedule_rx)(struct uart_port *);
	void (*schedule_tx)(struct uart_port *);
	void (*release_rx)(struct uart_port *);
	void (*release_tx)(struct uart_port *);
};

enum {
	UARTDM_1P1 = 1,
	UARTDM_1P2 = 2,
	UARTDM_1P3 = 3,
	UARTDM_1P4 = 4,
};

struct msm_dma {
	struct dma_chan *chan;
	enum dma_data_direction dir;
	dma_addr_t phys;
	unsigned char *virt;
	dma_cookie_t cookie;
	u32 enable_bit;
	unsigned int count;
	struct dma_async_tx_descriptor *desc;
};

struct msm_port {
	struct uart_port uart;
	char name[16];
	struct clk *clk;
	struct clk *pclk;
	unsigned int imr;
	int is_uartdm;
	unsigned int old_snap_state;
	bool break_detected;
	struct msm_dma tx_dma;
	struct msm_dma rx_dma;
};

struct msm_baud_map {
	u16 divisor;
	u8 code;
	u8 rxstale;
};

struct omap_uart_port_info {
	bool dma_enabled;
	unsigned int uartclk;
	upf_t flags;
	unsigned int dma_rx_buf_size;
	unsigned int dma_rx_timeout;
	unsigned int autosuspend_timeout;
	unsigned int dma_rx_poll_rate;
	int (*get_context_loss_count)(struct device *);
	void (*enable_wakeup)(struct device *, bool);
};

struct uart_omap_dma {
	u8 uart_dma_tx;
	u8 uart_dma_rx;
	int rx_dma_channel;
	int tx_dma_channel;
	dma_addr_t rx_buf_dma_phys;
	dma_addr_t tx_buf_dma_phys;
	unsigned int uart_base;
	unsigned char *rx_buf;
	unsigned int prev_rx_dma_pos;
	int tx_buf_size;
	int tx_dma_used;
	int rx_dma_used;
	spinlock_t tx_lock;
	spinlock_t rx_lock;
	struct timer_list rx_timer;
	unsigned int rx_buf_size;
	unsigned int rx_poll_rate;
	unsigned int rx_timeout;
};

struct uart_omap_port {
	struct uart_port port;
	struct uart_omap_dma uart_dma;
	struct device *dev;
	int wakeirq;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char fcr;
	unsigned char efr;
	unsigned char dll;
	unsigned char dlh;
	unsigned char mdr1;
	unsigned char scr;
	unsigned char wer;
	int use_dma;
	unsigned int lsr_break_flag;
	unsigned char msr_saved_flags;
	char name[20];
	long unsigned int port_activity;
	int context_loss_cnt;
	u32 errata;
	u32 features;
	struct gpio_desc *rts_gpiod;
	struct pm_qos_request pm_qos_request;
	u32 latency;
	u32 calc_latency;
	struct work_struct qos_work;
	bool is_suspending;
};

struct asc_port {
	struct uart_port port;
	struct gpio_desc *rts;
	struct clk *clk;
	struct pinctrl *pinctrl;
	struct pinctrl_state *states[2];
	unsigned int hw_flow_control: 1;
	unsigned int force_m1: 1;
};

struct vt8500_port {
	struct uart_port uart;
	char name[16];
	struct clk *clk;
	unsigned int clk_predivisor;
	unsigned int ier;
	unsigned int vt8500_uart_flags;
};

struct cdns_uart {
	struct uart_port *port;
	struct clk *uartclk;
	struct clk *pclk;
	struct uart_driver *cdns_uart_driver;
	unsigned int baud;
	struct notifier_block clk_rate_change_nb;
	u32 quirks;
	bool cts_override;
};

struct cdns_platform_data {
	u32 quirks;
};

struct sirfsoc_uart_param {
	const char *uart_name;
	const char *port_name;
};

struct sirfsoc_register {
	u32 sirfsoc_line_ctrl;
	u32 sirfsoc_divisor;
	u32 sirfsoc_tx_rx_en;
	u32 sirfsoc_int_en_reg;
	u32 sirfsoc_int_st_reg;
	u32 sirfsoc_int_en_clr_reg;
	u32 sirfsoc_tx_dma_io_ctrl;
	u32 sirfsoc_tx_dma_io_len;
	u32 sirfsoc_tx_fifo_ctrl;
	u32 sirfsoc_tx_fifo_level_chk;
	u32 sirfsoc_tx_fifo_op;
	u32 sirfsoc_tx_fifo_status;
	u32 sirfsoc_tx_fifo_data;
	u32 sirfsoc_rx_dma_io_ctrl;
	u32 sirfsoc_rx_dma_io_len;
	u32 sirfsoc_rx_fifo_ctrl;
	u32 sirfsoc_rx_fifo_level_chk;
	u32 sirfsoc_rx_fifo_op;
	u32 sirfsoc_rx_fifo_status;
	u32 sirfsoc_rx_fifo_data;
	u32 sirfsoc_afc_ctrl;
	u32 sirfsoc_swh_dma_io;
	u32 sirfsoc_mode1;
	u32 sirfsoc_mode2;
	u32 sirfsoc_tx_frame_ctrl;
	u32 sirfsoc_rx_frame_ctrl;
	u32 sirfsoc_async_param_reg;
};

typedef u32 (*fifo_full_mask)(struct uart_port *);

typedef u32 (*fifo_empty_mask)(struct uart_port *);

struct sirfsoc_fifo_status {
	fifo_full_mask ff_full;
	fifo_empty_mask ff_empty;
};

struct sirfsoc_int_en {
	u32 sirfsoc_rx_done_en;
	u32 sirfsoc_tx_done_en;
	u32 sirfsoc_rx_oflow_en;
	u32 sirfsoc_tx_allout_en;
	u32 sirfsoc_rx_io_dma_en;
	u32 sirfsoc_tx_io_dma_en;
	u32 sirfsoc_rxfifo_full_en;
	u32 sirfsoc_txfifo_empty_en;
	u32 sirfsoc_rxfifo_thd_en;
	u32 sirfsoc_txfifo_thd_en;
	u32 sirfsoc_frm_err_en;
	u32 sirfsoc_rxd_brk_en;
	u32 sirfsoc_rx_timeout_en;
	u32 sirfsoc_parity_err_en;
	u32 sirfsoc_cts_en;
	u32 sirfsoc_rts_en;
};

struct sirfsoc_int_status {
	u32 sirfsoc_rx_done;
	u32 sirfsoc_tx_done;
	u32 sirfsoc_rx_oflow;
	u32 sirfsoc_tx_allout;
	u32 sirfsoc_rx_io_dma;
	u32 sirfsoc_tx_io_dma;
	u32 sirfsoc_rxfifo_full;
	u32 sirfsoc_txfifo_empty;
	u32 sirfsoc_rxfifo_thd;
	u32 sirfsoc_txfifo_thd;
	u32 sirfsoc_frm_err;
	u32 sirfsoc_rxd_brk;
	u32 sirfsoc_rx_timeout;
	u32 sirfsoc_parity_err;
	u32 sirfsoc_cts;
	u32 sirfsoc_rts;
};

enum sirfsoc_uart_type {
	SIRF_REAL_UART = 0,
	SIRF_USP_UART = 1,
};

struct sirfsoc_uart_register {
	struct sirfsoc_register uart_reg;
	struct sirfsoc_int_en uart_int_en;
	struct sirfsoc_int_status uart_int_st;
	struct sirfsoc_fifo_status fifo_status;
	struct sirfsoc_uart_param uart_param;
	enum sirfsoc_uart_type uart_type;
};

struct sirfsoc_baudrate_to_regv {
	unsigned int baud_rate;
	unsigned int reg_val;
};

enum sirfsoc_tx_state {
	TX_DMA_IDLE = 0,
	TX_DMA_RUNNING = 1,
	TX_DMA_PAUSE = 2,
};

struct sirfsoc_rx_buffer {
	struct circ_buf xmit;
	dma_cookie_t cookie;
	struct dma_async_tx_descriptor *desc;
	dma_addr_t dma_addr;
};

struct sirfsoc_uart_port {
	bool hw_flow_ctrl;
	bool ms_enabled;
	struct uart_port port;
	struct clk *clk;
	bool is_atlas7;
	struct sirfsoc_uart_register *uart_reg;
	struct dma_chan *rx_dma_chan;
	struct dma_chan *tx_dma_chan;
	dma_addr_t tx_dma_addr;
	struct dma_async_tx_descriptor *tx_dma_desc;
	long unsigned int transfer_size;
	enum sirfsoc_tx_state tx_dma_state;
	unsigned int cts_gpio;
	unsigned int rts_gpio;
	struct sirfsoc_rx_buffer rx_dma_items;
	struct hrtimer hrt;
	bool is_hrt_enabled;
	long unsigned int rx_period_time;
	long unsigned int rx_last_pos;
	long unsigned int pio_fetch_cnt;
};

struct tegra_uart_chip_data {
	bool tx_fifo_full_status;
	bool allow_txfifo_reset_fifo_mode;
	bool support_clk_src_div;
	bool fifo_mode_enable_status;
	int uart_max_port;
	int max_dma_burst_bytes;
	int error_tolerance_low_range;
	int error_tolerance_high_range;
};

struct tegra_baud_tolerance {
	u32 lower_range_baud;
	u32 upper_range_baud;
	s32 tolerance;
};

struct tegra_uart_port {
	struct uart_port uport;
	const struct tegra_uart_chip_data *cdata;
	struct clk *uart_clk;
	struct reset_control *rst;
	unsigned int current_baud;
	long unsigned int fcr_shadow;
	long unsigned int mcr_shadow;
	long unsigned int lcr_shadow;
	long unsigned int ier_shadow;
	bool rts_active;
	int tx_in_progress;
	unsigned int tx_bytes;
	bool enable_modem_interrupt;
	bool rx_timeout;
	int rx_in_progress;
	int symb_bit;
	struct dma_chan *rx_dma_chan;
	struct dma_chan *tx_dma_chan;
	dma_addr_t rx_dma_buf_phys;
	dma_addr_t tx_dma_buf_phys;
	unsigned char *rx_dma_buf_virt;
	unsigned char *tx_dma_buf_virt;
	struct dma_async_tx_descriptor *tx_dma_desc;
	struct dma_async_tx_descriptor *rx_dma_desc;
	dma_cookie_t tx_cookie;
	dma_cookie_t rx_cookie;
	unsigned int tx_bytes_requested;
	unsigned int rx_bytes_requested;
	struct tegra_baud_tolerance *baud_tolerance;
	int n_adjustable_baud_rates;
	int required_rate;
	int configured_rate;
	bool use_rx_pio;
	bool use_tx_pio;
	bool rx_dma_active;
};

enum lpuart_type {
	VF610_LPUART = 0,
	LS1021A_LPUART = 1,
	LS1028A_LPUART = 2,
	IMX7ULP_LPUART = 3,
	IMX8QXP_LPUART = 4,
};

struct lpuart_port {
	struct uart_port port;
	enum lpuart_type devtype;
	struct clk *ipg_clk;
	struct clk *baud_clk;
	unsigned int txfifo_size;
	unsigned int rxfifo_size;
	bool lpuart_dma_tx_use;
	bool lpuart_dma_rx_use;
	struct dma_chan *dma_tx_chan;
	struct dma_chan *dma_rx_chan;
	struct dma_async_tx_descriptor *dma_tx_desc;
	struct dma_async_tx_descriptor *dma_rx_desc;
	dma_cookie_t dma_tx_cookie;
	dma_cookie_t dma_rx_cookie;
	unsigned int dma_tx_bytes;
	unsigned int dma_rx_bytes;
	bool dma_tx_in_progress;
	unsigned int dma_rx_timeout;
	struct timer_list lpuart_timer;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	struct circ_buf rx_ring;
	int rx_dma_rng_buf_len;
	unsigned int dma_tx_nents;
	wait_queue_head_t dma_wait;
	bool id_allocated;
};

struct lpuart_soc_data {
	enum lpuart_type devtype;
	char iotype;
	u8 reg_off;
};

struct digicolor_port {
	struct uart_port port;
	struct delayed_work rx_poll_work;
};

struct stm32_usart_offsets {
	u8 cr1;
	u8 cr2;
	u8 cr3;
	u8 brr;
	u8 gtpr;
	u8 rtor;
	u8 rqr;
	u8 isr;
	u8 icr;
	u8 rdr;
	u8 tdr;
};

struct stm32_usart_config {
	u8 uart_enable_bit;
	bool has_7bits_data;
	bool has_wakeup;
	bool has_fifo;
	int fifosize;
};

struct stm32_usart_info {
	struct stm32_usart_offsets ofs;
	struct stm32_usart_config cfg;
};

struct stm32_port {
	struct uart_port port;
	struct clk *clk;
	struct stm32_usart_info *info;
	struct dma_chan *rx_ch;
	dma_addr_t rx_dma_buf;
	unsigned char *rx_buf;
	struct dma_chan *tx_ch;
	dma_addr_t tx_dma_buf;
	unsigned char *tx_buf;
	u32 cr1_irq;
	u32 cr3_irq;
	int last_res;
	bool tx_dma_busy;
	bool hw_flow_control;
	bool fifoen;
	int wakeirq;
	int rdr_mask;
	struct mctrl_gpios *gpios;
};

struct mctrl_gpios___2 {
	struct uart_port *port;
	struct gpio_desc *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

struct serdev_device;

struct serdev_device_ops {
	int (*receive_buf)(struct serdev_device *, const unsigned char *, size_t);
	void (*write_wakeup)(struct serdev_device *);
};

struct serdev_controller;

struct serdev_device {
	struct device dev;
	int nr;
	struct serdev_controller *ctrl;
	const struct serdev_device_ops *ops;
	struct completion write_comp;
	struct mutex write_lock;
};

struct serdev_controller_ops;

struct serdev_controller {
	struct device dev;
	unsigned int nr;
	struct serdev_device *serdev;
	const struct serdev_controller_ops *ops;
	int: 32;
};

struct serdev_device_driver {
	struct device_driver driver;
	int (*probe)(struct serdev_device *);
	void (*remove)(struct serdev_device *);
};

enum serdev_parity {
	SERDEV_PARITY_NONE = 0,
	SERDEV_PARITY_EVEN = 1,
	SERDEV_PARITY_ODD = 2,
};

struct serdev_controller_ops {
	int (*write_buf)(struct serdev_controller *, const unsigned char *, size_t);
	void (*write_flush)(struct serdev_controller *);
	int (*write_room)(struct serdev_controller *);
	int (*open)(struct serdev_controller *);
	void (*close)(struct serdev_controller *);
	void (*set_flow_control)(struct serdev_controller *, bool);
	int (*set_parity)(struct serdev_controller *, enum serdev_parity);
	unsigned int (*set_baudrate)(struct serdev_controller *, unsigned int);
	void (*wait_until_sent)(struct serdev_controller *, long int);
	int (*get_tiocm)(struct serdev_controller *);
	int (*set_tiocm)(struct serdev_controller *, unsigned int, unsigned int);
};

struct serport {
	struct tty_port *port;
	struct tty_struct *tty;
	struct tty_driver *tty_drv;
	int tty_idx;
	long unsigned int flags;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	cycles_t last_time;
	long int last_delta;
	long int last_delta2;
};

struct trace_event_raw_add_device_randomness {
	struct trace_entry ent;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__mix_pool_bytes {
	struct trace_entry ent;
	const char *pool_name;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_credit_entropy_bits {
	struct trace_entry ent;
	const char *pool_name;
	int bits;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_push_to_pool {
	struct trace_entry ent;
	const char *pool_name;
	int pool_bits;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_debit_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int debit_bits;
	char __data[0];
};

struct trace_event_raw_add_input_randomness {
	struct trace_entry ent;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_add_disk_randomness {
	struct trace_entry ent;
	dev_t dev;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_xfer_secondary_pool {
	struct trace_entry ent;
	const char *pool_name;
	int xfer_bits;
	int request_bits;
	int pool_entropy;
	int input_entropy;
	char __data[0];
};

struct trace_event_raw_random__get_random_bytes {
	struct trace_entry ent;
	int nbytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__extract_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int nbytes;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random_read {
	struct trace_entry ent;
	int got_bits;
	int need_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_urandom_read {
	struct trace_entry ent;
	int got_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_prandom_u32 {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_data_offsets_add_device_randomness {};

struct trace_event_data_offsets_random__mix_pool_bytes {};

struct trace_event_data_offsets_credit_entropy_bits {};

struct trace_event_data_offsets_push_to_pool {};

struct trace_event_data_offsets_debit_entropy {};

struct trace_event_data_offsets_add_input_randomness {};

struct trace_event_data_offsets_add_disk_randomness {};

struct trace_event_data_offsets_xfer_secondary_pool {};

struct trace_event_data_offsets_random__get_random_bytes {};

struct trace_event_data_offsets_random__extract_entropy {};

struct trace_event_data_offsets_random_read {};

struct trace_event_data_offsets_urandom_read {};

struct trace_event_data_offsets_prandom_u32 {};

typedef void (*btf_trace_add_device_randomness)(void *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes_nolock)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_credit_entropy_bits)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_push_to_pool)(void *, const char *, int, int);

typedef void (*btf_trace_debit_entropy)(void *, const char *, int);

typedef void (*btf_trace_add_input_randomness)(void *, int);

typedef void (*btf_trace_add_disk_randomness)(void *, dev_t, int);

typedef void (*btf_trace_xfer_secondary_pool)(void *, const char *, int, int, int, int);

typedef void (*btf_trace_get_random_bytes)(void *, int, long unsigned int);

typedef void (*btf_trace_get_random_bytes_arch)(void *, int, long unsigned int);

typedef void (*btf_trace_extract_entropy)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_extract_entropy_user)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_random_read)(void *, int, int, int, int);

typedef void (*btf_trace_urandom_read)(void *, int, int, int);

typedef void (*btf_trace_prandom_u32)(void *, unsigned int);

struct poolinfo {
	int poolbitshift;
	int poolwords;
	int poolbytes;
	int poolfracbits;
	int tap1;
	int tap2;
	int tap3;
	int tap4;
	int tap5;
};

struct crng_state {
	__u32 state[16];
	long unsigned int init_time;
	spinlock_t lock;
};

struct entropy_store {
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	spinlock_t lock;
	short unsigned int add_ptr;
	short unsigned int input_rotate;
	int entropy_count;
	unsigned int initialized: 1;
	unsigned int last_data_init: 1;
	__u8 last_data[10];
};

struct fast_pool {
	__u32 pool[4];
	long unsigned int last;
	short unsigned int reg_idx;
	unsigned char count;
};

struct batched_entropy {
	union {
		u64 entropy_u64[8];
		u32 entropy_u32[16];
	};
	unsigned int position;
	spinlock_t batch_lock;
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct ports_driver_data {
	struct class *class;
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	unsigned int next_vtermno;
	struct list_head consoles;
};

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct port {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
};

struct atmel_trng_data {
	bool has_half_rate;
};

struct atmel_trng {
	struct clk *clk;
	void *base;
	struct hwrng rng;
};

struct exynos_trng_dev {
	struct device *dev;
	void *mem;
	struct clk *clk;
	struct hwrng rng;
};

enum {
	RNG_OUTPUT_0_REG = 0,
	RNG_OUTPUT_1_REG = 1,
	RNG_OUTPUT_2_REG = 2,
	RNG_OUTPUT_3_REG = 3,
	RNG_STATUS_REG = 4,
	RNG_INTMASK_REG = 5,
	RNG_INTACK_REG = 6,
	RNG_CONTROL_REG = 7,
	RNG_CONFIG_REG = 8,
	RNG_ALARMCNT_REG = 9,
	RNG_FROENABLE_REG = 10,
	RNG_FRODETUNE_REG = 11,
	RNG_ALARMMASK_REG = 12,
	RNG_ALARMSTOP_REG = 13,
	RNG_REV_REG = 14,
	RNG_SYSCONFIG_REG = 15,
};

struct omap_rng_dev;

struct omap_rng_pdata {
	u16 *regs;
	u32 data_size;
	u32 (*data_present)(struct omap_rng_dev *);
	int (*init)(struct omap_rng_dev *);
	void (*cleanup)(struct omap_rng_dev *);
};

struct omap_rng_dev {
	void *base;
	struct device *dev;
	const struct omap_rng_pdata *pdata;
	struct hwrng rng;
	struct clk *clk;
	struct clk *clk_reg;
};

struct omap_rom_rng {
	struct clk *clk;
	struct device *dev;
	struct hwrng ops;
	u32 (*rom_rng_call)(u32, u32, u32);
};

struct imx_rngc {
	struct device *dev;
	struct clk *clk;
	void *base;
	struct hwrng rng;
	struct completion rng_op_done;
	u32 err_reg;
};

struct hisi_rng {
	void *base;
	struct hwrng rng;
};

struct bcm2835_rng_priv {
	struct hwrng rng;
	void *base;
	bool mask_interrupts;
	struct clk *clk;
};

struct bcm2835_rng_of_data {
	bool mask_interrupts;
};

struct iproc_rng200_dev {
	struct hwrng rng;
	void *base;
};

struct st_rng_data {
	void *base;
	struct clk *clk;
	struct hwrng ops;
};

struct stm32_rng_private {
	struct hwrng rng;
	void *base;
	struct clk *clk;
	struct reset_control *rst;
	bool ced;
};

struct meson_rng_data {
	void *base;
	struct platform_device *pdev;
	struct hwrng rng;
	struct clk *core_clk;
};

struct mtk_rng {
	void *base;
	struct clk *clk;
	struct hwrng rng;
};

struct trng_regs {
	u32 output_l;
	u32 output_h;
	u32 status;
	u32 intmask;
	u32 intack;
	u32 control;
	u32 config;
};

struct ks_sa_rng {
	struct device *dev;
	struct hwrng rng;
	struct clk *clk;
	struct regmap *regmap_cfg;
	struct trng_regs *reg_rng;
	int: 32;
	u64 ready_ts;
	unsigned int refill_delay_ns;
	int: 32;
};

struct iommu_group {
	struct kobject kobj;
	struct kobject *devices_kobj;
	struct list_head devices;
	struct mutex mutex;
	struct blocking_notifier_head notifier;
	void *iommu_data;
	void (*iommu_data_release)(void *);
	char *name;
	int id;
	struct iommu_domain *default_domain;
	struct iommu_domain *domain;
	struct list_head entry;
};

typedef unsigned int ioasid_t;

enum iommu_fault_type {
	IOMMU_FAULT_DMA_UNRECOV = 1,
	IOMMU_FAULT_PAGE_REQ = 2,
};

enum iommu_inv_granularity {
	IOMMU_INV_GRANU_DOMAIN = 0,
	IOMMU_INV_GRANU_PASID = 1,
	IOMMU_INV_GRANU_ADDR = 2,
	IOMMU_INV_GRANU_NR = 3,
};

struct fsl_mc_obj_desc {
	char type[16];
	int id;
	u16 vendor;
	u16 ver_major;
	u16 ver_minor;
	u8 irq_count;
	u8 region_count;
	u32 state;
	char label[16];
	u16 flags;
};

struct fsl_mc_io;

struct fsl_mc_device_irq;

struct fsl_mc_resource;

struct fsl_mc_device {
	struct device dev;
	u64 dma_mask;
	u16 flags;
	u32 icid;
	u16 mc_handle;
	struct fsl_mc_io *mc_io;
	struct fsl_mc_obj_desc obj_desc;
	struct resource *regions;
	struct fsl_mc_device_irq **irqs;
	struct fsl_mc_resource *resource;
	struct device_link *consumer_link;
	char *driver_override;
};

enum fsl_mc_pool_type {
	FSL_MC_POOL_DPMCP = 0,
	FSL_MC_POOL_DPBP = 1,
	FSL_MC_POOL_DPCON = 2,
	FSL_MC_POOL_IRQ = 3,
	FSL_MC_NUM_POOL_TYPES = 4,
};

struct fsl_mc_resource_pool;

struct fsl_mc_resource {
	enum fsl_mc_pool_type type;
	s32 id;
	void *data;
	struct fsl_mc_resource_pool *parent_pool;
	struct list_head node;
};

struct fsl_mc_device_irq {
	struct msi_desc *msi_desc;
	struct fsl_mc_device *mc_dev;
	u8 dev_irq_index;
	struct fsl_mc_resource resource;
};

struct fsl_mc_io {
	struct device *dev;
	u16 flags;
	u32 portal_size;
	phys_addr_t portal_phys_addr;
	void *portal_virt_addr;
	struct fsl_mc_device *dpmcp_dev;
	union {
		struct mutex mutex;
		raw_spinlock_t spinlock;
	};
};

struct group_device {
	struct list_head list;
	struct device *dev;
	char *name;
};

struct iommu_group_attribute {
	struct attribute attr;
	ssize_t (*show)(struct iommu_group *, char *);
	ssize_t (*store)(struct iommu_group *, const char *, size_t);
};

struct group_for_pci_data {
	struct pci_dev *pdev;
	struct iommu_group *group;
};

struct __group_domain_type {
	struct device *dev;
	unsigned int type;
};

struct trace_event_raw_iommu_group_event {
	struct trace_entry ent;
	int gid;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_iommu_device_event {
	struct trace_entry ent;
	u32 __data_loc_device;
	char __data[0];
};

struct trace_event_raw_map {
	struct trace_entry ent;
	u64 iova;
	u64 paddr;
	size_t size;
	char __data[0];
	int: 32;
};

struct trace_event_raw_unmap {
	struct trace_entry ent;
	u64 iova;
	size_t size;
	size_t unmapped_size;
	char __data[0];
};

struct trace_event_raw_iommu_error {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u64 iova;
	int flags;
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_iommu_group_event {
	u32 device;
};

struct trace_event_data_offsets_iommu_device_event {
	u32 device;
};

struct trace_event_data_offsets_map {};

struct trace_event_data_offsets_unmap {};

struct trace_event_data_offsets_iommu_error {
	u32 device;
	u32 driver;
};

typedef void (*btf_trace_add_device_to_group)(void *, int, struct device *);

typedef void (*btf_trace_remove_device_from_group)(void *, int, struct device *);

typedef void (*btf_trace_attach_device_to_domain)(void *, struct device *);

typedef void (*btf_trace_detach_device_from_domain)(void *, struct device *);

typedef void (*btf_trace_map)(void *, long unsigned int, phys_addr_t, size_t);

typedef void (*btf_trace_unmap)(void *, long unsigned int, size_t, size_t);

typedef void (*btf_trace_io_page_fault)(void *, struct device *, long unsigned int, int);

enum io_pgtable_fmt {
	ARM_32_LPAE_S1 = 0,
	ARM_32_LPAE_S2 = 1,
	ARM_64_LPAE_S1 = 2,
	ARM_64_LPAE_S2 = 3,
	ARM_V7S = 4,
	ARM_MALI_LPAE = 5,
	IO_PGTABLE_NUM_FMTS = 6,
};

struct iommu_flush_ops {
	void (*tlb_flush_all)(void *);
	void (*tlb_flush_walk)(long unsigned int, size_t, size_t, void *);
	void (*tlb_add_page)(struct iommu_iotlb_gather *, long unsigned int, size_t, void *);
};

struct io_pgtable_cfg {
	long unsigned int quirks;
	long unsigned int pgsize_bitmap;
	unsigned int ias;
	unsigned int oas;
	bool coherent_walk;
	const struct iommu_flush_ops *tlb;
	struct device *iommu_dev;
	int: 32;
	union {
		struct {
			u64 ttbr;
			struct {
				u32 ips: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 tsz: 6;
			} tcr;
			int: 32;
			u64 mair;
		} arm_lpae_s1_cfg;
		struct {
			u64 vttbr;
			struct {
				u32 ps: 3;
				u32 tg: 2;
				u32 sh: 2;
				u32 orgn: 2;
				u32 irgn: 2;
				u32 sl: 2;
				u32 tsz: 6;
			} vtcr;
			int: 32;
		} arm_lpae_s2_cfg;
		struct {
			u32 ttbr;
			u32 tcr;
			u32 nmrr;
			u32 prrr;
		} arm_v7s_cfg;
		struct {
			u64 transtab;
			u64 memattr;
		} arm_mali_lpae_cfg;
	};
};

struct io_pgtable_ops {
	int (*map)(struct io_pgtable_ops *, long unsigned int, phys_addr_t, size_t, int, gfp_t);
	size_t (*unmap)(struct io_pgtable_ops *, long unsigned int, size_t, struct iommu_iotlb_gather *);
	phys_addr_t (*iova_to_phys)(struct io_pgtable_ops *, long unsigned int);
};

struct io_pgtable {
	enum io_pgtable_fmt fmt;
	void *cookie;
	struct io_pgtable_cfg cfg;
	struct io_pgtable_ops ops;
	int: 32;
};

struct io_pgtable_init_fns {
	struct io_pgtable * (*alloc)(struct io_pgtable_cfg *, void *);
	void (*free)(struct io_pgtable *);
};

struct arm_lpae_io_pgtable {
	struct io_pgtable iop;
	int pgd_bits;
	int start_level;
	int bits_per_level;
	void *pgd;
};

typedef u64 arm_lpae_iopte;

struct iova {
	struct rb_node node;
	long unsigned int pfn_hi;
	long unsigned int pfn_lo;
};

struct iova_magazine;

struct iova_cpu_rcache;

struct iova_rcache {
	spinlock_t lock;
	long unsigned int depot_size;
	struct iova_magazine *depot[32];
	struct iova_cpu_rcache *cpu_rcaches;
};

struct iova_magazine {
	long unsigned int size;
	long unsigned int pfns[128];
};

struct iova_cpu_rcache {
	spinlock_t lock;
	struct iova_magazine *loaded;
	struct iova_magazine *prev;
};

struct iova_domain;

typedef void (*iova_flush_cb)(struct iova_domain *);

typedef void (*iova_entry_dtor)(long unsigned int);

struct iova_fq;

struct iova_domain {
	spinlock_t iova_rbtree_lock;
	struct rb_root rbroot;
	struct rb_node *cached_node;
	struct rb_node *cached32_node;
	long unsigned int granule;
	long unsigned int start_pfn;
	long unsigned int dma_32bit_pfn;
	long unsigned int max32_alloc_size;
	struct iova_fq *fq;
	int: 32;
	atomic64_t fq_flush_start_cnt;
	atomic64_t fq_flush_finish_cnt;
	struct iova anchor;
	struct iova_rcache rcaches[6];
	iova_flush_cb flush_cb;
	iova_entry_dtor entry_dtor;
	struct timer_list fq_timer;
	atomic_t fq_timer_on;
	int: 32;
};

struct iova_fq_entry {
	long unsigned int iova_pfn;
	long unsigned int pages;
	long unsigned int data;
	int: 32;
	u64 counter;
};

struct iova_fq {
	struct iova_fq_entry entries[256];
	unsigned int head;
	unsigned int tail;
	spinlock_t lock;
	int: 32;
};

struct of_pci_iommu_alias_info {
	struct device *dev;
	struct device_node *np;
};

struct rk_iommu_domain {
	struct list_head iommus;
	u32 *dt;
	dma_addr_t dt_dma;
	spinlock_t iommus_lock;
	spinlock_t dt_lock;
	struct iommu_domain domain;
};

struct rk_iommu {
	struct device *dev;
	void **bases;
	int num_mmu;
	int num_irq;
	struct clk_bulk_data *clocks;
	int num_clocks;
	bool reset_disabled;
	struct iommu_device iommu;
	struct list_head node;
	struct iommu_domain *domain;
	struct iommu_group *group;
};

struct rk_iommudata {
	struct device_link *link;
	struct rk_iommu *iommu;
};

struct icc_node;

struct icc_node_data {
	struct icc_node *node;
	u32 tag;
};

struct icc_provider;

struct icc_node {
	int id;
	const char *name;
	struct icc_node **links;
	size_t num_links;
	struct icc_provider *provider;
	struct list_head node_list;
	struct list_head search_list;
	struct icc_node *reverse;
	u8 is_traversed: 1;
	struct hlist_head req_list;
	u32 avg_bw;
	u32 peak_bw;
	u32 init_avg;
	u32 init_peak;
	void *data;
};

struct icc_provider {
	struct list_head provider_list;
	struct list_head nodes;
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	void (*pre_aggregate)(struct icc_node *);
	int (*get_bw)(struct icc_node *, u32 *, u32 *);
	struct icc_node * (*xlate)(struct of_phandle_args *, void *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
	struct device *dev;
	int users;
	bool inter_set;
	void *data;
};

struct tegra_smmu_enable {
	unsigned int reg;
	unsigned int bit;
};

struct tegra_mc_timing {
	long unsigned int rate;
	u32 *emem_data;
};

struct tegra_mc_la {
	unsigned int reg;
	unsigned int shift;
	unsigned int mask;
	unsigned int def;
};

struct tegra_mc_client {
	unsigned int id;
	const char *name;
	unsigned int swgroup;
	unsigned int fifo_size;
	struct tegra_smmu_enable smmu;
	struct tegra_mc_la la;
};

struct tegra_smmu_swgroup {
	const char *name;
	unsigned int swgroup;
	unsigned int reg;
};

struct tegra_smmu_group_soc {
	const char *name;
	const unsigned int *swgroups;
	unsigned int num_swgroups;
};

struct tegra_smmu_soc {
	const struct tegra_mc_client *clients;
	unsigned int num_clients;
	const struct tegra_smmu_swgroup *swgroups;
	unsigned int num_swgroups;
	const struct tegra_smmu_group_soc *groups;
	unsigned int num_groups;
	bool supports_round_robin_arbitration;
	bool supports_request_limit;
	unsigned int num_tlb_lines;
	unsigned int num_asids;
};

struct tegra_mc_reset {
	const char *name;
	long unsigned int id;
	unsigned int control;
	unsigned int status;
	unsigned int reset;
	unsigned int bit;
};

struct tegra_mc;

struct tegra_mc_reset_ops {
	int (*hotreset_assert)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*hotreset_deassert)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*block_dma)(struct tegra_mc *, const struct tegra_mc_reset *);
	bool (*dma_idling)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*unblock_dma)(struct tegra_mc *, const struct tegra_mc_reset *);
	int (*reset_status)(struct tegra_mc *, const struct tegra_mc_reset *);
};

struct tegra_smmu;

struct gart_device;

struct tegra_mc_soc;

struct tegra_mc {
	struct device *dev;
	struct tegra_smmu *smmu;
	struct gart_device *gart;
	void *regs;
	struct clk *clk;
	int irq;
	const struct tegra_mc_soc *soc;
	long unsigned int tick;
	struct tegra_mc_timing *timings;
	unsigned int num_timings;
	struct reset_controller_dev reset;
	struct icc_provider provider;
	spinlock_t lock;
};

struct tegra_mc_icc_ops {
	int (*set)(struct icc_node *, struct icc_node *);
	int (*aggregate)(struct icc_node *, u32, u32, u32, u32 *, u32 *);
	struct icc_node_data * (*xlate_extended)(struct of_phandle_args *, void *);
};

struct tegra_mc_soc {
	const struct tegra_mc_client *clients;
	unsigned int num_clients;
	const long unsigned int *emem_regs;
	unsigned int num_emem_regs;
	unsigned int num_address_bits;
	unsigned int atom_size;
	u8 client_id_mask;
	const struct tegra_smmu_soc *smmu;
	u32 intmask;
	const struct tegra_mc_reset_ops *reset_ops;
	const struct tegra_mc_reset *resets;
	unsigned int num_resets;
	const struct tegra_mc_icc_ops *icc_ops;
};

struct gart_device {
	void *regs;
	u32 *savedata;
	long unsigned int iovmm_base;
	long unsigned int iovmm_end;
	spinlock_t pte_lock;
	spinlock_t dom_lock;
	unsigned int active_devices;
	struct iommu_domain *active_domain;
	struct iommu_device iommu;
	struct device *dev;
};

struct tegra_smmu {
	void *regs;
	struct device *dev;
	struct tegra_mc *mc;
	const struct tegra_smmu_soc *soc;
	struct list_head groups;
	long unsigned int pfn_mask;
	long unsigned int tlb_mask;
	long unsigned int *asids;
	struct mutex lock;
	struct list_head list;
	struct dentry *debugfs;
	struct iommu_device iommu;
};

struct tegra_smmu_group {
	struct list_head list;
	struct tegra_smmu *smmu;
	const struct tegra_smmu_group_soc *soc;
	struct iommu_group *group;
	unsigned int swgroup;
};

struct tegra_smmu_as {
	struct iommu_domain domain;
	struct tegra_smmu *smmu;
	unsigned int use_count;
	spinlock_t lock;
	u32 *count;
	struct page **pts;
	struct page *pd;
	dma_addr_t pd_dma;
	unsigned int id;
	u32 attr;
};

typedef u32 sysmmu_iova_t;

typedef u32 sysmmu_pte_t;

struct sysmmu_fault_info {
	unsigned int bit;
	short unsigned int addr_reg;
	const char *name;
	unsigned int type;
};

struct exynos_iommu_owner {
	struct list_head controllers;
	struct iommu_domain *domain;
	struct mutex rpm_lock;
};

struct exynos_iommu_domain {
	struct list_head clients;
	sysmmu_pte_t *pgtable;
	short int *lv2entcnt;
	spinlock_t lock;
	spinlock_t pgtablelock;
	struct iommu_domain domain;
};

struct sysmmu_drvdata {
	struct device *sysmmu;
	struct device *master;
	struct device_link *link;
	void *sfrbase;
	struct clk *clk;
	struct clk *aclk;
	struct clk *pclk;
	struct clk *clk_master;
	spinlock_t lock;
	bool active;
	struct exynos_iommu_domain *domain;
	struct list_head domain_node;
	struct list_head owner_node;
	phys_addr_t pgtable;
	unsigned int version;
	struct iommu_device iommu;
};

enum host1x_class {
	HOST1X_CLASS_HOST1X = 1,
	HOST1X_CLASS_GR2D = 81,
	HOST1X_CLASS_GR2D_SB = 82,
	HOST1X_CLASS_VIC = 93,
	HOST1X_CLASS_GR3D = 96,
};

struct host1x_client;

struct host1x_client_ops {
	int (*init)(struct host1x_client *);
	int (*exit)(struct host1x_client *);
	int (*suspend)(struct host1x_client *);
	int (*resume)(struct host1x_client *);
};

struct host1x_channel;

struct host1x_syncpt;

struct host1x_client {
	struct list_head list;
	struct device *host;
	struct device *dev;
	struct iommu_group *group;
	const struct host1x_client_ops *ops;
	enum host1x_class class;
	struct host1x_channel *channel;
	struct host1x_syncpt **syncpts;
	unsigned int num_syncpts;
	struct host1x_client *parent;
	unsigned int usecount;
	struct mutex lock;
};

enum cdma_event {
	CDMA_EVENT_NONE = 0,
	CDMA_EVENT_SYNC_QUEUE_EMPTY = 1,
	CDMA_EVENT_PUSH_BUFFER_SPACE = 2,
};

struct push_buffer {
	void *mapped;
	dma_addr_t dma;
	dma_addr_t phys;
	u32 fence;
	u32 pos;
	u32 size;
	u32 alloc_size;
};

struct buffer_timeout {
	struct delayed_work wq;
	bool initialized;
	struct host1x_syncpt *syncpt;
	u32 syncpt_val;
	ktime_t start_ktime;
	struct host1x_client *client;
	int: 32;
};

struct host1x_cdma {
	struct mutex lock;
	struct completion complete;
	enum cdma_event event;
	unsigned int slots_used;
	unsigned int slots_free;
	unsigned int first_get;
	unsigned int last_pos;
	struct push_buffer push_buffer;
	struct list_head sync_queue;
	int: 32;
	struct buffer_timeout timeout;
	bool running;
	bool torndown;
	int: 16;
	int: 32;
};

struct host1x_channel {
	struct kref refcount;
	unsigned int id;
	struct mutex submitlock;
	void *regs;
	struct host1x_client *client;
	struct device *dev;
	struct host1x_cdma cdma;
};

struct host1x_syncpt_intr {
	spinlock_t lock;
	struct list_head wait_head;
	char thresh_irq_name[12];
	struct work_struct work;
};

struct host1x;

struct host1x_syncpt_base;

struct host1x_syncpt {
	unsigned int id;
	atomic_t min_val;
	atomic_t max_val;
	u32 base_val;
	const char *name;
	bool client_managed;
	struct host1x *host;
	struct host1x_client *client;
	struct host1x_syncpt_base *base;
	struct host1x_syncpt_intr intr;
};

struct host1x_bo;

struct host1x_bo_ops {
	struct host1x_bo * (*get)(struct host1x_bo *);
	void (*put)(struct host1x_bo *);
	struct sg_table * (*pin)(struct device *, struct host1x_bo *, dma_addr_t *);
	void (*unpin)(struct device *, struct sg_table *);
	void * (*mmap)(struct host1x_bo *);
	void (*munmap)(struct host1x_bo *, void *);
};

struct host1x_bo {
	const struct host1x_bo_ops *ops;
};

struct host1x_reloc {
	struct {
		struct host1x_bo *bo;
		long unsigned int offset;
	} cmdbuf;
	struct {
		struct host1x_bo *bo;
		long unsigned int offset;
	} target;
	long unsigned int shift;
	long unsigned int flags;
};

struct host1x_job_gather;

struct host1x_job_unpin_data;

struct host1x_job {
	struct kref ref;
	struct list_head list;
	struct host1x_channel *channel;
	struct host1x_client *client;
	struct host1x_job_gather *gathers;
	unsigned int num_gathers;
	struct host1x_reloc *relocs;
	unsigned int num_relocs;
	struct host1x_job_unpin_data *unpins;
	unsigned int num_unpins;
	dma_addr_t *addr_phys;
	dma_addr_t *gather_addr_phys;
	dma_addr_t *reloc_addr_phys;
	u32 syncpt_id;
	u32 syncpt_incrs;
	u32 syncpt_end;
	unsigned int timeout;
	unsigned int first_get;
	unsigned int num_slots;
	size_t gather_copy_size;
	dma_addr_t gather_copy;
	u8 *gather_copy_mapped;
	int (*is_addr_reg)(struct device *, u32, u32);
	int (*is_valid_class)(u32);
	u32 class;
	bool serialize;
};

struct host1x_job_gather {
	unsigned int words;
	dma_addr_t base;
	struct host1x_bo *bo;
	unsigned int offset;
	bool handled;
};

struct host1x_job_unpin_data {
	struct host1x_bo *bo;
	struct sg_table *sgt;
	struct device *dev;
	size_t size;
	enum dma_data_direction dir;
};

struct host1x_device;

struct host1x_driver {
	struct device_driver driver;
	const struct of_device_id *subdevs;
	struct list_head list;
	int (*probe)(struct host1x_device *);
	int (*remove)(struct host1x_device *);
	void (*shutdown)(struct host1x_device *);
};

struct host1x_device {
	struct host1x_driver *driver;
	struct list_head list;
	int: 32;
	struct device dev;
	struct mutex subdevs_lock;
	struct list_head subdevs;
	struct list_head active;
	struct mutex clients_lock;
	struct list_head clients;
	bool registered;
	struct device_dma_parameters dma_parms;
	int: 32;
};

struct host1x_channel_list {
	struct host1x_channel *channels;
	long unsigned int *allocated_channels;
};

struct host1x_syncpt_base {
	unsigned int id;
	bool requested;
};

struct host1x_info;

struct host1x_syncpt_ops;

struct host1x_intr_ops;

struct host1x_channel_ops;

struct host1x_cdma_ops;

struct host1x_pushbuffer_ops;

struct host1x_debug_ops;

struct host1x {
	const struct host1x_info *info;
	void *regs;
	void *hv_regs;
	struct host1x_syncpt *syncpt;
	struct host1x_syncpt_base *bases;
	struct device *dev;
	struct clk *clk;
	struct reset_control *rst;
	struct iommu_group *group;
	struct iommu_domain *domain;
	struct iova_domain iova;
	dma_addr_t iova_end;
	struct mutex intr_mutex;
	int intr_syncpt_irq;
	const struct host1x_syncpt_ops *syncpt_op;
	const struct host1x_intr_ops *intr_op;
	const struct host1x_channel_ops *channel_op;
	const struct host1x_cdma_ops *cdma_op;
	const struct host1x_pushbuffer_ops *cdma_pb_op;
	const struct host1x_debug_ops *debug_op;
	struct host1x_syncpt *nop_sp;
	struct mutex syncpt_mutex;
	struct host1x_channel_list channel_list;
	struct dentry *debugfs;
	struct mutex devices_lock;
	struct list_head devices;
	struct list_head list;
	struct device_dma_parameters dma_parms;
	int: 32;
};

struct host1x_channel_ops {
	int (*init)(struct host1x_channel *, struct host1x *, unsigned int);
	int (*submit)(struct host1x_job *);
};

struct host1x_cdma_ops {
	void (*start)(struct host1x_cdma *);
	void (*stop)(struct host1x_cdma *);
	void (*flush)(struct host1x_cdma *);
	int (*timeout_init)(struct host1x_cdma *, unsigned int);
	void (*timeout_destroy)(struct host1x_cdma *);
	void (*freeze)(struct host1x_cdma *);
	void (*resume)(struct host1x_cdma *, u32);
	void (*timeout_cpu_incr)(struct host1x_cdma *, u32, u32, u32, u32);
};

struct host1x_pushbuffer_ops {
	void (*init)(struct push_buffer *);
};

struct output;

struct host1x_debug_ops {
	void (*debug_init)(struct dentry *);
	void (*show_channel_cdma)(struct host1x *, struct host1x_channel *, struct output *);
	void (*show_channel_fifo)(struct host1x *, struct host1x_channel *, struct output *);
	void (*show_mlocks)(struct host1x *, struct output *);
};

struct host1x_syncpt_ops {
	void (*restore)(struct host1x_syncpt *);
	void (*restore_wait_base)(struct host1x_syncpt *);
	void (*load_wait_base)(struct host1x_syncpt *);
	u32 (*load)(struct host1x_syncpt *);
	int (*cpu_incr)(struct host1x_syncpt *);
	void (*assign_to_channel)(struct host1x_syncpt *, struct host1x_channel *);
	void (*enable_protection)(struct host1x *);
};

struct host1x_intr_ops {
	int (*init_host_sync)(struct host1x *, u32, void (*)(struct work_struct *));
	void (*set_syncpt_threshold)(struct host1x *, unsigned int, u32);
	void (*enable_syncpt_intr)(struct host1x *, unsigned int);
	void (*disable_syncpt_intr)(struct host1x *, unsigned int);
	void (*disable_all_syncpt_intrs)(struct host1x *);
	int (*free_syncpt_irq)(struct host1x *);
};

struct host1x_sid_entry {
	unsigned int base;
	unsigned int offset;
	unsigned int limit;
};

struct host1x_info {
	unsigned int nb_channels;
	unsigned int nb_pts;
	unsigned int nb_bases;
	unsigned int nb_mlocks;
	int (*init)(struct host1x *);
	unsigned int sync_offset;
	u64 dma_mask;
	bool has_wide_gather;
	bool has_hypervisor;
	unsigned int num_sid_entries;
	const struct host1x_sid_entry *sid_table;
	int: 32;
};

struct host1x_subdev {
	struct host1x_client *client;
	struct device_node *np;
	struct list_head list;
};

enum host1x_intr_action {
	HOST1X_INTR_ACTION_SUBMIT_COMPLETE = 0,
	HOST1X_INTR_ACTION_WAKEUP = 1,
	HOST1X_INTR_ACTION_WAKEUP_INTERRUPTIBLE = 2,
	HOST1X_INTR_ACTION_COUNT = 3,
};

struct host1x_waitlist {
	struct list_head list;
	struct kref refcount;
	u32 thresh;
	enum host1x_intr_action action;
	atomic_t state;
	void *data;
	int count;
};

struct output {
	void (*fn)(void *, const char *, size_t, bool);
	void *ctx;
	char buf[256];
};

struct trace_event_raw_host1x {
	struct trace_entry ent;
	const char *name;
	char __data[0];
};

struct trace_event_raw_host1x_cdma_push {
	struct trace_entry ent;
	const char *name;
	u32 op1;
	u32 op2;
	char __data[0];
};

struct trace_event_raw_host1x_cdma_push_wide {
	struct trace_entry ent;
	const char *name;
	u32 op1;
	u32 op2;
	u32 op3;
	u32 op4;
	char __data[0];
};

struct trace_event_raw_host1x_cdma_push_gather {
	struct trace_entry ent;
	const char *name;
	struct host1x_bo *bo;
	u32 words;
	u32 offset;
	bool cmdbuf;
	u32 __data_loc_cmdbuf;
	char __data[0];
};

struct trace_event_raw_host1x_channel_submit {
	struct trace_entry ent;
	const char *name;
	u32 cmdbufs;
	u32 relocs;
	u32 syncpt_id;
	u32 syncpt_incrs;
	char __data[0];
};

struct trace_event_raw_host1x_channel_submitted {
	struct trace_entry ent;
	const char *name;
	u32 syncpt_base;
	u32 syncpt_max;
	char __data[0];
};

struct trace_event_raw_host1x_channel_submit_complete {
	struct trace_entry ent;
	const char *name;
	int count;
	u32 thresh;
	char __data[0];
};

struct trace_event_raw_host1x_wait_cdma {
	struct trace_entry ent;
	const char *name;
	u32 eventid;
	char __data[0];
};

struct trace_event_raw_host1x_syncpt_load_min {
	struct trace_entry ent;
	u32 id;
	u32 val;
	char __data[0];
};

struct trace_event_raw_host1x_syncpt_wait_check {
	struct trace_entry ent;
	struct host1x_bo *bo;
	u32 offset;
	u32 syncpt_id;
	u32 thresh;
	u32 min;
	char __data[0];
};

struct trace_event_data_offsets_host1x {};

struct trace_event_data_offsets_host1x_cdma_push {};

struct trace_event_data_offsets_host1x_cdma_push_wide {};

struct trace_event_data_offsets_host1x_cdma_push_gather {
	u32 cmdbuf;
};

struct trace_event_data_offsets_host1x_channel_submit {};

struct trace_event_data_offsets_host1x_channel_submitted {};

struct trace_event_data_offsets_host1x_channel_submit_complete {};

struct trace_event_data_offsets_host1x_wait_cdma {};

struct trace_event_data_offsets_host1x_syncpt_load_min {};

struct trace_event_data_offsets_host1x_syncpt_wait_check {};

typedef void (*btf_trace_host1x_channel_open)(void *, const char *);

typedef void (*btf_trace_host1x_channel_release)(void *, const char *);

typedef void (*btf_trace_host1x_cdma_begin)(void *, const char *);

typedef void (*btf_trace_host1x_cdma_end)(void *, const char *);

typedef void (*btf_trace_host1x_cdma_push)(void *, const char *, u32, u32);

typedef void (*btf_trace_host1x_cdma_push_wide)(void *, const char *, u32, u32, u32, u32);

typedef void (*btf_trace_host1x_cdma_push_gather)(void *, const char *, struct host1x_bo *, u32, u32, void *);

typedef void (*btf_trace_host1x_channel_submit)(void *, const char *, u32, u32, u32, u32);

typedef void (*btf_trace_host1x_channel_submitted)(void *, const char *, u32, u32);

typedef void (*btf_trace_host1x_channel_submit_complete)(void *, const char *, int, u32);

typedef void (*btf_trace_host1x_wait_cdma)(void *, const char *, u32);

typedef void (*btf_trace_host1x_syncpt_load_min)(void *, u32, u32);

typedef void (*btf_trace_host1x_syncpt_wait_check)(void *, struct host1x_bo *, u32, u32, u32, u32);

enum waitlist_state {
	WLS_PENDING = 0,
	WLS_REMOVED = 1,
	WLS_CANCELLED = 2,
	WLS_HANDLED = 3,
};

typedef void (*action_handler)(struct host1x_waitlist *);

struct host1x_firewall {
	struct host1x_job *job;
	struct device *dev;
	unsigned int num_relocs;
	struct host1x_reloc *reloc;
	struct host1x_bo *cmdbuf;
	unsigned int offset;
	u32 words;
	u32 class;
	u32 reg;
	u32 mask;
	u32 count;
};

struct tegra_mipi_pad {
	long unsigned int data;
	long unsigned int clk;
};

struct tegra_mipi_soc {
	bool has_clk_lane;
	const struct tegra_mipi_pad *pads;
	unsigned int num_pads;
	bool clock_enable_override;
	bool needs_vclamp_ref;
	u8 pad_drive_down_ref;
	u8 pad_drive_up_ref;
	u8 pad_vclamp_level;
	u8 pad_vauxp_level;
	u8 hspdos;
	u8 hspuos;
	u8 termos;
	u8 hsclkpdos;
	u8 hsclkpuos;
};

struct tegra_mipi {
	const struct tegra_mipi_soc *soc;
	struct device *dev;
	void *regs;
	struct mutex lock;
	struct clk *clk;
	long unsigned int usage_count;
};

struct tegra_mipi_device {
	struct platform_device *pdev;
	struct tegra_mipi *mipi;
	struct device *device;
	long unsigned int pads;
};

enum {
	HOST1X_OPCODE_SETCLASS = 0,
	HOST1X_OPCODE_INCR = 1,
	HOST1X_OPCODE_NONINCR = 2,
	HOST1X_OPCODE_MASK = 3,
	HOST1X_OPCODE_IMM = 4,
	HOST1X_OPCODE_RESTART = 5,
	HOST1X_OPCODE_GATHER = 6,
	HOST1X_OPCODE_SETSTRMID = 7,
	HOST1X_OPCODE_SETAPPID = 8,
	HOST1X_OPCODE_SETPYLD = 9,
	HOST1X_OPCODE_INCR_W = 10,
	HOST1X_OPCODE_NONINCR_W = 11,
	HOST1X_OPCODE_GATHER_W = 12,
	HOST1X_OPCODE_RESTART_W = 13,
	HOST1X_OPCODE_EXTEND = 14,
};

enum {
	HOST1X_OPCODE_EXTEND_ACQUIRE_MLOCK = 0,
	HOST1X_OPCODE_EXTEND_RELEASE_MLOCK = 1,
};

struct drm_dmi_panel_orientation_data {
	int width;
	int height;
	const char * const *bios_dates;
	int orientation;
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	void *cookie;
	void (*irq_set_state)(void *, bool);
	unsigned int (*set_vga_decode)(void *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct master;

struct component {
	struct list_head node;
	struct master *master;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct master {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *dev;
	struct component_match *match;
	struct dentry *dentry;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
	int: 32;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

typedef void *acpi_handle;

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map___2 {
	struct probe *probes[255];
	struct mutex *lock;
};

typedef int (*dr_match_t)(struct device *, void *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
};

struct devres___2 {
	struct devres_node node;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	int: 32;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
	int: 32;
};

typedef void * (*devcon_match_fn_t)(struct fwnode_handle *, const char *, void *);

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	int: 32;
	__u64 ring_cookie;
	__u32 location;
	int: 32;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
	int: 32;
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 reserved1[1];
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		u8 __link_ext_substate;
	};
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[3];
		long unsigned int advertising[3];
		long unsigned int lp_advertising[3];
	} link_modes;
};

struct ethtool_pause_stats {
	u64 tx_pause_frames;
	u64 rx_pause_frames;
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

struct cache_type_info {
	const char *size_prop;
	const char *line_size_props[2];
	const char *nr_sets_prop;
};

struct software_node;

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct swnode {
	int id;
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

typedef int (*pm_callback_t)(struct device *);

struct of_phandle_iterator {
	const char *cells_name;
	int cell_count;
	const struct device_node *parent;
	const __be32 *list_end;
	const __be32 *phandle_end;
	const __be32 *cur;
	uint32_t cur_count;
	phandle phandle;
	struct device_node *node;
};

enum genpd_notication {
	GENPD_NOTIFY_PRE_OFF = 0,
	GENPD_NOTIFY_OFF = 1,
	GENPD_NOTIFY_PRE_ON = 2,
	GENPD_NOTIFY_ON = 3,
};

struct gpd_link {
	struct generic_pm_domain *parent;
	struct list_head parent_node;
	struct generic_pm_domain *child;
	struct list_head child_node;
	unsigned int performance_state;
	unsigned int prev_performance_state;
};

struct of_genpd_provider {
	struct list_head link;
	struct device_node *node;
	genpd_xlate_t xlate;
	void *data;
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_ENABLED = 2,
	PCE_STATUS_ERROR = 3,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct regmap___2;

struct regmap_async {
	struct list_head list;
	struct regmap___2 *map;
	void *work_buf;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t val_bytes;
	void (*format_write)(struct regmap___2 *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct regcache_ops;

struct regmap___2 {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap___2 *);
	int (*exit)(struct regmap___2 *);
	void (*debugfs_init)(struct regmap___2 *);
	int (*read)(struct regmap___2 *, unsigned int, unsigned int *);
	int (*write)(struct regmap___2 *, unsigned int, unsigned int);
	int (*sync)(struct regmap___2 *, unsigned int, unsigned int);
	int (*drop)(struct regmap___2 *, unsigned int, unsigned int);
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap___2 *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_field___2 {
	struct regmap___2 *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap___2 *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap___2 *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap___2 *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap___2 *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap___2 *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap___2 *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap___2 *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap___2 *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap___2 *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap___2 *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap___2 *, unsigned int, unsigned int);

struct regcache_rbtree_node {
	void *block;
	long int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_debugfs_node {
	struct regmap___2 *map;
	struct list_head link;
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct spi_statistics {
	spinlock_t lock;
	long unsigned int messages;
	long unsigned int transfers;
	long unsigned int errors;
	long unsigned int timedout;
	long unsigned int spi_sync;
	long unsigned int spi_sync_immediate;
	long unsigned int spi_async;
	long long unsigned int bytes;
	long long unsigned int bytes_rx;
	long long unsigned int bytes_tx;
	long unsigned int transfer_bytes_histo[17];
	long unsigned int transfers_split_maxsize;
};

struct spi_delay {
	u16 value;
	u8 unit;
};

struct spi_controller;

struct spi_device {
	struct device dev;
	struct spi_controller *controller;
	struct spi_controller *master;
	u32 max_speed_hz;
	u8 chip_select;
	u8 bits_per_word;
	bool rt;
	u32 mode;
	int irq;
	void *controller_state;
	void *controller_data;
	char modalias[32];
	const char *driver_override;
	int cs_gpio;
	struct gpio_desc *cs_gpiod;
	struct spi_delay word_delay;
	struct spi_statistics statistics;
};

struct spi_message;

struct spi_transfer;

struct spi_controller_mem_ops;

struct spi_controller {
	struct device dev;
	struct list_head list;
	s16 bus_num;
	u16 num_chipselect;
	u16 dma_alignment;
	u32 mode_bits;
	u32 buswidth_override_bits;
	u32 bits_per_word_mask;
	u32 min_speed_hz;
	u32 max_speed_hz;
	u16 flags;
	bool slave;
	size_t (*max_transfer_size)(struct spi_device *);
	size_t (*max_message_size)(struct spi_device *);
	struct mutex io_mutex;
	spinlock_t bus_lock_spinlock;
	struct mutex bus_lock_mutex;
	bool bus_lock_flag;
	int (*setup)(struct spi_device *);
	int (*set_cs_timing)(struct spi_device *, struct spi_delay *, struct spi_delay *, struct spi_delay *);
	int (*transfer)(struct spi_device *, struct spi_message *);
	void (*cleanup)(struct spi_device *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	bool queued;
	struct kthread_worker *kworker;
	struct kthread_work pump_messages;
	spinlock_t queue_lock;
	struct list_head queue;
	struct spi_message *cur_msg;
	bool idling;
	bool busy;
	bool running;
	bool rt;
	bool auto_runtime_pm;
	bool cur_msg_prepared;
	bool cur_msg_mapped;
	bool last_cs_enable;
	bool last_cs_mode_high;
	bool fallback;
	struct completion xfer_completion;
	size_t max_dma_len;
	int (*prepare_transfer_hardware)(struct spi_controller *);
	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_transfer_hardware)(struct spi_controller *);
	int (*prepare_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
	int (*slave_abort)(struct spi_controller *);
	void (*set_cs)(struct spi_device *, bool);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	void (*handle_err)(struct spi_controller *, struct spi_message *);
	const struct spi_controller_mem_ops *mem_ops;
	struct spi_delay cs_setup;
	struct spi_delay cs_hold;
	struct spi_delay cs_inactive;
	int *cs_gpios;
	struct gpio_desc **cs_gpiods;
	bool use_gpio_descriptors;
	u8 unused_native_cs;
	u8 max_native_cs;
	struct spi_statistics statistics;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	void *dummy_rx;
	void *dummy_tx;
	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
	bool ptp_sts_supported;
	long unsigned int irq_flags;
	int: 32;
};

struct spi_message {
	struct list_head transfers;
	struct spi_device *spi;
	unsigned int is_dma_mapped: 1;
	void (*complete)(void *);
	void *context;
	unsigned int frame_length;
	unsigned int actual_length;
	int status;
	struct list_head queue;
	void *state;
	struct list_head resources;
};

struct spi_transfer {
	const void *tx_buf;
	void *rx_buf;
	unsigned int len;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	struct sg_table tx_sg;
	struct sg_table rx_sg;
	unsigned int cs_change: 1;
	unsigned int tx_nbits: 3;
	unsigned int rx_nbits: 3;
	u8 bits_per_word;
	u16 delay_usecs;
	struct spi_delay delay;
	struct spi_delay cs_change_delay;
	struct spi_delay word_delay;
	u32 speed_hz;
	u32 effective_speed_hz;
	unsigned int ptp_sts_word_pre;
	unsigned int ptp_sts_word_post;
	struct ptp_system_timestamp *ptp_sts;
	bool timestamped;
	struct list_head transfer_list;
	u16 error;
};

struct spi_mem;

struct spi_mem_op;

struct spi_mem_dirmap_desc;

struct spi_controller_mem_ops {
	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
	const char * (*get_name)(struct spi_mem *);
	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
};

struct regmap_async_spi {
	struct regmap_async core;
	struct spi_message m;
	struct spi_transfer t[2];
};

struct spmi_controller;

struct spmi_device {
	struct device dev;
	struct spmi_controller *ctrl;
	u8 usid;
};

struct spmi_controller {
	struct device dev;
	unsigned int nr;
	int (*cmd)(struct spmi_controller *, u8, u8);
	int (*read_cmd)(struct spmi_controller *, u8, u8, u16, u8 *, size_t);
	int (*write_cmd)(struct spmi_controller *, u8, u8, u16, const u8 *, size_t);
};

struct regmap_mmio_context {
	void *regs;
	unsigned int val_bytes;
	bool relaxed_mmio;
	bool attached_clk;
	struct clk *clk;
	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
};

struct regmap_irq_chip_data___2 {
	struct mutex lock;
	struct irq_chip irq_chip;
	struct regmap___2 *map;
	const struct regmap_irq_chip *chip;
	int irq_base;
	struct irq_domain *domain;
	int irq;
	int wake_count;
	void *status_reg_buf;
	unsigned int *main_status_buf;
	unsigned int *status_buf;
	unsigned int *mask_buf;
	unsigned int *mask_buf_def;
	unsigned int *wake_buf;
	unsigned int *type_buf;
	unsigned int *type_buf_def;
	unsigned int irq_reg_stride;
	unsigned int type_reg_stride;
	bool clear_status: 1;
};

struct soc_device___2 {
	struct device dev;
	struct soc_device_attribute *attr;
	int soc_dev_num;
};

struct devcd_entry {
	struct device devcd_dev;
	void *data;
	size_t datalen;
	struct module *owner;
	ssize_t (*read)(char *, loff_t, size_t, void *, size_t);
	void (*free)(void *);
	struct delayed_work del_wk;
	struct device *failing_dev;
	int: 32;
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

struct brd_device {
	int brd_number;
	struct request_queue *brd_queue;
	struct gendisk *brd_disk;
	struct list_head brd_list;
	spinlock_t brd_lock;
	struct xarray brd_pages;
};

typedef short unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
};

struct loop_func_table;

struct loop_device {
	int lo_number;
	atomic_t lo_refcnt;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	char lo_file_name[64];
	char lo_crypt_name[64];
	char lo_encrypt_key[32];
	int lo_encrypt_key_size;
	struct loop_func_table *lo_encryption;
	__u32 lo_init[2];
	kuid_t lo_key_owner;
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct file *lo_backing_file;
	struct block_device *lo_device;
	void *key_data;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	struct kthread_worker worker;
	struct task_struct *worker_task;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
};

struct loop_func_table {
	int number;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	int (*init)(struct loop_device *, const struct loop_info64 *);
	int (*release)(struct loop_device *);
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct module *owner;
};

struct loop_cmd {
	struct kthread_work work;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *css;
};

struct virtio_blk_geometry {
	__virtio16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_config {
	__virtio64 capacity;
	__virtio32 size_max;
	__virtio32 seg_max;
	struct virtio_blk_geometry geometry;
	__virtio32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__virtio16 min_io_size;
	__virtio32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__virtio16 num_queues;
	__virtio32 max_discard_sectors;
	__virtio32 max_discard_seg;
	__virtio32 discard_sector_alignment;
	__virtio32 max_write_zeroes_sectors;
	__virtio32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
};

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	refcount_t refs;
	unsigned int sg_elems;
	int index;
	int num_vqs;
	struct virtio_blk_vq *vqs;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	u8 status;
	struct scatterlist sg[0];
	int: 32;
};

enum dpot_devid {
	AD5258_ID = 6817152,
	AD5259_ID = 6817281,
	AD5251_ID = 7088514,
	AD5252_ID = 7088643,
	AD5253_ID = 7093636,
	AD5254_ID = 7093765,
	AD5255_ID = 7085638,
	AD5160_ID = 58721799,
	AD5161_ID = 58721800,
	AD5162_ID = 92278281,
	AD5165_ID = 58721802,
	AD5200_ID = 58721803,
	AD5201_ID = 58721612,
	AD5203_ID = 58736013,
	AD5204_ID = 92290574,
	AD5206_ID = 92339727,
	AD5207_ID = 92278288,
	AD5231_ID = 139200145,
	AD5232_ID = 72093202,
	AD5233_ID = 72105363,
	AD5235_ID = 139202196,
	AD5260_ID = 58721813,
	AD5262_ID = 92278294,
	AD5263_ID = 92290583,
	AD5290_ID = 58721816,
	AD5291_ID = 72353305,
	AD5292_ID = 72353434,
	AD5293_ID = 71304859,
	AD7376_ID = 58721756,
	AD8400_ID = 92276253,
	AD8402_ID = 92278302,
	AD8403_ID = 92282399,
	ADN2850_ID = 139202208,
	AD5241_ID = 4195873,
	AD5242_ID = 4197922,
	AD5243_ID = 4197923,
	AD5245_ID = 4195876,
	AD5246_ID = 4195813,
	AD5247_ID = 4195814,
	AD5248_ID = 4197927,
	AD5280_ID = 4195880,
	AD5282_ID = 4197929,
	ADN2860_ID = 7085674,
	AD5273_ID = 5244331,
	AD5171_ID = 5244332,
	AD5170_ID = 5244461,
	AD5172_ID = 5246510,
	AD5173_ID = 5246511,
	AD5270_ID = 72353456,
	AD5271_ID = 72353329,
	AD5272_ID = 5244594,
	AD5274_ID = 5244467,
};

struct ad_dpot_bus_ops {
	int (*read_d8)(void *);
	int (*read_r8d8)(void *, u8);
	int (*read_r8d16)(void *, u8);
	int (*write_d8)(void *, u8);
	int (*write_r8d8)(void *, u8, u8);
	int (*write_r8d16)(void *, u8, u16);
};

struct ad_dpot_bus_data {
	void *client;
	const struct ad_dpot_bus_ops *bops;
};

struct dpot_data {
	struct ad_dpot_bus_data bdata;
	struct mutex update_lock;
	unsigned int rdac_mask;
	unsigned int max_pos;
	long unsigned int devid;
	unsigned int uid;
	unsigned int feat;
	unsigned int wipers;
	u16 rdac_cache[6];
	long unsigned int otp_en_mask[1];
};

struct atmel_tcb_config {
	size_t counter_width;
	bool has_gclk;
	bool has_qdec;
};

struct atmel_tc {
	struct platform_device *pdev;
	void *regs;
	int id;
	const struct atmel_tcb_config *tcb_config;
	int irq[3];
	struct clk *clk[3];
	struct clk *slow_clk;
	struct list_head node;
	bool allocated;
};

struct ics932s401_data {
	struct attribute_group attrs;
	struct mutex lock;
	char sensors_valid;
	long unsigned int sensors_last_updated;
	u8 regs[21];
};

struct als_data {
	struct mutex mutex;
};

struct isl29003_data {
	struct i2c_client *client;
	struct mutex lock;
	u8 reg_cache[4];
	u8 power_state_before_suspend;
};

struct at24_client {
	struct i2c_client *client;
	struct regmap *regmap;
};

struct at24_data {
	struct mutex lock;
	unsigned int write_max;
	unsigned int num_addresses;
	unsigned int offset_adj;
	u32 byte_len;
	u16 page_size;
	u8 flags;
	struct nvmem_device *nvmem;
	struct regulator *vcc_reg;
	void (*read_post)(unsigned int, char *, size_t);
	struct at24_client client[0];
};

struct at24_chip_data {
	u32 byte_len;
	u8 flags;
	void (*read_post)(unsigned int, char *, size_t);
};

struct eeprom_93cx6 {
	void *data;
	void (*register_read)(struct eeprom_93cx6 *);
	void (*register_write)(struct eeprom_93cx6 *);
	int width;
	char drive_data;
	char reg_data_in;
	char reg_data_out;
	char reg_data_clock;
	char reg_chip_select;
};

struct sram_partition {
	void *base;
	struct gen_pool *pool;
	struct bin_attribute battr;
	struct mutex lock;
	struct list_head list;
};

struct sram_dev {
	struct device *dev;
	void *virt_base;
	struct gen_pool *pool;
	struct clk *clk;
	struct sram_partition *partition;
	u32 partitions;
};

struct sram_reserve {
	struct list_head list;
	u32 start;
	u32 size;
	bool export;
	bool pool;
	bool protect_exec;
	const char *label;
};

enum stmpe_block {
	STMPE_BLOCK_GPIO = 1,
	STMPE_BLOCK_KEYPAD = 2,
	STMPE_BLOCK_TOUCHSCREEN = 4,
	STMPE_BLOCK_ADC = 8,
	STMPE_BLOCK_PWM = 16,
	STMPE_BLOCK_ROTATOR = 32,
};

enum stmpe_partnum {
	STMPE610 = 0,
	STMPE801 = 1,
	STMPE811 = 2,
	STMPE1600 = 3,
	STMPE1601 = 4,
	STMPE1801 = 5,
	STMPE2401 = 6,
	STMPE2403 = 7,
	STMPE_NBR_PARTS = 8,
};

enum {
	STMPE_IDX_CHIP_ID = 0,
	STMPE_IDX_SYS_CTRL = 1,
	STMPE_IDX_SYS_CTRL2 = 2,
	STMPE_IDX_ICR_LSB = 3,
	STMPE_IDX_IER_LSB = 4,
	STMPE_IDX_IER_MSB = 5,
	STMPE_IDX_ISR_LSB = 6,
	STMPE_IDX_ISR_MSB = 7,
	STMPE_IDX_GPMR_LSB = 8,
	STMPE_IDX_GPMR_CSB = 9,
	STMPE_IDX_GPMR_MSB = 10,
	STMPE_IDX_GPSR_LSB = 11,
	STMPE_IDX_GPSR_CSB = 12,
	STMPE_IDX_GPSR_MSB = 13,
	STMPE_IDX_GPCR_LSB = 14,
	STMPE_IDX_GPCR_CSB = 15,
	STMPE_IDX_GPCR_MSB = 16,
	STMPE_IDX_GPDR_LSB = 17,
	STMPE_IDX_GPDR_CSB = 18,
	STMPE_IDX_GPDR_MSB = 19,
	STMPE_IDX_GPEDR_LSB = 20,
	STMPE_IDX_GPEDR_CSB = 21,
	STMPE_IDX_GPEDR_MSB = 22,
	STMPE_IDX_GPRER_LSB = 23,
	STMPE_IDX_GPRER_CSB = 24,
	STMPE_IDX_GPRER_MSB = 25,
	STMPE_IDX_GPFER_LSB = 26,
	STMPE_IDX_GPFER_CSB = 27,
	STMPE_IDX_GPFER_MSB = 28,
	STMPE_IDX_GPPUR_LSB = 29,
	STMPE_IDX_GPPDR_LSB = 30,
	STMPE_IDX_GPAFR_U_MSB = 31,
	STMPE_IDX_IEGPIOR_LSB = 32,
	STMPE_IDX_IEGPIOR_CSB = 33,
	STMPE_IDX_IEGPIOR_MSB = 34,
	STMPE_IDX_ISGPIOR_LSB = 35,
	STMPE_IDX_ISGPIOR_CSB = 36,
	STMPE_IDX_ISGPIOR_MSB = 37,
	STMPE_IDX_MAX = 38,
};

struct stmpe_client_info;

struct stmpe_variant_info;

struct stmpe_platform_data;

struct stmpe {
	struct regulator *vcc;
	struct regulator *vio;
	struct mutex lock;
	struct mutex irq_lock;
	struct device *dev;
	struct irq_domain *domain;
	void *client;
	struct stmpe_client_info *ci;
	enum stmpe_partnum partnum;
	struct stmpe_variant_info *variant;
	const u8 *regs;
	int irq;
	int num_gpios;
	u8 ier[2];
	u8 oldier[2];
	struct stmpe_platform_data *pdata;
	u8 sample_time;
	u8 mod_12b;
	u8 ref_sel;
	u8 adc_freq;
};

struct stmpe_client_info {
	void *data;
	int irq;
	void *client;
	struct device *dev;
	int (*read_byte)(struct stmpe *, u8);
	int (*write_byte)(struct stmpe *, u8, u8);
	int (*read_block)(struct stmpe *, u8, u8, u8 *);
	int (*write_block)(struct stmpe *, u8, u8, const u8 *);
	void (*init)(struct stmpe *);
};

struct stmpe_variant_block;

struct stmpe_variant_info {
	const char *name;
	u16 id_val;
	u16 id_mask;
	int num_gpios;
	int af_bits;
	const u8 *regs;
	struct stmpe_variant_block *blocks;
	int num_blocks;
	int num_irqs;
	int (*enable)(struct stmpe *, unsigned int, bool);
	int (*get_altfunc)(struct stmpe *, enum stmpe_block);
	int (*enable_autosleep)(struct stmpe *, int);
};

struct stmpe_platform_data {
	int id;
	unsigned int blocks;
	unsigned int irq_trigger;
	bool autosleep;
	bool irq_over_gpio;
	int irq_gpio;
	int autosleep_timeout;
};

struct stmpe_variant_block {
	const struct mfd_cell *cell;
	int irq;
	enum stmpe_block block;
};

struct prcm_data {
	int nsubdevs;
	const struct mfd_cell *subdevs;
};

enum tps65218_irqs {
	TPS65218_PRGC_IRQ = 0,
	TPS65218_CC_AQC_IRQ = 1,
	TPS65218_HOT_IRQ = 2,
	TPS65218_PB_IRQ = 3,
	TPS65218_AC_IRQ = 4,
	TPS65218_VPRG_IRQ = 5,
	TPS65218_INVALID1_IRQ = 6,
	TPS65218_INVALID2_IRQ = 7,
	TPS65218_LS1_I_IRQ = 8,
	TPS65218_LS2_I_IRQ = 9,
	TPS65218_LS3_I_IRQ = 10,
	TPS65218_LS1_F_IRQ = 11,
	TPS65218_LS2_F_IRQ = 12,
	TPS65218_LS3_F_IRQ = 13,
	TPS65218_INVALID3_IRQ = 14,
	TPS65218_INVALID4_IRQ = 15,
};

struct tps65910_platform_data {
	int irq;
	int irq_base;
};

struct matrix_keymap_data {
	const uint32_t *keymap;
	unsigned int keymap_size;
};

struct twl4030_clock_init_data {
	bool ck32k_lowpwr_enable;
};

struct twl4030_bci_platform_data {
	int *battery_tmp_tbl;
	unsigned int tblsize;
	int bb_uvolt;
	int bb_uamp;
};

struct twl4030_madc_platform_data {
	int irq_line;
};

struct twl4030_keypad_data {
	const struct matrix_keymap_data *keymap_data;
	unsigned int rows;
	unsigned int cols;
	bool rep;
};

enum twl4030_usb_mode {
	T2_USB_MODE_ULPI = 1,
	T2_USB_MODE_CEA2011_3PIN = 2,
};

struct twl4030_usb_data {
	enum twl4030_usb_mode usb_mode;
	long unsigned int features;
	int (*phy_init)(struct device *);
	int (*phy_exit)(struct device *);
	int (*phy_power)(struct device *, int, int);
	int (*phy_set_clock)(struct device *, int);
	int (*phy_suspend)(struct device *, int);
};

struct twl4030_ins {
	u16 pmb_message;
	u8 delay;
};

struct twl4030_script {
	struct twl4030_ins *script;
	unsigned int size;
	u8 flags;
};

struct twl4030_resconfig {
	u8 resource;
	u8 devgroup;
	u8 type;
	u8 type2;
	u8 remap_off;
	u8 remap_sleep;
};

struct twl4030_power_data {
	struct twl4030_script **scripts;
	unsigned int num;
	struct twl4030_resconfig *resource_config;
	struct twl4030_resconfig *board_config;
	bool use_poweroff;
	bool ac_charger_quirk;
};

struct twl4030_codec_data {
	unsigned int digimic_delay;
	unsigned int ramp_delay_value;
	unsigned int offset_cncl_path;
	unsigned int hs_extmute: 1;
	int hs_extmute_gpio;
};

struct twl4030_vibra_data {
	unsigned int coexist;
};

struct twl4030_audio_data {
	unsigned int audio_mclk;
	struct twl4030_codec_data *codec;
	struct twl4030_vibra_data *vibra;
	int audpwron_gpio;
	int naudint_irq;
	unsigned int irq_base;
};

struct twl4030_platform_data {
	struct twl4030_clock_init_data *clock;
	struct twl4030_bci_platform_data *bci;
	struct twl4030_gpio_platform_data *gpio;
	struct twl4030_madc_platform_data *madc;
	struct twl4030_keypad_data *keypad;
	struct twl4030_usb_data *usb;
	struct twl4030_power_data *power;
	struct twl4030_audio_data *audio;
	struct regulator_init_data *vdac;
	struct regulator_init_data *vaux1;
	struct regulator_init_data *vaux2;
	struct regulator_init_data *vaux3;
	struct regulator_init_data *vdd1;
	struct regulator_init_data *vdd2;
	struct regulator_init_data *vdd3;
	struct regulator_init_data *vpll1;
	struct regulator_init_data *vpll2;
	struct regulator_init_data *vmmc1;
	struct regulator_init_data *vmmc2;
	struct regulator_init_data *vsim;
	struct regulator_init_data *vaux4;
	struct regulator_init_data *vio;
	struct regulator_init_data *vintana1;
	struct regulator_init_data *vintana2;
	struct regulator_init_data *vintdig;
	struct regulator_init_data *vmmc;
	struct regulator_init_data *vpp;
	struct regulator_init_data *vusim;
	struct regulator_init_data *vana;
	struct regulator_init_data *vcxio;
	struct regulator_init_data *vusb;
	struct regulator_init_data *clk32kg;
	struct regulator_init_data *v1v8;
	struct regulator_init_data *v2v1;
	struct regulator_init_data *ldo1;
	struct regulator_init_data *ldo2;
	struct regulator_init_data *ldo3;
	struct regulator_init_data *ldo4;
	struct regulator_init_data *ldo5;
	struct regulator_init_data *ldo6;
	struct regulator_init_data *ldo7;
	struct regulator_init_data *ldoln;
	struct regulator_init_data *ldousb;
	struct regulator_init_data *smps3;
	struct regulator_init_data *smps4;
	struct regulator_init_data *vio6025;
};

struct twl_regulator_driver_data {
	int (*set_voltage)(void *, int);
	int (*get_voltage)(void *);
	void *data;
	long unsigned int features;
};

struct twl_client {
	struct i2c_client *client;
	struct regmap *regmap;
};

struct twl_mapping {
	unsigned char sid;
	unsigned char base;
};

struct twl_private {
	bool ready;
	u32 twl_idcode;
	unsigned int twl_id;
	struct twl_mapping *twl_map;
	struct twl_client *twl_modules;
};

struct sih_irq_data {
	u8 isr_offset;
	u8 imr_offset;
};

struct sih {
	char name[8];
	u8 module;
	u8 control_offset;
	bool set_cor;
	u8 bits;
	u8 bytes_ixr;
	u8 edr_offset;
	u8 bytes_edr;
	u8 irq_lines;
	struct sih_irq_data mask[2];
};

struct sih_agent {
	int irq_base;
	const struct sih *sih;
	u32 imr;
	bool imr_change_pending;
	u32 edge_change;
	struct mutex irq_lock;
	char *irq_name;
};

struct twl6030_irq {
	unsigned int irq_base;
	int twl_irq;
	bool irq_wake_enabled;
	atomic_t wakeirqs;
	struct notifier_block pm_nb;
	struct irq_chip irq_chip;
	struct irq_domain *irq_domain;
	const int *irq_mapping_tbl;
};

enum {
	TWL_REMAP_OFF = 0,
	TWL_REMAP_SLEEP = 8,
	TWL_REMAP_ACTIVE = 9,
};

struct mfd_of_node_entry {
	struct list_head list;
	struct device *dev;
	struct device_node *np;
};

struct spi_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct spi_driver {
	const struct spi_device_id *id_table;
	int (*probe)(struct spi_device *);
	int (*remove)(struct spi_device *);
	void (*shutdown)(struct spi_device *);
	struct device_driver driver;
};

struct cpcap_ddata___2 {
	struct spi_device *spi;
	struct regmap_irq *irqs;
	struct regmap_irq_chip_data *irqdata[3];
	const struct regmap_config *regmap_conf;
	struct regmap *regmap;
};

struct ac100_dev {
	struct device *dev;
	struct regmap *regmap;
};

enum {
	AXP152_IRQ_LDO0IN_CONNECT = 1,
	AXP152_IRQ_LDO0IN_REMOVAL = 2,
	AXP152_IRQ_ALDO0IN_CONNECT = 3,
	AXP152_IRQ_ALDO0IN_REMOVAL = 4,
	AXP152_IRQ_DCDC1_V_LOW = 5,
	AXP152_IRQ_DCDC2_V_LOW = 6,
	AXP152_IRQ_DCDC3_V_LOW = 7,
	AXP152_IRQ_DCDC4_V_LOW = 8,
	AXP152_IRQ_PEK_SHORT = 9,
	AXP152_IRQ_PEK_LONG = 10,
	AXP152_IRQ_TIMER = 11,
	AXP152_IRQ_PEK_RIS_EDGE = 12,
	AXP152_IRQ_PEK_FAL_EDGE = 13,
	AXP152_IRQ_GPIO3_INPUT = 14,
	AXP152_IRQ_GPIO2_INPUT = 15,
	AXP152_IRQ_GPIO1_INPUT = 16,
	AXP152_IRQ_GPIO0_INPUT = 17,
};

enum {
	AXP20X_IRQ_ACIN_OVER_V = 1,
	AXP20X_IRQ_ACIN_PLUGIN = 2,
	AXP20X_IRQ_ACIN_REMOVAL = 3,
	AXP20X_IRQ_VBUS_OVER_V = 4,
	AXP20X_IRQ_VBUS_PLUGIN = 5,
	AXP20X_IRQ_VBUS_REMOVAL = 6,
	AXP20X_IRQ_VBUS_V_LOW = 7,
	AXP20X_IRQ_BATT_PLUGIN = 8,
	AXP20X_IRQ_BATT_REMOVAL = 9,
	AXP20X_IRQ_BATT_ENT_ACT_MODE = 10,
	AXP20X_IRQ_BATT_EXIT_ACT_MODE = 11,
	AXP20X_IRQ_CHARG = 12,
	AXP20X_IRQ_CHARG_DONE = 13,
	AXP20X_IRQ_BATT_TEMP_HIGH = 14,
	AXP20X_IRQ_BATT_TEMP_LOW = 15,
	AXP20X_IRQ_DIE_TEMP_HIGH = 16,
	AXP20X_IRQ_CHARG_I_LOW = 17,
	AXP20X_IRQ_DCDC1_V_LONG = 18,
	AXP20X_IRQ_DCDC2_V_LONG = 19,
	AXP20X_IRQ_DCDC3_V_LONG = 20,
	AXP20X_IRQ_PEK_SHORT = 22,
	AXP20X_IRQ_PEK_LONG = 23,
	AXP20X_IRQ_N_OE_PWR_ON = 24,
	AXP20X_IRQ_N_OE_PWR_OFF = 25,
	AXP20X_IRQ_VBUS_VALID = 26,
	AXP20X_IRQ_VBUS_NOT_VALID = 27,
	AXP20X_IRQ_VBUS_SESS_VALID = 28,
	AXP20X_IRQ_VBUS_SESS_END = 29,
	AXP20X_IRQ_LOW_PWR_LVL1 = 30,
	AXP20X_IRQ_LOW_PWR_LVL2 = 31,
	AXP20X_IRQ_TIMER = 32,
	AXP20X_IRQ_PEK_RIS_EDGE = 33,
	AXP20X_IRQ_PEK_FAL_EDGE = 34,
	AXP20X_IRQ_GPIO3_INPUT = 35,
	AXP20X_IRQ_GPIO2_INPUT = 36,
	AXP20X_IRQ_GPIO1_INPUT = 37,
	AXP20X_IRQ_GPIO0_INPUT = 38,
};

enum axp22x_irqs {
	AXP22X_IRQ_ACIN_OVER_V = 1,
	AXP22X_IRQ_ACIN_PLUGIN = 2,
	AXP22X_IRQ_ACIN_REMOVAL = 3,
	AXP22X_IRQ_VBUS_OVER_V = 4,
	AXP22X_IRQ_VBUS_PLUGIN = 5,
	AXP22X_IRQ_VBUS_REMOVAL = 6,
	AXP22X_IRQ_VBUS_V_LOW = 7,
	AXP22X_IRQ_BATT_PLUGIN = 8,
	AXP22X_IRQ_BATT_REMOVAL = 9,
	AXP22X_IRQ_BATT_ENT_ACT_MODE = 10,
	AXP22X_IRQ_BATT_EXIT_ACT_MODE = 11,
	AXP22X_IRQ_CHARG = 12,
	AXP22X_IRQ_CHARG_DONE = 13,
	AXP22X_IRQ_BATT_TEMP_HIGH = 14,
	AXP22X_IRQ_BATT_TEMP_LOW = 15,
	AXP22X_IRQ_DIE_TEMP_HIGH = 16,
	AXP22X_IRQ_PEK_SHORT = 17,
	AXP22X_IRQ_PEK_LONG = 18,
	AXP22X_IRQ_LOW_PWR_LVL1 = 19,
	AXP22X_IRQ_LOW_PWR_LVL2 = 20,
	AXP22X_IRQ_TIMER = 21,
	AXP22X_IRQ_PEK_RIS_EDGE = 22,
	AXP22X_IRQ_PEK_FAL_EDGE = 23,
	AXP22X_IRQ_GPIO1_INPUT = 24,
	AXP22X_IRQ_GPIO0_INPUT = 25,
};

enum axp288_irqs {
	AXP288_IRQ_VBUS_FALL = 2,
	AXP288_IRQ_VBUS_RISE = 3,
	AXP288_IRQ_OV = 4,
	AXP288_IRQ_FALLING_ALT = 5,
	AXP288_IRQ_RISING_ALT = 6,
	AXP288_IRQ_OV_ALT = 7,
	AXP288_IRQ_DONE = 10,
	AXP288_IRQ_CHARGING = 11,
	AXP288_IRQ_SAFE_QUIT = 12,
	AXP288_IRQ_SAFE_ENTER = 13,
	AXP288_IRQ_ABSENT = 14,
	AXP288_IRQ_APPEND = 15,
	AXP288_IRQ_QWBTU = 16,
	AXP288_IRQ_WBTU = 17,
	AXP288_IRQ_QWBTO = 18,
	AXP288_IRQ_WBTO = 19,
	AXP288_IRQ_QCBTU = 20,
	AXP288_IRQ_CBTU = 21,
	AXP288_IRQ_QCBTO = 22,
	AXP288_IRQ_CBTO = 23,
	AXP288_IRQ_WL2 = 24,
	AXP288_IRQ_WL1 = 25,
	AXP288_IRQ_GPADC = 26,
	AXP288_IRQ_OT = 31,
	AXP288_IRQ_GPIO0 = 32,
	AXP288_IRQ_GPIO1 = 33,
	AXP288_IRQ_POKO = 34,
	AXP288_IRQ_POKL = 35,
	AXP288_IRQ_POKS = 36,
	AXP288_IRQ_POKN = 37,
	AXP288_IRQ_POKP = 38,
	AXP288_IRQ_TIMER = 39,
	AXP288_IRQ_MV_CHNG = 40,
	AXP288_IRQ_BC_USB_CHNG = 41,
};

enum axp803_irqs {
	AXP803_IRQ_ACIN_OVER_V = 1,
	AXP803_IRQ_ACIN_PLUGIN = 2,
	AXP803_IRQ_ACIN_REMOVAL = 3,
	AXP803_IRQ_VBUS_OVER_V = 4,
	AXP803_IRQ_VBUS_PLUGIN = 5,
	AXP803_IRQ_VBUS_REMOVAL = 6,
	AXP803_IRQ_BATT_PLUGIN = 7,
	AXP803_IRQ_BATT_REMOVAL = 8,
	AXP803_IRQ_BATT_ENT_ACT_MODE = 9,
	AXP803_IRQ_BATT_EXIT_ACT_MODE = 10,
	AXP803_IRQ_CHARG = 11,
	AXP803_IRQ_CHARG_DONE = 12,
	AXP803_IRQ_BATT_CHG_TEMP_HIGH = 13,
	AXP803_IRQ_BATT_CHG_TEMP_HIGH_END = 14,
	AXP803_IRQ_BATT_CHG_TEMP_LOW = 15,
	AXP803_IRQ_BATT_CHG_TEMP_LOW_END = 16,
	AXP803_IRQ_BATT_ACT_TEMP_HIGH = 17,
	AXP803_IRQ_BATT_ACT_TEMP_HIGH_END = 18,
	AXP803_IRQ_BATT_ACT_TEMP_LOW = 19,
	AXP803_IRQ_BATT_ACT_TEMP_LOW_END = 20,
	AXP803_IRQ_DIE_TEMP_HIGH = 21,
	AXP803_IRQ_GPADC = 22,
	AXP803_IRQ_LOW_PWR_LVL1 = 23,
	AXP803_IRQ_LOW_PWR_LVL2 = 24,
	AXP803_IRQ_TIMER = 25,
	AXP803_IRQ_PEK_RIS_EDGE = 26,
	AXP803_IRQ_PEK_FAL_EDGE = 27,
	AXP803_IRQ_PEK_SHORT = 28,
	AXP803_IRQ_PEK_LONG = 29,
	AXP803_IRQ_PEK_OVER_OFF = 30,
	AXP803_IRQ_GPIO1_INPUT = 31,
	AXP803_IRQ_GPIO0_INPUT = 32,
	AXP803_IRQ_BC_USB_CHNG = 33,
	AXP803_IRQ_MV_CHNG = 34,
};

enum axp806_irqs {
	AXP806_IRQ_DIE_TEMP_HIGH_LV1 = 0,
	AXP806_IRQ_DIE_TEMP_HIGH_LV2 = 1,
	AXP806_IRQ_DCDCA_V_LOW = 2,
	AXP806_IRQ_DCDCB_V_LOW = 3,
	AXP806_IRQ_DCDCC_V_LOW = 4,
	AXP806_IRQ_DCDCD_V_LOW = 5,
	AXP806_IRQ_DCDCE_V_LOW = 6,
	AXP806_IRQ_POK_LONG = 7,
	AXP806_IRQ_POK_SHORT = 8,
	AXP806_IRQ_WAKEUP = 9,
	AXP806_IRQ_POK_FALL = 10,
	AXP806_IRQ_POK_RISE = 11,
};

enum axp809_irqs {
	AXP809_IRQ_ACIN_OVER_V = 1,
	AXP809_IRQ_ACIN_PLUGIN = 2,
	AXP809_IRQ_ACIN_REMOVAL = 3,
	AXP809_IRQ_VBUS_OVER_V = 4,
	AXP809_IRQ_VBUS_PLUGIN = 5,
	AXP809_IRQ_VBUS_REMOVAL = 6,
	AXP809_IRQ_VBUS_V_LOW = 7,
	AXP809_IRQ_BATT_PLUGIN = 8,
	AXP809_IRQ_BATT_REMOVAL = 9,
	AXP809_IRQ_BATT_ENT_ACT_MODE = 10,
	AXP809_IRQ_BATT_EXIT_ACT_MODE = 11,
	AXP809_IRQ_CHARG = 12,
	AXP809_IRQ_CHARG_DONE = 13,
	AXP809_IRQ_BATT_CHG_TEMP_HIGH = 14,
	AXP809_IRQ_BATT_CHG_TEMP_HIGH_END = 15,
	AXP809_IRQ_BATT_CHG_TEMP_LOW = 16,
	AXP809_IRQ_BATT_CHG_TEMP_LOW_END = 17,
	AXP809_IRQ_BATT_ACT_TEMP_HIGH = 18,
	AXP809_IRQ_BATT_ACT_TEMP_HIGH_END = 19,
	AXP809_IRQ_BATT_ACT_TEMP_LOW = 20,
	AXP809_IRQ_BATT_ACT_TEMP_LOW_END = 21,
	AXP809_IRQ_DIE_TEMP_HIGH = 22,
	AXP809_IRQ_LOW_PWR_LVL1 = 23,
	AXP809_IRQ_LOW_PWR_LVL2 = 24,
	AXP809_IRQ_TIMER = 25,
	AXP809_IRQ_PEK_RIS_EDGE = 26,
	AXP809_IRQ_PEK_FAL_EDGE = 27,
	AXP809_IRQ_PEK_SHORT = 28,
	AXP809_IRQ_PEK_LONG = 29,
	AXP809_IRQ_PEK_OVER_OFF = 30,
	AXP809_IRQ_GPIO1_INPUT = 31,
	AXP809_IRQ_GPIO0_INPUT = 32,
};

struct max14577_regulator_platform_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *of_node;
};

struct max14577_platform_data {
	int irq_base;
	int gpio_pogo_vbatt_en;
	int gpio_pogo_vbus_en;
	int (*set_gpio_pogo_vbatt_en)(int);
	int (*set_gpio_pogo_vbus_en)(int);
	int (*set_gpio_pogo_cb)(int);
	struct max14577_regulator_platform_data *regulators;
};

struct maxim_charger_current {
	unsigned int min;
	unsigned int high_start;
	unsigned int high_step;
	unsigned int max;
};

enum maxim_device_type {
	MAXIM_DEVICE_TYPE_UNKNOWN = 0,
	MAXIM_DEVICE_TYPE_MAX14577 = 1,
	MAXIM_DEVICE_TYPE_MAX77836 = 2,
	MAXIM_DEVICE_TYPE_NUM = 3,
};

enum max14577_reg {
	MAX14577_REG_DEVICEID = 0,
	MAX14577_REG_INT1 = 1,
	MAX14577_REG_INT2 = 2,
	MAX14577_REG_INT3 = 3,
	MAX14577_REG_STATUS1 = 4,
	MAX14577_REG_STATUS2 = 5,
	MAX14577_REG_STATUS3 = 6,
	MAX14577_REG_INTMASK1 = 7,
	MAX14577_REG_INTMASK2 = 8,
	MAX14577_REG_INTMASK3 = 9,
	MAX14577_REG_CDETCTRL1 = 10,
	MAX14577_REG_RFU = 11,
	MAX14577_REG_CONTROL1 = 12,
	MAX14577_REG_CONTROL2 = 13,
	MAX14577_REG_CONTROL3 = 14,
	MAX14577_REG_CHGCTRL1 = 15,
	MAX14577_REG_CHGCTRL2 = 16,
	MAX14577_REG_CHGCTRL3 = 17,
	MAX14577_REG_CHGCTRL4 = 18,
	MAX14577_REG_CHGCTRL5 = 19,
	MAX14577_REG_CHGCTRL6 = 20,
	MAX14577_REG_CHGCTRL7 = 21,
	MAX14577_REG_END = 22,
};

enum max77836_pmic_reg {
	MAX77836_PMIC_REG_PMIC_ID = 32,
	MAX77836_PMIC_REG_PMIC_REV = 33,
	MAX77836_PMIC_REG_INTSRC = 34,
	MAX77836_PMIC_REG_INTSRC_MASK = 35,
	MAX77836_PMIC_REG_TOPSYS_INT = 36,
	MAX77836_PMIC_REG_TOPSYS_INT_MASK = 38,
	MAX77836_PMIC_REG_TOPSYS_STAT = 40,
	MAX77836_PMIC_REG_MRSTB_CNTL = 42,
	MAX77836_PMIC_REG_LSCNFG = 43,
	MAX77836_LDO_REG_CNFG1_LDO1 = 81,
	MAX77836_LDO_REG_CNFG2_LDO1 = 82,
	MAX77836_LDO_REG_CNFG1_LDO2 = 83,
	MAX77836_LDO_REG_CNFG2_LDO2 = 84,
	MAX77836_LDO_REG_CNFG_LDO_BIAS = 85,
	MAX77836_COMP_REG_COMP1 = 96,
	MAX77836_PMIC_REG_END = 97,
};

enum max77836_fg_reg {
	MAX77836_FG_REG_VCELL_MSB = 2,
	MAX77836_FG_REG_VCELL_LSB = 3,
	MAX77836_FG_REG_SOC_MSB = 4,
	MAX77836_FG_REG_SOC_LSB = 5,
	MAX77836_FG_REG_MODE_H = 6,
	MAX77836_FG_REG_MODE_L = 7,
	MAX77836_FG_REG_VERSION_MSB = 8,
	MAX77836_FG_REG_VERSION_LSB = 9,
	MAX77836_FG_REG_HIBRT_H = 10,
	MAX77836_FG_REG_HIBRT_L = 11,
	MAX77836_FG_REG_CONFIG_H = 12,
	MAX77836_FG_REG_CONFIG_L = 13,
	MAX77836_FG_REG_VALRT_MIN = 20,
	MAX77836_FG_REG_VALRT_MAX = 21,
	MAX77836_FG_REG_CRATE_MSB = 22,
	MAX77836_FG_REG_CRATE_LSB = 23,
	MAX77836_FG_REG_VRESET = 24,
	MAX77836_FG_REG_FGID = 25,
	MAX77836_FG_REG_STATUS_H = 26,
	MAX77836_FG_REG_STATUS_L = 27,
	MAX77836_FG_REG_END = 28,
};

struct max14577 {
	struct device *dev;
	struct i2c_client *i2c;
	struct i2c_client *i2c_pmic;
	enum maxim_device_type dev_type;
	struct regmap *regmap;
	struct regmap *regmap_pmic;
	struct regmap_irq_chip_data *irq_data;
	struct regmap_irq_chip_data *irq_data_pmic;
	int irq;
};

enum max77802_rtc_reg {
	MAX77802_RTC_INT = 192,
	MAX77802_RTC_INTM = 193,
	MAX77802_RTC_CONTROLM = 194,
	MAX77802_RTC_CONTROL = 195,
	MAX77802_RTC_UPDATE0 = 196,
	MAX77802_RTC_UPDATE1 = 197,
	MAX77802_WTSR_SMPL_CNTL = 198,
	MAX77802_RTC_SEC = 199,
	MAX77802_RTC_MIN = 200,
	MAX77802_RTC_HOUR = 201,
	MAX77802_RTC_WEEKDAY = 202,
	MAX77802_RTC_MONTH = 203,
	MAX77802_RTC_YEAR = 204,
	MAX77802_RTC_DATE = 205,
	MAX77802_RTC_AE1 = 206,
	MAX77802_ALARM1_SEC = 207,
	MAX77802_ALARM1_MIN = 208,
	MAX77802_ALARM1_HOUR = 209,
	MAX77802_ALARM1_WEEKDAY = 210,
	MAX77802_ALARM1_MONTH = 211,
	MAX77802_ALARM1_YEAR = 212,
	MAX77802_ALARM1_DATE = 213,
	MAX77802_RTC_AE2 = 214,
	MAX77802_ALARM2_SEC = 215,
	MAX77802_ALARM2_MIN = 216,
	MAX77802_ALARM2_HOUR = 217,
	MAX77802_ALARM2_WEEKDAY = 218,
	MAX77802_ALARM2_MONTH = 219,
	MAX77802_ALARM2_YEAR = 220,
	MAX77802_ALARM2_DATE = 221,
	MAX77802_RTC_END = 223,
};

enum max77686_types {
	TYPE_MAX77686 = 0,
	TYPE_MAX77802 = 1,
};

struct max8997_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
};

struct max8997_muic_reg_data {
	u8 addr;
	u8 data;
};

struct max8997_muic_platform_data {
	struct max8997_muic_reg_data *init_data;
	int num_init_data;
	int detcable_delay_ms;
	int path_usb;
	int path_uart;
};

enum max8997_haptic_motor_type {
	MAX8997_HAPTIC_ERM = 0,
	MAX8997_HAPTIC_LRA = 1,
};

enum max8997_haptic_pulse_mode {
	MAX8997_EXTERNAL_MODE = 0,
	MAX8997_INTERNAL_MODE = 1,
};

enum max8997_haptic_pwm_divisor {
	MAX8997_PWM_DIVISOR_32 = 0,
	MAX8997_PWM_DIVISOR_64 = 1,
	MAX8997_PWM_DIVISOR_128 = 2,
	MAX8997_PWM_DIVISOR_256 = 3,
};

struct max8997_haptic_platform_data {
	unsigned int pwm_channel_id;
	unsigned int pwm_period;
	enum max8997_haptic_motor_type type;
	enum max8997_haptic_pulse_mode mode;
	enum max8997_haptic_pwm_divisor pwm_divisor;
	unsigned int internal_mode_pattern;
	unsigned int pattern_cycle;
	unsigned int pattern_signal_period;
};

enum max8997_led_mode {
	MAX8997_NONE = 0,
	MAX8997_FLASH_MODE = 1,
	MAX8997_MOVIE_MODE = 2,
	MAX8997_FLASH_PIN_CONTROL_MODE = 3,
	MAX8997_MOVIE_PIN_CONTROL_MODE = 4,
};

struct max8997_led_platform_data {
	enum max8997_led_mode mode[2];
	u8 brightness[2];
};

struct max8997_platform_data {
	int ono;
	struct max8997_regulator_data *regulators;
	int num_regulators;
	bool ignore_gpiodvs_side_effect;
	int buck125_gpios[3];
	int buck125_default_idx;
	unsigned int buck1_voltage[8];
	bool buck1_gpiodvs;
	unsigned int buck2_voltage[8];
	bool buck2_gpiodvs;
	unsigned int buck5_voltage[8];
	bool buck5_gpiodvs;
	int eoc_mA;
	int timeout;
	struct max8997_muic_platform_data *muic_pdata;
	struct max8997_haptic_platform_data *haptic_pdata;
	struct max8997_led_platform_data *led_pdata;
};

enum max8997_pmic_reg {
	MAX8997_REG_PMIC_ID0 = 0,
	MAX8997_REG_PMIC_ID1 = 1,
	MAX8997_REG_INTSRC = 2,
	MAX8997_REG_INT1 = 3,
	MAX8997_REG_INT2 = 4,
	MAX8997_REG_INT3 = 5,
	MAX8997_REG_INT4 = 6,
	MAX8997_REG_INT1MSK = 8,
	MAX8997_REG_INT2MSK = 9,
	MAX8997_REG_INT3MSK = 10,
	MAX8997_REG_INT4MSK = 11,
	MAX8997_REG_STATUS1 = 13,
	MAX8997_REG_STATUS2 = 14,
	MAX8997_REG_STATUS3 = 15,
	MAX8997_REG_STATUS4 = 16,
	MAX8997_REG_MAINCON1 = 19,
	MAX8997_REG_MAINCON2 = 20,
	MAX8997_REG_BUCKRAMP = 21,
	MAX8997_REG_BUCK1CTRL = 24,
	MAX8997_REG_BUCK1DVS1 = 25,
	MAX8997_REG_BUCK1DVS2 = 26,
	MAX8997_REG_BUCK1DVS3 = 27,
	MAX8997_REG_BUCK1DVS4 = 28,
	MAX8997_REG_BUCK1DVS5 = 29,
	MAX8997_REG_BUCK1DVS6 = 30,
	MAX8997_REG_BUCK1DVS7 = 31,
	MAX8997_REG_BUCK1DVS8 = 32,
	MAX8997_REG_BUCK2CTRL = 33,
	MAX8997_REG_BUCK2DVS1 = 34,
	MAX8997_REG_BUCK2DVS2 = 35,
	MAX8997_REG_BUCK2DVS3 = 36,
	MAX8997_REG_BUCK2DVS4 = 37,
	MAX8997_REG_BUCK2DVS5 = 38,
	MAX8997_REG_BUCK2DVS6 = 39,
	MAX8997_REG_BUCK2DVS7 = 40,
	MAX8997_REG_BUCK2DVS8 = 41,
	MAX8997_REG_BUCK3CTRL = 42,
	MAX8997_REG_BUCK3DVS = 43,
	MAX8997_REG_BUCK4CTRL = 44,
	MAX8997_REG_BUCK4DVS = 45,
	MAX8997_REG_BUCK5CTRL = 46,
	MAX8997_REG_BUCK5DVS1 = 47,
	MAX8997_REG_BUCK5DVS2 = 48,
	MAX8997_REG_BUCK5DVS3 = 49,
	MAX8997_REG_BUCK5DVS4 = 50,
	MAX8997_REG_BUCK5DVS5 = 51,
	MAX8997_REG_BUCK5DVS6 = 52,
	MAX8997_REG_BUCK5DVS7 = 53,
	MAX8997_REG_BUCK5DVS8 = 54,
	MAX8997_REG_BUCK6CTRL = 55,
	MAX8997_REG_BUCK6BPSKIPCTRL = 56,
	MAX8997_REG_BUCK7CTRL = 57,
	MAX8997_REG_BUCK7DVS = 58,
	MAX8997_REG_LDO1CTRL = 59,
	MAX8997_REG_LDO2CTRL = 60,
	MAX8997_REG_LDO3CTRL = 61,
	MAX8997_REG_LDO4CTRL = 62,
	MAX8997_REG_LDO5CTRL = 63,
	MAX8997_REG_LDO6CTRL = 64,
	MAX8997_REG_LDO7CTRL = 65,
	MAX8997_REG_LDO8CTRL = 66,
	MAX8997_REG_LDO9CTRL = 67,
	MAX8997_REG_LDO10CTRL = 68,
	MAX8997_REG_LDO11CTRL = 69,
	MAX8997_REG_LDO12CTRL = 70,
	MAX8997_REG_LDO13CTRL = 71,
	MAX8997_REG_LDO14CTRL = 72,
	MAX8997_REG_LDO15CTRL = 73,
	MAX8997_REG_LDO16CTRL = 74,
	MAX8997_REG_LDO17CTRL = 75,
	MAX8997_REG_LDO18CTRL = 76,
	MAX8997_REG_LDO21CTRL = 77,
	MAX8997_REG_MBCCTRL1 = 80,
	MAX8997_REG_MBCCTRL2 = 81,
	MAX8997_REG_MBCCTRL3 = 82,
	MAX8997_REG_MBCCTRL4 = 83,
	MAX8997_REG_MBCCTRL5 = 84,
	MAX8997_REG_MBCCTRL6 = 85,
	MAX8997_REG_OTPCGHCVS = 86,
	MAX8997_REG_SAFEOUTCTRL = 90,
	MAX8997_REG_LBCNFG1 = 94,
	MAX8997_REG_LBCNFG2 = 95,
	MAX8997_REG_BBCCTRL = 96,
	MAX8997_REG_FLASH1_CUR = 99,
	MAX8997_REG_FLASH2_CUR = 100,
	MAX8997_REG_MOVIE_CUR = 101,
	MAX8997_REG_GSMB_CUR = 102,
	MAX8997_REG_BOOST_CNTL = 103,
	MAX8997_REG_LEN_CNTL = 104,
	MAX8997_REG_FLASH_CNTL = 105,
	MAX8997_REG_WDT_CNTL = 106,
	MAX8997_REG_MAXFLASH1 = 107,
	MAX8997_REG_MAXFLASH2 = 108,
	MAX8997_REG_FLASHSTATUS = 109,
	MAX8997_REG_FLASHSTATUSMASK = 110,
	MAX8997_REG_GPIOCNTL1 = 112,
	MAX8997_REG_GPIOCNTL2 = 113,
	MAX8997_REG_GPIOCNTL3 = 114,
	MAX8997_REG_GPIOCNTL4 = 115,
	MAX8997_REG_GPIOCNTL5 = 116,
	MAX8997_REG_GPIOCNTL6 = 117,
	MAX8997_REG_GPIOCNTL7 = 118,
	MAX8997_REG_GPIOCNTL8 = 119,
	MAX8997_REG_GPIOCNTL9 = 120,
	MAX8997_REG_GPIOCNTL10 = 121,
	MAX8997_REG_GPIOCNTL11 = 122,
	MAX8997_REG_GPIOCNTL12 = 123,
	MAX8997_REG_LDO1CONFIG = 128,
	MAX8997_REG_LDO2CONFIG = 129,
	MAX8997_REG_LDO3CONFIG = 130,
	MAX8997_REG_LDO4CONFIG = 131,
	MAX8997_REG_LDO5CONFIG = 132,
	MAX8997_REG_LDO6CONFIG = 133,
	MAX8997_REG_LDO7CONFIG = 134,
	MAX8997_REG_LDO8CONFIG = 135,
	MAX8997_REG_LDO9CONFIG = 136,
	MAX8997_REG_LDO10CONFIG = 137,
	MAX8997_REG_LDO11CONFIG = 138,
	MAX8997_REG_LDO12CONFIG = 139,
	MAX8997_REG_LDO13CONFIG = 140,
	MAX8997_REG_LDO14CONFIG = 141,
	MAX8997_REG_LDO15CONFIG = 142,
	MAX8997_REG_LDO16CONFIG = 143,
	MAX8997_REG_LDO17CONFIG = 144,
	MAX8997_REG_LDO18CONFIG = 145,
	MAX8997_REG_LDO21CONFIG = 146,
	MAX8997_REG_DVSOKTIMER1 = 151,
	MAX8997_REG_DVSOKTIMER2 = 152,
	MAX8997_REG_DVSOKTIMER4 = 153,
	MAX8997_REG_DVSOKTIMER5 = 154,
	MAX8997_REG_PMIC_END = 155,
};

enum max8997_muic_reg {
	MAX8997_MUIC_REG_ID = 0,
	MAX8997_MUIC_REG_INT1 = 1,
	MAX8997_MUIC_REG_INT2 = 2,
	MAX8997_MUIC_REG_INT3 = 3,
	MAX8997_MUIC_REG_STATUS1 = 4,
	MAX8997_MUIC_REG_STATUS2 = 5,
	MAX8997_MUIC_REG_STATUS3 = 6,
	MAX8997_MUIC_REG_INTMASK1 = 7,
	MAX8997_MUIC_REG_INTMASK2 = 8,
	MAX8997_MUIC_REG_INTMASK3 = 9,
	MAX8997_MUIC_REG_CDETCTRL = 10,
	MAX8997_MUIC_REG_CONTROL1 = 12,
	MAX8997_MUIC_REG_CONTROL2 = 13,
	MAX8997_MUIC_REG_CONTROL3 = 14,
	MAX8997_MUIC_REG_END = 15,
};

enum max8997_haptic_reg {
	MAX8997_HAPTIC_REG_GENERAL = 0,
	MAX8997_HAPTIC_REG_CONF1 = 1,
	MAX8997_HAPTIC_REG_CONF2 = 2,
	MAX8997_HAPTIC_REG_DRVCONF = 3,
	MAX8997_HAPTIC_REG_CYCLECONF1 = 4,
	MAX8997_HAPTIC_REG_CYCLECONF2 = 5,
	MAX8997_HAPTIC_REG_SIGCONF1 = 6,
	MAX8997_HAPTIC_REG_SIGCONF2 = 7,
	MAX8997_HAPTIC_REG_SIGCONF3 = 8,
	MAX8997_HAPTIC_REG_SIGCONF4 = 9,
	MAX8997_HAPTIC_REG_SIGDC1 = 10,
	MAX8997_HAPTIC_REG_SIGDC2 = 11,
	MAX8997_HAPTIC_REG_SIGPWMDC1 = 12,
	MAX8997_HAPTIC_REG_SIGPWMDC2 = 13,
	MAX8997_HAPTIC_REG_SIGPWMDC3 = 14,
	MAX8997_HAPTIC_REG_SIGPWMDC4 = 15,
	MAX8997_HAPTIC_REG_MTR_REV = 16,
	MAX8997_HAPTIC_REG_END = 17,
};

enum max8997_irq_source {
	PMIC_INT1___2 = 0,
	PMIC_INT2___2 = 1,
	PMIC_INT3 = 2,
	PMIC_INT4 = 3,
	FUEL_GAUGE = 4,
	MUIC_INT1 = 5,
	MUIC_INT2 = 6,
	MUIC_INT3 = 7,
	GPIO_LOW = 8,
	GPIO_HI = 9,
	FLASH_STATUS = 10,
	MAX8997_IRQ_GROUP_NR = 11,
};

struct max8997_dev {
	struct device *dev;
	struct max8997_platform_data *pdata;
	struct i2c_client *i2c;
	struct i2c_client *rtc;
	struct i2c_client *haptic;
	struct i2c_client *muic;
	struct mutex iolock;
	long unsigned int type;
	struct platform_device *battery;
	int irq;
	int ono;
	struct irq_domain *irq_domain;
	struct mutex irqlock;
	int irq_masks_cur[11];
	int irq_masks_cache[11];
	u8 reg_dump[187];
	bool gpio_status[12];
};

enum max8997_types {
	TYPE_MAX8997 = 0,
	TYPE_MAX8966 = 1,
};

enum max8997_irq {
	MAX8997_PMICIRQ_PWRONR = 0,
	MAX8997_PMICIRQ_PWRONF = 1,
	MAX8997_PMICIRQ_PWRON1SEC = 2,
	MAX8997_PMICIRQ_JIGONR = 3,
	MAX8997_PMICIRQ_JIGONF = 4,
	MAX8997_PMICIRQ_LOWBAT2 = 5,
	MAX8997_PMICIRQ_LOWBAT1 = 6,
	MAX8997_PMICIRQ_JIGR = 7,
	MAX8997_PMICIRQ_JIGF = 8,
	MAX8997_PMICIRQ_MR = 9,
	MAX8997_PMICIRQ_DVS1OK = 10,
	MAX8997_PMICIRQ_DVS2OK = 11,
	MAX8997_PMICIRQ_DVS3OK = 12,
	MAX8997_PMICIRQ_DVS4OK = 13,
	MAX8997_PMICIRQ_CHGINS = 14,
	MAX8997_PMICIRQ_CHGRM = 15,
	MAX8997_PMICIRQ_DCINOVP = 16,
	MAX8997_PMICIRQ_TOPOFFR = 17,
	MAX8997_PMICIRQ_CHGRSTF = 18,
	MAX8997_PMICIRQ_MBCHGTMEXPD = 19,
	MAX8997_PMICIRQ_RTC60S = 20,
	MAX8997_PMICIRQ_RTCA1 = 21,
	MAX8997_PMICIRQ_RTCA2 = 22,
	MAX8997_PMICIRQ_SMPL_INT = 23,
	MAX8997_PMICIRQ_RTC1S = 24,
	MAX8997_PMICIRQ_WTSR = 25,
	MAX8997_MUICIRQ_ADCError = 26,
	MAX8997_MUICIRQ_ADCLow = 27,
	MAX8997_MUICIRQ_ADC = 28,
	MAX8997_MUICIRQ_VBVolt = 29,
	MAX8997_MUICIRQ_DBChg = 30,
	MAX8997_MUICIRQ_DCDTmr = 31,
	MAX8997_MUICIRQ_ChgDetRun = 32,
	MAX8997_MUICIRQ_ChgTyp = 33,
	MAX8997_MUICIRQ_OVP = 34,
	MAX8997_IRQ_NR = 35,
};

struct max8997_irq_data {
	int mask;
	enum max8997_irq_source group;
};

struct max8998_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
};

struct max8998_platform_data {
	struct max8998_regulator_data *regulators;
	int num_regulators;
	unsigned int irq_base;
	int ono;
	bool buck_voltage_lock;
	int buck1_voltage[4];
	int buck2_voltage[2];
	int buck1_set1;
	int buck1_set2;
	int buck1_default_idx;
	int buck2_set3;
	int buck2_default_idx;
	bool wakeup;
	bool rtc_delay;
	int eoc;
	int restart;
	int timeout;
};

enum {
	MAX8998_REG_IRQ1 = 0,
	MAX8998_REG_IRQ2 = 1,
	MAX8998_REG_IRQ3 = 2,
	MAX8998_REG_IRQ4 = 3,
	MAX8998_REG_IRQM1 = 4,
	MAX8998_REG_IRQM2 = 5,
	MAX8998_REG_IRQM3 = 6,
	MAX8998_REG_IRQM4 = 7,
	MAX8998_REG_STATUS1 = 8,
	MAX8998_REG_STATUS2 = 9,
	MAX8998_REG_STATUSM1 = 10,
	MAX8998_REG_STATUSM2 = 11,
	MAX8998_REG_CHGR1 = 12,
	MAX8998_REG_CHGR2 = 13,
	MAX8998_REG_LDO_ACTIVE_DISCHARGE1 = 14,
	MAX8998_REG_LDO_ACTIVE_DISCHARGE2 = 15,
	MAX8998_REG_BUCK_ACTIVE_DISCHARGE3 = 16,
	MAX8998_REG_ONOFF1 = 17,
	MAX8998_REG_ONOFF2 = 18,
	MAX8998_REG_ONOFF3 = 19,
	MAX8998_REG_ONOFF4 = 20,
	MAX8998_REG_BUCK1_VOLTAGE1 = 21,
	MAX8998_REG_BUCK1_VOLTAGE2 = 22,
	MAX8998_REG_BUCK1_VOLTAGE3 = 23,
	MAX8998_REG_BUCK1_VOLTAGE4 = 24,
	MAX8998_REG_BUCK2_VOLTAGE1 = 25,
	MAX8998_REG_BUCK2_VOLTAGE2 = 26,
	MAX8998_REG_BUCK3 = 27,
	MAX8998_REG_BUCK4 = 28,
	MAX8998_REG_LDO2_LDO3 = 29,
	MAX8998_REG_LDO4 = 30,
	MAX8998_REG_LDO5 = 31,
	MAX8998_REG_LDO6 = 32,
	MAX8998_REG_LDO7 = 33,
	MAX8998_REG_LDO8_LDO9 = 34,
	MAX8998_REG_LDO10_LDO11 = 35,
	MAX8998_REG_LDO12 = 36,
	MAX8998_REG_LDO13 = 37,
	MAX8998_REG_LDO14 = 38,
	MAX8998_REG_LDO15 = 39,
	MAX8998_REG_LDO16 = 40,
	MAX8998_REG_LDO17 = 41,
	MAX8998_REG_BKCHR = 42,
	MAX8998_REG_LBCNFG1 = 43,
	MAX8998_REG_LBCNFG2 = 44,
};

enum {
	TYPE_MAX8998 = 0,
	TYPE_LP3974 = 1,
	TYPE_LP3979 = 2,
};

struct max8998_dev {
	struct device *dev;
	struct max8998_platform_data *pdata;
	struct i2c_client *i2c;
	struct i2c_client *rtc;
	struct mutex iolock;
	struct mutex irqlock;
	unsigned int irq_base;
	struct irq_domain *irq_domain;
	int irq;
	int ono;
	u8 irq_masks_cur[4];
	u8 irq_masks_cache[4];
	long unsigned int type;
	bool wakeup;
};

struct max8998_reg_dump {
	u8 addr;
	u8 val;
};

enum {
	MAX8998_IRQ_DCINF = 0,
	MAX8998_IRQ_DCINR = 1,
	MAX8998_IRQ_JIGF = 2,
	MAX8998_IRQ_JIGR = 3,
	MAX8998_IRQ_PWRONF = 4,
	MAX8998_IRQ_PWRONR = 5,
	MAX8998_IRQ_WTSREVNT = 6,
	MAX8998_IRQ_SMPLEVNT = 7,
	MAX8998_IRQ_ALARM1 = 8,
	MAX8998_IRQ_ALARM0 = 9,
	MAX8998_IRQ_ONKEY1S = 10,
	MAX8998_IRQ_TOPOFFR = 11,
	MAX8998_IRQ_DCINOVPR = 12,
	MAX8998_IRQ_CHGRSTF = 13,
	MAX8998_IRQ_DONER = 14,
	MAX8998_IRQ_CHGFAULT = 15,
	MAX8998_IRQ_LOBAT1 = 16,
	MAX8998_IRQ_LOBAT2 = 17,
	MAX8998_IRQ_NR = 18,
};

struct max8998_irq_data {
	int reg;
	int mask;
};

struct max8997_dev___2;

struct abx500_ops {
	int (*get_chip_id)(struct device *);
	int (*get_register)(struct device *, u8, u8, u8 *);
	int (*set_register)(struct device *, u8, u8, u8);
	int (*get_register_page)(struct device *, u8, u8, u8 *, u8);
	int (*set_register_page)(struct device *, u8, u8, u8 *, u8);
	int (*mask_and_set_register)(struct device *, u8, u8, u8, u8);
	int (*event_registers_startup_state_get)(struct device *, u8 *);
	int (*startup_irq_enabled)(struct device *, unsigned int);
	void (*dump_all_banks)(struct device *);
};

struct abx500_device_entry {
	struct list_head list;
	struct abx500_ops ops;
	struct device *dev;
};

enum prcmu_wakeup_index {
	PRCMU_WAKEUP_INDEX_RTC = 0,
	PRCMU_WAKEUP_INDEX_RTT0 = 1,
	PRCMU_WAKEUP_INDEX_RTT1 = 2,
	PRCMU_WAKEUP_INDEX_HSI0 = 3,
	PRCMU_WAKEUP_INDEX_HSI1 = 4,
	PRCMU_WAKEUP_INDEX_USB = 5,
	PRCMU_WAKEUP_INDEX_ABB = 6,
	PRCMU_WAKEUP_INDEX_ABB_FIFO = 7,
	PRCMU_WAKEUP_INDEX_ARM = 8,
	PRCMU_WAKEUP_INDEX_CD_IRQ = 9,
	NUM_PRCMU_WAKEUP_INDICES = 10,
};

enum ape_opp {
	APE_OPP_INIT = 0,
	APE_NO_CHANGE = 1,
	APE_100_OPP = 2,
	APE_50_OPP = 3,
	APE_50_PARTLY_25_OPP = 255,
};

enum arm_opp {
	ARM_OPP_INIT = 0,
	ARM_NO_CHANGE = 1,
	ARM_100_OPP = 2,
	ARM_50_OPP = 3,
	ARM_MAX_OPP = 4,
	ARM_MAX_FREQ100OPP = 5,
	ARM_EXTCLK = 7,
};

enum ddr_pwrst {
	DDR_PWR_STATE_UNCHANGED = 0,
	DDR_PWR_STATE_ON = 1,
	DDR_PWR_STATE_OFFLOWLAT = 2,
	DDR_PWR_STATE_OFFHIGHLAT = 3,
};

enum state___2 {
	OFF___2 = 0,
	ON = 1,
};

enum romcode_write {
	RDY_2_DS = 9,
	RDY_2_XP70_RST = 16,
};

enum romcode_read {
	INIT___2 = 0,
	FS_2_DS = 10,
	END_DS = 11,
	DS_TO_FS = 12,
	END_FS = 13,
	SWR = 14,
	END_SWR = 15,
};

enum ap_pwrst {
	NO_PWRST = 0,
	AP_BOOT = 1,
	AP_EXECUTE = 2,
	AP_DEEP_SLEEP = 3,
	AP_SLEEP = 4,
	AP_IDLE = 5,
	AP_RESET = 6,
};

enum ap_pwrst_trans {
	PRCMU_AP_NO_CHANGE = 0,
	APEXECUTE_TO_APSLEEP = 1,
	APIDLE_TO_APSLEEP = 2,
	PRCMU_AP_SLEEP = 1,
	APBOOT_TO_APEXECUTE = 3,
	APEXECUTE_TO_APDEEPSLEEP = 4,
	PRCMU_AP_DEEP_SLEEP = 4,
	APEXECUTE_TO_APIDLE = 5,
	PRCMU_AP_IDLE = 5,
	PRCMU_AP_DEEP_IDLE = 7,
};

struct prcmu_auto_pm_config {
	u8 sia_auto_pm_enable;
	u8 sia_power_on;
	u8 sia_policy;
	u8 sva_auto_pm_enable;
	u8 sva_power_on;
	u8 sva_policy;
};

struct ux500_wdt_data {
	unsigned int timeout;
	bool has_28_bits_resolution;
};

struct clk_mgt {
	u32 offset;
	u32 pllsw;
	int branch;
	bool clk38div;
};

enum {
	PLL_RAW = 0,
	PLL_FIX = 1,
	PLL_DIV = 2,
};

struct dsiclk {
	u32 divsel_mask;
	u32 divsel_shift;
	u32 divsel;
};

struct dsiescclk {
	u32 en;
	u32 div_mask;
	u32 div_shift;
};

enum abx500_adc_therm {
	ABx500_ADC_THERM_BATCTRL = 0,
	ABx500_ADC_THERM_BATTEMP = 1,
};

struct abx500_res_to_temp {
	int temp;
	int resist;
};

struct abx500_v_to_cap {
	int voltage;
	int capacity;
};

struct abx500_fg_parameters {
	int recovery_sleep_timer;
	int recovery_total_time;
	int init_timer;
	int init_discard_time;
	int init_total_time;
	int high_curr_time;
	int accu_charging;
	int accu_high_curr;
	int high_curr_threshold;
	int lowbat_threshold;
	int overbat_threshold;
	int battok_falling_th_sel0;
	int battok_raising_th_sel1;
	int user_cap_limit;
	int maint_thres;
	bool pcut_enable;
	u8 pcut_max_time;
	u8 pcut_flag_time;
	u8 pcut_max_restart;
	u8 pcut_debounce_time;
};

struct abx500_maxim_parameters {
	bool ena_maxi;
	int chg_curr;
	int wait_cycles;
	int charger_curr_step;
};

struct batres_vs_temp;

struct abx500_battery_type {
	int name;
	int resis_high;
	int resis_low;
	int charge_full_design;
	int nominal_voltage;
	int termination_vol;
	int termination_curr;
	int recharge_cap;
	int normal_cur_lvl;
	int normal_vol_lvl;
	int maint_a_cur_lvl;
	int maint_a_vol_lvl;
	int maint_a_chg_timer_h;
	int maint_b_cur_lvl;
	int maint_b_vol_lvl;
	int maint_b_chg_timer_h;
	int low_high_cur_lvl;
	int low_high_vol_lvl;
	int battery_resistance;
	int n_temp_tbl_elements;
	const struct abx500_res_to_temp *r_to_t_tbl;
	int n_v_cap_tbl_elements;
	const struct abx500_v_to_cap *v_to_cap_tbl;
	int n_batres_tbl_elements;
	const struct batres_vs_temp *batres_tbl;
};

struct batres_vs_temp {
	int temp;
	int resist;
};

struct abx500_bm_capacity_levels {
	int critical;
	int low;
	int normal;
	int high;
	int full;
};

struct abx500_bm_charger_parameters {
	int usb_volt_max;
	int usb_curr_max;
	int ac_volt_max;
	int ac_curr_max;
};

struct abx500_bm_data {
	int temp_under;
	int temp_low;
	int temp_high;
	int temp_over;
	int temp_now;
	int temp_interval_chg;
	int temp_interval_nochg;
	int main_safety_tmr_h;
	int usb_safety_tmr_h;
	int bkup_bat_v;
	int bkup_bat_i;
	bool autopower_cfg;
	bool ac_enabled;
	bool usb_enabled;
	bool no_maintenance;
	bool capacity_scaling;
	bool chg_unknown_bat;
	bool enable_overshoot;
	bool auto_trig;
	enum abx500_adc_therm adc_therm;
	int fg_res;
	int n_btypes;
	int batt_id;
	int interval_charging;
	int interval_not_charging;
	int temp_hysteresis;
	int gnd_lift_resistance;
	int n_chg_out_curr;
	int n_chg_in_curr;
	int *chg_output_curr;
	int *chg_input_curr;
	const struct abx500_maxim_parameters *maxi;
	const struct abx500_bm_capacity_levels *cap_levels;
	struct abx500_battery_type *bat_type;
	const struct abx500_bm_charger_parameters *chg_params;
	const struct abx500_fg_parameters *fg_params;
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

struct tps6586x_irq_data {
	u8 mask_reg;
	u8 mask_mask;
};

struct tps6586x {
	struct device *dev;
	struct i2c_client *client;
	struct regmap *regmap;
	int version;
	int irq;
	struct irq_chip irq_chip;
	struct mutex irq_lock;
	int irq_base;
	u32 irq_en;
	u8 mask_reg[5];
	struct irq_domain *irq_domain;
};

enum usbhs_omap_port_mode {
	OMAP_USBHS_PORT_MODE_UNUSED = 0,
	OMAP_EHCI_PORT_MODE_PHY = 1,
	OMAP_EHCI_PORT_MODE_TLL = 2,
	OMAP_EHCI_PORT_MODE_HSIC = 3,
	OMAP_OHCI_PORT_MODE_PHY_6PIN_DATSE0 = 4,
	OMAP_OHCI_PORT_MODE_PHY_6PIN_DPDM = 5,
	OMAP_OHCI_PORT_MODE_PHY_3PIN_DATSE0 = 6,
	OMAP_OHCI_PORT_MODE_PHY_4PIN_DPDM = 7,
	OMAP_OHCI_PORT_MODE_TLL_6PIN_DATSE0 = 8,
	OMAP_OHCI_PORT_MODE_TLL_6PIN_DPDM = 9,
	OMAP_OHCI_PORT_MODE_TLL_3PIN_DATSE0 = 10,
	OMAP_OHCI_PORT_MODE_TLL_4PIN_DPDM = 11,
	OMAP_OHCI_PORT_MODE_TLL_2PIN_DATSE0 = 12,
	OMAP_OHCI_PORT_MODE_TLL_2PIN_DPDM = 13,
};

struct ehci_hcd_omap_platform_data {
	enum usbhs_omap_port_mode port_mode[3];
	int reset_gpio_port[3];
	struct regulator *regulator[3];
	unsigned int phy_reset: 1;
};

struct ohci_hcd_omap_platform_data {
	enum usbhs_omap_port_mode port_mode[3];
	unsigned int es2_compatibility: 1;
};

struct usbhs_omap_platform_data {
	int nports;
	enum usbhs_omap_port_mode port_mode[3];
	int reset_gpio_port[3];
	struct regulator *regulator[3];
	struct ehci_hcd_omap_platform_data *ehci_data;
	struct ohci_hcd_omap_platform_data *ohci_data;
	unsigned int single_ulpi_bypass: 1;
	unsigned int es2_compatibility: 1;
	unsigned int phy_reset: 1;
};

struct usbhs_hcd_omap {
	int nports;
	struct clk **utmi_clk;
	struct clk **hsic60m_clk;
	struct clk **hsic480m_clk;
	struct clk *xclk60mhsp1_ck;
	struct clk *xclk60mhsp2_ck;
	struct clk *utmi_p1_gfclk;
	struct clk *utmi_p2_gfclk;
	struct clk *init_60m_fclk;
	struct clk *ehci_logic_fck;
	void *uhh_base;
	struct usbhs_omap_platform_data *pdata;
	u32 usbhs_rev;
};

struct usbtll_omap {
	void *base;
	int nch;
	struct clk *ch_clk[0];
};

struct pm_irq_data {
	int num_irqs;
	struct irq_chip *irq_chip;
	void (*irq_handler)(struct irq_desc *);
};

struct pm_irq_chip {
	struct regmap *regmap;
	spinlock_t pm_irq_lock;
	struct irq_domain *irqdomain;
	unsigned int num_blocks;
	unsigned int num_masters;
	const struct pm_irq_data *pm_irq_data;
	u8 config[0];
};

enum ssbi_controller_type {
	MSM_SBI_CTRL_SSBI = 0,
	MSM_SBI_CTRL_SSBI2 = 1,
	MSM_SBI_CTRL_PMIC_ARBITER = 2,
};

struct ssbi {
	struct device *slave;
	void *base;
	spinlock_t lock;
	enum ssbi_controller_type controller_type;
	int (*read)(struct ssbi *, u16, u8 *, int);
	int (*write)(struct ssbi *, u16, const u8 *, int);
};

struct qcom_rpm_resource {
	unsigned int target_id;
	unsigned int status_id;
	unsigned int select_id;
	unsigned int size;
};

struct qcom_rpm_data {
	u32 version;
	const struct qcom_rpm_resource *resource_table;
	unsigned int n_resources;
	unsigned int req_ctx_off;
	unsigned int req_sel_off;
	unsigned int ack_ctx_off;
	unsigned int ack_sel_off;
	unsigned int req_sel_size;
	unsigned int ack_sel_size;
};

struct qcom_rpm___2 {
	struct device *dev;
	struct regmap *ipc_regmap;
	unsigned int ipc_offset;
	unsigned int ipc_bit;
	struct clk *ramclk;
	struct completion ack;
	struct mutex lock;
	void *status_regs;
	void *ctrl_regs;
	void *req_regs;
	u32 ack_status;
	const struct qcom_rpm_data *data;
};

struct spmi_driver {
	struct device_driver driver;
	int (*probe)(struct spmi_device *);
	void (*remove)(struct spmi_device *);
	void (*shutdown)(struct spmi_device *);
};

enum {
	TPS65090_IRQ_INTERRUPT = 0,
	TPS65090_IRQ_VAC_STATUS_CHANGE = 1,
	TPS65090_IRQ_VSYS_STATUS_CHANGE = 2,
	TPS65090_IRQ_BAT_STATUS_CHANGE = 3,
	TPS65090_IRQ_CHARGING_STATUS_CHANGE = 4,
	TPS65090_IRQ_CHARGING_COMPLETE = 5,
	TPS65090_IRQ_OVERLOAD_DCDC1 = 6,
	TPS65090_IRQ_OVERLOAD_DCDC2 = 7,
	TPS65090_IRQ_OVERLOAD_DCDC3 = 8,
	TPS65090_IRQ_OVERLOAD_FET1 = 9,
	TPS65090_IRQ_OVERLOAD_FET2 = 10,
	TPS65090_IRQ_OVERLOAD_FET3 = 11,
	TPS65090_IRQ_OVERLOAD_FET4 = 12,
	TPS65090_IRQ_OVERLOAD_FET5 = 13,
	TPS65090_IRQ_OVERLOAD_FET6 = 14,
	TPS65090_IRQ_OVERLOAD_FET7 = 15,
};

enum tps65090_cells {
	PMIC = 0,
	CHARGER = 1,
};

struct atmel_flexcom {
	void *base;
	u32 opmode;
	struct clk *clk;
};

struct atmel_hsmc_reg_layout {
	unsigned int timing_regs_offset;
};

struct atmel_smc_cs_conf {
	u32 setup;
	u32 pulse;
	u32 cycle;
	u32 timings;
	u32 mode;
};

enum tps65917_irqs {
	TPS65917_RESERVED1 = 0,
	TPS65917_PWRON_IRQ = 1,
	TPS65917_LONG_PRESS_KEY_IRQ = 2,
	TPS65917_RESERVED2 = 3,
	TPS65917_PWRDOWN_IRQ = 4,
	TPS65917_HOTDIE_IRQ = 5,
	TPS65917_VSYS_MON_IRQ = 6,
	TPS65917_RESERVED3 = 7,
	TPS65917_RESERVED4 = 8,
	TPS65917_OTP_ERROR_IRQ = 9,
	TPS65917_WDT_IRQ = 10,
	TPS65917_RESERVED5 = 11,
	TPS65917_RESET_IN_IRQ = 12,
	TPS65917_FSD_IRQ = 13,
	TPS65917_SHORT_IRQ = 14,
	TPS65917_RESERVED6 = 15,
	TPS65917_GPADC_AUTO_0_IRQ = 16,
	TPS65917_GPADC_AUTO_1_IRQ = 17,
	TPS65917_GPADC_EOC_SW_IRQ = 18,
	TPS65917_RESREVED6 = 19,
	TPS65917_RESERVED7 = 20,
	TPS65917_RESERVED8 = 21,
	TPS65917_RESERVED9 = 22,
	TPS65917_VBUS_IRQ = 23,
	TPS65917_GPIO_0_IRQ = 24,
	TPS65917_GPIO_1_IRQ = 25,
	TPS65917_GPIO_2_IRQ = 26,
	TPS65917_GPIO_3_IRQ = 27,
	TPS65917_GPIO_4_IRQ = 28,
	TPS65917_GPIO_5_IRQ = 29,
	TPS65917_GPIO_6_IRQ = 30,
	TPS65917_RESERVED10 = 31,
	TPS65917_NUM_IRQ = 32,
};

struct palmas_driver_data {
	unsigned int *features;
	struct regmap_irq_chip *irq_chip;
};

enum {
	BUCK_ILMIN_50MA = 0,
	BUCK_ILMIN_100MA = 1,
	BUCK_ILMIN_150MA = 2,
	BUCK_ILMIN_200MA = 3,
	BUCK_ILMIN_250MA = 4,
	BUCK_ILMIN_300MA = 5,
	BUCK_ILMIN_350MA = 6,
	BUCK_ILMIN_400MA = 7,
};

enum {
	BOOST_ILMIN_75MA = 0,
	BOOST_ILMIN_100MA = 1,
	BOOST_ILMIN_125MA = 2,
	BOOST_ILMIN_150MA = 3,
	BOOST_ILMIN_175MA = 4,
	BOOST_ILMIN_200MA = 5,
	BOOST_ILMIN_225MA = 6,
	BOOST_ILMIN_250MA = 7,
};

enum {
	RK805_BUCK1_2_ILMAX_2500MA = 0,
	RK805_BUCK1_2_ILMAX_3000MA = 1,
	RK805_BUCK1_2_ILMAX_3500MA = 2,
	RK805_BUCK1_2_ILMAX_4000MA = 3,
};

enum {
	RK805_BUCK3_ILMAX_1500MA = 0,
	RK805_BUCK3_ILMAX_2000MA = 1,
	RK805_BUCK3_ILMAX_2500MA = 2,
	RK805_BUCK3_ILMAX_3000MA = 3,
};

enum {
	RK805_BUCK4_ILMAX_2000MA = 0,
	RK805_BUCK4_ILMAX_2500MA = 1,
	RK805_BUCK4_ILMAX_3000MA = 2,
	RK805_BUCK4_ILMAX_3500MA = 3,
};

struct rk808_reg_data {
	int addr;
	int mask;
	int value;
};

enum {
	RN5T618_IRQ_SYS = 0,
	RN5T618_IRQ_DCDC = 1,
	RN5T618_IRQ_RTC = 2,
	RN5T618_IRQ_ADC = 3,
	RN5T618_IRQ_GPIO = 4,
	RN5T618_IRQ_CHG = 5,
	RN5T618_NR_IRQS = 6,
};

enum s2mpa01_reg {
	S2MPA01_REG_ID = 0,
	S2MPA01_REG_INT1 = 1,
	S2MPA01_REG_INT2 = 2,
	S2MPA01_REG_INT3 = 3,
	S2MPA01_REG_INT1M = 4,
	S2MPA01_REG_INT2M = 5,
	S2MPA01_REG_INT3M = 6,
	S2MPA01_REG_ST1 = 7,
	S2MPA01_REG_ST2 = 8,
	S2MPA01_REG_PWRONSRC = 9,
	S2MPA01_REG_OFFSRC = 10,
	S2MPA01_REG_RTC_BUF = 11,
	S2MPA01_REG_CTRL1 = 12,
	S2MPA01_REG_ETC_TEST = 13,
	S2MPA01_REG_RSVD1 = 14,
	S2MPA01_REG_BU_CHG = 15,
	S2MPA01_REG_RAMP1 = 16,
	S2MPA01_REG_RAMP2 = 17,
	S2MPA01_REG_LDO_DSCH1 = 18,
	S2MPA01_REG_LDO_DSCH2 = 19,
	S2MPA01_REG_LDO_DSCH3 = 20,
	S2MPA01_REG_LDO_DSCH4 = 21,
	S2MPA01_REG_OTP_ADRL = 22,
	S2MPA01_REG_OTP_ADRH = 23,
	S2MPA01_REG_OTP_DATA = 24,
	S2MPA01_REG_MON1SEL = 25,
	S2MPA01_REG_MON2SEL = 26,
	S2MPA01_REG_LEE = 27,
	S2MPA01_REG_RSVD2 = 28,
	S2MPA01_REG_RSVD3 = 29,
	S2MPA01_REG_RSVD4 = 30,
	S2MPA01_REG_RSVD5 = 31,
	S2MPA01_REG_RSVD6 = 32,
	S2MPA01_REG_TOP_RSVD = 33,
	S2MPA01_REG_DVS_SEL = 34,
	S2MPA01_REG_DVS_PTR = 35,
	S2MPA01_REG_DVS_DATA = 36,
	S2MPA01_REG_RSVD_NO = 37,
	S2MPA01_REG_UVLO = 38,
	S2MPA01_REG_LEE_NO = 39,
	S2MPA01_REG_B1CTRL1 = 40,
	S2MPA01_REG_B1CTRL2 = 41,
	S2MPA01_REG_B2CTRL1 = 42,
	S2MPA01_REG_B2CTRL2 = 43,
	S2MPA01_REG_B3CTRL1 = 44,
	S2MPA01_REG_B3CTRL2 = 45,
	S2MPA01_REG_B4CTRL1 = 46,
	S2MPA01_REG_B4CTRL2 = 47,
	S2MPA01_REG_B5CTRL1 = 48,
	S2MPA01_REG_B5CTRL2 = 49,
	S2MPA01_REG_B5CTRL3 = 50,
	S2MPA01_REG_B5CTRL4 = 51,
	S2MPA01_REG_B5CTRL5 = 52,
	S2MPA01_REG_B5CTRL6 = 53,
	S2MPA01_REG_B6CTRL1 = 54,
	S2MPA01_REG_B6CTRL2 = 55,
	S2MPA01_REG_B7CTRL1 = 56,
	S2MPA01_REG_B7CTRL2 = 57,
	S2MPA01_REG_B8CTRL1 = 58,
	S2MPA01_REG_B8CTRL2 = 59,
	S2MPA01_REG_B9CTRL1 = 60,
	S2MPA01_REG_B9CTRL2 = 61,
	S2MPA01_REG_B10CTRL1 = 62,
	S2MPA01_REG_B10CTRL2 = 63,
	S2MPA01_REG_L1CTRL = 64,
	S2MPA01_REG_L2CTRL = 65,
	S2MPA01_REG_L3CTRL = 66,
	S2MPA01_REG_L4CTRL = 67,
	S2MPA01_REG_L5CTRL = 68,
	S2MPA01_REG_L6CTRL = 69,
	S2MPA01_REG_L7CTRL = 70,
	S2MPA01_REG_L8CTRL = 71,
	S2MPA01_REG_L9CTRL = 72,
	S2MPA01_REG_L10CTRL = 73,
	S2MPA01_REG_L11CTRL = 74,
	S2MPA01_REG_L12CTRL = 75,
	S2MPA01_REG_L13CTRL = 76,
	S2MPA01_REG_L14CTRL = 77,
	S2MPA01_REG_L15CTRL = 78,
	S2MPA01_REG_L16CTRL = 79,
	S2MPA01_REG_L17CTRL = 80,
	S2MPA01_REG_L18CTRL = 81,
	S2MPA01_REG_L19CTRL = 82,
	S2MPA01_REG_L20CTRL = 83,
	S2MPA01_REG_L21CTRL = 84,
	S2MPA01_REG_L22CTRL = 85,
	S2MPA01_REG_L23CTRL = 86,
	S2MPA01_REG_L24CTRL = 87,
	S2MPA01_REG_L25CTRL = 88,
	S2MPA01_REG_L26CTRL = 89,
	S2MPA01_REG_LDO_OVCB1 = 90,
	S2MPA01_REG_LDO_OVCB2 = 91,
	S2MPA01_REG_LDO_OVCB3 = 92,
	S2MPA01_REG_LDO_OVCB4 = 93,
};

enum s5m8763_reg {
	S5M8763_REG_IRQ1 = 0,
	S5M8763_REG_IRQ2 = 1,
	S5M8763_REG_IRQ3 = 2,
	S5M8763_REG_IRQ4 = 3,
	S5M8763_REG_IRQM1 = 4,
	S5M8763_REG_IRQM2 = 5,
	S5M8763_REG_IRQM3 = 6,
	S5M8763_REG_IRQM4 = 7,
	S5M8763_REG_STATUS1 = 8,
	S5M8763_REG_STATUS2 = 9,
	S5M8763_REG_STATUSM1 = 10,
	S5M8763_REG_STATUSM2 = 11,
	S5M8763_REG_CHGR1 = 12,
	S5M8763_REG_CHGR2 = 13,
	S5M8763_REG_LDO_ACTIVE_DISCHARGE1 = 14,
	S5M8763_REG_LDO_ACTIVE_DISCHARGE2 = 15,
	S5M8763_REG_BUCK_ACTIVE_DISCHARGE3 = 16,
	S5M8763_REG_ONOFF1 = 17,
	S5M8763_REG_ONOFF2 = 18,
	S5M8763_REG_ONOFF3 = 19,
	S5M8763_REG_ONOFF4 = 20,
	S5M8763_REG_BUCK1_VOLTAGE1 = 21,
	S5M8763_REG_BUCK1_VOLTAGE2 = 22,
	S5M8763_REG_BUCK1_VOLTAGE3 = 23,
	S5M8763_REG_BUCK1_VOLTAGE4 = 24,
	S5M8763_REG_BUCK2_VOLTAGE1 = 25,
	S5M8763_REG_BUCK2_VOLTAGE2 = 26,
	S5M8763_REG_BUCK3 = 27,
	S5M8763_REG_BUCK4 = 28,
	S5M8763_REG_LDO1_LDO2 = 29,
	S5M8763_REG_LDO3 = 30,
	S5M8763_REG_LDO4 = 31,
	S5M8763_REG_LDO5 = 32,
	S5M8763_REG_LDO6 = 33,
	S5M8763_REG_LDO7 = 34,
	S5M8763_REG_LDO7_LDO8 = 35,
	S5M8763_REG_LDO9_LDO10 = 36,
	S5M8763_REG_LDO11 = 37,
	S5M8763_REG_LDO12 = 38,
	S5M8763_REG_LDO13 = 39,
	S5M8763_REG_LDO14 = 40,
	S5M8763_REG_LDO15 = 41,
	S5M8763_REG_LDO16 = 42,
	S5M8763_REG_BKCHR = 43,
	S5M8763_REG_LBCNFG1 = 44,
	S5M8763_REG_LBCNFG2 = 45,
};

enum s2mps11_irq {
	S2MPS11_IRQ_PWRONF = 0,
	S2MPS11_IRQ_PWRONR = 1,
	S2MPS11_IRQ_JIGONBF = 2,
	S2MPS11_IRQ_JIGONBR = 3,
	S2MPS11_IRQ_ACOKBF = 4,
	S2MPS11_IRQ_ACOKBR = 5,
	S2MPS11_IRQ_PWRON1S = 6,
	S2MPS11_IRQ_MRB = 7,
	S2MPS11_IRQ_RTC60S = 8,
	S2MPS11_IRQ_RTCA1 = 9,
	S2MPS11_IRQ_RTCA0 = 10,
	S2MPS11_IRQ_SMPL = 11,
	S2MPS11_IRQ_RTC1S = 12,
	S2MPS11_IRQ_WTSR = 13,
	S2MPS11_IRQ_INT120C = 14,
	S2MPS11_IRQ_INT140C = 15,
	S2MPS11_IRQ_NR = 16,
};

enum s2mps14_irq {
	S2MPS14_IRQ_PWRONF = 0,
	S2MPS14_IRQ_PWRONR = 1,
	S2MPS14_IRQ_JIGONBF = 2,
	S2MPS14_IRQ_JIGONBR = 3,
	S2MPS14_IRQ_ACOKBF = 4,
	S2MPS14_IRQ_ACOKBR = 5,
	S2MPS14_IRQ_PWRON1S = 6,
	S2MPS14_IRQ_MRB = 7,
	S2MPS14_IRQ_RTC60S = 8,
	S2MPS14_IRQ_RTCA1 = 9,
	S2MPS14_IRQ_RTCA0 = 10,
	S2MPS14_IRQ_SMPL = 11,
	S2MPS14_IRQ_RTC1S = 12,
	S2MPS14_IRQ_WTSR = 13,
	S2MPS14_IRQ_INT120C = 14,
	S2MPS14_IRQ_INT140C = 15,
	S2MPS14_IRQ_TSD = 16,
	S2MPS14_IRQ_NR = 17,
};

enum s2mpu02_irq {
	S2MPU02_IRQ_PWRONF = 0,
	S2MPU02_IRQ_PWRONR = 1,
	S2MPU02_IRQ_JIGONBF = 2,
	S2MPU02_IRQ_JIGONBR = 3,
	S2MPU02_IRQ_ACOKBF = 4,
	S2MPU02_IRQ_ACOKBR = 5,
	S2MPU02_IRQ_PWRON1S = 6,
	S2MPU02_IRQ_MRB = 7,
	S2MPU02_IRQ_RTC60S = 8,
	S2MPU02_IRQ_RTCA1 = 9,
	S2MPU02_IRQ_RTCA0 = 10,
	S2MPU02_IRQ_SMPL = 11,
	S2MPU02_IRQ_RTC1S = 12,
	S2MPU02_IRQ_WTSR = 13,
	S2MPU02_IRQ_INT120C = 14,
	S2MPU02_IRQ_INT140C = 15,
	S2MPU02_IRQ_TSD = 16,
	S2MPU02_IRQ_NR = 17,
};

enum s5m8767_irq {
	S5M8767_IRQ_PWRR = 0,
	S5M8767_IRQ_PWRF = 1,
	S5M8767_IRQ_PWR1S = 2,
	S5M8767_IRQ_JIGR = 3,
	S5M8767_IRQ_JIGF = 4,
	S5M8767_IRQ_LOWBAT2 = 5,
	S5M8767_IRQ_LOWBAT1 = 6,
	S5M8767_IRQ_MRB = 7,
	S5M8767_IRQ_DVSOK2 = 8,
	S5M8767_IRQ_DVSOK3 = 9,
	S5M8767_IRQ_DVSOK4 = 10,
	S5M8767_IRQ_RTC60S = 11,
	S5M8767_IRQ_RTCA1 = 12,
	S5M8767_IRQ_RTCA2 = 13,
	S5M8767_IRQ_SMPL = 14,
	S5M8767_IRQ_RTC1S = 15,
	S5M8767_IRQ_WTSR = 16,
	S5M8767_IRQ_NR = 17,
};

enum s5m8763_irq {
	S5M8763_IRQ_DCINF = 0,
	S5M8763_IRQ_DCINR = 1,
	S5M8763_IRQ_JIGF = 2,
	S5M8763_IRQ_JIGR = 3,
	S5M8763_IRQ_PWRONF = 4,
	S5M8763_IRQ_PWRONR = 5,
	S5M8763_IRQ_WTSREVNT = 6,
	S5M8763_IRQ_SMPLEVNT = 7,
	S5M8763_IRQ_ALARM1 = 8,
	S5M8763_IRQ_ALARM0 = 9,
	S5M8763_IRQ_ONKEY1S = 10,
	S5M8763_IRQ_TOPOFFR = 11,
	S5M8763_IRQ_DCINOVPR = 12,
	S5M8763_IRQ_CHGRSTF = 13,
	S5M8763_IRQ_DONER = 14,
	S5M8763_IRQ_CHGFAULT = 15,
	S5M8763_IRQ_LOBAT1 = 16,
	S5M8763_IRQ_LOBAT2 = 17,
	S5M8763_IRQ_NR = 18,
};

struct syscon_platform_data {
	const char *label;
};

struct syscon {
	struct device_node *np;
	struct regmap *regmap;
	struct list_head list;
};

struct as3711_platform_data {
	struct as3711_regulator_pdata regulator;
	struct as3711_bl_pdata backlight;
};

enum {
	AS3711_REGULATOR = 0,
	AS3711_BACKLIGHT = 1,
};

enum as3722_irq {
	AS3722_IRQ_LID = 0,
	AS3722_IRQ_ACOK = 1,
	AS3722_IRQ_ENABLE1 = 2,
	AS3722_IRQ_OCCUR_ALARM_SD0 = 3,
	AS3722_IRQ_ONKEY_LONG_PRESS = 4,
	AS3722_IRQ_ONKEY = 5,
	AS3722_IRQ_OVTMP = 6,
	AS3722_IRQ_LOWBAT = 7,
	AS3722_IRQ_SD0_LV = 8,
	AS3722_IRQ_SD1_LV = 9,
	AS3722_IRQ_SD2_LV = 10,
	AS3722_IRQ_PWM1_OV_PROT = 11,
	AS3722_IRQ_PWM2_OV_PROT = 12,
	AS3722_IRQ_ENABLE2 = 13,
	AS3722_IRQ_SD6_LV = 14,
	AS3722_IRQ_RTC_REP = 15,
	AS3722_IRQ_RTC_ALARM = 16,
	AS3722_IRQ_GPIO1 = 17,
	AS3722_IRQ_GPIO2 = 18,
	AS3722_IRQ_GPIO3 = 19,
	AS3722_IRQ_GPIO4 = 20,
	AS3722_IRQ_GPIO5 = 21,
	AS3722_IRQ_WATCHDOG = 22,
	AS3722_IRQ_ENABLE3 = 23,
	AS3722_IRQ_TEMP_SD0_SHUTDOWN = 24,
	AS3722_IRQ_TEMP_SD1_SHUTDOWN = 25,
	AS3722_IRQ_TEMP_SD2_SHUTDOWN = 26,
	AS3722_IRQ_TEMP_SD0_ALARM = 27,
	AS3722_IRQ_TEMP_SD1_ALARM = 28,
	AS3722_IRQ_TEMP_SD6_ALARM = 29,
	AS3722_IRQ_OCCUR_ALARM_SD6 = 30,
	AS3722_IRQ_ADC = 31,
	AS3722_IRQ_MAX = 32,
};

enum stmfx_irqs {
	STMFX_REG_IRQ_SRC_EN_GPIO = 0,
	STMFX_REG_IRQ_SRC_EN_IDD = 1,
	STMFX_REG_IRQ_SRC_EN_ERROR = 2,
	STMFX_REG_IRQ_SRC_EN_TS_DET = 3,
	STMFX_REG_IRQ_SRC_EN_TS_NE = 4,
	STMFX_REG_IRQ_SRC_EN_TS_TH = 5,
	STMFX_REG_IRQ_SRC_EN_TS_FULL = 6,
	STMFX_REG_IRQ_SRC_EN_TS_OVF = 7,
	STMFX_REG_IRQ_SRC_MAX = 8,
};

struct seqcount_ww_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_ww_mutex seqcount_ww_mutex_t;

struct dma_buf_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
	int: 32;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf;

struct dma_buf_attachment;

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct dma_buf_map *);
	void (*vunmap)(struct dma_buf *, struct dma_buf_map *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	struct dma_buf_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_excl;
	struct dma_buf_poll_cb_t cb_shared;
};

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	seqcount_ww_mutex_t seq;
	struct dma_fence *fence_excl;
	struct dma_resv_list *fence;
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 shared_count;
	u32 shared_max;
	struct dma_fence *shared[0];
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
	int: 32;
};

struct dma_fence_chain {
	struct dma_fence base;
	spinlock_t lock;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
	struct irq_work work;
	int: 32;
};

enum seqno_fence_condition {
	SEQNO_FENCE_WAIT_GEQUAL = 0,
	SEQNO_FENCE_WAIT_NONZERO = 1,
};

struct seqno_fence {
	struct dma_fence base;
	const struct dma_fence_ops *ops;
	struct dma_buf *sync_buf;
	uint32_t seqno_ofs;
	enum seqno_fence_condition condition;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	atomic_t device_busy;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	int: 32;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	unsigned char current_tag;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int active_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	int: 32;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	int: 32;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
	int: 32;
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_pointer {
	char *ptr;
	int this_residual;
	struct scatterlist *buffer;
	int buffers_residual;
	dma_addr_t dma_handle;
	volatile int Status;
	volatile int Message;
	volatile int have_data_in;
	volatile int sent_command;
	volatile int phase;
};

struct scsi_cmnd {
	struct scsi_request req;
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	struct request *request;
	unsigned char *sense_buffer;
	void (*scsi_done)(struct scsi_cmnd *);
	struct scsi_pointer SCp;
	unsigned char *host_scribble;
	int result;
	int flags;
	long unsigned int state;
	unsigned char tag;
	unsigned int extra_len;
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct scsi_host_cmd_pool;

struct scsi_host_template {
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	int (*map_queues)(struct Scsi_Host *);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int max_host_blocked;
	struct device_attribute **shost_attrs;
	struct device_attribute **sdev_attrs;
	const struct attribute_group **sdev_groups;
	int: 32;
	u64 vendor_id;
	unsigned int cmd_size;
	struct scsi_host_cmd_pool *cmd_pool;
	int rpm_autosuspend_delay;
	int: 32;
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *, bool);
	void *priv;
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	int (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	unsigned char eh_cmnd[16];
	struct scatterlist sense_sgl;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_RETRY = 2,
	ACTION_DELAYED_RETRY = 3,
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 1000,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
	int: 32;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct opal_dev;

struct scsi_disk {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct device dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	int: 32;
	sector_t capacity;
	int max_retries;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
	int: 3;
	int: 32;
};

enum {
	mechtype_caddy = 0,
	mechtype_tray = 1,
	mechtype_popup = 2,
	mechtype_individual_changer = 4,
	mechtype_cartridge_changer = 5,
};

struct event_header {
	__be16 data_len;
	__u8 notification_class: 3;
	__u8 reserved1: 4;
	__u8 nea: 1;
	__u8 supp_event_class;
};

struct media_event_desc {
	__u8 media_event_code: 4;
	__u8 reserved1: 4;
	__u8 door_open: 1;
	__u8 media_present: 1;
	__u8 reserved2: 6;
	__u8 start_slot;
	__u8 end_slot;
};

struct scsi_cd {
	struct scsi_driver *driver;
	unsigned int capacity;
	struct scsi_device *device;
	unsigned int vendor;
	long unsigned int ms_offset;
	unsigned int writeable: 1;
	unsigned int use: 1;
	unsigned int xa_flag: 1;
	unsigned int readcd_known: 1;
	unsigned int readcd_cdda: 1;
	unsigned int media_present: 1;
	int tur_mismatch;
	bool tur_changed: 1;
	bool get_event_changed: 1;
	bool ignore_get_event: 1;
	struct cdrom_device_info cdi;
	struct mutex lock;
	struct kref kref;
	struct gendisk *disk;
};

struct cdrom_ti {
	__u8 cdti_trk0;
	__u8 cdti_ind0;
	__u8 cdti_trk1;
	__u8 cdti_ind1;
};

struct cdrom_tochdr {
	__u8 cdth_trk0;
	__u8 cdth_trk1;
};

struct cdrom_tocentry {
	__u8 cdte_track;
	__u8 cdte_adr: 4;
	__u8 cdte_ctrl: 4;
	__u8 cdte_format;
	union cdrom_addr cdte_addr;
	__u8 cdte_datamode;
};

typedef struct scsi_cd Scsi_CD;

struct ccs_modesel_head {
	__u8 _r1;
	__u8 medium;
	__u8 _r2;
	__u8 block_desc_length;
	__u8 density;
	__u8 number_blocks_hi;
	__u8 number_blocks_med;
	__u8 number_blocks_lo;
	__u8 _r3;
	__u8 block_length_hi;
	__u8 block_length_med;
	__u8 block_length_lo;
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = 2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

enum {
	ATA_MSG_DRV = 1,
	ATA_MSG_INFO = 2,
	ATA_MSG_PROBE = 4,
	ATA_MSG_WARN = 8,
	ATA_MSG_MALLOC = 16,
	ATA_MSG_CTL = 32,
	ATA_MSG_INTR = 64,
	ATA_MSG_ERR = 128,
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = 4294967295,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_CFG_MASK = 4095,
	ATA_DFLAG_PIO = 4096,
	ATA_DFLAG_NCQ_OFF = 8192,
	ATA_DFLAG_SLEEPING = 32768,
	ATA_DFLAG_DUBIOUS_XFER = 65536,
	ATA_DFLAG_NO_UNLOAD = 131072,
	ATA_DFLAG_UNLOCK_HPA = 262144,
	ATA_DFLAG_NCQ_SEND_RECV = 524288,
	ATA_DFLAG_NCQ_PRIO = 1048576,
	ATA_DFLAG_NCQ_PRIO_ENABLE = 2097152,
	ATA_DFLAG_INIT_MASK = 16777215,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DB_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_FAILED = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 5000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_PERDEV_MASK = 33,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_PROBE_MAX_TRIES = 3,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	u8 feature;
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	u8 command;
	u32 auxiliary;
};

struct ata_port;

struct ata_device;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_link;

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[12];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	int: 32;
	struct ata_ering_entry ring[32];
};

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	int spdn_cnt;
	struct ata_ering ering;
	int: 32;
	int: 32;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	int: 32;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

enum sw_activity {
	OFF___3 = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	bool (*qc_fill_rtf)(struct ata_queued_cmd *);
	int (*cable_detect)(struct ata_port *);
	long unsigned int (*mode_filter)(struct ata_device *, long unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, u16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	void (*phy_reset)(struct ata_port *);
	void (*eng_timeout)(struct ata_port *);
	const struct ata_port_operations *inherits;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	long unsigned int sas_tag_allocated;
	int: 32;
	u64 qc_active;
	int nr_active_links;
	unsigned int sas_last_tag;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	int: 32;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct work_struct scsi_rescan_task;
	unsigned int hsm_task_state;
	u32 msg_enable;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	long unsigned int fastdrain_cnt;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u8 sector_buf[512];
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	long unsigned int pio_mask;
	long unsigned int mwdma_mask;
	long unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct trace_event_raw_ata_qc_issue {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = 2147483648,
};

struct ata_force_param {
	const char *name;
	u8 cbl;
	u8 spd_limit;
	long unsigned int xfer_mask;
	unsigned int horkage_on;
	unsigned int horkage_off;
	u16 lflags;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	long unsigned int horkage;
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = 2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const long unsigned int *timeouts;
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
	int: 32;
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_CLKS = 5,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DEV_ILCK = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_IS_MOBILE = 33554432,
	AHCI_HFLAG_SUSPEND_PHYS = 67108864,
	AHCI_HFLAG_IGN_NOTSUPP_POWER_ON = 134217728,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 8,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	long unsigned int saved_activity;
	long unsigned int activity;
	long unsigned int led_state;
	struct ata_link *link;
};

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[8];
	char *irq_desc;
};

struct ahci_host_priv {
	unsigned int flags;
	u32 force_port_map;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	u32 remapped_nvme;
	bool got_runtime_pm;
	struct clk *clks[5];
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

enum {
	AHCI_PCI_BAR_STA2X11 = 0,
	AHCI_PCI_BAR_CAVIUM = 0,
	AHCI_PCI_BAR_LOONGSON = 0,
	AHCI_PCI_BAR_ENMOTUS = 2,
	AHCI_PCI_BAR_CAVIUM_GEN5 = 4,
	AHCI_PCI_BAR_STANDARD = 5,
};

enum board_ids {
	board_ahci = 0,
	board_ahci_ign_iferr = 1,
	board_ahci_mobile = 2,
	board_ahci_nomsi = 3,
	board_ahci_noncq = 4,
	board_ahci_nosntf = 5,
	board_ahci_yes_fbs = 6,
	board_ahci_al = 7,
	board_ahci_avn = 8,
	board_ahci_mcp65 = 9,
	board_ahci_mcp77 = 10,
	board_ahci_mcp89 = 11,
	board_ahci_mv = 12,
	board_ahci_sb600 = 13,
	board_ahci_sb700 = 14,
	board_ahci_vt8251 = 15,
	board_ahci_pcs7 = 16,
	board_ahci_mcp_linux = 9,
	board_ahci_mcp67 = 9,
	board_ahci_mcp73 = 9,
	board_ahci_mcp79 = 10,
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

struct phy_lane_info {
	void *phy_base;
	u8 lane_mapping;
	u8 phy_devs;
	u8 tx_atten;
};

struct ecx_plat_data {
	u32 n_ports;
	u32 pre_clocks;
	u32 post_clocks;
	struct gpio_desc *sgpio_gpiod[3];
	u32 sgpio_pattern;
	u32 port_to_sgpio[8];
};

enum brcm_ahci_version {
	BRCM_SATA_BCM7425 = 1,
	BRCM_SATA_BCM7445 = 2,
	BRCM_SATA_NSP = 3,
	BRCM_SATA_BCM7216 = 4,
};

enum brcm_ahci_quirks {
	BRCM_AHCI_QUIRK_SKIP_PHY_ENABLE = 1,
};

struct brcm_ahci_priv {
	struct device *dev;
	void *top_ctrl;
	u32 port_mask;
	u32 quirks;
	enum brcm_ahci_version version;
	struct reset_control *rcdev;
};

struct sensor_device_attribute {
	struct device_attribute dev_attr;
	int index;
};

enum {
	IMX_TIMER1MS = 224,
	IMX_P0PHYCR = 376,
	IMX_P0PHYCR_TEST_PDDQ = 1048576,
	IMX_P0PHYCR_CR_READ = 524288,
	IMX_P0PHYCR_CR_WRITE = 262144,
	IMX_P0PHYCR_CR_CAP_DATA = 131072,
	IMX_P0PHYCR_CR_CAP_ADDR = 65536,
	IMX_P0PHYSR = 380,
	IMX_P0PHYSR_CR_ACK = 262144,
	IMX_P0PHYSR_CR_DATA_OUT = 65535,
	IMX_LANE0_OUT_STAT = 8195,
	IMX_LANE0_OUT_STAT_RX_PLL_STATE = 2,
	IMX_CLOCK_RESET = 32575,
	IMX_CLOCK_RESET_RESET = 1,
	IMX8QM_SATA_PHY_RX_IMPED_RATIO_OFFSET = 3,
	IMX8QM_SATA_PHY_TX_IMPED_RATIO_OFFSET = 9,
	IMX8QM_SATA_PHY_IMPED_RATIO_85OHM = 108,
	IMX8QM_LPCG_PHYX2_OFFSET = 0,
	IMX8QM_CSR_PHYX2_OFFSET = 589824,
	IMX8QM_CSR_PHYX1_OFFSET = 655360,
	IMX8QM_CSR_PHYX_STTS0_OFFSET = 4,
	IMX8QM_CSR_PCIEA_OFFSET = 720896,
	IMX8QM_CSR_PCIEB_OFFSET = 786432,
	IMX8QM_CSR_SATA_OFFSET = 851968,
	IMX8QM_CSR_PCIE_CTRL2_OFFSET = 8,
	IMX8QM_CSR_MISC_OFFSET = 917504,
	IMX8QM_LPCG_PHYX2_PCLK0_MASK = 196608,
	IMX8QM_LPCG_PHYX2_PCLK1_MASK = 3145728,
	IMX8QM_PHY_APB_RSTN_0 = 1,
	IMX8QM_PHY_MODE_SATA = 524288,
	IMX8QM_PHY_MODE_MASK = 1966080,
	IMX8QM_PHY_PIPE_RSTN_0 = 16777216,
	IMX8QM_PHY_PIPE_RSTN_OVERRIDE_0 = 33554432,
	IMX8QM_PHY_PIPE_RSTN_1 = 67108864,
	IMX8QM_PHY_PIPE_RSTN_OVERRIDE_1 = 134217728,
	IMX8QM_STTS0_LANE0_TX_PLL_LOCK = 16,
	IMX8QM_MISC_IOB_RXENA = 1,
	IMX8QM_MISC_IOB_TXENA = 2,
	IMX8QM_MISC_PHYX1_EPCS_SEL = 4096,
	IMX8QM_MISC_CLKREQN_OUT_OVERRIDE_1 = 16777216,
	IMX8QM_MISC_CLKREQN_OUT_OVERRIDE_0 = 33554432,
	IMX8QM_MISC_CLKREQN_IN_OVERRIDE_1 = 268435456,
	IMX8QM_MISC_CLKREQN_IN_OVERRIDE_0 = 536870912,
	IMX8QM_SATA_CTRL_RESET_N = 4096,
	IMX8QM_SATA_CTRL_EPCS_PHYRESET_N = 128,
	IMX8QM_CTRL_BUTTON_RST_N = 2097152,
	IMX8QM_CTRL_POWER_UP_RST_N = 8388608,
	IMX8QM_CTRL_LTSSM_ENABLE = 16,
};

enum ahci_imx_type {
	AHCI_IMX53 = 0,
	AHCI_IMX6Q = 1,
	AHCI_IMX6QP = 2,
	AHCI_IMX8QM = 3,
};

struct imx_ahci_priv {
	struct platform_device *ahci_pdev;
	enum ahci_imx_type type;
	struct clk *sata_clk;
	struct clk *sata_ref_clk;
	struct clk *ahb_clk;
	struct clk *epcs_tx_clk;
	struct clk *epcs_rx_clk;
	struct clk *phy_apbclk;
	struct clk *phy_pclk0;
	struct clk *phy_pclk1;
	void *phy_base;
	struct gpio_desc *clkreq_gpiod;
	struct regmap *gpr;
	bool no_device;
	bool first_time;
	u32 phy_params;
	u32 imped_ratio;
};

enum {
	SATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT = 1,
	SATA_PHY_CR_CLOCK_DAC_CTL = 8,
	SATA_PHY_CR_CLOCK_RTUNE_CTL = 9,
	SATA_PHY_CR_CLOCK_ADC_OUT = 10,
	SATA_PHY_CR_CLOCK_MPLL_TST = 23,
};

struct reg_value {
	u32 of_value;
	u32 reg_value;
};

struct reg_property {
	const char *name;
	const struct reg_value *values;
	size_t num_values;
	u32 def_value;
	u32 set_value;
};

struct st_ahci_drv_data {
	struct platform_device *ahci;
	struct reset_control *pwr;
	struct reset_control *sw_rst;
	struct reset_control *pwr_rst;
};

struct sata_pad_calibration {
	u8 gen1_tx_amp;
	u8 gen1_tx_peak;
	u8 gen2_tx_amp;
	u8 gen2_tx_peak;
};

struct tegra_ahci_ops {
	int (*init)(struct ahci_host_priv *);
};

struct tegra_ahci_soc {
	const char * const *supply_names;
	u32 num_supplies;
	bool supports_devslp;
	const struct tegra_ahci_ops *ops;
};

struct tegra_ahci_priv {
	struct platform_device *pdev;
	void *sata_regs;
	void *sata_aux_regs;
	struct reset_control *sata_rst;
	struct reset_control *sata_oob_rst;
	struct reset_control *sata_cold_rst;
	struct clk *sata_clk;
	struct regulator_bulk_data *supplies;
	const struct tegra_ahci_soc *soc;
};

struct mv_sata_platform_data {
	int n_ports;
};

enum {
	MV_PRIMARY_BAR = 0,
	MV_IO_BAR = 2,
	MV_MISC_BAR = 3,
	MV_MAJOR_REG_AREA_SZ = 65536,
	MV_MINOR_REG_AREA_SZ = 8192,
	COAL_CLOCKS_PER_USEC = 150,
	MAX_COAL_TIME_THRESHOLD = 16777215,
	MAX_COAL_IO_COUNT = 255,
	MV_PCI_REG_BASE = 0,
	COAL_REG_BASE = 98304,
	IRQ_COAL_CAUSE = 98312,
	ALL_PORTS_COAL_IRQ = 16,
	IRQ_COAL_IO_THRESHOLD = 98508,
	IRQ_COAL_TIME_THRESHOLD = 98512,
	TRAN_COAL_CAUSE_LO = 98440,
	TRAN_COAL_CAUSE_HI = 98444,
	SATAHC0_REG_BASE = 131072,
	FLASH_CTL = 66668,
	GPIO_PORT_CTL = 66800,
	RESET_CFG = 98520,
	MV_PCI_REG_SZ = 65536,
	MV_SATAHC_REG_SZ = 65536,
	MV_SATAHC_ARBTR_REG_SZ = 8192,
	MV_PORT_REG_SZ = 8192,
	MV_MAX_Q_DEPTH = 32,
	MV_MAX_Q_DEPTH_MASK = 31,
	MV_CRQB_Q_SZ = 1024,
	MV_CRPB_Q_SZ = 256,
	MV_MAX_SG_CT = 256,
	MV_SG_TBL_SZ = 4096,
	MV_PORT_HC_SHIFT = 2,
	MV_PORTS_PER_HC = 4,
	MV_PORT_MASK = 3,
	MV_FLAG_DUAL_HC = 1073741824,
	MV_COMMON_FLAGS = 514,
	MV_GEN_I_FLAGS = 578,
	MV_GEN_II_FLAGS = 656898,
	MV_GEN_IIE_FLAGS = 919042,
	CRQB_FLAG_READ = 1,
	CRQB_TAG_SHIFT = 1,
	CRQB_IOID_SHIFT = 6,
	CRQB_PMP_SHIFT = 12,
	CRQB_HOSTQ_SHIFT = 17,
	CRQB_CMD_ADDR_SHIFT = 8,
	CRQB_CMD_CS = 4096,
	CRQB_CMD_LAST = 32768,
	CRPB_FLAG_STATUS_SHIFT = 8,
	CRPB_IOID_SHIFT_6 = 5,
	CRPB_IOID_SHIFT_7 = 7,
	EPRD_FLAG_END_OF_TBL = 2147483648,
	MV_PCI_COMMAND = 3072,
	MV_PCI_COMMAND_MWRCOM = 16,
	MV_PCI_COMMAND_MRDTRIG = 128,
	PCI_MAIN_CMD_STS = 3376,
	STOP_PCI_MASTER = 4,
	PCI_MASTER_EMPTY = 8,
	GLOB_SFT_RST = 16,
	MV_PCI_MODE = 3328,
	MV_PCI_MODE_MASK = 48,
	MV_PCI_EXP_ROM_BAR_CTL = 3372,
	MV_PCI_DISC_TIMER = 3332,
	MV_PCI_MSI_TRIGGER = 3128,
	MV_PCI_SERR_MASK = 3112,
	MV_PCI_XBAR_TMOUT = 7428,
	MV_PCI_ERR_LOW_ADDRESS = 7488,
	MV_PCI_ERR_HIGH_ADDRESS = 7492,
	MV_PCI_ERR_ATTRIBUTE = 7496,
	MV_PCI_ERR_COMMAND = 7504,
	PCI_IRQ_CAUSE = 7512,
	PCI_IRQ_MASK = 7516,
	PCI_UNMASK_ALL_IRQS = 8388607,
	PCIE_IRQ_CAUSE = 6400,
	PCIE_IRQ_MASK = 6416,
	PCIE_UNMASK_ALL_IRQS = 1034,
	PCI_HC_MAIN_IRQ_CAUSE = 7520,
	PCI_HC_MAIN_IRQ_MASK = 7524,
	SOC_HC_MAIN_IRQ_CAUSE = 131104,
	SOC_HC_MAIN_IRQ_MASK = 131108,
	ERR_IRQ = 1,
	DONE_IRQ = 2,
	HC0_IRQ_PEND = 511,
	HC_SHIFT = 9,
	DONE_IRQ_0_3 = 170,
	DONE_IRQ_4_7 = 87040,
	PCI_ERR = 262144,
	TRAN_COAL_LO_DONE = 524288,
	TRAN_COAL_HI_DONE = 1048576,
	PORTS_0_3_COAL_DONE = 256,
	PORTS_4_7_COAL_DONE = 131072,
	ALL_PORTS_COAL_DONE = 2097152,
	GPIO_INT = 4194304,
	SELF_INT = 8388608,
	TWSI_INT = 16777216,
	HC_MAIN_RSVD = 4261412864,
	HC_MAIN_RSVD_5 = 4294443008,
	HC_MAIN_RSVD_SOC = 4294966976,
	HC_CFG = 0,
	HC_IRQ_CAUSE = 20,
	DMA_IRQ = 1,
	HC_COAL_IRQ = 16,
	DEV_IRQ = 256,
	HC_IRQ_COAL_IO_THRESHOLD = 12,
	HC_IRQ_COAL_TIME_THRESHOLD = 16,
	SOC_LED_CTRL = 44,
	SOC_LED_CTRL_BLINK = 1,
	SOC_LED_CTRL_ACT_PRESENCE = 4,
	SHD_BLK = 256,
	SHD_CTL_AST = 32,
	SATA_STATUS = 768,
	SATA_ACTIVE = 848,
	FIS_IRQ_CAUSE = 868,
	FIS_IRQ_CAUSE_AN = 512,
	LTMODE = 780,
	LTMODE_BIT8 = 256,
	PHY_MODE2 = 816,
	PHY_MODE3 = 784,
	PHY_MODE4 = 788,
	PHY_MODE4_CFG_MASK = 3,
	PHY_MODE4_CFG_VALUE = 1,
	PHY_MODE4_RSVD_ZEROS = 1575223290,
	PHY_MODE4_RSVD_ONES = 5,
	SATA_IFCTL = 836,
	SATA_TESTCTL = 840,
	SATA_IFSTAT = 844,
	VENDOR_UNIQUE_FIS = 860,
	FISCFG = 864,
	FISCFG_WAIT_DEV_ERR = 256,
	FISCFG_SINGLE_SYNC = 65536,
	PHY_MODE9_GEN2 = 920,
	PHY_MODE9_GEN1 = 924,
	PHYCFG_OFS = 928,
	MV5_PHY_MODE = 116,
	MV5_LTMODE = 48,
	MV5_PHY_CTL = 12,
	SATA_IFCFG = 80,
	LP_PHY_CTL = 88,
	LP_PHY_CTL_PIN_PU_PLL = 1,
	LP_PHY_CTL_PIN_PU_RX = 2,
	LP_PHY_CTL_PIN_PU_TX = 4,
	LP_PHY_CTL_GEN_TX_3G = 32,
	LP_PHY_CTL_GEN_RX_3G = 512,
	MV_M2_PREAMP_MASK = 2016,
	EDMA_CFG = 0,
	EDMA_CFG_Q_DEPTH = 31,
	EDMA_CFG_NCQ = 32,
	EDMA_CFG_NCQ_GO_ON_ERR = 16384,
	EDMA_CFG_RD_BRST_EXT = 2048,
	EDMA_CFG_WR_BUFF_LEN = 8192,
	EDMA_CFG_EDMA_FBS = 65536,
	EDMA_CFG_FBS = 67108864,
	EDMA_ERR_IRQ_CAUSE = 8,
	EDMA_ERR_IRQ_MASK = 12,
	EDMA_ERR_D_PAR = 1,
	EDMA_ERR_PRD_PAR = 2,
	EDMA_ERR_DEV = 4,
	EDMA_ERR_DEV_DCON = 8,
	EDMA_ERR_DEV_CON = 16,
	EDMA_ERR_SERR = 32,
	EDMA_ERR_SELF_DIS = 128,
	EDMA_ERR_SELF_DIS_5 = 256,
	EDMA_ERR_BIST_ASYNC = 256,
	EDMA_ERR_TRANS_IRQ_7 = 256,
	EDMA_ERR_CRQB_PAR = 512,
	EDMA_ERR_CRPB_PAR = 1024,
	EDMA_ERR_INTRL_PAR = 2048,
	EDMA_ERR_IORDY = 4096,
	EDMA_ERR_LNK_CTRL_RX = 122880,
	EDMA_ERR_LNK_CTRL_RX_0 = 8192,
	EDMA_ERR_LNK_CTRL_RX_1 = 16384,
	EDMA_ERR_LNK_CTRL_RX_2 = 32768,
	EDMA_ERR_LNK_CTRL_RX_3 = 65536,
	EDMA_ERR_LNK_DATA_RX = 1966080,
	EDMA_ERR_LNK_CTRL_TX = 65011712,
	EDMA_ERR_LNK_CTRL_TX_0 = 2097152,
	EDMA_ERR_LNK_CTRL_TX_1 = 4194304,
	EDMA_ERR_LNK_CTRL_TX_2 = 8388608,
	EDMA_ERR_LNK_CTRL_TX_3 = 16777216,
	EDMA_ERR_LNK_CTRL_TX_4 = 33554432,
	EDMA_ERR_LNK_DATA_TX = 2080374784,
	EDMA_ERR_TRANS_PROTO = 2147483648,
	EDMA_ERR_OVERRUN_5 = 32,
	EDMA_ERR_UNDERRUN_5 = 64,
	EDMA_ERR_IRQ_TRANSIENT = 65101824,
	EDMA_EH_FREEZE = 4229865147,
	EDMA_EH_FREEZE_5 = 8059,
	EDMA_REQ_Q_BASE_HI = 16,
	EDMA_REQ_Q_IN_PTR = 20,
	EDMA_REQ_Q_OUT_PTR = 24,
	EDMA_REQ_Q_PTR_SHIFT = 5,
	EDMA_RSP_Q_BASE_HI = 28,
	EDMA_RSP_Q_IN_PTR = 32,
	EDMA_RSP_Q_OUT_PTR = 36,
	EDMA_RSP_Q_PTR_SHIFT = 3,
	EDMA_CMD = 40,
	EDMA_EN = 1,
	EDMA_DS = 2,
	EDMA_RESET = 4,
	EDMA_STATUS = 48,
	EDMA_STATUS_CACHE_EMPTY = 64,
	EDMA_STATUS_IDLE = 128,
	EDMA_IORDY_TMOUT = 52,
	EDMA_ARB_CFG = 56,
	EDMA_HALTCOND = 96,
	EDMA_UNKNOWN_RSVD = 108,
	BMDMA_CMD = 548,
	BMDMA_STATUS = 552,
	BMDMA_PRD_LOW = 556,
	BMDMA_PRD_HIGH = 560,
	MV_HP_FLAG_MSI = 1,
	MV_HP_ERRATA_50XXB0 = 2,
	MV_HP_ERRATA_50XXB2 = 4,
	MV_HP_ERRATA_60X1B2 = 8,
	MV_HP_ERRATA_60X1C0 = 16,
	MV_HP_GEN_I = 64,
	MV_HP_GEN_II = 128,
	MV_HP_GEN_IIE = 256,
	MV_HP_PCIE = 512,
	MV_HP_CUT_THROUGH = 1024,
	MV_HP_FLAG_SOC = 2048,
	MV_HP_QUIRK_LED_BLINK_EN = 4096,
	MV_HP_FIX_LP_PHY_CTL = 8192,
	MV_PP_FLAG_EDMA_EN = 1,
	MV_PP_FLAG_NCQ_EN = 2,
	MV_PP_FLAG_FBS_EN = 4,
	MV_PP_FLAG_DELAYED_EH = 8,
	MV_PP_FLAG_FAKE_ATA_BUSY = 16,
};

enum {
	MV_DMA_BOUNDARY = 65535,
	EDMA_REQ_Q_BASE_LO_MASK = 4294966272,
	EDMA_RSP_Q_BASE_LO_MASK = 4294967040,
};

enum chip_type {
	chip_504x = 0,
	chip_508x = 1,
	chip_5080 = 2,
	chip_604x = 3,
	chip_608x = 4,
	chip_6042 = 5,
	chip_7042 = 6,
	chip_soc = 7,
};

struct mv_crqb {
	__le32 sg_addr;
	__le32 sg_addr_hi;
	__le16 ctrl_flags;
	__le16 ata_cmd[11];
};

struct mv_crqb_iie {
	__le32 addr;
	__le32 addr_hi;
	__le32 flags;
	__le32 len;
	__le32 ata_cmd[4];
};

struct mv_crpb {
	__le16 id;
	__le16 flags;
	__le32 tmstmp;
};

struct mv_sg {
	__le32 addr;
	__le32 flags_size;
	__le32 addr_hi;
	__le32 reserved;
};

struct mv_cached_regs {
	u32 fiscfg;
	u32 ltmode;
	u32 haltcond;
	u32 unknown_rsvd;
};

struct mv_port_priv {
	struct mv_crqb *crqb;
	dma_addr_t crqb_dma;
	struct mv_crpb *crpb;
	dma_addr_t crpb_dma;
	struct mv_sg *sg_tbl[32];
	dma_addr_t sg_tbl_dma[32];
	unsigned int req_idx;
	unsigned int resp_idx;
	u32 pp_flags;
	struct mv_cached_regs cached;
	unsigned int delayed_eh_pmp_map;
};

struct mv_port_signal {
	u32 amps;
	u32 pre;
};

struct mv_hw_ops;

struct mv_host_priv {
	u32 hp_flags;
	unsigned int board_idx;
	u32 main_irq_mask;
	struct mv_port_signal signal[8];
	const struct mv_hw_ops *ops;
	int n_ports;
	void *base;
	void *main_irq_cause_addr;
	void *main_irq_mask_addr;
	u32 irq_cause_offset;
	u32 irq_mask_offset;
	u32 unmask_all_irqs;
	struct clk *clk;
	struct clk **port_clks;
	struct phy **port_phys;
	struct dma_pool___2 *crqb_pool;
	struct dma_pool___2 *crpb_pool;
	struct dma_pool___2 *sg_tbl_pool;
};

struct mv_hw_ops {
	void (*phy_errata)(struct mv_host_priv *, void *, unsigned int);
	void (*enable_leds)(struct mv_host_priv *, void *);
	void (*read_preamp)(struct mv_host_priv *, int, void *);
	int (*reset_hc)(struct mv_host_priv *, void *, unsigned int);
	void (*reset_flash)(struct mv_host_priv *, void *);
	void (*reset_bus)(struct ata_host *, void *);
};

enum sata_rcar_type {
	RCAR_GEN1_SATA = 0,
	RCAR_GEN2_SATA = 1,
	RCAR_GEN3_SATA = 2,
	RCAR_R8A7790_ES1_SATA = 3,
};

struct sata_rcar_priv {
	void *base;
	u32 sataint_mask;
	enum sata_rcar_type type;
};

struct mtd_ecc_stats {
	__u32 corrected;
	__u32 failed;
	__u32 badblocks;
	__u32 bbtblocks;
};

struct mtd_debug_info {
	struct dentry *dfs_dir;
	const char *partname;
	const char *partid;
};

struct mtd_part {
	struct list_head node;
	u64 offset;
	u64 size;
	u32 flags;
	int: 32;
};

struct mtd_master {
	struct mutex partitions_lock;
	unsigned int suspended: 1;
};

struct mtd_ooblayout_ops;

struct mtd_pairing_scheme;

struct mtd_erase_region_info;

struct erase_info;

struct mtd_oob_ops;

struct otp_info;

struct mtd_info {
	u_char type;
	uint32_t flags;
	uint64_t size;
	uint32_t erasesize;
	uint32_t writesize;
	uint32_t writebufsize;
	uint32_t oobsize;
	uint32_t oobavail;
	unsigned int erasesize_shift;
	unsigned int writesize_shift;
	unsigned int erasesize_mask;
	unsigned int writesize_mask;
	unsigned int bitflip_threshold;
	const char *name;
	int index;
	const struct mtd_ooblayout_ops *ooblayout;
	const struct mtd_pairing_scheme *pairing;
	unsigned int ecc_step_size;
	unsigned int ecc_strength;
	int numeraseregions;
	struct mtd_erase_region_info *eraseregions;
	int (*_erase)(struct mtd_info *, struct erase_info *);
	int (*_point)(struct mtd_info *, loff_t, size_t, size_t *, void **, resource_size_t *);
	int (*_unpoint)(struct mtd_info *, loff_t, size_t);
	int (*_read)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_panic_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_read_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_write_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_get_fact_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_fact_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_get_user_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_lock_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_writev)(struct mtd_info *, const struct kvec *, long unsigned int, loff_t, size_t *);
	void (*_sync)(struct mtd_info *);
	int (*_lock)(struct mtd_info *, loff_t, uint64_t);
	int (*_unlock)(struct mtd_info *, loff_t, uint64_t);
	int (*_is_locked)(struct mtd_info *, loff_t, uint64_t);
	int (*_block_isreserved)(struct mtd_info *, loff_t);
	int (*_block_isbad)(struct mtd_info *, loff_t);
	int (*_block_markbad)(struct mtd_info *, loff_t);
	int (*_max_bad_blocks)(struct mtd_info *, loff_t, size_t);
	int (*_suspend)(struct mtd_info *);
	void (*_resume)(struct mtd_info *);
	void (*_reboot)(struct mtd_info *);
	int (*_get_device)(struct mtd_info *);
	void (*_put_device)(struct mtd_info *);
	bool oops_panic_write;
	struct notifier_block reboot_notifier;
	struct mtd_ecc_stats ecc_stats;
	int subpage_sft;
	void *priv;
	struct module *owner;
	int: 32;
	struct device dev;
	int usecount;
	struct mtd_debug_info dbg;
	struct nvmem_device *nvmem;
	struct mtd_info *parent;
	struct list_head partitions;
	union {
		struct mtd_part part;
		struct mtd_master master;
	};
};

enum {
	MTD_OPS_PLACE_OOB = 0,
	MTD_OPS_AUTO_OOB = 1,
	MTD_OPS_RAW = 2,
};

struct otp_info {
	__u32 start;
	__u32 length;
	__u32 locked;
};

struct erase_info {
	uint64_t addr;
	uint64_t len;
	uint64_t fail_addr;
};

struct mtd_erase_region_info {
	uint64_t offset;
	uint32_t erasesize;
	uint32_t numblocks;
	long unsigned int *lockmap;
	int: 32;
};

struct mtd_oob_ops {
	unsigned int mode;
	size_t len;
	size_t retlen;
	size_t ooblen;
	size_t oobretlen;
	uint32_t ooboffs;
	uint8_t *datbuf;
	uint8_t *oobbuf;
};

struct mtd_oob_region {
	u32 offset;
	u32 length;
};

struct mtd_ooblayout_ops {
	int (*ecc)(struct mtd_info *, int, struct mtd_oob_region *);
	int (*free)(struct mtd_info *, int, struct mtd_oob_region *);
};

struct mtd_pairing_info {
	int pair;
	int group;
};

struct mtd_pairing_scheme {
	int ngroups;
	int (*get_info)(struct mtd_info *, int, struct mtd_pairing_info *);
	int (*get_wunit)(struct mtd_info *, const struct mtd_pairing_info *);
};

struct mtd_notifier {
	void (*add)(struct mtd_info *);
	void (*remove)(struct mtd_info *);
	struct list_head list;
};

struct mtd_partition {
	const char *name;
	const char * const *types;
	uint64_t size;
	uint64_t offset;
	uint32_t mask_flags;
	uint32_t add_flags;
	struct device_node *of_node;
	int: 32;
};

struct mtd_part_parser_data {
	long unsigned int origin;
};

struct mtd_concat {
	struct mtd_info mtd;
	int num_subdev;
	struct mtd_info **subdev;
};

struct mtd_part_parser {
	struct list_head list;
	struct module *owner;
	const char *name;
	const struct of_device_id *of_match_table;
	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **, struct mtd_part_parser_data *);
	void (*cleanup)(const struct mtd_partition *, int);
};

struct mtd_partitions {
	const struct mtd_partition *parts;
	int nr_parts;
	const struct mtd_part_parser *parser;
};

typedef long unsigned int u_long;

struct erase_info_user {
	__u32 start;
	__u32 length;
};

struct erase_info_user64 {
	__u64 start;
	__u64 length;
};

struct mtd_oob_buf {
	__u32 start;
	__u32 length;
	unsigned char *ptr;
};

struct mtd_oob_buf64 {
	__u64 start;
	__u32 pad;
	__u32 length;
	__u64 usr_ptr;
};

struct mtd_write_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
};

struct mtd_info_user {
	__u8 type;
	__u32 flags;
	__u32 size;
	__u32 erasesize;
	__u32 writesize;
	__u32 oobsize;
	__u64 padding;
};

struct region_info_user {
	__u32 offset;
	__u32 erasesize;
	__u32 numblocks;
	__u32 regionindex;
};

struct nand_oobinfo {
	__u32 useecc;
	__u32 eccbytes;
	__u32 oobfree[16];
	__u32 eccpos[32];
};

struct nand_oobfree {
	__u32 offset;
	__u32 length;
};

struct nand_ecclayout_user {
	__u32 eccbytes;
	__u32 eccpos[64];
	__u32 oobavail;
	struct nand_oobfree oobfree[8];
};

enum mtd_file_modes {
	MTD_FILE_MODE_NORMAL = 0,
	MTD_FILE_MODE_OTP_FACTORY = 1,
	MTD_FILE_MODE_OTP_USER = 2,
	MTD_FILE_MODE_RAW = 3,
};

struct mtd_chip_driver;

struct map_info___2 {
	const char *name;
	long unsigned int size;
	resource_size_t phys;
	void *virt;
	void *cached;
	int swap;
	int bankwidth;
	void (*inval_cache)(struct map_info___2 *, long unsigned int, ssize_t);
	void (*set_vpp)(struct map_info___2 *, int);
	long unsigned int pfow_base;
	long unsigned int map_priv_1;
	long unsigned int map_priv_2;
	struct device_node *device_node;
	void *fldrv_priv;
	struct mtd_chip_driver *fldrv;
};

struct mtd_chip_driver {
	struct mtd_info * (*probe)(struct map_info___2 *);
	void (*destroy)(struct mtd_info *);
	struct module *module;
	char *name;
	struct list_head list;
};

struct mtd_file_info {
	struct mtd_info *mtd;
	enum mtd_file_modes mode;
};

struct cmdline_mtd_partition {
	struct cmdline_mtd_partition *next;
	char *mtd_id;
	int num_parts;
	struct mtd_partition *parts;
};

struct mtd_blktrans_ops;

struct mtd_blktrans_dev {
	struct mtd_blktrans_ops *tr;
	struct list_head list;
	struct mtd_info *mtd;
	struct mutex lock;
	int devnum;
	bool bg_stop;
	long unsigned int size;
	int readonly;
	int open;
	struct kref ref;
	struct gendisk *disk;
	struct attribute_group *disk_attributes;
	struct request_queue *rq;
	struct list_head rq_list;
	struct blk_mq_tag_set *tag_set;
	spinlock_t queue_lock;
	void *priv;
	fmode_t file_mode;
};

struct mtd_blktrans_ops {
	char *name;
	int major;
	int part_bits;
	int blksize;
	int blkshift;
	int (*readsect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*writesect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*discard)(struct mtd_blktrans_dev *, long unsigned int, unsigned int);
	void (*background)(struct mtd_blktrans_dev *);
	int (*getgeo)(struct mtd_blktrans_dev *, struct hd_geometry *);
	int (*flush)(struct mtd_blktrans_dev *);
	int (*open)(struct mtd_blktrans_dev *);
	void (*release)(struct mtd_blktrans_dev *);
	void (*add_mtd)(struct mtd_blktrans_ops *, struct mtd_info *);
	void (*remove_dev)(struct mtd_blktrans_dev *);
	struct list_head devs;
	struct list_head list;
	struct module *owner;
};

struct mtdblk_dev {
	struct mtd_blktrans_dev mbd;
	int count;
	struct mutex cache_mutex;
	unsigned char *cache_data;
	long unsigned int cache_offset;
	unsigned int cache_size;
	enum {
		STATE_EMPTY = 0,
		STATE_CLEAN = 1,
		STATE_DIRTY = 2,
	} cache_state;
};

typedef union {
	long unsigned int x[1];
} map_word;

typedef enum {
	FL_READY = 0,
	FL_STATUS = 1,
	FL_CFI_QUERY = 2,
	FL_JEDEC_QUERY = 3,
	FL_ERASING = 4,
	FL_ERASE_SUSPENDING = 5,
	FL_ERASE_SUSPENDED = 6,
	FL_WRITING = 7,
	FL_WRITING_TO_BUFFER = 8,
	FL_OTP_WRITE = 9,
	FL_WRITE_SUSPENDING = 10,
	FL_WRITE_SUSPENDED = 11,
	FL_PM_SUSPENDED = 12,
	FL_SYNCING = 13,
	FL_UNLOADING = 14,
	FL_LOCKING = 15,
	FL_UNLOCKING = 16,
	FL_POINT = 17,
	FL_XIP_WHILE_ERASING = 18,
	FL_XIP_WHILE_WRITING = 19,
	FL_SHUTDOWN = 20,
	FL_READING = 21,
	FL_CACHEDPRG = 22,
	FL_RESETTING = 23,
	FL_OTPING = 24,
	FL_PREPARING_ERASE = 25,
	FL_VERIFYING_ERASE = 26,
	FL_UNKNOWN = 27,
} flstate_t;

struct flchip {
	long unsigned int start;
	int ref_point_counter;
	flstate_t state;
	flstate_t oldstate;
	unsigned int write_suspended: 1;
	unsigned int erase_suspended: 1;
	long unsigned int in_progress_block_addr;
	long unsigned int in_progress_block_mask;
	struct mutex mutex;
	wait_queue_head_t wq;
	int word_write_time;
	int buffer_write_time;
	int erase_time;
	int word_write_time_max;
	int buffer_write_time_max;
	int erase_time_max;
	void *priv;
};

struct cfi_ident {
	uint8_t qry[3];
	uint16_t P_ID;
	uint16_t P_ADR;
	uint16_t A_ID;
	uint16_t A_ADR;
	uint8_t VccMin;
	uint8_t VccMax;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t WordWriteTimeoutTyp;
	uint8_t BufWriteTimeoutTyp;
	uint8_t BlockEraseTimeoutTyp;
	uint8_t ChipEraseTimeoutTyp;
	uint8_t WordWriteTimeoutMax;
	uint8_t BufWriteTimeoutMax;
	uint8_t BlockEraseTimeoutMax;
	uint8_t ChipEraseTimeoutMax;
	uint8_t DevSize;
	uint16_t InterfaceDesc;
	uint16_t MaxBufWriteSize;
	uint8_t NumEraseRegions;
	uint32_t EraseRegionInfo[0];
} __attribute__((packed));

struct cfi_private {
	uint16_t cmdset;
	void *cmdset_priv;
	int interleave;
	int device_type;
	int cfi_mode;
	int addr_unlock1;
	int addr_unlock2;
	struct mtd_info * (*cmdset_setup)(struct map_info___2 *);
	struct cfi_ident *cfiq;
	int mfr;
	int id;
	int numchips;
	map_word sector_erase_cmd;
	long unsigned int chipshift;
	const char *im_name;
	struct flchip chips[0];
};

struct chip_probe {
	char *name;
	int (*probe_chip)(struct map_info___2 *, __u32, long unsigned int *, struct cfi_private *);
};

struct cfi_early_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct cfi_private *);
};

struct cfi_extquery {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
};

struct cfi_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct mtd_info *);
};

typedef int (*varsize_frob_t)(struct map_info___2 *, struct flchip *, long unsigned int, int, void *);

struct flchip_shared {
	struct mutex lock;
	struct flchip *writing;
	struct flchip *erasing;
};

struct cfi_pri_intelext {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint32_t FeatureSupport;
	uint8_t SuspendCmdSupport;
	uint16_t BlkStatusRegMask;
	uint8_t VccOptimal;
	uint8_t VppOptimal;
	uint8_t NumProtectionFields;
	uint16_t ProtRegAddr;
	uint8_t FactProtRegSize;
	uint8_t UserProtRegSize;
	uint8_t extra[0];
} __attribute__((packed));

struct cfi_intelext_blockinfo {
	uint16_t NumIdentBlocks;
	uint16_t BlockSize;
	uint16_t MinBlockEraseCycles;
	uint8_t BitsPerCell;
	uint8_t BlockCap;
};

struct cfi_intelext_regioninfo {
	uint16_t NumIdentPartitions;
	uint8_t NumOpAllowed;
	uint8_t NumOpAllowedSimProgMode;
	uint8_t NumOpAllowedSimEraMode;
	uint8_t NumBlockTypes;
	struct cfi_intelext_blockinfo BlockTypes[1];
};

struct cfi_intelext_programming_regioninfo {
	uint8_t ProgRegShift;
	uint8_t Reserved1;
	uint8_t ControlValid;
	uint8_t Reserved2;
	uint8_t ControlInvalid;
	uint8_t Reserved3;
};

struct cfi_pri_atmel {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t Features;
	uint8_t BottomBoot;
	uint8_t BurstMode;
	uint8_t PageMode;
};

enum fwh_lock_state {
	FWH_UNLOCKED = 0,
	FWH_DENY_WRITE = 1,
	FWH_IMMUTABLE = 2,
	FWH_DENY_READ = 4,
};

struct fwh_xxlock_thunk {
	enum fwh_lock_state val;
	flstate_t state;
};

typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info___2 *, int);

struct physmap_flash_data {
	unsigned int width;
	int (*init)(struct platform_device *);
	void (*exit)(struct platform_device *);
	void (*set_vpp)(struct platform_device *, int);
	unsigned int nr_parts;
	unsigned int pfow_base;
	char *probe_type;
	struct mtd_partition *parts;
	const char * const *part_probe_types;
};

struct physmap_flash_info {
	unsigned int nmaps;
	struct mtd_info **mtds;
	struct mtd_info *cmtd;
	struct map_info___2 *maps;
	spinlock_t vpp_lock;
	int vpp_refcnt;
	const char *probe_type;
	const char * const *part_types;
	unsigned int nparts;
	const struct mtd_partition *parts;
	struct gpio_descs *gpios;
	unsigned int gpio_values;
	unsigned int win_order;
};

struct spear_smi_flash_info {
	char *name;
	long unsigned int mem_base;
	long unsigned int size;
	struct mtd_partition *partitions;
	int nr_partitions;
	u8 fast_mode;
};

struct spear_smi_plat_data {
	long unsigned int clk_rate;
	int num_flashes;
	struct spear_smi_flash_info *board_flash_info;
	struct device_node *np[4];
};

struct flash_device {
	char *name;
	u8 erase_cmd;
	u32 device_id;
	u32 pagesize;
	long unsigned int sectorsize;
	long unsigned int size_in_bytes;
};

struct spear_snor_flash;

struct spear_smi {
	struct clk *clk;
	u32 status;
	long unsigned int clk_rate;
	struct mutex lock;
	void *io_base;
	struct platform_device *pdev;
	wait_queue_head_t cmd_complete;
	u32 num_flashes;
	struct spear_snor_flash *flash[4];
};

struct spear_snor_flash {
	u32 bank;
	u32 dev_id;
	struct mutex lock;
	int: 32;
	struct mtd_info mtd;
	u32 num_parts;
	struct mtd_partition *parts;
	u32 page_size;
	void *base_addr;
	u8 erase_cmd;
	u8 fast_mode;
	int: 16;
	int: 32;
};

struct nand_memory_organization {
	unsigned int bits_per_cell;
	unsigned int pagesize;
	unsigned int oobsize;
	unsigned int pages_per_eraseblock;
	unsigned int eraseblocks_per_lun;
	unsigned int max_bad_eraseblocks_per_lun;
	unsigned int planes_per_lun;
	unsigned int luns_per_target;
	unsigned int ntargets;
};

struct nand_row_converter {
	unsigned int lun_addr_shift;
	unsigned int eraseblock_addr_shift;
};

struct nand_pos {
	unsigned int target;
	unsigned int lun;
	unsigned int plane;
	unsigned int eraseblock;
	unsigned int page;
};

enum nand_page_io_req_type {
	NAND_PAGE_READ = 0,
	NAND_PAGE_WRITE = 1,
};

struct nand_page_io_req {
	enum nand_page_io_req_type type;
	struct nand_pos pos;
	unsigned int dataoffs;
	unsigned int datalen;
	union {
		const void *out;
		void *in;
	} databuf;
	unsigned int ooboffs;
	unsigned int ooblen;
	union {
		const void *out;
		void *in;
	} oobbuf;
	int mode;
};

enum nand_ecc_engine_type {
	NAND_ECC_ENGINE_TYPE_INVALID = 0,
	NAND_ECC_ENGINE_TYPE_NONE = 1,
	NAND_ECC_ENGINE_TYPE_SOFT = 2,
	NAND_ECC_ENGINE_TYPE_ON_HOST = 3,
	NAND_ECC_ENGINE_TYPE_ON_DIE = 4,
};

enum nand_ecc_placement {
	NAND_ECC_PLACEMENT_UNKNOWN = 0,
	NAND_ECC_PLACEMENT_OOB = 1,
	NAND_ECC_PLACEMENT_INTERLEAVED = 2,
};

enum nand_ecc_algo {
	NAND_ECC_ALGO_UNKNOWN = 0,
	NAND_ECC_ALGO_HAMMING = 1,
	NAND_ECC_ALGO_BCH = 2,
	NAND_ECC_ALGO_RS = 3,
};

struct nand_ecc_props {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	unsigned int strength;
	unsigned int step_size;
	unsigned int flags;
};

struct nand_bbt {
	long unsigned int *cache;
};

struct nand_device;

struct nand_ops {
	int (*erase)(struct nand_device *, const struct nand_pos *);
	int (*markbad)(struct nand_device *, const struct nand_pos *);
	bool (*isbad)(struct nand_device *, const struct nand_pos *);
};

struct nand_ecc_context {
	struct nand_ecc_props conf;
	unsigned int total;
	void *priv;
};

struct nand_ecc_engine;

struct nand_ecc {
	struct nand_ecc_props defaults;
	struct nand_ecc_props requirements;
	struct nand_ecc_props user_conf;
	struct nand_ecc_context ctx;
	struct nand_ecc_engine *ondie_engine;
	struct nand_ecc_engine *engine;
};

struct nand_device {
	struct mtd_info mtd;
	struct nand_memory_organization memorg;
	struct nand_ecc ecc;
	struct nand_row_converter rowconv;
	struct nand_bbt bbt;
	const struct nand_ops *ops;
	int: 32;
};

struct nand_ecc_engine_ops {
	int (*init_ctx)(struct nand_device *);
	void (*cleanup_ctx)(struct nand_device *);
	int (*prepare_io_req)(struct nand_device *, struct nand_page_io_req *);
	int (*finish_io_req)(struct nand_device *, struct nand_page_io_req *);
};

struct nand_ecc_engine {
	struct nand_ecc_engine_ops *ops;
};

enum nand_bbt_block_status {
	NAND_BBT_BLOCK_STATUS_UNKNOWN = 0,
	NAND_BBT_BLOCK_GOOD = 1,
	NAND_BBT_BLOCK_WORN = 2,
	NAND_BBT_BLOCK_RESERVED = 3,
	NAND_BBT_BLOCK_FACTORY_BAD = 4,
	NAND_BBT_BLOCK_NUM_STATUS = 5,
};

struct nand_ecc_req_tweak_ctx {
	struct nand_page_io_req orig_req;
	struct nand_device *nand;
	unsigned int page_buffer_size;
	unsigned int oob_buffer_size;
	void *spare_databuf;
	void *spare_oobbuf;
	bool bounce_data;
	bool bounce_oob;
};

struct nand_ecc_sw_hamming_conf {
	struct nand_ecc_req_tweak_ctx req_ctx;
	unsigned int code_size;
	unsigned int nsteps;
	u8 *calc_buf;
	u8 *code_buf;
	unsigned int sm_order;
};

struct nand_ecc_sw_bch_conf {
	struct nand_ecc_req_tweak_ctx req_ctx;
	unsigned int code_size;
	unsigned int nsteps;
	u8 *calc_buf;
	u8 *code_buf;
	struct bch_control *bch;
	unsigned int *errloc;
	unsigned char *eccmask;
};

struct nand_bbt_descr {
	int options;
	int pages[8];
	int offs;
	int veroffs;
	uint8_t version[8];
	int len;
	int maxblocks;
	int reserved_block_code;
	uint8_t *pattern;
};

struct nand_onfi_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	__le16 opt_cmd;
	u8 reserved0[2];
	__le16 ext_param_page_length;
	u8 num_of_param_pages;
	u8 reserved1[17];
	char manufacturer[12];
	char model[20];
	u8 jedec_id;
	__le16 date_code;
	u8 reserved2[13];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	__le32 data_bytes_per_ppage;
	__le16 spare_bytes_per_ppage;
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	u8 programs_per_page;
	u8 ppage_attr;
	u8 ecc_bits;
	u8 interleaved_bits;
	u8 interleaved_ops;
	u8 reserved3[13];
	u8 io_pin_capacitance_max;
	__le16 async_timing_mode;
	__le16 program_cache_timing_mode;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_ccs;
	__le16 src_sync_timing_mode;
	u8 src_ssync_features;
	__le16 clk_pin_capacitance_typ;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	u8 input_pin_capacitance_max;
	u8 driver_strength_support;
	__le16 t_int_r;
	__le16 t_adl;
	u8 reserved4[8];
	__le16 vendor_revision;
	u8 vendor[88];
	__le16 crc;
} __attribute__((packed));

struct onfi_params {
	int version;
	u16 tPROG;
	u16 tBERS;
	u16 tR;
	u16 tCCS;
	u16 async_timing_mode;
	u16 vendor_revision;
	u8 vendor[88];
};

struct nand_parameters {
	const char *model;
	bool supports_set_get_features;
	long unsigned int set_feature_list[8];
	long unsigned int get_feature_list[8];
	struct onfi_params *onfi;
};

struct nand_id {
	u8 data[8];
	int len;
};

struct nand_ecc_step_info {
	int stepsize;
	const int *strengths;
	int nstrengths;
};

struct nand_ecc_caps {
	const struct nand_ecc_step_info *stepinfos;
	int nstepinfos;
	int (*calc_ecc_bytes)(int, int);
};

struct nand_chip;

struct nand_ecc_ctrl {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	int steps;
	int size;
	int bytes;
	int total;
	int strength;
	int prepad;
	int postpad;
	unsigned int options;
	u8 *calc_buf;
	u8 *code_buf;
	void (*hwctl)(struct nand_chip *, int);
	int (*calculate)(struct nand_chip *, const uint8_t *, uint8_t *);
	int (*correct)(struct nand_chip *, uint8_t *, uint8_t *, uint8_t *);
	int (*read_page_raw)(struct nand_chip *, uint8_t *, int, int);
	int (*write_page_raw)(struct nand_chip *, const uint8_t *, int, int);
	int (*read_page)(struct nand_chip *, uint8_t *, int, int);
	int (*read_subpage)(struct nand_chip *, uint32_t, uint32_t, uint8_t *, int);
	int (*write_subpage)(struct nand_chip *, uint32_t, uint32_t, const uint8_t *, int, int);
	int (*write_page)(struct nand_chip *, const uint8_t *, int, int);
	int (*write_oob_raw)(struct nand_chip *, int);
	int (*read_oob_raw)(struct nand_chip *, int);
	int (*read_oob)(struct nand_chip *, int);
	int (*write_oob)(struct nand_chip *, int);
};

struct nand_manufacturer_desc;

struct nand_manufacturer {
	const struct nand_manufacturer_desc *desc;
	void *priv;
};

struct nand_interface_config;

struct nand_chip_ops {
	int (*suspend)(struct nand_chip *);
	void (*resume)(struct nand_chip *);
	int (*lock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*unlock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*setup_read_retry)(struct nand_chip *, int);
	int (*choose_interface_config)(struct nand_chip *, struct nand_interface_config *);
};

struct nand_controller_ops;

struct nand_controller {
	struct mutex lock;
	const struct nand_controller_ops *ops;
};

struct nand_legacy {
	void *IO_ADDR_R;
	void *IO_ADDR_W;
	void (*select_chip)(struct nand_chip *, int);
	u8 (*read_byte)(struct nand_chip *);
	void (*write_byte)(struct nand_chip *, u8);
	void (*write_buf)(struct nand_chip *, const u8 *, int);
	void (*read_buf)(struct nand_chip *, u8 *, int);
	void (*cmd_ctrl)(struct nand_chip *, int, unsigned int);
	void (*cmdfunc)(struct nand_chip *, unsigned int, int, int);
	int (*dev_ready)(struct nand_chip *);
	int (*waitfunc)(struct nand_chip *);
	int (*block_bad)(struct nand_chip *, loff_t);
	int (*block_markbad)(struct nand_chip *, loff_t);
	int (*set_features)(struct nand_chip *, int, u8 *);
	int (*get_features)(struct nand_chip *, int, u8 *);
	int chip_delay;
	struct nand_controller dummy_controller;
};

struct nand_chip {
	struct nand_device base;
	struct nand_id id;
	struct nand_parameters parameters;
	struct nand_manufacturer manufacturer;
	struct nand_chip_ops ops;
	struct nand_legacy legacy;
	unsigned int options;
	const struct nand_interface_config *current_interface_config;
	struct nand_interface_config *best_interface_config;
	unsigned int bbt_erase_shift;
	unsigned int bbt_options;
	unsigned int badblockpos;
	unsigned int badblockbits;
	struct nand_bbt_descr *bbt_td;
	struct nand_bbt_descr *bbt_md;
	struct nand_bbt_descr *badblock_pattern;
	u8 *bbt;
	unsigned int page_shift;
	unsigned int phys_erase_shift;
	unsigned int chip_shift;
	unsigned int pagemask;
	unsigned int subpagesize;
	u8 *data_buf;
	u8 *oob_poi;
	struct {
		unsigned int bitflips;
		int page;
	} pagecache;
	long unsigned int buf_align;
	struct mutex lock;
	unsigned int suspended: 1;
	int cur_cs;
	int read_retries;
	struct nand_controller *controller;
	struct nand_ecc_ctrl ecc;
	void *priv;
	int: 32;
};

struct nand_sdr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	int: 32;
	u64 tPROG_max;
	u64 tR_max;
	u32 tALH_min;
	u32 tADL_min;
	u32 tALS_min;
	u32 tAR_min;
	u32 tCEA_max;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCHZ_max;
	u32 tCLH_min;
	u32 tCLR_min;
	u32 tCLS_min;
	u32 tCOH_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDS_min;
	u32 tFEAT_max;
	u32 tIR_min;
	u32 tITC_max;
	u32 tRC_min;
	u32 tREA_max;
	u32 tREH_min;
	u32 tRHOH_min;
	u32 tRHW_min;
	u32 tRHZ_max;
	u32 tRLOH_min;
	u32 tRP_min;
	u32 tRR_min;
	int: 32;
	u64 tRST_max;
	u32 tWB_max;
	u32 tWC_min;
	u32 tWH_min;
	u32 tWHR_min;
	u32 tWP_min;
	u32 tWW_min;
};

enum nand_interface_type {
	NAND_SDR_IFACE = 0,
};

struct nand_timings {
	unsigned int mode;
	int: 32;
	union {
		struct nand_sdr_timings sdr;
	};
};

struct nand_interface_config {
	enum nand_interface_type type;
	int: 32;
	struct nand_timings timings;
};

struct nand_op_cmd_instr {
	u8 opcode;
};

struct nand_op_addr_instr {
	unsigned int naddrs;
	const u8 *addrs;
};

struct nand_op_data_instr {
	unsigned int len;
	union {
		void *in;
		const void *out;
	} buf;
	bool force_8bit;
};

struct nand_op_waitrdy_instr {
	unsigned int timeout_ms;
};

enum nand_op_instr_type {
	NAND_OP_CMD_INSTR = 0,
	NAND_OP_ADDR_INSTR = 1,
	NAND_OP_DATA_IN_INSTR = 2,
	NAND_OP_DATA_OUT_INSTR = 3,
	NAND_OP_WAITRDY_INSTR = 4,
};

struct nand_op_instr {
	enum nand_op_instr_type type;
	union {
		struct nand_op_cmd_instr cmd;
		struct nand_op_addr_instr addr;
		struct nand_op_data_instr data;
		struct nand_op_waitrdy_instr waitrdy;
	} ctx;
	unsigned int delay_ns;
};

struct nand_subop {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	unsigned int first_instr_start_off;
	unsigned int last_instr_end_off;
};

struct nand_op_parser_addr_constraints {
	unsigned int maxcycles;
};

struct nand_op_parser_data_constraints {
	unsigned int maxlen;
};

struct nand_op_parser_pattern_elem {
	enum nand_op_instr_type type;
	bool optional;
	union {
		struct nand_op_parser_addr_constraints addr;
		struct nand_op_parser_data_constraints data;
	} ctx;
};

struct nand_op_parser_pattern {
	const struct nand_op_parser_pattern_elem *elems;
	unsigned int nelems;
	int (*exec)(struct nand_chip *, const struct nand_subop *);
};

struct nand_op_parser {
	const struct nand_op_parser_pattern *patterns;
	unsigned int npatterns;
};

struct nand_operation {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
};

struct nand_controller_ops {
	int (*attach_chip)(struct nand_chip *);
	void (*detach_chip)(struct nand_chip *);
	int (*exec_op)(struct nand_chip *, const struct nand_operation *, bool);
	int (*setup_interface)(struct nand_chip *, int, const struct nand_interface_config *);
};

struct nand_manufacturer_ops;

struct nand_manufacturer_desc {
	int id;
	char *name;
	const struct nand_manufacturer_ops *ops;
};

struct nand_flash_dev {
	char *name;
	union {
		struct {
			uint8_t mfr_id;
			uint8_t dev_id;
		};
		uint8_t id[8];
	};
	unsigned int pagesize;
	unsigned int chipsize;
	unsigned int erasesize;
	unsigned int options;
	uint16_t id_len;
	uint16_t oobsize;
	struct {
		uint16_t strength_ds;
		uint16_t step_ds;
	} ecc;
};

struct nand_manufacturer_ops {
	void (*detect)(struct nand_chip *);
	int (*init)(struct nand_chip *);
	void (*cleanup)(struct nand_chip *);
	void (*fixup_onfi_param_page)(struct nand_chip *, struct nand_onfi_params *);
};

struct nand_op_parser_ctx {
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	struct nand_subop subop;
};

enum nand_ecc_legacy_mode {
	NAND_ECC_INVALID = 0,
	NAND_ECC_NONE = 1,
	NAND_ECC_SOFT = 2,
	NAND_ECC_SOFT_BCH = 3,
	NAND_ECC_HW = 4,
	NAND_ECC_HW_SYNDROME = 5,
	NAND_ECC_ON_DIE = 6,
};

typedef s8 int8_t;

struct onfi_ext_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct onfi_ext_section {
	u8 type;
	u8 length;
};

struct onfi_ext_param_page {
	__le16 crc;
	u8 sig[4];
	u8 reserved0[10];
	struct onfi_ext_section sections[8];
};

struct jedec_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct nand_jedec_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	u8 opt_cmd[3];
	__le16 sec_cmd;
	u8 num_of_param_pages;
	u8 reserved0[18];
	char manufacturer[12];
	char model[20];
	u8 jedec_id[6];
	u8 reserved1[10];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	u8 reserved2[6];
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	u8 programs_per_page;
	u8 multi_plane_addr;
	u8 multi_plane_op_attr;
	u8 reserved3[38];
	__le16 async_sdr_speed_grade;
	__le16 toggle_ddr_speed_grade;
	__le16 sync_ddr_speed_grade;
	u8 async_sdr_features;
	u8 toggle_ddr_features;
	u8 sync_ddr_features;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_r_multi_plane;
	__le16 t_ccs;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	__le16 clk_pin_capacitance_typ;
	u8 driver_strength_support;
	__le16 t_adl;
	u8 reserved4[36];
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	struct jedec_ecc_info ecc_info[4];
	u8 reserved5[29];
	u8 reserved6[148];
	__le16 vendor_rev_num;
	u8 reserved7[88];
	__le16 crc;
} __attribute__((packed));

struct hynix_read_retry {
	int nregs;
	const u8 *regs;
	u8 values[0];
};

struct hynix_nand {
	const struct hynix_read_retry *read_retry;
};

struct hynix_read_retry_otp {
	int nregs;
	const u8 *regs;
	const u8 *values;
	int page;
	int size;
};

struct nand_onfi_vendor_macronix {
	u8 reserved;
	u8 reliability_func;
};

struct nand_onfi_vendor_micron {
	u8 two_plane_read;
	u8 read_cache;
	u8 read_unique_id;
	u8 dq_imped;
	u8 dq_imped_num_settings;
	u8 dq_imped_feat_addr;
	u8 rb_pulldown_strength;
	u8 rb_pulldown_strength_feat_addr;
	u8 rb_pulldown_strength_num_settings;
	u8 otp_mode;
	u8 otp_page_start;
	u8 otp_data_prot_addr;
	u8 otp_num_pages;
	u8 otp_feat_addr;
	u8 read_retry_options;
	u8 reserved[72];
	u8 param_revision;
};

struct micron_on_die_ecc {
	bool forced;
	bool enabled;
	void *rawbuf;
};

struct micron_nand {
	struct micron_on_die_ecc ecc;
};

enum {
	MICRON_ON_DIE_UNSUPPORTED = 0,
	MICRON_ON_DIE_SUPPORTED = 1,
	MICRON_ON_DIE_MANDATORY = 2,
};

struct denali_chip_sel {
	int bank;
	u32 hwhr2_and_we_2_re;
	u32 tcwaw_and_addr_2_data;
	u32 re_2_we;
	u32 acc_clks;
	u32 rdwr_en_lo_cnt;
	u32 rdwr_en_hi_cnt;
	u32 cs_setup_cnt;
	u32 re_2_re;
};

struct denali_chip {
	struct nand_chip chip;
	struct list_head node;
	unsigned int nsels;
	struct denali_chip_sel sels[0];
	int: 32;
};

struct denali_controller {
	struct nand_controller controller;
	struct device *dev;
	struct list_head chips;
	long unsigned int clk_rate;
	long unsigned int clk_x_rate;
	void *reg;
	void *host;
	struct completion complete;
	int irq;
	u32 irq_mask;
	u32 irq_status;
	spinlock_t irq_lock;
	bool dma_avail;
	int devs_per_cs;
	int oob_skip_bytes;
	int active_bank;
	int nbanks;
	unsigned int revision;
	unsigned int caps;
	const struct nand_ecc_caps *ecc_caps;
	u32 (*host_read)(struct denali_controller *, u32);
	void (*host_write)(struct denali_controller *, u32, u32);
	void (*setup_dma)(struct denali_controller *, dma_addr_t, int, bool);
};

struct denali_dt {
	struct denali_controller controller;
	struct clk *clk;
	struct clk *clk_x;
	struct clk *clk_ecc;
	struct reset_control *rst;
	struct reset_control *rst_reg;
};

struct denali_dt_data {
	unsigned int revision;
	unsigned int caps;
	unsigned int oob_skip_bytes;
	const struct nand_ecc_caps *ecc_caps;
};

struct davinci_aemif_timing;

struct davinci_nand_pdata {
	uint32_t mask_ale;
	uint32_t mask_cle;
	uint32_t core_chipsel;
	uint32_t mask_chipsel;
	struct mtd_partition *parts;
	unsigned int nr_parts;
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement ecc_placement;
	u8 ecc_bits;
	unsigned int options;
	unsigned int bbt_options;
	struct nand_bbt_descr *bbt_td;
	struct nand_bbt_descr *bbt_md;
	struct davinci_aemif_timing *timing;
};

struct davinci_aemif_timing {
	u8 wsetup;
	u8 wstrobe;
	u8 whold;
	u8 rsetup;
	u8 rstrobe;
	u8 rhold;
	u8 ta;
};

struct davinci_nand_info {
	struct nand_controller controller;
	struct nand_chip chip;
	struct platform_device *pdev;
	bool is_readmode;
	void *base;
	void *vaddr;
	void *current_cs;
	uint32_t mask_chipsel;
	uint32_t mask_ale;
	uint32_t mask_cle;
	uint32_t core_chipsel;
	struct davinci_aemif_timing *timing;
};

struct atmel_pmecc_user_req {
	int pagesize;
	int oobsize;
	struct {
		int strength;
		int bytes;
		int sectorsize;
		int nsectors;
		int ooboffset;
	} ecc;
};

enum atmel_nand_rb_type {
	ATMEL_NAND_NO_RB = 0,
	ATMEL_NAND_NATIVE_RB = 1,
	ATMEL_NAND_GPIO_RB = 2,
};

struct atmel_nand_rb {
	enum atmel_nand_rb_type type;
	union {
		struct gpio_desc *gpio;
		int id;
	};
};

struct atmel_nand_cs {
	int id;
	struct atmel_nand_rb rb;
	struct gpio_desc *csgpio;
	struct {
		void *virt;
		dma_addr_t dma;
	} io;
	struct atmel_smc_cs_conf smcconf;
};

struct atmel_pmecc_user;

struct atmel_nand {
	struct list_head node;
	struct device *dev;
	int: 32;
	struct nand_chip base;
	struct atmel_nand_cs *activecs;
	struct atmel_pmecc_user *pmecc;
	struct gpio_desc *cdgpio;
	int numcs;
	struct atmel_nand_cs cs[0];
};

enum atmel_nfc_data_xfer {
	ATMEL_NFC_NO_DATA = 0,
	ATMEL_NFC_READ_DATA = 1,
	ATMEL_NFC_WRITE_DATA = 2,
};

struct atmel_nfc_op {
	u8 cs;
	u8 ncmds;
	u8 cmds[2];
	u8 naddrs;
	u8 addrs[5];
	enum atmel_nfc_data_xfer data;
	u32 wait;
	u32 errors;
};

struct atmel_nand_controller_caps;

struct atmel_nand_controller;

struct atmel_nand_controller_ops {
	int (*probe)(struct platform_device *, const struct atmel_nand_controller_caps *);
	int (*remove)(struct atmel_nand_controller *);
	void (*nand_init)(struct atmel_nand_controller *, struct atmel_nand *);
	int (*ecc_init)(struct nand_chip *);
	int (*setup_interface)(struct atmel_nand *, int, const struct nand_interface_config *);
	int (*exec_op)(struct atmel_nand *, const struct nand_operation *, bool);
};

struct atmel_nand_controller_caps {
	bool has_dma;
	bool legacy_of_bindings;
	u32 ale_offs;
	u32 cle_offs;
	const char *ebi_csa_regmap_name;
	const struct atmel_nand_controller_ops *ops;
};

struct atmel_pmecc;

struct atmel_nand_controller {
	struct nand_controller base;
	const struct atmel_nand_controller_caps *caps;
	struct device *dev;
	struct regmap *smc;
	struct dma_chan *dmac;
	struct atmel_pmecc *pmecc;
	struct list_head chips;
	struct clk *mck;
};

struct atmel_smc_nand_ebi_csa_cfg {
	u32 offs;
	u32 nfd0_on_d16;
};

struct atmel_smc_nand_controller {
	struct atmel_nand_controller base;
	struct regmap *ebi_csa_regmap;
	struct atmel_smc_nand_ebi_csa_cfg *ebi_csa;
};

struct atmel_hsmc_nand_controller {
	struct atmel_nand_controller base;
	struct {
		struct gen_pool *pool;
		void *virt;
		dma_addr_t dma;
	} sram;
	const struct atmel_hsmc_reg_layout *hsmc_layout;
	struct regmap *io;
	struct atmel_nfc_op op;
	struct completion complete;
	u32 cfg;
	int irq;
	struct clk *clk;
};

struct atmel_pmecc_gf_tables {
	u16 *alpha_to;
	u16 *index_of;
};

struct atmel_pmecc_caps {
	const int *strengths;
	int nstrengths;
	int el_offset;
	bool correct_erased_chunks;
};

struct atmel_pmecc___2 {
	struct device *dev;
	const struct atmel_pmecc_caps *caps;
	struct {
		void *base;
		void *errloc;
	} regs;
	struct mutex lock;
};

struct atmel_pmecc_user_conf_cache {
	u32 cfg;
	u32 sarea;
	u32 saddr;
	u32 eaddr;
};

struct atmel_pmecc_user___2 {
	struct atmel_pmecc_user_conf_cache cache;
	struct atmel_pmecc___2 *pmecc;
	const struct atmel_pmecc_gf_tables *gf_tables;
	int eccbytes;
	s16 *partial_syn;
	s16 *si;
	s16 *lmu;
	s16 *smu;
	s32 *mu;
	s32 *dmu;
	s32 *delta;
	u32 isr;
};

enum bch_ecc {
	BCH4_ECC = 0,
	BCH8_ECC = 1,
	BCH16_ECC = 2,
};

struct elm_errorvec {
	bool error_reported;
	bool error_uncorrectable;
	int error_count;
	int error_loc[16];
};

struct gpmc_nand_ops {
	bool (*nand_writebuffer_empty)();
};

enum nand_io {
	NAND_OMAP_PREFETCH_POLLED = 0,
	NAND_OMAP_POLLED = 1,
	NAND_OMAP_PREFETCH_DMA = 2,
	NAND_OMAP_PREFETCH_IRQ = 3,
};

enum omap_ecc {
	OMAP_ECC_HAM1_CODE_SW = 0,
	OMAP_ECC_HAM1_CODE_HW = 1,
	OMAP_ECC_BCH4_CODE_HW_DETECTION_SW = 2,
	OMAP_ECC_BCH4_CODE_HW = 3,
	OMAP_ECC_BCH8_CODE_HW_DETECTION_SW = 4,
	OMAP_ECC_BCH8_CODE_HW = 5,
	OMAP_ECC_BCH16_CODE_HW = 6,
};

struct gpmc_nand_regs {
	void *gpmc_nand_command;
	void *gpmc_nand_address;
	void *gpmc_nand_data;
	void *gpmc_prefetch_config1;
	void *gpmc_prefetch_config2;
	void *gpmc_prefetch_control;
	void *gpmc_prefetch_status;
	void *gpmc_ecc_config;
	void *gpmc_ecc_control;
	void *gpmc_ecc_size_config;
	void *gpmc_ecc1_result;
	void *gpmc_bch_result0[8];
	void *gpmc_bch_result1[8];
	void *gpmc_bch_result2[8];
	void *gpmc_bch_result3[8];
	void *gpmc_bch_result4[8];
	void *gpmc_bch_result5[8];
	void *gpmc_bch_result6[8];
};

struct omap_nand_info {
	struct nand_chip nand;
	struct platform_device *pdev;
	int gpmc_cs;
	bool dev_ready;
	enum nand_io xfer_type;
	int devsize;
	enum omap_ecc ecc_opt;
	struct device_node *elm_of_node;
	long unsigned int phys_base;
	struct completion comp;
	struct dma_chan *dma;
	int gpmc_irq_fifo;
	int gpmc_irq_count;
	enum {
		OMAP_NAND_IO_READ = 0,
		OMAP_NAND_IO_WRITE = 1,
	} iomode;
	u_char *buf;
	int buf_len;
	struct gpmc_nand_regs reg;
	struct gpmc_nand_ops *ops;
	bool flash_bbt;
	struct device *elm_dev;
	struct gpio_desc *ready_gpiod;
	int: 32;
};

struct elm_registers {
	u32 elm_irqenable;
	u32 elm_sysconfig;
	u32 elm_location_config;
	u32 elm_page_ctrl;
	u32 elm_syndrome_fragment_6[8];
	u32 elm_syndrome_fragment_5[8];
	u32 elm_syndrome_fragment_4[8];
	u32 elm_syndrome_fragment_3[8];
	u32 elm_syndrome_fragment_2[8];
	u32 elm_syndrome_fragment_1[8];
	u32 elm_syndrome_fragment_0[8];
};

struct elm_info {
	struct device *dev;
	void *elm_base;
	struct completion elm_completion;
	struct list_head list;
	enum bch_ecc bch_type;
	struct elm_registers elm_regs;
	int ecc_steps;
	int ecc_syndrome_size;
};

struct pxa3xx_nand_platform_data {
	bool keep_config;
	bool flash_bbt;
	int ecc_strength;
	int ecc_step_size;
	const struct mtd_partition *parts;
	unsigned int nr_parts;
};

struct marvell_hw_ecc_layout {
	int writesize;
	int chunk;
	int strength;
	int nchunks;
	int full_chunk_cnt;
	int data_bytes;
	int spare_bytes;
	int ecc_bytes;
	int last_data_bytes;
	int last_spare_bytes;
	int last_ecc_bytes;
};

struct marvell_nand_chip_sel {
	unsigned int cs;
	u32 ndcb0_csel;
	unsigned int rb;
};

struct marvell_nand_chip {
	struct nand_chip chip;
	struct list_head node;
	const struct marvell_hw_ecc_layout *layout;
	u32 ndcr;
	u32 ndtr0;
	u32 ndtr1;
	int addr_cyc;
	int selected_die;
	unsigned int nsels;
	struct marvell_nand_chip_sel sels[0];
	int: 32;
};

struct marvell_nfc_caps {
	unsigned int max_cs_nb;
	unsigned int max_rb_nb;
	bool need_system_controller;
	bool legacy_of_bindings;
	bool is_nfcv2;
	bool use_dma;
};

struct marvell_nfc {
	struct nand_controller controller;
	struct device *dev;
	void *regs;
	struct clk *core_clk;
	struct clk *reg_clk;
	struct completion complete;
	long unsigned int assigned_cs;
	struct list_head chips;
	struct nand_chip *selected_chip;
	const struct marvell_nfc_caps *caps;
	bool use_dma;
	struct dma_chan *dma_chan;
	u8 *dma_buf;
};

struct marvell_nfc_timings {
	unsigned int tRP;
	unsigned int tRH;
	unsigned int tWP;
	unsigned int tWH;
	unsigned int tCS;
	unsigned int tCH;
	unsigned int tADL;
	unsigned int tAR;
	unsigned int tWHR;
	unsigned int tRHW;
	unsigned int tR;
};

struct marvell_nfc_op {
	u32 ndcb[4];
	unsigned int cle_ale_delay_ns;
	unsigned int rdy_timeout_ms;
	unsigned int rdy_delay_ns;
	unsigned int data_delay_ns;
	unsigned int data_instr_idx;
	const struct nand_op_instr *data_instr;
};

enum vf610_nfc_variant {
	NFC_VFC610 = 1,
};

struct vf610_nfc {
	struct nand_controller base;
	struct nand_chip chip;
	struct device *dev;
	void *regs;
	struct completion cmd_done;
	enum vf610_nfc_variant variant;
	struct clk *clk;
	bool data_access;
	u32 ecc_mode;
};

struct resources {
	void *gpmi_regs;
	void *bch_regs;
	unsigned int dma_low_channel;
	unsigned int dma_high_channel;
	struct clk *clock[5];
};

struct bch_geometry {
	unsigned int gf_len;
	unsigned int ecc_strength;
	unsigned int page_size;
	unsigned int metadata_size;
	unsigned int ecc_chunk_size;
	unsigned int ecc_chunk_count;
	unsigned int payload_size;
	unsigned int auxiliary_size;
	unsigned int auxiliary_status_offset;
	unsigned int block_mark_byte_offset;
	unsigned int block_mark_bit_offset;
};

struct boot_rom_geometry {
	unsigned int stride_size_in_pages;
	unsigned int search_area_stride_exponent;
};

enum gpmi_type {
	IS_MX23 = 0,
	IS_MX28 = 1,
	IS_MX6Q = 2,
	IS_MX6SX = 3,
	IS_MX7D = 4,
};

struct gpmi_devdata {
	enum gpmi_type type;
	int bch_max_ecc_strength;
	int max_chain_delay;
	const char * const *clks;
	const int clks_count;
};

struct gpmi_nfc_hardware_timing {
	bool must_apply_timings;
	long unsigned int clk_rate;
	u32 timing0;
	u32 timing1;
	u32 ctrl1n;
};

struct gpmi_transfer {
	u8 cmdbuf[8];
	struct scatterlist sgl;
	enum dma_data_direction direction;
};

struct gpmi_nand_data {
	const struct gpmi_devdata *devdata;
	struct device *dev;
	struct platform_device *pdev;
	struct resources resources;
	struct gpmi_nfc_hardware_timing hw;
	struct bch_geometry bch_geometry;
	struct completion bch_done;
	bool swap_block_mark;
	struct boot_rom_geometry rom_geometry;
	struct nand_controller base;
	int: 32;
	struct nand_chip nand;
	struct gpmi_transfer transfers[8];
	int ntransfers;
	bool bch;
	uint32_t bch_flashlayout0;
	uint32_t bch_flashlayout1;
	char *data_buffer_dma;
	void *auxiliary_virt;
	dma_addr_t auxiliary_phys;
	void *raw_buffer;
	struct dma_chan *dma_chans[8];
	struct completion dma_done;
};

struct brcmnand_soc {
	bool (*ctlrdy_ack)(struct brcmnand_soc *);
	void (*ctlrdy_set_enabled)(struct brcmnand_soc *, bool);
	void (*prepare_data_bus)(struct brcmnand_soc *, bool, bool);
};

struct iproc_nand_soc {
	struct brcmnand_soc soc;
	void *idm_base;
	void *ext_base;
	spinlock_t idm_lock;
};

struct bcm63138_nand_soc {
	struct brcmnand_soc soc;
	void *base;
};

enum {
	BCM63138_CTLRDY = 16,
};

struct bcm6368_nand_soc {
	struct brcmnand_soc soc;
	void *base;
};

enum {
	BCM6368_NP_READ = 1,
	BCM6368_BLOCK_ERASE = 2,
	BCM6368_COPY_BACK = 4,
	BCM6368_PAGE_PGM = 8,
	BCM6368_CTRL_READY = 16,
	BCM6368_DEV_RBPIN = 32,
	BCM6368_ECC_ERR_UNC = 64,
	BCM6368_ECC_ERR_CORR = 128,
};

struct brcm_nand_dma_desc {
	u32 next_desc;
	u32 next_desc_ext;
	u32 cmd_irq;
	u32 dram_addr;
	u32 dram_addr_ext;
	u32 tfr_len;
	u32 total_len;
	u32 flash_addr;
	u32 flash_addr_ext;
	u32 cs;
	u32 pad2[5];
	u32 status_valid;
};

enum edu_reg {
	EDU_CONFIG = 0,
	EDU_DRAM_ADDR = 1,
	EDU_EXT_ADDR = 2,
	EDU_LENGTH = 3,
	EDU_CMD = 4,
	EDU_STOP = 5,
	EDU_STATUS = 6,
	EDU_DONE = 7,
	EDU_ERR_STATUS = 8,
};

enum flash_dma_reg {
	FLASH_DMA_REVISION = 0,
	FLASH_DMA_FIRST_DESC = 1,
	FLASH_DMA_FIRST_DESC_EXT = 2,
	FLASH_DMA_CTRL = 3,
	FLASH_DMA_MODE = 4,
	FLASH_DMA_STATUS = 5,
	FLASH_DMA_INTERRUPT_DESC = 6,
	FLASH_DMA_INTERRUPT_DESC_EXT = 7,
	FLASH_DMA_ERROR_STATUS = 8,
	FLASH_DMA_CURRENT_DESC = 9,
	FLASH_DMA_CURRENT_DESC_EXT = 10,
};

enum {
	BRCMNAND_HAS_1K_SECTORS = 1,
	BRCMNAND_HAS_PREFETCH = 2,
	BRCMNAND_HAS_CACHE_MODE = 4,
	BRCMNAND_HAS_WP = 8,
};

struct brcmnand_host;

struct brcmnand_controller {
	struct device *dev;
	struct nand_controller controller;
	void *nand_base;
	void *nand_fc;
	void *flash_dma_base;
	unsigned int irq;
	unsigned int dma_irq;
	int nand_version;
	struct brcmnand_soc *soc;
	struct clk *clk;
	int cmd_pending;
	bool dma_pending;
	bool edu_pending;
	struct completion done;
	struct completion dma_done;
	struct completion edu_done;
	struct list_head host_list;
	const u16 *edu_offsets;
	void *edu_base;
	int edu_irq;
	int edu_count;
	int: 32;
	u64 edu_dram_addr;
	u32 edu_ext_addr;
	u32 edu_cmd;
	u32 edu_config;
	const u16 *flash_dma_offsets;
	struct brcm_nand_dma_desc *dma_desc;
	dma_addr_t dma_pa;
	int (*dma_trans)(struct brcmnand_host *, u64, u32 *, u32, u8);
	u8 flash_cache[512];
	const u16 *reg_offsets;
	unsigned int reg_spacing;
	const u8 *cs_offsets;
	const u8 *cs0_offsets;
	unsigned int max_block_size;
	const unsigned int *block_sizes;
	unsigned int max_page_size;
	const unsigned int *page_sizes;
	unsigned int page_size_shift;
	unsigned int max_oob;
	u32 features;
	u32 nand_cs_nand_select;
	u32 nand_cs_nand_xor;
	u32 corr_stat_threshold;
	u32 flash_dma_mode;
	u32 flash_edu_mode;
	bool pio_poll_mode;
};

struct brcmnand_cfg {
	u64 device_size;
	unsigned int block_size;
	unsigned int page_size;
	unsigned int spare_area_size;
	unsigned int device_width;
	unsigned int col_adr_bytes;
	unsigned int blk_adr_bytes;
	unsigned int ful_adr_bytes;
	unsigned int sector_size_1k;
	unsigned int ecc_level;
	u32 acc_control;
	u32 config;
	u32 config_ext;
	u32 timing_1;
	u32 timing_2;
};

struct brcmnand_host {
	struct list_head node;
	struct nand_chip chip;
	struct platform_device *pdev;
	int cs;
	unsigned int last_cmd;
	unsigned int last_byte;
	u64 last_addr;
	struct brcmnand_cfg hwcfg;
	struct brcmnand_controller *ctrl;
	int: 32;
};

enum brcmnand_reg {
	BRCMNAND_CMD_START = 0,
	BRCMNAND_CMD_EXT_ADDRESS = 1,
	BRCMNAND_CMD_ADDRESS = 2,
	BRCMNAND_INTFC_STATUS = 3,
	BRCMNAND_CS_SELECT = 4,
	BRCMNAND_CS_XOR = 5,
	BRCMNAND_LL_OP = 6,
	BRCMNAND_CS0_BASE = 7,
	BRCMNAND_CS1_BASE = 8,
	BRCMNAND_CORR_THRESHOLD = 9,
	BRCMNAND_CORR_THRESHOLD_EXT = 10,
	BRCMNAND_UNCORR_COUNT = 11,
	BRCMNAND_CORR_COUNT = 12,
	BRCMNAND_CORR_EXT_ADDR = 13,
	BRCMNAND_CORR_ADDR = 14,
	BRCMNAND_UNCORR_EXT_ADDR = 15,
	BRCMNAND_UNCORR_ADDR = 16,
	BRCMNAND_SEMAPHORE = 17,
	BRCMNAND_ID = 18,
	BRCMNAND_ID_EXT = 19,
	BRCMNAND_LL_RDATA = 20,
	BRCMNAND_OOB_READ_BASE = 21,
	BRCMNAND_OOB_READ_10_BASE = 22,
	BRCMNAND_OOB_WRITE_BASE = 23,
	BRCMNAND_OOB_WRITE_10_BASE = 24,
	BRCMNAND_FC_BASE = 25,
};

enum brcmnand_cs_reg {
	BRCMNAND_CS_CFG_EXT = 0,
	BRCMNAND_CS_CFG = 1,
	BRCMNAND_CS_ACC_CONTROL = 2,
	BRCMNAND_CS_TIMING1 = 3,
	BRCMNAND_CS_TIMING2 = 4,
};

enum {
	CFG_BLK_ADR_BYTES_SHIFT = 8,
	CFG_COL_ADR_BYTES_SHIFT = 12,
	CFG_FUL_ADR_BYTES_SHIFT = 16,
	CFG_BUS_WIDTH_SHIFT = 23,
	CFG_BUS_WIDTH = 8388608,
	CFG_DEVICE_SIZE_SHIFT = 24,
	CFG_PAGE_SIZE_SHIFT_v2_1 = 30,
	CFG_PAGE_SIZE_SHIFT = 20,
	CFG_BLK_SIZE_SHIFT = 28,
	CFG_EXT_PAGE_SIZE_SHIFT = 0,
	CFG_EXT_BLK_SIZE_SHIFT = 4,
};

enum {
	INTFC_FLASH_STATUS = 255,
	INTFC_ERASED = 134217728,
	INTFC_OOB_VALID = 268435456,
	INTFC_CACHE_VALID = 536870912,
	INTFC_FLASH_READY = 1073741824,
	INTFC_CTLR_READY = 2147483648,
};

enum {
	ACC_CONTROL_CACHE_MODE = 4194304,
	ACC_CONTROL_PREFETCH = 8388608,
	ACC_CONTROL_PAGE_HIT = 16777216,
	ACC_CONTROL_WR_PREEMPT = 33554432,
	ACC_CONTROL_PARTIAL_PAGE = 67108864,
	ACC_CONTROL_RD_ERASED = 134217728,
	ACC_CONTROL_FAST_PGM_RDIN = 268435456,
	ACC_CONTROL_WR_ECC = 1073741824,
	ACC_CONTROL_RD_ECC = 2147483648,
};

enum {
	CS_SELECT_NAND_WP = 536870912,
	CS_SELECT_AUTO_DEVICE_ID_CFG = 1073741824,
};

enum brcmnand_llop_type {
	LL_OP_CMD = 0,
	LL_OP_ADDR = 1,
	LL_OP_WR = 2,
	LL_OP_RD = 3,
};

enum {
	LLOP_RE = 65536,
	LLOP_WE = 131072,
	LLOP_ALE = 262144,
	LLOP_CLE = 524288,
	LLOP_RETURN_IDLE = 2147483648,
	LLOP_DATA_MASK = 65535,
};

enum stm32_fmc2_ecc {
	FMC2_ECC_HAM = 1,
	FMC2_ECC_BCH4 = 4,
	FMC2_ECC_BCH8 = 8,
};

enum stm32_fmc2_irq_state {
	FMC2_IRQ_UNKNOWN = 0,
	FMC2_IRQ_BCH = 1,
	FMC2_IRQ_SEQ = 2,
};

struct stm32_fmc2_timings {
	u8 tclr;
	u8 tar;
	u8 thiz;
	u8 twait;
	u8 thold_mem;
	u8 tset_mem;
	u8 thold_att;
	u8 tset_att;
};

struct stm32_fmc2_nand {
	struct nand_chip chip;
	struct stm32_fmc2_timings timings;
	int ncs;
	int cs_used[2];
	int: 32;
};

struct stm32_fmc2_nfc {
	struct nand_controller base;
	struct stm32_fmc2_nand nand;
	struct device *dev;
	struct device *cdev;
	struct regmap *regmap;
	void *data_base[2];
	void *cmd_base[2];
	void *addr_base[2];
	phys_addr_t io_phys_addr;
	phys_addr_t data_phys_addr[2];
	struct clk *clk;
	u8 irq_state;
	struct dma_chan *dma_tx_ch;
	struct dma_chan *dma_rx_ch;
	struct dma_chan *dma_ecc_ch;
	struct sg_table dma_data_sg;
	struct sg_table dma_ecc_sg;
	u8 *ecc_buf;
	int dma_ecc_len;
	struct completion complete;
	struct completion dma_data_complete;
	struct completion dma_ecc_complete;
	u8 cs_assigned;
	int cs_sel;
	int: 32;
};

struct mtd_partition___2;

struct flash_platform_data {
	char *name;
	struct mtd_partition___2 *parts;
	unsigned int nr_parts;
	char *type;
};

enum spi_mem_data_dir {
	SPI_MEM_NO_DATA = 0,
	SPI_MEM_DATA_IN = 1,
	SPI_MEM_DATA_OUT = 2,
};

struct spi_mem_op {
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u16 opcode;
	} cmd;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		int: 15;
		int: 32;
		u64 val;
	} addr;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
	} dummy;
	struct {
		u8 buswidth;
		u8 dtr: 1;
		enum spi_mem_data_dir dir;
		unsigned int nbytes;
		union {
			void *in;
			const void *out;
		} buf;
	} data;
	int: 32;
};

struct spi_mem_dirmap_info {
	struct spi_mem_op op_tmpl;
	u64 offset;
	u64 length;
};

struct spi_mem_dirmap_desc {
	struct spi_mem *mem;
	int: 32;
	struct spi_mem_dirmap_info info;
	unsigned int nodirmap;
	void *priv;
};

struct spi_mem {
	struct spi_device *spi;
	void *drvpriv;
	const char *name;
};

struct spi_mem_driver {
	struct spi_driver spidrv;
	int (*probe)(struct spi_mem *);
	int (*remove)(struct spi_mem *);
	void (*shutdown)(struct spi_mem *);
};

enum spi_nor_protocol {
	SNOR_PROTO_1_1_1 = 65793,
	SNOR_PROTO_1_1_2 = 65794,
	SNOR_PROTO_1_1_4 = 65796,
	SNOR_PROTO_1_1_8 = 65800,
	SNOR_PROTO_1_2_2 = 66050,
	SNOR_PROTO_1_4_4 = 66564,
	SNOR_PROTO_1_8_8 = 67592,
	SNOR_PROTO_2_2_2 = 131586,
	SNOR_PROTO_4_4_4 = 263172,
	SNOR_PROTO_8_8_8 = 526344,
	SNOR_PROTO_1_1_1_DTR = 16843009,
	SNOR_PROTO_1_2_2_DTR = 16843266,
	SNOR_PROTO_1_4_4_DTR = 16843780,
	SNOR_PROTO_1_8_8_DTR = 16844808,
	SNOR_PROTO_8_8_8_DTR = 17303560,
};

struct spi_nor_hwcaps {
	u32 mask;
};

struct spi_nor;

struct spi_nor_controller_ops {
	int (*prepare)(struct spi_nor *);
	void (*unprepare)(struct spi_nor *);
	int (*read_reg)(struct spi_nor *, u8, u8 *, size_t);
	int (*write_reg)(struct spi_nor *, u8, const u8 *, size_t);
	ssize_t (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	ssize_t (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*erase)(struct spi_nor *, loff_t);
};

enum spi_nor_cmd_ext {
	SPI_NOR_EXT_NONE = 0,
	SPI_NOR_EXT_REPEAT = 1,
	SPI_NOR_EXT_INVERT = 2,
	SPI_NOR_EXT_HEX = 3,
};

struct flash_info;

struct spi_nor_manufacturer;

struct spi_nor_flash_parameter;

struct spi_nor {
	struct mtd_info mtd;
	struct mutex lock;
	struct device *dev;
	struct spi_mem *spimem;
	u8 *bouncebuf;
	size_t bouncebuf_size;
	const struct flash_info *info;
	const struct spi_nor_manufacturer *manufacturer;
	u32 page_size;
	u8 addr_width;
	u8 erase_opcode;
	u8 read_opcode;
	u8 read_dummy;
	u8 program_opcode;
	enum spi_nor_protocol read_proto;
	enum spi_nor_protocol write_proto;
	enum spi_nor_protocol reg_proto;
	bool sst_write_second;
	u32 flags;
	enum spi_nor_cmd_ext cmd_ext_type;
	const struct spi_nor_controller_ops *controller_ops;
	struct spi_nor_flash_parameter *params;
	struct {
		struct spi_mem_dirmap_desc *rdesc;
		struct spi_mem_dirmap_desc *wdesc;
	} dirmap;
	void *priv;
	int: 32;
};

struct spi_nor_fixups;

struct flash_info {
	char *name;
	u8 id[6];
	u8 id_len;
	unsigned int sector_size;
	u16 n_sectors;
	u16 page_size;
	u16 addr_width;
	u32 flags;
	const struct spi_nor_fixups *fixups;
};

struct spi_nor_manufacturer {
	const char *name;
	const struct flash_info *parts;
	unsigned int nparts;
	const struct spi_nor_fixups *fixups;
};

struct spi_nor_read_command {
	u8 num_mode_clocks;
	u8 num_wait_states;
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_pp_command {
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_erase_region {
	u64 offset;
	u64 size;
};

struct spi_nor_erase_type {
	u32 size;
	u32 size_shift;
	u32 size_mask;
	u8 opcode;
	u8 idx;
};

struct spi_nor_erase_map {
	struct spi_nor_erase_region *regions;
	int: 32;
	struct spi_nor_erase_region uniform_region;
	struct spi_nor_erase_type erase_type[4];
	u8 uniform_erase_type;
	int: 24;
	int: 32;
};

struct spi_nor_locking_ops;

struct spi_nor_flash_parameter {
	u64 size;
	u32 writesize;
	u32 page_size;
	u8 rdsr_dummy;
	u8 rdsr_addr_nbytes;
	struct spi_nor_hwcaps hwcaps;
	struct spi_nor_read_command reads[16];
	struct spi_nor_pp_command page_programs[8];
	struct spi_nor_erase_map erase_map;
	int (*octal_dtr_enable)(struct spi_nor *, bool);
	int (*quad_enable)(struct spi_nor *);
	int (*set_4byte_addr_mode)(struct spi_nor *, bool);
	u32 (*convert_addr)(struct spi_nor *, u32);
	int (*setup)(struct spi_nor *, const struct spi_nor_hwcaps *);
	const struct spi_nor_locking_ops *locking_ops;
};

struct sfdp_bfpt {
	u32 dwords[20];
};

struct sfdp_parameter_header {
	u8 id_lsb;
	u8 minor;
	u8 major;
	u8 length;
	u8 parameter_table_pointer[3];
	u8 id_msb;
};

enum spi_nor_option_flags {
	SNOR_F_USE_FSR = 1,
	SNOR_F_HAS_SR_TB = 2,
	SNOR_F_NO_OP_CHIP_ERASE = 4,
	SNOR_F_READY_XSR_RDY = 8,
	SNOR_F_USE_CLSR = 16,
	SNOR_F_BROKEN_RESET = 32,
	SNOR_F_4B_OPCODES = 64,
	SNOR_F_HAS_4BAIT = 128,
	SNOR_F_HAS_LOCK = 256,
	SNOR_F_HAS_16BIT_SR = 512,
	SNOR_F_NO_READ_CR = 1024,
	SNOR_F_HAS_SR_TB_BIT6 = 2048,
	SNOR_F_HAS_4BIT_BP = 4096,
	SNOR_F_HAS_SR_BP3_BIT6 = 8192,
	SNOR_F_IO_MODE_EN_VOLATILE = 16384,
	SNOR_F_SOFT_RESET = 32768,
	SNOR_F_SWP_IS_VOLATILE = 65536,
};

enum spi_nor_read_command_index {
	SNOR_CMD_READ = 0,
	SNOR_CMD_READ_FAST = 1,
	SNOR_CMD_READ_1_1_1_DTR = 2,
	SNOR_CMD_READ_1_1_2 = 3,
	SNOR_CMD_READ_1_2_2 = 4,
	SNOR_CMD_READ_2_2_2 = 5,
	SNOR_CMD_READ_1_2_2_DTR = 6,
	SNOR_CMD_READ_1_1_4 = 7,
	SNOR_CMD_READ_1_4_4 = 8,
	SNOR_CMD_READ_4_4_4 = 9,
	SNOR_CMD_READ_1_4_4_DTR = 10,
	SNOR_CMD_READ_1_1_8 = 11,
	SNOR_CMD_READ_1_8_8 = 12,
	SNOR_CMD_READ_8_8_8 = 13,
	SNOR_CMD_READ_1_8_8_DTR = 14,
	SNOR_CMD_READ_8_8_8_DTR = 15,
	SNOR_CMD_READ_MAX = 16,
};

enum spi_nor_pp_command_index {
	SNOR_CMD_PP = 0,
	SNOR_CMD_PP_1_1_4 = 1,
	SNOR_CMD_PP_1_4_4 = 2,
	SNOR_CMD_PP_4_4_4 = 3,
	SNOR_CMD_PP_1_1_8 = 4,
	SNOR_CMD_PP_1_8_8 = 5,
	SNOR_CMD_PP_8_8_8 = 6,
	SNOR_CMD_PP_8_8_8_DTR = 7,
	SNOR_CMD_PP_MAX = 8,
};

struct spi_nor_erase_command {
	struct list_head list;
	u32 count;
	u32 size;
	u8 opcode;
};

struct spi_nor_locking_ops {
	int (*lock)(struct spi_nor *, loff_t, uint64_t);
	int (*unlock)(struct spi_nor *, loff_t, uint64_t);
	int (*is_locked)(struct spi_nor *, loff_t, uint64_t);
};

struct spi_nor_fixups {
	void (*default_init)(struct spi_nor *);
	int (*post_bfpt)(struct spi_nor *, const struct sfdp_parameter_header *, const struct sfdp_bfpt *, struct spi_nor_flash_parameter *);
	void (*post_sfdp)(struct spi_nor *);
};

struct sfdp_header {
	u32 signature;
	u8 minor;
	u8 major;
	u8 nph;
	u8 unused;
	struct sfdp_parameter_header bfpt_header;
};

struct sfdp_bfpt_read {
	u32 hwcaps;
	u32 supported_dword;
	u32 supported_bit;
	u32 settings_dword;
	u32 settings_shift;
	enum spi_nor_protocol proto;
};

struct sfdp_bfpt_erase {
	u32 dword;
	u32 shift;
};

struct sfdp_4bait {
	u32 hwcaps;
	u32 supported_bit;
};

enum {
	UBI_VID_DYNAMIC = 1,
	UBI_VID_STATIC = 2,
};

enum {
	UBI_VTBL_AUTORESIZE_FLG = 1,
	UBI_VTBL_SKIP_CRC_CHECK_FLG = 2,
};

enum {
	UBI_COMPAT_DELETE = 1,
	UBI_COMPAT_RO = 2,
	UBI_COMPAT_PRESERVE = 4,
	UBI_COMPAT_REJECT = 5,
};

struct ubi_ec_hdr {
	__be32 magic;
	__u8 version;
	__u8 padding1[3];
	__be64 ec;
	__be32 vid_hdr_offset;
	__be32 data_offset;
	__be32 image_seq;
	__u8 padding2[32];
	__be32 hdr_crc;
};

struct ubi_vid_hdr {
	__be32 magic;
	__u8 version;
	__u8 vol_type;
	__u8 copy_flag;
	__u8 compat;
	__be32 vol_id;
	__be32 lnum;
	__u8 padding1[4];
	__be32 data_size;
	__be32 used_ebs;
	__be32 data_pad;
	__be32 data_crc;
	__u8 padding2[4];
	__be64 sqnum;
	__u8 padding3[12];
	__be32 hdr_crc;
};

struct ubi_vtbl_record {
	__be32 reserved_pebs;
	__be32 alignment;
	__be32 data_pad;
	__u8 vol_type;
	__u8 upd_marker;
	__be16 name_len;
	__u8 name[128];
	__u8 flags;
	__u8 padding[23];
	__be32 crc;
};

enum {
	UBI_IO_FF = 1,
	UBI_IO_FF_BITFLIPS = 2,
	UBI_IO_BAD_HDR = 3,
	UBI_IO_BAD_HDR_EBADMSG = 4,
	UBI_IO_BITFLIPS = 5,
};

struct ubi_vid_io_buf {
	struct ubi_vid_hdr *hdr;
	void *buffer;
};

struct ubi_wl_entry {
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
	int ec;
	int pnum;
};

struct ubi_volume_desc___2;

struct ubi_rename_entry {
	int new_name_len;
	char new_name[128];
	int remove;
	struct ubi_volume_desc___2 *desc;
	struct list_head list;
};

struct ubi_volume;

struct ubi_volume_desc___2 {
	struct ubi_volume *vol;
	int mode;
};

struct ubi_fastmap_layout {
	struct ubi_wl_entry *e[32];
	int to_be_tortured[32];
	int used_blocks;
	int max_pool_size;
	int max_wl_pool_size;
};

struct ubi_fm_pool {
	int pebs[256];
	int used;
	int size;
	int max_size;
};

struct ubi_device;

struct ubi_eba_table;

struct ubi_volume {
	struct device dev;
	struct cdev cdev;
	struct ubi_device *ubi;
	int vol_id;
	int ref_count;
	int readers;
	int writers;
	int exclusive;
	int metaonly;
	int reserved_pebs;
	int vol_type;
	int usable_leb_size;
	int used_ebs;
	int last_eb_bytes;
	int: 32;
	long long int used_bytes;
	int alignment;
	int data_pad;
	int name_len;
	char name[128];
	int upd_ebs;
	int ch_lnum;
	int: 32;
	long long int upd_bytes;
	long long int upd_received;
	void *upd_buf;
	struct ubi_eba_table *eba_tbl;
	unsigned int skip_check: 1;
	unsigned int checked: 1;
	unsigned int corrupted: 1;
	unsigned int upd_marker: 1;
	unsigned int updating: 1;
	unsigned int changing_leb: 1;
	unsigned int direct_writes: 1;
	int: 25;
	int: 32;
};

struct ubi_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_io: 1;
	unsigned int chk_fastmap: 1;
	unsigned int disable_bgt: 1;
	unsigned int emulate_bitflips: 1;
	unsigned int emulate_io_failures: 1;
	unsigned int emulate_power_cut: 2;
	unsigned int power_cut_counter;
	unsigned int power_cut_min;
	unsigned int power_cut_max;
	char dfs_dir_name[7];
	struct dentry *dfs_dir;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_io;
	struct dentry *dfs_chk_fastmap;
	struct dentry *dfs_disable_bgt;
	struct dentry *dfs_emulate_bitflips;
	struct dentry *dfs_emulate_io_failures;
	struct dentry *dfs_emulate_power_cut;
	struct dentry *dfs_power_cut_min;
	struct dentry *dfs_power_cut_max;
};

struct ubi_device {
	struct cdev cdev;
	int: 32;
	struct device dev;
	int ubi_num;
	char ubi_name[9];
	int vol_count;
	struct ubi_volume *volumes[129];
	spinlock_t volumes_lock;
	int ref_count;
	int image_seq;
	int rsvd_pebs;
	int avail_pebs;
	int beb_rsvd_pebs;
	int beb_rsvd_level;
	int bad_peb_limit;
	int autoresize_vol_id;
	int vtbl_slots;
	int vtbl_size;
	struct ubi_vtbl_record *vtbl;
	struct mutex device_mutex;
	int max_ec;
	int mean_ec;
	int: 32;
	long long unsigned int global_sqnum;
	spinlock_t ltree_lock;
	struct rb_root ltree;
	struct mutex alc_mutex;
	int fm_disabled;
	struct ubi_fastmap_layout *fm;
	struct ubi_fm_pool fm_pool;
	struct ubi_fm_pool fm_wl_pool;
	struct rw_semaphore fm_eba_sem;
	struct rw_semaphore fm_protect;
	void *fm_buf;
	size_t fm_size;
	struct work_struct fm_work;
	int fm_work_scheduled;
	int fast_attach;
	struct ubi_wl_entry *fm_anchor;
	struct ubi_wl_entry *fm_next_anchor;
	int fm_do_produce_anchor;
	struct rb_root used;
	struct rb_root erroneous;
	struct rb_root free;
	int free_count;
	struct rb_root scrub;
	struct list_head pq[10];
	int pq_head;
	spinlock_t wl_lock;
	struct mutex move_mutex;
	struct rw_semaphore work_sem;
	int wl_scheduled;
	struct ubi_wl_entry **lookuptbl;
	struct ubi_wl_entry *move_from;
	struct ubi_wl_entry *move_to;
	int move_to_put;
	struct list_head works;
	int works_count;
	struct task_struct *bgt_thread;
	int thread_enabled;
	char bgt_name[13];
	long long int flash_size;
	int peb_count;
	int peb_size;
	int bad_peb_count;
	int good_peb_count;
	int corr_peb_count;
	int erroneous_peb_count;
	int max_erroneous;
	int min_io_size;
	int hdrs_min_io_size;
	int ro_mode;
	int leb_size;
	int leb_start;
	int ec_hdr_alsize;
	int vid_hdr_alsize;
	int vid_hdr_offset;
	int vid_hdr_aloffset;
	int vid_hdr_shift;
	unsigned int bad_allowed: 1;
	unsigned int nor_flash: 1;
	int max_write_size;
	struct mtd_info *mtd;
	void *peb_buf;
	struct mutex buf_mutex;
	struct mutex ckvol_mutex;
	struct ubi_debug_info dbg;
	int: 32;
};

struct ubi_ainf_peb {
	int ec;
	int pnum;
	int vol_id;
	int lnum;
	unsigned int scrub: 1;
	unsigned int copy_flag: 1;
	int: 30;
	int: 32;
	long long unsigned int sqnum;
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
	int: 32;
};

struct ubi_ainf_volume {
	int vol_id;
	int highest_lnum;
	int leb_count;
	int vol_type;
	int used_ebs;
	int last_data_size;
	int data_pad;
	int compat;
	struct rb_node rb;
	struct rb_root root;
};

struct ubi_attach_info {
	struct rb_root volumes;
	struct list_head corr;
	struct list_head free;
	struct list_head erase;
	struct list_head alien;
	struct list_head fastmap;
	int corr_peb_count;
	int empty_peb_count;
	int alien_peb_count;
	int bad_peb_count;
	int maybe_bad_peb_count;
	int vols_found;
	int highest_vol_id;
	int is_empty;
	int force_full_scan;
	int min_ec;
	int max_ec;
	long long unsigned int max_sqnum;
	int mean_ec;
	int: 32;
	uint64_t ec_sum;
	int ec_count;
	struct kmem_cache *aeb_slab_cache;
	struct ubi_ec_hdr *ech;
	struct ubi_vid_io_buf *vidb;
};

enum {
	UBI_VOL_SKIP_CRC_CHECK_FLG = 1,
};

struct ubi_mkvol_req {
	__s32 vol_id;
	__s32 alignment;
	__s64 bytes;
	__s8 vol_type;
	__u8 flags;
	__s16 name_len;
	__s8 padding2[4];
	char name[128];
};

enum {
	UBI_VOLUME_ADDED = 0,
	UBI_VOLUME_REMOVED = 1,
	UBI_VOLUME_RESIZED = 2,
	UBI_VOLUME_RENAMED = 3,
	UBI_VOLUME_UPDATED = 4,
};

struct ubi_leb_change_req {
	__s32 lnum;
	__s32 bytes;
	__s8 dtype;
	__s8 padding[7];
};

struct ubi_notification {
	struct ubi_device_info di;
	int: 32;
	struct ubi_volume_info vi;
};

struct mtd_dev_param {
	char name[64];
	int ubi_num;
	int vid_hdr_offs;
	int max_beb_per1024;
};

enum {
	UBI_VOL_PROP_DIRECT_WRITE = 1,
};

struct ubi_attach_req {
	__s32 ubi_num;
	__s32 mtd_num;
	__s32 vid_hdr_offset;
	__s16 max_beb_per1024;
	__s8 padding[10];
};

struct ubi_rsvol_req {
	__s64 bytes;
	__s32 vol_id;
};

struct ubi_rnvol_req {
	__s32 count;
	__s8 padding1[12];
	struct {
		__s32 vol_id;
		__s16 name_len;
		__s8 padding2[2];
		char name[128];
	} ents[32];
};

struct ubi_map_req {
	__s32 lnum;
	__s8 dtype;
	__s8 padding[3];
};

struct ubi_set_vol_prop_req {
	__u8 property;
	__u8 padding[7];
	__u64 value;
};

struct ubi_sgl {
	int list_pos;
	int page_pos;
	struct scatterlist sg[64];
};

enum {
	MOVE_CANCEL_RACE = 1,
	MOVE_SOURCE_RD_ERR = 2,
	MOVE_TARGET_RD_ERR = 3,
	MOVE_TARGET_WR_ERR = 4,
	MOVE_TARGET_BITFLIPS = 5,
	MOVE_RETRY = 6,
};

struct ubi_ltree_entry {
	struct rb_node rb;
	int vol_id;
	int lnum;
	int users;
	struct rw_semaphore mutex;
};

struct ubi_eba_leb_desc {
	int lnum;
	int pnum;
};

struct ubi_eba_entry;

struct ubi_eba_table {
	struct ubi_eba_entry *entries;
};

struct ubi_eba_entry {
	int pnum;
};

enum {
	POWER_CUT_EC_WRITE = 1,
	POWER_CUT_VID_WRITE = 2,
};

struct ubi_work {
	struct list_head list;
	int (*func)(struct ubi_device *, struct ubi_work *, int);
	struct ubi_wl_entry *e;
	int vol_id;
	int lnum;
	int torture;
};

typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);

struct spi_res {
	struct list_head entry;
	spi_res_release_t release;
	int: 32;
	long long unsigned int data[0];
};

struct spi_replaced_transfers;

typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);

struct spi_replaced_transfers {
	spi_replaced_release_t release;
	void *extradata;
	struct list_head replaced_transfers;
	struct list_head *replaced_after;
	size_t inserted;
	struct spi_transfer inserted_transfers[0];
};

struct spi_board_info {
	char modalias[32];
	const void *platform_data;
	const struct property_entry *properties;
	void *controller_data;
	int irq;
	u32 max_speed_hz;
	u16 bus_num;
	u16 chip_select;
	u32 mode;
};

struct trace_event_raw_spi_controller {
	struct trace_entry ent;
	int bus_num;
	char __data[0];
};

struct trace_event_raw_spi_message {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	char __data[0];
};

struct trace_event_raw_spi_message_done {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	unsigned int frame;
	unsigned int actual;
	char __data[0];
};

struct trace_event_raw_spi_transfer {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_transfer *xfer;
	int len;
	u32 __data_loc_rx_buf;
	u32 __data_loc_tx_buf;
	char __data[0];
};

struct trace_event_data_offsets_spi_controller {};

struct trace_event_data_offsets_spi_message {};

struct trace_event_data_offsets_spi_message_done {};

struct trace_event_data_offsets_spi_transfer {
	u32 rx_buf;
	u32 tx_buf;
};

typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);

typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);

typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);

struct boardinfo {
	struct list_head list;
	struct spi_board_info board_info;
};

struct spi_ioc_transfer {
	__u64 tx_buf;
	__u64 rx_buf;
	__u32 len;
	__u32 speed_hz;
	__u16 delay_usecs;
	__u8 bits_per_word;
	__u8 cs_change;
	__u8 tx_nbits;
	__u8 rx_nbits;
	__u8 word_delay_usecs;
	__u8 pad;
};

struct spidev_data {
	dev_t devt;
	spinlock_t spi_lock;
	struct spi_device *spi;
	struct list_head device_entry;
	struct mutex buf_lock;
	unsigned int users;
	u8 *tx_buffer;
	u8 *rx_buffer;
	u32 speed_hz;
};

struct bcm2835_spi {
	void *regs;
	struct clk *clk;
	int irq;
	struct spi_transfer *tfr;
	struct spi_controller *ctlr;
	const u8 *tx_buf;
	u8 *rx_buf;
	int tx_len;
	int rx_len;
	int tx_prologue;
	int rx_prologue;
	unsigned int tx_spillover;
	u32 prepare_cs[4];
	struct dentry *debugfs_dir;
	int: 32;
	u64 count_transfer_polling;
	u64 count_transfer_irq;
	u64 count_transfer_irq_after_polling;
	u64 count_transfer_dma;
	u8 chip_select;
	unsigned int tx_dma_active;
	unsigned int rx_dma_active;
	struct dma_async_tx_descriptor *fill_tx_desc;
	dma_addr_t fill_tx_addr;
	struct dma_async_tx_descriptor *clear_rx_desc[4];
	dma_addr_t clear_rx_addr;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 clear_rx_cs[4];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bcm2835aux_spi {
	void *regs;
	struct clk *clk;
	int irq;
	u32 cntl[2];
	const u8 *tx_buf;
	u8 *rx_buf;
	int tx_len;
	int rx_len;
	int pending;
	u64 count_transfer_polling;
	u64 count_transfer_irq;
	u64 count_transfer_irq_after_poll;
	struct dentry *debugfs_dir;
	int: 32;
};

enum {
	MSPI_DONE = 1,
	BSPI_DONE = 2,
	BSPI_ERR = 4,
	MSPI_BSPI_DONE = 7,
};

struct bcm_qspi_soc_intc {
	void (*bcm_qspi_int_ack)(struct bcm_qspi_soc_intc *, int);
	void (*bcm_qspi_int_set)(struct bcm_qspi_soc_intc *, int, bool);
	u32 (*bcm_qspi_get_int_status)(struct bcm_qspi_soc_intc *);
};

struct bcm_iproc_intc {
	struct bcm_qspi_soc_intc soc_intc;
	struct platform_device *pdev;
	void *int_reg;
	void *int_status_reg;
	spinlock_t soclock;
	bool big_endian;
};

struct bcm_qspi_parms {
	u32 speed_hz;
	u8 mode;
	u8 bits_per_word;
};

struct bcm_xfer_mode {
	bool flex_mode;
	unsigned int width;
	unsigned int addrlen;
	unsigned int hp;
};

enum base_type___2 {
	MSPI = 0,
	BSPI = 1,
	CHIP_SELECT = 2,
	BASEMAX = 3,
};

enum irq_source {
	SINGLE_L2 = 0,
	MUXED_L1 = 1,
};

struct bcm_qspi_irq {
	const char *irq_name;
	const irq_handler_t irq_handler;
	int irq_source;
	u32 mask;
};

struct bcm_qspi_dev_id {
	const struct bcm_qspi_irq *irqp;
	void *dev;
};

struct qspi_trans {
	struct spi_transfer *trans;
	int byte;
	bool mspi_last_trans;
};

struct bcm_qspi {
	struct platform_device *pdev;
	struct spi_controller *master;
	struct clk *clk;
	u32 base_clk;
	u32 max_speed_hz;
	void *base[3];
	struct bcm_qspi_soc_intc *soc_intc;
	struct bcm_qspi_parms last_parms;
	struct qspi_trans trans_pos;
	int curr_cs;
	int bspi_maj_rev;
	int bspi_min_rev;
	int bspi_enabled;
	const struct spi_mem_op *bspi_rf_op;
	u32 bspi_rf_op_idx;
	u32 bspi_rf_op_len;
	u32 bspi_rf_op_status;
	struct bcm_xfer_mode xfer_mode;
	u32 s3_strap_override_ctrl;
	bool bspi_mode;
	bool big_endian;
	int num_irqs;
	struct bcm_qspi_dev_id *dev_ids;
	struct completion mspi_done;
	struct completion bspi_done;
	u8 mspi_maj_rev;
	u8 mspi_min_rev;
	bool mspi_spcr3_sysclk;
};

struct bcm_qspi_data {
	bool has_mspi_rev;
	bool has_spcr3_sysclk;
};

struct spi_bitbang {
	struct mutex lock;
	u8 busy;
	u8 use_dma;
	u16 flags;
	struct spi_controller *master;
	int (*setup_transfer)(struct spi_device *, struct spi_transfer *);
	void (*chipselect)(struct spi_device *, int);
	int (*txrx_bufs)(struct spi_device *, struct spi_transfer *);
	u32 (*txrx_word[4])(struct spi_device *, unsigned int, u32, u8, unsigned int);
	int (*set_line_direction)(struct spi_device *, bool);
};

struct spi_bitbang_cs {
	unsigned int nsecs;
	u32 (*txrx_word)(struct spi_device *, unsigned int, u32, u8, unsigned int);
	unsigned int (*txrx_bufs)(struct spi_device *, u32 (*)(struct spi_device *, unsigned int, u32, u8, unsigned int), unsigned int, struct spi_transfer *, unsigned int);
};

struct cdns_spi {
	void *regs;
	struct clk *ref_clk;
	struct clk *pclk;
	unsigned int clk_rate;
	u32 speed_hz;
	const u8 *txbuf;
	u8 *rxbuf;
	int tx_bytes;
	int rx_bytes;
	u8 dev_busy;
	u32 is_decoded_cs;
};

enum {
	SPI_VERSION_1 = 0,
	SPI_VERSION_2 = 1,
};

struct davinci_spi_platform_data {
	u8 version;
	u8 num_chipselect;
	u8 intr_line;
	u8 prescaler_limit;
	bool cshold_bug;
	enum dma_event_q dma_event_q;
};

struct davinci_spi_config {
	u8 wdelay;
	u8 odd_parity;
	u8 parity_enable;
	u8 io_type;
	u8 timer_disable;
	u8 c2tdelay;
	u8 t2cdelay;
	u8 t2edelay;
	u8 c2edelay;
};

struct davinci_spi {
	struct spi_bitbang bitbang;
	struct clk *clk;
	u8 version;
	resource_size_t pbase;
	void *base;
	u32 irq;
	struct completion done;
	const void *tx;
	void *rx;
	int rcount;
	int wcount;
	struct dma_chan *dma_rx;
	struct dma_chan *dma_tx;
	struct davinci_spi_platform_data pdata;
	void (*get_rx)(u32, struct davinci_spi *);
	u32 (*get_tx)(struct davinci_spi *);
	u8 *bytes_per_word;
	u8 prescaler_limit;
};

struct davinci_spi_of_data {
	u8 version;
	u8 prescaler_limit;
};

struct omap2_mcspi_platform_config {
	short unsigned int num_cs;
	unsigned int regs_offset;
	unsigned int pin_dir: 1;
	size_t max_xfer_len;
};

struct omap2_mcspi_device_config {
	unsigned int turbo_mode: 1;
	unsigned int cs_per_word: 1;
};

struct omap2_mcspi_dma {
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	struct completion dma_tx_completion;
	struct completion dma_rx_completion;
	char dma_rx_ch_name[14];
	char dma_tx_ch_name[14];
};

struct omap2_mcspi_regs {
	u32 modulctrl;
	u32 wakeupenable;
	struct list_head cs;
};

struct omap2_mcspi {
	struct completion txdone;
	struct spi_controller *master;
	void *base;
	long unsigned int phys;
	struct omap2_mcspi_dma *dma_channels;
	struct device *dev;
	struct omap2_mcspi_regs ctx;
	int fifo_depth;
	bool slave_aborted;
	unsigned int pin_dir: 1;
	size_t max_xfer_len;
};

struct omap2_mcspi_cs {
	void *base;
	long unsigned int phys;
	int word_len;
	u16 mode;
	struct list_head node;
	u32 chconf0;
	u32 chctrl0;
};

enum orion_spi_type {
	ORION_SPI = 0,
	ARMADA_SPI = 1,
};

struct orion_spi_dev {
	enum orion_spi_type typ;
	long unsigned int max_hz;
	unsigned int min_divisor;
	unsigned int max_divisor;
	u32 prescale_mask;
	bool is_errata_50mhz_ac;
};

struct orion_direct_acc {
	void *vaddr;
	u32 size;
};

struct orion_child_options {
	struct orion_direct_acc direct_access;
};

struct orion_spi {
	struct spi_controller *master;
	void *base;
	struct clk *clk;
	struct clk *axi_clk;
	const struct orion_spi_dev *devdata;
	struct orion_child_options child[8];
};

enum ssp_loopback {
	LOOPBACK_DISABLED = 0,
	LOOPBACK_ENABLED = 1,
};

enum ssp_interface {
	SSP_INTERFACE_MOTOROLA_SPI = 0,
	SSP_INTERFACE_TI_SYNC_SERIAL = 1,
	SSP_INTERFACE_NATIONAL_MICROWIRE = 2,
	SSP_INTERFACE_UNIDIRECTIONAL = 3,
};

enum ssp_hierarchy {
	SSP_MASTER = 0,
	SSP_SLAVE = 1,
};

struct ssp_clock_params {
	u8 cpsdvsr;
	u8 scr;
};

enum ssp_rx_endian {
	SSP_RX_MSB = 0,
	SSP_RX_LSB = 1,
};

enum ssp_tx_endian {
	SSP_TX_MSB = 0,
	SSP_TX_LSB = 1,
};

enum ssp_data_size {
	SSP_DATA_BITS_4 = 3,
	SSP_DATA_BITS_5 = 4,
	SSP_DATA_BITS_6 = 5,
	SSP_DATA_BITS_7 = 6,
	SSP_DATA_BITS_8 = 7,
	SSP_DATA_BITS_9 = 8,
	SSP_DATA_BITS_10 = 9,
	SSP_DATA_BITS_11 = 10,
	SSP_DATA_BITS_12 = 11,
	SSP_DATA_BITS_13 = 12,
	SSP_DATA_BITS_14 = 13,
	SSP_DATA_BITS_15 = 14,
	SSP_DATA_BITS_16 = 15,
	SSP_DATA_BITS_17 = 16,
	SSP_DATA_BITS_18 = 17,
	SSP_DATA_BITS_19 = 18,
	SSP_DATA_BITS_20 = 19,
	SSP_DATA_BITS_21 = 20,
	SSP_DATA_BITS_22 = 21,
	SSP_DATA_BITS_23 = 22,
	SSP_DATA_BITS_24 = 23,
	SSP_DATA_BITS_25 = 24,
	SSP_DATA_BITS_26 = 25,
	SSP_DATA_BITS_27 = 26,
	SSP_DATA_BITS_28 = 27,
	SSP_DATA_BITS_29 = 28,
	SSP_DATA_BITS_30 = 29,
	SSP_DATA_BITS_31 = 30,
	SSP_DATA_BITS_32 = 31,
};

enum ssp_mode {
	INTERRUPT_TRANSFER = 0,
	POLLING_TRANSFER = 1,
	DMA_TRANSFER = 2,
};

enum ssp_rx_level_trig {
	SSP_RX_1_OR_MORE_ELEM = 0,
	SSP_RX_4_OR_MORE_ELEM = 1,
	SSP_RX_8_OR_MORE_ELEM = 2,
	SSP_RX_16_OR_MORE_ELEM = 3,
	SSP_RX_32_OR_MORE_ELEM = 4,
};

enum ssp_tx_level_trig {
	SSP_TX_1_OR_MORE_EMPTY_LOC = 0,
	SSP_TX_4_OR_MORE_EMPTY_LOC = 1,
	SSP_TX_8_OR_MORE_EMPTY_LOC = 2,
	SSP_TX_16_OR_MORE_EMPTY_LOC = 3,
	SSP_TX_32_OR_MORE_EMPTY_LOC = 4,
};

enum ssp_spi_clk_phase {
	SSP_CLK_FIRST_EDGE = 0,
	SSP_CLK_SECOND_EDGE = 1,
};

enum ssp_spi_clk_pol {
	SSP_CLK_POL_IDLE_LOW = 0,
	SSP_CLK_POL_IDLE_HIGH = 1,
};

enum ssp_microwire_ctrl_len {
	SSP_BITS_4 = 3,
	SSP_BITS_5 = 4,
	SSP_BITS_6 = 5,
	SSP_BITS_7 = 6,
	SSP_BITS_8 = 7,
	SSP_BITS_9 = 8,
	SSP_BITS_10 = 9,
	SSP_BITS_11 = 10,
	SSP_BITS_12 = 11,
	SSP_BITS_13 = 12,
	SSP_BITS_14 = 13,
	SSP_BITS_15 = 14,
	SSP_BITS_16 = 15,
	SSP_BITS_17 = 16,
	SSP_BITS_18 = 17,
	SSP_BITS_19 = 18,
	SSP_BITS_20 = 19,
	SSP_BITS_21 = 20,
	SSP_BITS_22 = 21,
	SSP_BITS_23 = 22,
	SSP_BITS_24 = 23,
	SSP_BITS_25 = 24,
	SSP_BITS_26 = 25,
	SSP_BITS_27 = 26,
	SSP_BITS_28 = 27,
	SSP_BITS_29 = 28,
	SSP_BITS_30 = 29,
	SSP_BITS_31 = 30,
	SSP_BITS_32 = 31,
};

enum ssp_microwire_wait_state {
	SSP_MWIRE_WAIT_ZERO = 0,
	SSP_MWIRE_WAIT_ONE = 1,
};

enum ssp_duplex {
	SSP_MICROWIRE_CHANNEL_FULL_DUPLEX = 0,
	SSP_MICROWIRE_CHANNEL_HALF_DUPLEX = 1,
};

enum ssp_clkdelay {
	SSP_FEEDBACK_CLK_DELAY_NONE = 0,
	SSP_FEEDBACK_CLK_DELAY_1T = 1,
	SSP_FEEDBACK_CLK_DELAY_2T = 2,
	SSP_FEEDBACK_CLK_DELAY_3T = 3,
	SSP_FEEDBACK_CLK_DELAY_4T = 4,
	SSP_FEEDBACK_CLK_DELAY_5T = 5,
	SSP_FEEDBACK_CLK_DELAY_6T = 6,
	SSP_FEEDBACK_CLK_DELAY_7T = 7,
};

enum ssp_chip_select {
	SSP_CHIP_SELECT = 0,
	SSP_CHIP_DESELECT = 1,
};

struct pl022_ssp_controller {
	u16 bus_id;
	u8 num_chipselect;
	u8 enable_dma: 1;
	bool (*dma_filter)(struct dma_chan *, void *);
	void *dma_rx_param;
	void *dma_tx_param;
	int autosuspend_delay;
	bool rt;
	int *chipselects;
};

struct pl022_config_chip {
	enum ssp_interface iface;
	enum ssp_hierarchy hierarchy;
	bool slave_tx_disable;
	struct ssp_clock_params clk_freq;
	enum ssp_mode com_mode;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	enum ssp_microwire_ctrl_len ctrl_len;
	enum ssp_microwire_wait_state wait_state;
	enum ssp_duplex duplex;
	enum ssp_clkdelay clkdelay;
	void (*cs_control)(u32);
};

enum ssp_reading {
	READING_NULL = 0,
	READING_U8 = 1,
	READING_U16 = 2,
	READING_U32 = 3,
};

enum ssp_writing {
	WRITING_NULL = 0,
	WRITING_U8 = 1,
	WRITING_U16 = 2,
	WRITING_U32 = 3,
};

struct vendor_data___2 {
	int fifodepth;
	int max_bpw;
	bool unidir;
	bool extended_cr;
	bool pl023;
	bool loopback;
	bool internal_cs_ctrl;
};

struct chip_data;

struct pl022 {
	struct amba_device *adev;
	struct vendor_data___2 *vendor;
	resource_size_t phybase;
	void *virtbase;
	struct clk *clk;
	struct spi_controller *master;
	struct pl022_ssp_controller *master_info;
	struct tasklet_struct pump_transfers;
	struct spi_message *cur_msg;
	struct spi_transfer *cur_transfer;
	struct chip_data *cur_chip;
	bool next_msg_cs_active;
	void *tx;
	void *tx_end;
	void *rx;
	void *rx_end;
	enum ssp_reading read;
	enum ssp_writing write;
	u32 exp_fifo_level;
	enum ssp_rx_level_trig rx_lev_trig;
	enum ssp_tx_level_trig tx_lev_trig;
	struct dma_chan *dma_rx_channel;
	struct dma_chan *dma_tx_channel;
	struct sg_table sgt_rx;
	struct sg_table sgt_tx;
	char *dummypage;
	bool dma_running;
	int cur_cs;
	int *chipselects;
};

struct chip_data {
	u32 cr0;
	u16 cr1;
	u16 dmacr;
	u16 cpsr;
	u8 n_bytes;
	bool enable_dma;
	enum ssp_reading read;
	enum ssp_writing write;
	void (*cs_control)(u32);
	int xfer_type;
};

struct rspi_plat_data {
	unsigned int dma_tx_id;
	unsigned int dma_rx_id;
	u16 num_chipselect;
};

struct spi_ops;

struct rspi_data {
	void *addr;
	u32 speed_hz;
	struct spi_controller *ctlr;
	struct platform_device *pdev;
	wait_queue_head_t wait;
	spinlock_t lock;
	struct clk *clk;
	u16 spcmd;
	u8 spsr;
	u8 sppcr;
	int rx_irq;
	int tx_irq;
	const struct spi_ops *ops;
	unsigned int dma_callbacked: 1;
	unsigned int byte_access: 1;
};

struct spi_ops {
	int (*set_config_register)(struct rspi_data *, int);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	u16 extra_mode_bits;
	u16 min_div;
	u16 max_div;
	u16 flags;
	u16 fifo_size;
	u8 num_hw_ss;
};

struct hspi_priv {
	void *addr;
	struct spi_controller *ctlr;
	struct device *dev;
	struct clk *clk;
};

enum sirf_spi_type {
	SIRF_REAL_SPI = 0,
	SIRF_USP_SPI_P2 = 1,
	SIRF_USP_SPI_A7 = 2,
};

struct sirf_spi_register {
	u32 tx_rx_en;
	u32 int_en;
	u32 int_st;
	u32 tx_dma_io_ctrl;
	u32 tx_dma_io_len;
	u32 txfifo_ctrl;
	u32 txfifo_level_chk;
	u32 txfifo_op;
	u32 txfifo_st;
	u32 txfifo_data;
	u32 rx_dma_io_ctrl;
	u32 rx_dma_io_len;
	u32 rxfifo_ctrl;
	u32 rxfifo_level_chk;
	u32 rxfifo_op;
	u32 rxfifo_st;
	u32 rxfifo_data;
	u32 spi_ctrl;
	u32 spi_cmd;
	u32 spi_dummy_delay_ctrl;
	u32 usp_mode1;
	u32 usp_mode2;
	u32 usp_tx_frame_ctrl;
	u32 usp_rx_frame_ctrl;
	u32 usp_pin_io_data;
	u32 usp_risc_dsp_mode;
	u32 usp_async_param_reg;
	u32 usp_irda_x_mode_div;
	u32 usp_sm_cfg;
	u32 usp_int_en_clr;
};

struct sirfsoc_spi {
	struct spi_bitbang bitbang;
	struct completion rx_done;
	struct completion tx_done;
	void *base;
	u32 ctrl_freq;
	struct clk *clk;
	const void *tx;
	void *rx;
	void (*rx_word)(struct sirfsoc_spi *);
	void (*tx_word)(struct sirfsoc_spi *);
	unsigned int left_tx_word;
	unsigned int left_rx_word;
	struct dma_chan *rx_chan;
	struct dma_chan *tx_chan;
	dma_addr_t src_start;
	dma_addr_t dst_start;
	int word_width;
	bool tx_by_cmd;
	bool hw_cs;
	enum sirf_spi_type type;
	const struct sirf_spi_register *regs;
	unsigned int fifo_size;
	unsigned int fifo_full_offset;
	unsigned int fifo_level_chk_mask;
	unsigned int dat_max_frm_len;
};

struct sirf_spi_comp_data {
	const struct sirf_spi_register *regs;
	enum sirf_spi_type type;
	unsigned int dat_max_frm_len;
	unsigned int fifo_size;
	void (*hwinit)(struct sirfsoc_spi *);
};

struct stm32_qspi;

struct stm32_qspi_flash {
	struct stm32_qspi *qspi;
	u32 cs;
	u32 presc;
};

struct stm32_qspi {
	struct device *dev;
	struct spi_controller *ctrl;
	phys_addr_t phys_base;
	void *io_base;
	void *mm_base;
	resource_size_t mm_size;
	struct clk *clk;
	u32 clk_rate;
	struct stm32_qspi_flash flash[2];
	struct completion data_completion;
	u32 fmode;
	struct dma_chan *dma_chtx;
	struct dma_chan *dma_chrx;
	struct completion dma_completion;
	u32 cr_reg;
	u32 dcr_reg;
	struct mutex lock;
};

struct sun4i_spi {
	struct spi_controller *master;
	void *base_addr;
	struct clk *hclk;
	struct clk *mclk;
	struct completion done;
	const u8 *tx_buf;
	u8 *rx_buf;
	int len;
};

struct sun6i_spi {
	struct spi_controller *master;
	void *base_addr;
	dma_addr_t dma_addr_rx;
	dma_addr_t dma_addr_tx;
	struct clk *hclk;
	struct clk *mclk;
	struct reset_control *rstc;
	struct completion done;
	const u8 *tx_buf;
	u8 *rx_buf;
	int len;
	long unsigned int fifo_depth;
};

struct tegra_spi_soc_data {
	bool has_intr_mask_reg;
};

struct tegra_spi_client_data {
	int tx_clk_tap_delay;
	int rx_clk_tap_delay;
};

struct tegra_spi_data {
	struct device *dev;
	struct spi_controller *master;
	spinlock_t lock;
	struct clk *clk;
	struct reset_control *rst;
	void *base;
	phys_addr_t phys;
	unsigned int irq;
	u32 cur_speed;
	struct spi_device *cur_spi;
	struct spi_device *cs_control;
	unsigned int cur_pos;
	unsigned int words_per_32bit;
	unsigned int bytes_per_word;
	unsigned int curr_dma_words;
	unsigned int cur_direction;
	unsigned int cur_rx_pos;
	unsigned int cur_tx_pos;
	unsigned int dma_buf_size;
	unsigned int max_buf_size;
	bool is_curr_dma_xfer;
	bool use_hw_based_cs;
	struct completion rx_dma_complete;
	struct completion tx_dma_complete;
	u32 tx_status;
	u32 rx_status;
	u32 status_reg;
	bool is_packed;
	u32 command1_reg;
	u32 dma_control_reg;
	u32 def_command1_reg;
	u32 def_command2_reg;
	u32 spi_cs_timing1;
	u32 spi_cs_timing2;
	u8 last_used_cs;
	struct completion xfer_completion;
	struct spi_transfer *curr_xfer;
	struct dma_chan *rx_dma_chan;
	u32 *rx_dma_buf;
	dma_addr_t rx_dma_phys;
	struct dma_async_tx_descriptor *rx_dma_desc;
	struct dma_chan *tx_dma_chan;
	u32 *tx_dma_buf;
	dma_addr_t tx_dma_phys;
	struct dma_async_tx_descriptor *tx_dma_desc;
	const struct tegra_spi_soc_data *soc_data;
};

struct tegra_sflash_data {
	struct device *dev;
	struct spi_controller *master;
	spinlock_t lock;
	struct clk *clk;
	struct reset_control *rst;
	void *base;
	unsigned int irq;
	u32 cur_speed;
	struct spi_device *cur_spi;
	unsigned int cur_pos;
	unsigned int cur_len;
	unsigned int bytes_per_word;
	unsigned int cur_direction;
	unsigned int curr_xfer_words;
	unsigned int cur_rx_pos;
	unsigned int cur_tx_pos;
	u32 tx_status;
	u32 rx_status;
	u32 status_reg;
	u32 def_command_reg;
	u32 command_reg;
	u32 dma_control_reg;
	struct completion xfer_completion;
	struct spi_transfer *curr_xfer;
};

struct tegra_slink_chip_data {
	bool cs_hold_time;
};

struct tegra_slink_data {
	struct device *dev;
	struct spi_controller *master;
	const struct tegra_slink_chip_data *chip_data;
	spinlock_t lock;
	struct clk *clk;
	struct reset_control *rst;
	void *base;
	phys_addr_t phys;
	unsigned int irq;
	u32 cur_speed;
	struct spi_device *cur_spi;
	unsigned int cur_pos;
	unsigned int cur_len;
	unsigned int words_per_32bit;
	unsigned int bytes_per_word;
	unsigned int curr_dma_words;
	unsigned int cur_direction;
	unsigned int cur_rx_pos;
	unsigned int cur_tx_pos;
	unsigned int dma_buf_size;
	unsigned int max_buf_size;
	bool is_curr_dma_xfer;
	struct completion rx_dma_complete;
	struct completion tx_dma_complete;
	u32 tx_status;
	u32 rx_status;
	u32 status_reg;
	bool is_packed;
	u32 packed_size;
	u32 command_reg;
	u32 command2_reg;
	u32 dma_control_reg;
	u32 def_command_reg;
	u32 def_command2_reg;
	struct completion xfer_completion;
	struct spi_transfer *curr_xfer;
	struct dma_chan *rx_dma_chan;
	u32 *rx_dma_buf;
	dma_addr_t rx_dma_phys;
	struct dma_async_tx_descriptor *rx_dma_desc;
	struct dma_chan *tx_dma_chan;
	u32 *tx_dma_buf;
	dma_addr_t tx_dma_phys;
	struct dma_async_tx_descriptor *tx_dma_desc;
};

struct xspi_platform_data {
	u16 num_chipselect;
	u8 bits_per_word;
	struct spi_board_info *devices;
	u8 num_devices;
};

struct xilinx_spi {
	struct spi_bitbang bitbang;
	struct completion done;
	void *regs;
	int irq;
	u8 *rx_ptr;
	const u8 *tx_ptr;
	u8 bytes_per_word;
	int buffer_size;
	u32 cs_inactive;
	unsigned int (*read_fn)(void *);
	void (*write_fn)(u32, void *);
};

struct trace_event_raw_spmi_write_begin {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	u8 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_spmi_write_end {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	int ret;
	char __data[0];
};

struct trace_event_raw_spmi_read_begin {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	char __data[0];
};

struct trace_event_raw_spmi_read_end {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	u16 addr;
	int ret;
	u8 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_spmi_cmd {
	struct trace_entry ent;
	u8 opcode;
	u8 sid;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_spmi_write_begin {
	u32 buf;
};

struct trace_event_data_offsets_spmi_write_end {};

struct trace_event_data_offsets_spmi_read_begin {};

struct trace_event_data_offsets_spmi_read_end {
	u32 buf;
};

struct trace_event_data_offsets_spmi_cmd {};

typedef void (*btf_trace_spmi_write_begin)(void *, u8, u8, u16, u8, const u8 *);

typedef void (*btf_trace_spmi_write_end)(void *, u8, u8, u16, int);

typedef void (*btf_trace_spmi_read_begin)(void *, u8, u8, u16);

typedef void (*btf_trace_spmi_read_end)(void *, u8, u8, u16, int, u8, const u8 *);

typedef void (*btf_trace_spmi_cmd)(void *, u8, u8, int);

enum pmic_arb_chnl_status {
	PMIC_ARB_STATUS_DONE = 1,
	PMIC_ARB_STATUS_FAILURE = 2,
	PMIC_ARB_STATUS_DENIED = 4,
	PMIC_ARB_STATUS_DROPPED = 8,
};

enum pmic_arb_cmd_op_code {
	PMIC_ARB_OP_EXT_WRITEL = 0,
	PMIC_ARB_OP_EXT_READL = 1,
	PMIC_ARB_OP_EXT_WRITE = 2,
	PMIC_ARB_OP_RESET = 3,
	PMIC_ARB_OP_SLEEP = 4,
	PMIC_ARB_OP_SHUTDOWN = 5,
	PMIC_ARB_OP_WAKEUP = 6,
	PMIC_ARB_OP_AUTHENTICATE = 7,
	PMIC_ARB_OP_MSTR_READ = 8,
	PMIC_ARB_OP_MSTR_WRITE = 9,
	PMIC_ARB_OP_EXT_READ = 13,
	PMIC_ARB_OP_WRITE = 14,
	PMIC_ARB_OP_READ = 15,
	PMIC_ARB_OP_ZERO_WRITE = 16,
};

enum pmic_arb_channel {
	PMIC_ARB_CHANNEL_RW = 0,
	PMIC_ARB_CHANNEL_OBS = 1,
};

struct apid_data {
	u16 ppid;
	u8 write_ee;
	u8 irq_ee;
};

struct pmic_arb_ver_ops;

struct spmi_pmic_arb {
	void *rd_base;
	void *wr_base;
	void *intr;
	void *cnfg;
	void *core;
	resource_size_t core_size;
	raw_spinlock_t lock;
	u8 channel;
	int irq;
	u8 ee;
	u16 min_apid;
	u16 max_apid;
	u32 *mapping_table;
	long unsigned int mapping_table_valid[16];
	struct irq_domain *domain;
	struct spmi_controller *spmic;
	const struct pmic_arb_ver_ops *ver_ops;
	u16 *ppid_to_apid;
	u16 last_apid;
	struct apid_data apid_data[512];
};

struct pmic_arb_ver_ops {
	const char *ver_str;
	int (*ppid_to_apid)(struct spmi_pmic_arb *, u16);
	int (*offset)(struct spmi_pmic_arb *, u8, u16, enum pmic_arb_channel);
	u32 (*fmt_cmd)(u8, u8, u16, u8);
	int (*non_data_cmd)(struct spmi_controller *, u8, u8);
	void * (*owner_acc_status)(struct spmi_pmic_arb *, u8, u16);
	void * (*acc_enable)(struct spmi_pmic_arb *, u16);
	void * (*irq_status)(struct spmi_pmic_arb *, u16);
	void * (*irq_clear)(struct spmi_pmic_arb *, u16);
	u32 (*apid_map_offset)(u16);
};

enum qpnpint_regs {
	QPNPINT_REG_RT_STS = 16,
	QPNPINT_REG_SET_TYPE = 17,
	QPNPINT_REG_POLARITY_HIGH = 18,
	QPNPINT_REG_POLARITY_LOW = 19,
	QPNPINT_REG_LATCHED_CLR = 20,
	QPNPINT_REG_EN_SET = 21,
	QPNPINT_REG_EN_CLR = 22,
	QPNPINT_REG_LATCHED_STS = 24,
};

struct spmi_pmic_arb_qpnpint_type {
	u8 type;
	u8 polarity_high;
	u8 polarity_low;
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mii_if_info {
	int phy_id;
	int advertising;
	int phy_id_mask;
	int reg_num_mask;
	unsigned int full_duplex: 1;
	unsigned int force_media: 1;
	unsigned int supports_gmii: 1;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int);
	void (*mdio_write)(struct net_device *, int, int, int);
};

struct devprobe2 {
	struct net_device * (*probe)(int);
	int status;
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETDEV_FEATURE_COUNT = 59,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_DEV_ZEROCOPY = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_SHARED_FRAG = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

struct phylink_link_state {
	long unsigned int advertising[3];
	long unsigned int lp_advertising[3];
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	unsigned int link: 1;
	unsigned int an_enabled: 1;
	unsigned int an_complete: 1;
};

struct phylink_mac_ops;

struct phylink_pcs_ops;

struct phylink_config;

struct phylink_pcs;

struct phylink {
	struct net_device *netdev;
	const struct phylink_mac_ops *mac_ops;
	const struct phylink_pcs_ops *pcs_ops;
	struct phylink_config *config;
	struct phylink_pcs *pcs;
	struct device *dev;
	unsigned int old_link_state: 1;
	long unsigned int phylink_disable_state;
	struct phy_device *phydev;
	phy_interface_t link_interface;
	u8 cfg_link_an_mode;
	u8 cur_link_an_mode;
	u8 link_port;
	long unsigned int supported[3];
	struct phylink_link_state link_config;
	phy_interface_t cur_interface;
	struct gpio_desc *link_gpio;
	unsigned int link_irq;
	struct timer_list link_poll;
	void (*get_fixed_state)(struct net_device *, struct phylink_link_state *);
	struct mutex state_mutex;
	struct phylink_link_state phy_state;
	struct work_struct resolve;
	bool mac_link_dropped;
	struct sfp_bus *sfp_bus;
	bool sfp_may_have_phy;
	long unsigned int sfp_support[3];
	u8 sfp_port;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

enum {
	MLO_PAUSE_NONE = 0,
	MLO_PAUSE_RX = 1,
	MLO_PAUSE_TX = 2,
	MLO_PAUSE_TXRX_MASK = 3,
	MLO_PAUSE_AN = 4,
	MLO_AN_PHY = 0,
	MLO_AN_FIXED = 1,
	MLO_AN_INBAND = 2,
};

enum phylink_op_type {
	PHYLINK_NETDEV = 0,
	PHYLINK_DEV = 1,
};

struct phylink_config {
	struct device *dev;
	enum phylink_op_type type;
	bool pcs_poll;
	bool poll_fixed_state;
	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
};

struct phylink_mac_ops {
	void (*validate)(struct phylink_config *, long unsigned int *, struct phylink_link_state *);
	void (*mac_pcs_get_state)(struct phylink_config *, struct phylink_link_state *);
	int (*mac_prepare)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_config)(struct phylink_config *, unsigned int, const struct phylink_link_state *);
	int (*mac_finish)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_an_restart)(struct phylink_config *);
	void (*mac_link_down)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_link_up)(struct phylink_config *, struct phy_device *, unsigned int, phy_interface_t, int, int, bool, bool);
};

struct phylink_pcs {
	const struct phylink_pcs_ops *ops;
	bool poll;
};

struct phylink_pcs_ops {
	void (*pcs_get_state)(struct phylink_pcs *, struct phylink_link_state *);
	int (*pcs_config)(struct phylink_pcs *, unsigned int, phy_interface_t, const long unsigned int *, bool);
	void (*pcs_an_restart)(struct phylink_pcs *);
	void (*pcs_link_up)(struct phylink_pcs *, unsigned int, phy_interface_t, int, int);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

enum {
	PHYLINK_DISABLE_STOPPED = 0,
	PHYLINK_DISABLE_LINK = 1,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	__ETHTOOL_MSG_KERNEL_CNT = 30,
	ETHTOOL_MSG_KERNEL_MAX = 29,
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct mdio_device_id {
	__u32 phy_id;
	__u32 phy_id_mask;
};

enum {
	ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_CODE_OK = 1,
	ETHTOOL_A_CABLE_RESULT_CODE_OPEN = 2,
	ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT = 3,
	ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT = 4,
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

struct at803x_priv {
	int flags;
	u16 clk_25m_reg;
	u16 clk_25m_mask;
	struct regulator_dev *vddio_rdev;
	struct regulator_dev *vddh_rdev;
	struct regulator *vddio;
};

struct at803x_context {
	u16 bmcr;
	u16 advertise;
	u16 control1000;
	u16 int_enable;
	u16 smart_speed;
	u16 led_control;
};

struct bcm_phy_hw_stat {
	const char *string;
	u8 reg;
	u8 shift;
	u8 bits;
};

struct bcm53xx_phy_priv {
	u64 *stats;
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

enum ip101gr_sel_intr32 {
	IP101GR_SEL_INTR32_KEEP = 0,
	IP101GR_SEL_INTR32_INTR = 1,
	IP101GR_SEL_INTR32_RXER = 2,
};

struct ip101a_g_phy_priv {
	enum ip101gr_sel_intr32 sel_intr32;
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct marvell_hw_stat {
	const char *string;
	u8 page;
	u8 reg;
	u8 bits;
};

struct marvell_priv {
	u64 stats[3];
	char *hwmon_name;
	struct device *hwmon_dev;
	bool cable_test_tdr;
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
	int: 24;
	int: 32;
};

struct kszphy_hw_stat {
	const char *string;
	u8 reg;
	u8 bits;
};

struct kszphy_type {
	u32 led_mode_reg;
	u16 interrupt_level_mask;
	bool has_broadcast_disable;
	bool has_nand_tree_disable;
	bool has_rmii_ref_clk_sel;
};

struct kszphy_priv {
	const struct kszphy_type *type;
	int led_mode;
	bool rmii_ref_clk_sel;
	bool rmii_ref_clk_sel_val;
	int: 16;
	int: 32;
	u64 stats[2];
};

struct smsc_hw_stat {
	const char *string;
	u8 reg;
	u8 bits;
};

struct smsc_phy_priv {
	bool energy_enable;
	struct clk *refclk;
};

struct iproc_mdio_priv {
	struct mii_bus *mii_bus;
	void *base;
};

struct mdiobb_ctrl;

struct mdiobb_ops {
	struct module *owner;
	void (*set_mdc)(struct mdiobb_ctrl *, int);
	void (*set_mdio_dir)(struct mdiobb_ctrl *, int);
	void (*set_mdio_data)(struct mdiobb_ctrl *, int);
	int (*get_mdio_data)(struct mdiobb_ctrl *);
};

struct mdiobb_ctrl {
	const struct mdiobb_ops *ops;
};

struct sun4i_mdio_data {
	void *membase;
	struct regulator *regulator;
};

struct mdio_mux_child_bus;

struct mdio_mux_parent_bus {
	struct mii_bus *mii_bus;
	int current_child;
	int parent_id;
	void *switch_data;
	int (*switch_fn)(int, int, void *);
	struct mdio_mux_child_bus *children;
};

struct mdio_mux_child_bus {
	struct mii_bus *mii_bus;
	struct mdio_mux_parent_bus *parent;
	struct mdio_mux_child_bus *next;
	int bus_number;
};

struct iproc_mdiomux_desc {
	void *mux_handle;
	void *base;
	struct device *dev;
	struct mii_bus *mii_bus;
	struct clk *core_clk;
};

struct mdio_xpcs_args {
	long unsigned int supported[3];
	struct mii_bus *bus;
	int addr;
};

struct mdio_xpcs_ops {
	int (*validate)(struct mdio_xpcs_args *, long unsigned int *, struct phylink_link_state *);
	int (*config)(struct mdio_xpcs_args *, const struct phylink_link_state *);
	int (*get_state)(struct mdio_xpcs_args *, struct phylink_link_state *);
	int (*link_up)(struct mdio_xpcs_args *, int, phy_interface_t);
	int (*probe)(struct mdio_xpcs_args *, phy_interface_t);
};

struct xpcs_id {
	u32 id;
	u32 mask;
	const int *supported;
	const phy_interface_t *interface;
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[28];
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info {
	void (*callback)(struct ubuf_info *, bool);
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	refcount_t refcnt;
	struct mmpin mmp;
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

struct netdev_hw_addr {
	struct list_head list;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	int defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
	int: 32;
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct {
		u16 recursion;
		u8 more;
	} xmit;
	int: 32;
	unsigned int input_queue_head;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_COUNT = 16,
};

struct virtio_net_config {
	__u8 mac[6];
	__virtio16 status;
	__virtio16 max_virtqueue_pairs;
	__virtio16 mtu;
	__le32 speed;
	__u8 duplex;
	__u8 rss_max_key_size;
	__le16 rss_max_indirection_table_length;
	__le32 supported_hash_types;
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

typedef __u8 virtio_net_ctrl_ack;

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct failover {
	struct list_head list;
	struct net_device *failover_dev;
	struct failover_ops *ops;
};

struct ewma_pkt_len {
	long unsigned int internal;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	int: 32;
	u64 packets;
	u64 bytes;
	u64 xdp_tx;
	u64 xdp_tx_drops;
	u64 kicks;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	int: 32;
	u64 packets;
	u64 bytes;
	u64 drops;
	u64 xdp_packets;
	u64 xdp_tx;
	u64 xdp_redirects;
	u64 xdp_drops;
	u64 kicks;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[40];
	struct virtnet_sq_stats stats;
	struct napi_struct napi;
};

struct receive_queue {
	struct virtqueue *vq;
	int: 32;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	int: 32;
	struct virtnet_rq_stats stats;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[40];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xdp_rxq_info xdp_rxq;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
	struct virtio_net_ctrl_mq mq;
	u8 promisc;
	u8 allmulti;
	__virtio16 vid;
	int: 16;
	int: 32;
	__virtio64 offloads;
};

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool big_packets;
	bool mergeable_rx_bufs;
	bool has_cvq;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	struct work_struct config_work;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	long unsigned int guest_offloads;
	long unsigned int guest_offloads_capable;
	struct failover *failover;
};

struct emac_board_info {
	struct clk *clk;
	struct device *dev;
	struct platform_device *pdev;
	spinlock_t lock;
	void *membase;
	u32 msg_enable;
	struct net_device *ndev;
	struct sk_buff *skb_last;
	u16 tx_fifo_stat;
	int emacrx_completed_flag;
	struct device_node *phy_node;
	unsigned int link;
	unsigned int speed;
	unsigned int duplex;
	phy_interface_t phy_interface;
};

typedef __u16 __sum16;

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	__be32 saddr;
	__be32 daddr;
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_LAST = 16384,
	SOF_TIMESTAMPING_MASK = 32767,
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	int: 32;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_clock_info {
	struct module *owner;
	char name[16];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjfreq)(struct ptp_clock_info *, s32);
	int (*adjphase)(struct ptp_clock_info *, s32);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct macb_dma_desc {
	u32 addr;
	u32 ctrl;
};

struct macb_dma_desc_ptp {
	u32 ts_1;
	u32 ts_2;
};

struct gem_tx_ts {
	struct sk_buff *skb;
	struct macb_dma_desc_ptp desc_ptp;
};

struct macb_tx_skb {
	struct sk_buff *skb;
	dma_addr_t mapping;
	size_t size;
	bool mapped_as_page;
};

struct macb_stats {
	u32 rx_pause_frames;
	u32 tx_ok;
	u32 tx_single_cols;
	u32 tx_multiple_cols;
	u32 rx_ok;
	u32 rx_fcs_errors;
	u32 rx_align_errors;
	u32 tx_deferred;
	u32 tx_late_cols;
	u32 tx_excessive_cols;
	u32 tx_underruns;
	u32 tx_carrier_errors;
	u32 rx_resource_errors;
	u32 rx_overruns;
	u32 rx_symbol_errors;
	u32 rx_oversize_pkts;
	u32 rx_jabbers;
	u32 rx_undersize_pkts;
	u32 sqe_test_errors;
	u32 rx_length_mismatch;
	u32 tx_pause_frames;
};

struct gem_stats {
	u32 tx_octets_31_0;
	u32 tx_octets_47_32;
	u32 tx_frames;
	u32 tx_broadcast_frames;
	u32 tx_multicast_frames;
	u32 tx_pause_frames;
	u32 tx_64_byte_frames;
	u32 tx_65_127_byte_frames;
	u32 tx_128_255_byte_frames;
	u32 tx_256_511_byte_frames;
	u32 tx_512_1023_byte_frames;
	u32 tx_1024_1518_byte_frames;
	u32 tx_greater_than_1518_byte_frames;
	u32 tx_underrun;
	u32 tx_single_collision_frames;
	u32 tx_multiple_collision_frames;
	u32 tx_excessive_collisions;
	u32 tx_late_collisions;
	u32 tx_deferred_frames;
	u32 tx_carrier_sense_errors;
	u32 rx_octets_31_0;
	u32 rx_octets_47_32;
	u32 rx_frames;
	u32 rx_broadcast_frames;
	u32 rx_multicast_frames;
	u32 rx_pause_frames;
	u32 rx_64_byte_frames;
	u32 rx_65_127_byte_frames;
	u32 rx_128_255_byte_frames;
	u32 rx_256_511_byte_frames;
	u32 rx_512_1023_byte_frames;
	u32 rx_1024_1518_byte_frames;
	u32 rx_greater_than_1518_byte_frames;
	u32 rx_undersized_frames;
	u32 rx_oversize_frames;
	u32 rx_jabbers;
	u32 rx_frame_check_sequence_errors;
	u32 rx_length_field_frame_errors;
	u32 rx_symbol_errors;
	u32 rx_alignment_errors;
	u32 rx_resource_errors;
	u32 rx_overruns;
	u32 rx_ip_header_checksum_errors;
	u32 rx_tcp_checksum_errors;
	u32 rx_udp_checksum_errors;
};

struct gem_statistic {
	char stat_string[32];
	int offset;
	u32 stat_bits;
};

struct queue_stats {
	union {
		long unsigned int first;
		long unsigned int rx_packets;
	};
	long unsigned int rx_bytes;
	long unsigned int rx_dropped;
	long unsigned int tx_packets;
	long unsigned int tx_bytes;
	long unsigned int tx_dropped;
};

struct macb;

struct macb_queue;

struct macb_or_gem_ops {
	int (*mog_alloc_rx_buffers)(struct macb *);
	void (*mog_free_rx_buffers)(struct macb *);
	void (*mog_init_rings)(struct macb *);
	int (*mog_rx)(struct macb_queue *, struct napi_struct *, int);
};

struct macb_queue {
	struct macb *bp;
	int irq;
	unsigned int ISR;
	unsigned int IER;
	unsigned int IDR;
	unsigned int IMR;
	unsigned int TBQP;
	unsigned int TBQPH;
	unsigned int RBQS;
	unsigned int RBQP;
	unsigned int RBQPH;
	unsigned int tx_head;
	unsigned int tx_tail;
	struct macb_dma_desc *tx_ring;
	struct macb_tx_skb *tx_skb;
	dma_addr_t tx_ring_dma;
	struct work_struct tx_error_task;
	dma_addr_t rx_ring_dma;
	dma_addr_t rx_buffers_dma;
	unsigned int rx_tail;
	unsigned int rx_prepared_head;
	struct macb_dma_desc *rx_ring;
	struct sk_buff **rx_skbuff;
	void *rx_buffers;
	int: 32;
	struct napi_struct napi;
	struct queue_stats stats;
	struct work_struct tx_ts_task;
	unsigned int tx_ts_head;
	unsigned int tx_ts_tail;
	struct gem_tx_ts tx_timestamps[128];
};

struct ptp_clock;

struct tsu_incr {
	u32 sub_ns;
	u32 ns;
};

struct ethtool_rx_fs_list {
	struct list_head list;
	unsigned int count;
};

struct macb_pm_data {
	u32 scrt2;
	u32 usrio;
};

struct macb_ptp_info;

struct macb_usrio_config;

struct macb {
	void *regs;
	bool native_io;
	u32 (*macb_reg_readl)(struct macb *, int);
	void (*macb_reg_writel)(struct macb *, int, u32);
	size_t rx_buffer_size;
	unsigned int rx_ring_size;
	unsigned int tx_ring_size;
	unsigned int num_queues;
	unsigned int queue_mask;
	int: 32;
	struct macb_queue queues[8];
	spinlock_t lock;
	struct platform_device *pdev;
	struct clk *pclk;
	struct clk *hclk;
	struct clk *tx_clk;
	struct clk *rx_clk;
	struct clk *tsu_clk;
	struct net_device *dev;
	union {
		struct macb_stats macb;
		struct gem_stats gem;
	} hw_stats;
	struct macb_or_gem_ops macbgem_ops;
	struct mii_bus *mii_bus;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	struct phylink_pcs phylink_pcs;
	u32 caps;
	unsigned int dma_burst_length;
	phy_interface_t phy_interface;
	struct macb_tx_skb rm9200_txq[2];
	unsigned int max_tx_length;
	int: 32;
	u64 ethtool_stats[91];
	unsigned int rx_frm_len_mask;
	unsigned int jumbo_max_len;
	u32 wol;
	struct macb_ptp_info *ptp_info;
	uint8_t hw_dma_cap;
	spinlock_t tsu_clk_lock;
	unsigned int tsu_rate;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct tsu_incr tsu_incr;
	struct hwtstamp_config tstamp_config;
	struct ethtool_rx_fs_list rx_fs_list;
	spinlock_t rx_fs_lock;
	unsigned int max_tuples;
	struct tasklet_struct hresp_err_tasklet;
	int rx_bd_rd_prefetch;
	int tx_bd_rd_prefetch;
	u32 rx_intr_mask;
	struct macb_pm_data pm_data;
	const struct macb_usrio_config *usrio;
	int: 32;
};

struct macb_ptp_info {
	void (*ptp_init)(struct net_device *);
	void (*ptp_remove)(struct net_device *);
	s32 (*get_ptp_max_adj)();
	unsigned int (*get_tsu_rate)(struct macb *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_hwtst)(struct net_device *, struct ifreq *);
	int (*set_hwtst)(struct net_device *, struct ifreq *, int);
};

struct macb_usrio_config {
	u32 mii;
	u32 rmii;
	u32 rgmii;
	u32 refclk;
	u32 hdfctlen;
};

struct macb_config {
	u32 caps;
	unsigned int dma_burst_length;
	int (*clk_init)(struct platform_device *, struct clk **, struct clk **, struct clk **, struct clk **, struct clk **);
	int (*init)(struct platform_device *);
	int jumbo_max_len;
	const struct macb_usrio_config *usrio;
};

struct ethtool_rx_fs_item {
	struct ethtool_rx_flow_spec fs;
	struct list_head list;
};

enum macb_bd_control {
	TSTAMP_DISABLED = 0,
	TSTAMP_FRAME_PTP_EVENT_ONLY = 1,
	TSTAMP_ALL_PTP_FRAMES = 2,
	TSTAMP_ALL_FRAMES = 3,
};

struct macb_platform_data {
	struct clk *pclk;
	struct clk *hclk;
};

struct sifive_fu540_macb_mgmt {
	void *reg;
	long unsigned int rate;
	struct clk_hw hw;
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
	};
};

struct devlink;

struct devlink_port {
	struct list_head list;
	struct list_head param_list;
	struct list_head region_list;
	struct devlink *devlink;
	unsigned int index;
	bool registered;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct mutex reporters_lock;
};

struct dsa_device_ops;

struct dsa_switch_tree;

struct packet_type;

struct dsa_switch;

struct dsa_netdevice_ops;

struct dsa_port {
	union {
		struct net_device *master;
		struct net_device *slave;
	};
	const struct dsa_device_ops *tag_ops;
	struct dsa_switch_tree *dst;
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *);
	bool (*filter)(const struct sk_buff *, struct net_device *);
	enum {
		DSA_PORT_TYPE_UNUSED = 0,
		DSA_PORT_TYPE_CPU = 1,
		DSA_PORT_TYPE_DSA = 2,
		DSA_PORT_TYPE_USER = 3,
	} type;
	struct dsa_switch *ds;
	unsigned int index;
	const char *name;
	struct dsa_port *cpu_dp;
	const char *mac;
	struct device_node *dn;
	unsigned int ageing_time;
	bool vlan_filtering;
	u8 stp_state;
	struct net_device *bridge_dev;
	struct devlink_port devlink_port;
	bool devlink_port_setup;
	struct phylink *pl;
	struct phylink_config pl_config;
	struct list_head list;
	void *priv;
	const struct ethtool_ops *orig_ethtool_ops;
	const struct dsa_netdevice_ops *netdev_ops;
	bool setup;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	void *af_packet_priv;
	struct list_head list;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_WAKE = 19,
	FLOW_ACTION_QUEUE = 20,
	FLOW_ACTION_SAMPLE = 21,
	FLOW_ACTION_POLICE = 22,
	FLOW_ACTION_CT = 23,
	FLOW_ACTION_CT_METADATA = 24,
	FLOW_ACTION_MPLS_PUSH = 25,
	FLOW_ACTION_MPLS_POP = 26,
	FLOW_ACTION_MPLS_MANGLE = 27,
	FLOW_ACTION_GATE = 28,
	NUM_FLOW_ACTIONS = 29,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

typedef void (*action_destr)(void *);

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

struct psample_group;

struct nf_flowtable;

struct action_gate_entry;

struct ip_tunnel_info;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 index;
			u32 burst;
			u64 rate_bytes_ps;
			u32 mtu;
			int: 32;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			u32 index;
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
	};
	struct flow_action_cookie *cookie;
	int: 32;
};

struct flow_action {
	unsigned int num_entries;
	int: 32;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	int: 32;
	struct flow_action action;
};

struct dsa_chip_data {
	struct device *host_dev;
	int sw_addr;
	struct device *netdev[12];
	int eeprom_len;
	struct device_node *of_node;
	char *port_names[12];
	struct device_node *port_dn[12];
	s8 rtable[4];
};

struct dsa_platform_data {
	struct device *netdev;
	struct net_device *of_netdev;
	int nr_chips;
	struct dsa_chip_data *chip;
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	int: 32;
	struct flow_stats stats;
	u32 classid;
	int: 32;
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	struct list_head list;
	struct list_head port_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	const struct devlink_ops *ops;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	u8 reload_failed: 1;
	u8 reload_enabled: 1;
	u8 registered: 1;
	int: 29;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_sb_pool_info;

struct devlink_info_req;

struct devlink_flash_update_params;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_trap_policer;

struct devlink_ops {
	u32 supported_flash_update_params;
	long unsigned int reload_actions;
	long unsigned int reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, unsigned int, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_function_hw_addr_get)(struct devlink *, struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_function_hw_addr_set)(struct devlink *, struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct devlink_flash_update_params {
	const struct firmware *fw;
	const char *component;
	u32 overwrite_mask;
};

struct devlink_trap_policer {
	u32 id;
	int: 32;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

struct switchdev_trans {
	bool ph_prepare;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
};

struct switchdev_obj {
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_vlan {
	struct switchdev_obj obj;
	u16 flags;
	u16 vid_begin;
	u16 vid_end;
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

enum dsa_tag_protocol {
	DSA_TAG_PROTO_NONE = 0,
	DSA_TAG_PROTO_BRCM = 1,
	DSA_TAG_PROTO_BRCM_PREPEND = 2,
	DSA_TAG_PROTO_DSA = 3,
	DSA_TAG_PROTO_EDSA = 4,
	DSA_TAG_PROTO_GSWIP = 5,
	DSA_TAG_PROTO_KSZ9477 = 6,
	DSA_TAG_PROTO_KSZ9893 = 7,
	DSA_TAG_PROTO_LAN9303 = 8,
	DSA_TAG_PROTO_MTK = 9,
	DSA_TAG_PROTO_QCA = 10,
	DSA_TAG_PROTO_TRAILER = 11,
	DSA_TAG_PROTO_8021Q = 12,
	DSA_TAG_PROTO_SJA1105 = 13,
	DSA_TAG_PROTO_KSZ8795 = 14,
	DSA_TAG_PROTO_OCELOT = 15,
	DSA_TAG_PROTO_AR9331 = 16,
	DSA_TAG_PROTO_RTL4_A = 17,
	DSA_TAG_PROTO_HELLCREEK = 18,
};

struct dsa_device_ops {
	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *, struct packet_type *);
	void (*flow_dissect)(const struct sk_buff *, __be16 *, int *);
	bool (*filter)(const struct sk_buff *, struct net_device *);
	unsigned int overhead;
	const char *name;
	enum dsa_tag_protocol proto;
	bool promisc_on_master;
	bool tail_tag;
};

struct dsa_netdevice_ops {
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
};

struct dsa_switch_tree {
	struct list_head list;
	struct raw_notifier_head nh;
	unsigned int index;
	struct kref refcount;
	bool setup;
	struct dsa_platform_data *pd;
	struct list_head ports;
	struct list_head rtable;
};

struct dsa_mall_mirror_tc_entry {
	u8 to_local_port;
	bool ingress;
};

struct dsa_mall_policer_tc_entry {
	u32 burst;
	int: 32;
	u64 rate_bytes_per_sec;
};

struct dsa_switch_ops;

struct dsa_switch {
	bool setup;
	struct device *dev;
	struct dsa_switch_tree *dst;
	unsigned int index;
	struct notifier_block nb;
	void *priv;
	struct dsa_chip_data *cd;
	const struct dsa_switch_ops *ops;
	u32 phys_mii_mask;
	struct mii_bus *slave_mii_bus;
	unsigned int ageing_time_min;
	unsigned int ageing_time_max;
	struct devlink *devlink;
	unsigned int num_tx_queues;
	bool vlan_filtering_is_global;
	bool configure_vlan_while_not_filtering;
	bool untag_bridge_pvid;
	bool vlan_filtering;
	bool pcs_poll;
	bool mtu_enforcement_ingress;
	size_t num_ports;
};

typedef int dsa_fdb_dump_cb_t(const unsigned char *, u16, bool, void *);

struct dsa_switch_ops {
	enum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*setup)(struct dsa_switch *);
	void (*teardown)(struct dsa_switch *);
	u32 (*get_phy_flags)(struct dsa_switch *, int);
	int (*phy_read)(struct dsa_switch *, int, int);
	int (*phy_write)(struct dsa_switch *, int, int, u16);
	void (*adjust_link)(struct dsa_switch *, int, struct phy_device *);
	void (*fixed_link_update)(struct dsa_switch *, int, struct fixed_phy_status *);
	void (*phylink_validate)(struct dsa_switch *, int, long unsigned int *, struct phylink_link_state *);
	int (*phylink_mac_link_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*phylink_mac_config)(struct dsa_switch *, int, unsigned int, const struct phylink_link_state *);
	void (*phylink_mac_an_restart)(struct dsa_switch *, int);
	void (*phylink_mac_link_down)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_link_up)(struct dsa_switch *, int, unsigned int, phy_interface_t, struct phy_device *, int, int, bool, bool);
	void (*phylink_fixed_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*get_strings)(struct dsa_switch *, int, u32, uint8_t *);
	void (*get_ethtool_stats)(struct dsa_switch *, int, uint64_t *);
	int (*get_sset_count)(struct dsa_switch *, int, int);
	void (*get_ethtool_phy_stats)(struct dsa_switch *, int, uint64_t *);
	void (*get_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*set_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*get_ts_info)(struct dsa_switch *, int, struct ethtool_ts_info *);
	int (*suspend)(struct dsa_switch *);
	int (*resume)(struct dsa_switch *);
	int (*port_enable)(struct dsa_switch *, int, struct phy_device *);
	void (*port_disable)(struct dsa_switch *, int);
	int (*set_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_eeprom_len)(struct dsa_switch *);
	int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*get_regs_len)(struct dsa_switch *, int);
	void (*get_regs)(struct dsa_switch *, int, struct ethtool_regs *, void *);
	int (*port_prechangeupper)(struct dsa_switch *, int, struct netdev_notifier_changeupper_info *);
	int (*set_ageing_time)(struct dsa_switch *, unsigned int);
	int (*port_bridge_join)(struct dsa_switch *, int, struct net_device *);
	void (*port_bridge_leave)(struct dsa_switch *, int, struct net_device *);
	void (*port_stp_state_set)(struct dsa_switch *, int, u8);
	void (*port_fast_age)(struct dsa_switch *, int);
	int (*port_egress_floods)(struct dsa_switch *, int, bool, bool);
	int (*port_vlan_filtering)(struct dsa_switch *, int, bool, struct switchdev_trans *);
	int (*port_vlan_prepare)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	void (*port_vlan_add)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	int (*port_vlan_del)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	int (*port_fdb_add)(struct dsa_switch *, int, const unsigned char *, u16);
	int (*port_fdb_del)(struct dsa_switch *, int, const unsigned char *, u16);
	int (*port_fdb_dump)(struct dsa_switch *, int, dsa_fdb_dump_cb_t *, void *);
	int (*port_mdb_prepare)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	void (*port_mdb_add)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	int (*port_mdb_del)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *);
	int (*get_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *);
	int (*cls_flower_add)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_del)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_stats)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*port_mirror_add)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *, bool);
	void (*port_mirror_del)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *);
	int (*port_policer_add)(struct dsa_switch *, int, struct dsa_mall_policer_tc_entry *);
	void (*port_policer_del)(struct dsa_switch *, int);
	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
	int (*crosschip_bridge_join)(struct dsa_switch *, int, int, int, struct net_device *);
	void (*crosschip_bridge_leave)(struct dsa_switch *, int, int, int, struct net_device *);
	int (*port_hwtstamp_get)(struct dsa_switch *, int, struct ifreq *);
	int (*port_hwtstamp_set)(struct dsa_switch *, int, struct ifreq *);
	bool (*port_txtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
	bool (*port_rxtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
	int (*devlink_param_get)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_param_set)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_info_get)(struct dsa_switch *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*port_change_mtu)(struct dsa_switch *, int, int);
	int (*port_max_mtu)(struct dsa_switch *, int);
};

struct bgmac_slot_info {
	union {
		struct sk_buff *skb;
		void *buf;
	};
	dma_addr_t dma_addr;
};

struct bgmac_dma_desc {
	__le32 ctl0;
	__le32 ctl1;
	__le32 addr_low;
	__le32 addr_high;
};

enum bgmac_dma_ring_type {
	BGMAC_DMA_RING_TX = 0,
	BGMAC_DMA_RING_RX = 1,
};

struct bgmac_dma_ring {
	u32 start;
	u32 end;
	struct bgmac_dma_desc *cpu_base;
	dma_addr_t dma_base;
	u32 index_base;
	u16 mmio_base;
	bool unaligned;
	struct bgmac_slot_info slots[512];
};

struct bgmac_rx_header {
	__le16 len;
	__le16 flags;
	__le16 pad[12];
};

struct bgmac {
	union {
		struct {
			void *base;
			void *idm_base;
			void *nicpm_base;
		} plat;
		struct {
			struct bcma_device *core;
			struct bcma_device *cmn;
		} bcma;
	};
	struct device *dev;
	struct device *dma_dev;
	u32 feature_flags;
	struct net_device *net_dev;
	int: 32;
	struct napi_struct napi;
	struct mii_bus *mii_bus;
	struct bgmac_dma_ring tx_ring[4];
	struct bgmac_dma_ring rx_ring[1];
	bool stats_grabbed;
	u32 mib_tx_regs[43];
	u32 mib_rx_regs[31];
	int irq;
	u32 int_mask;
	int mac_speed;
	int mac_duplex;
	u8 phyaddr;
	bool has_robosw;
	bool loopback;
	u32 (*read)(struct bgmac *, u16);
	void (*write)(struct bgmac *, u16, u32);
	u32 (*idm_read)(struct bgmac *, u16);
	void (*idm_write)(struct bgmac *, u16, u32);
	bool (*clk_enabled)(struct bgmac *);
	void (*clk_enable)(struct bgmac *, u32);
	void (*cco_ctl_maskset)(struct bgmac *, u32, u32, u32);
	u32 (*get_bus_clock)(struct bgmac *);
	void (*cmn_maskset32)(struct bgmac *, u16, u32, u32);
	int (*phy_connect)(struct bgmac *);
	int: 32;
};

struct bgmac_stat {
	u8 size;
	u32 offset;
	const char *name;
};

struct xgmac_dma_desc {
	__le32 flags;
	__le32 buf_size;
	__le32 buf1_addr;
	__le32 buf2_addr;
	__le32 ext_status;
	__le32 res[3];
};

struct xgmac_extra_stats {
	long unsigned int tx_jabber;
	long unsigned int tx_frame_flushed;
	long unsigned int tx_payload_error;
	long unsigned int tx_ip_header_error;
	long unsigned int tx_local_fault;
	long unsigned int tx_remote_fault;
	long unsigned int rx_watchdog;
	long unsigned int rx_da_filter_fail;
	long unsigned int rx_payload_error;
	long unsigned int rx_ip_header_error;
	long unsigned int tx_process_stopped;
	long unsigned int rx_buf_unav;
	long unsigned int rx_process_stopped;
	long unsigned int tx_early;
	long unsigned int fatal_bus_error;
};

struct xgmac_priv {
	struct xgmac_dma_desc *dma_rx;
	struct sk_buff **rx_skbuff;
	unsigned int rx_tail;
	unsigned int rx_head;
	struct xgmac_dma_desc *dma_tx;
	struct sk_buff **tx_skbuff;
	unsigned int tx_head;
	unsigned int tx_tail;
	int tx_irq_cnt;
	void *base;
	unsigned int dma_buf_sz;
	dma_addr_t dma_rx_phy;
	dma_addr_t dma_tx_phy;
	struct net_device *dev;
	struct device *device;
	int: 32;
	struct napi_struct napi;
	int max_macs;
	struct xgmac_extra_stats xstats;
	spinlock_t stats_lock;
	int pmt_irq;
	char rx_pause;
	char tx_pause;
	int wolopts;
	struct work_struct tx_timeout_work;
};

struct xgmac_stats {
	char stat_string[32];
	int stat_offset;
	bool is_reg;
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	__ETHTOOL_TUNABLE_COUNT = 4,
};

struct fec_platform_data {
	phy_interface_t phy;
	unsigned char mac[6];
	void (*sleep_mode_enable)(int);
};

struct bufdesc {
	__le16 cbd_datlen;
	__le16 cbd_sc;
	__le32 cbd_bufaddr;
};

struct bufdesc_ex {
	struct bufdesc desc;
	__le32 cbd_esc;
	__le32 cbd_prot;
	__le32 cbd_bdu;
	__le32 ts;
	__le16 res0[4];
};

struct bufdesc_prop {
	int qid;
	struct bufdesc *base;
	struct bufdesc *last;
	struct bufdesc *cur;
	void *reg_desc_active;
	dma_addr_t dma;
	short unsigned int ring_size;
	unsigned char dsize;
	unsigned char dsize_log2;
};

struct fec_enet_priv_tx_q {
	struct bufdesc_prop bd;
	unsigned char *tx_bounce[512];
	struct sk_buff *tx_skbuff[512];
	short unsigned int tx_stop_threshold;
	short unsigned int tx_wake_threshold;
	struct bufdesc *dirty_tx;
	char *tso_hdrs;
	dma_addr_t tso_hdrs_dma;
};

struct fec_enet_priv_rx_q {
	struct bufdesc_prop bd;
	struct sk_buff *rx_skbuff[512];
};

struct fec_stop_mode_gpr {
	struct regmap *gpr;
	u8 reg;
	u8 bit;
};

struct fec_enet_private {
	void *hwp;
	struct net_device *netdev;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_ref;
	struct clk *clk_enet_out;
	struct clk *clk_ptp;
	bool ptp_clk_on;
	struct mutex ptp_clk_mutex;
	unsigned int num_tx_queues;
	unsigned int num_rx_queues;
	struct fec_enet_priv_tx_q *tx_queue[3];
	struct fec_enet_priv_rx_q *rx_queue[3];
	unsigned int total_tx_ring_size;
	unsigned int total_rx_ring_size;
	struct platform_device *pdev;
	int dev_id;
	struct mii_bus *mii_bus;
	uint phy_speed;
	phy_interface_t phy_interface;
	struct device_node *phy_node;
	int link;
	int full_duplex;
	int speed;
	int irq[3];
	bool bufdesc_ex;
	int pause_flag;
	int wol_flag;
	u32 quirks;
	int: 32;
	struct napi_struct napi;
	int csum_flags;
	struct work_struct tx_timeout_work;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	long unsigned int last_overflow_check;
	spinlock_t tmreg_lock;
	int: 32;
	struct cyclecounter cc;
	struct timecounter tc;
	int rx_hwtstamp_filter;
	u32 base_incval;
	u32 cycle_speed;
	int hwts_rx_en;
	int hwts_tx_en;
	struct delayed_work time_keep;
	struct regulator *reg_phy;
	struct fec_stop_mode_gpr stop_gpr;
	unsigned int tx_align;
	unsigned int rx_align;
	unsigned int rx_pkts_itr;
	unsigned int rx_time_itr;
	unsigned int tx_pkts_itr;
	unsigned int tx_time_itr;
	unsigned int itr_clk_rate;
	u32 rx_copybreak;
	unsigned int ptp_inc;
	int pps_channel;
	unsigned int reload_period;
	int pps_enable;
	unsigned int next_counter;
	u64 ethtool_stats[0];
};

struct fec_devinfo {
	u32 quirks;
};

enum imx_fec_type {
	IMX25_FEC = 1,
	IMX27_FEC = 2,
	IMX28_FEC = 3,
	IMX6Q_FEC = 4,
	MVF600_FEC = 5,
	IMX6SX_FEC = 6,
	IMX6UL_FEC = 7,
};

struct fec_stat {
	char name[32];
	u16 offset;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_PPS = 2,
	PTP_CLOCK_PPSUSR = 3,
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		struct pps_event_time pps_times;
	};
};

struct rmon_mib {
	u32 tr64;
	u32 tr127;
	u32 tr255;
	u32 tr511;
	u32 tr1k;
	u32 trmax;
	u32 trmgv;
	u32 rbyt;
	u32 rpkt;
	u32 rfcs;
	u32 rmca;
	u32 rbca;
	u32 rxcf;
	u32 rxpf;
	u32 rxuo;
	u32 raln;
	u32 rflr;
	u32 rcde;
	u32 rcse;
	u32 rund;
	u32 rovr;
	u32 rfrg;
	u32 rjbr;
	u32 rdrp;
	u32 tbyt;
	u32 tpkt;
	u32 tmca;
	u32 tbca;
	u32 txpf;
	u32 tdfr;
	u32 tedf;
	u32 tscl;
	u32 tmcl;
	u32 tlcl;
	u32 txcl;
	u32 tncl;
	u8 res1[4];
	u32 tdrp;
	u32 tjbr;
	u32 tfcs;
	u32 txcf;
	u32 tovr;
	u32 tund;
	u32 tfrg;
	u32 car1;
	u32 car2;
	u32 cam1;
	u32 cam2;
};

struct gfar {
	u32 tsec_id;
	u32 tsec_id2;
	u8 res1[8];
	u32 ievent;
	u32 imask;
	u32 edis;
	u32 emapg;
	u32 ecntrl;
	u32 minflr;
	u32 ptv;
	u32 dmactrl;
	u32 tbipa;
	u8 res2[28];
	u32 fifo_rx_pause;
	u32 fifo_rx_pause_shutoff;
	u32 fifo_rx_alarm;
	u32 fifo_rx_alarm_shutoff;
	u8 res3[44];
	u32 fifo_tx_thr;
	u8 res4[8];
	u32 fifo_tx_starve;
	u32 fifo_tx_starve_shutoff;
	u8 res5[96];
	u32 tctrl;
	u32 tstat;
	u32 dfvlan;
	u32 tbdlen;
	u32 txic;
	u32 tqueue;
	u8 res7[40];
	u32 tr03wt;
	u32 tr47wt;
	u8 res8[52];
	u32 tbdbph;
	u8 res9a[4];
	u32 tbptr0;
	u8 res9b[4];
	u32 tbptr1;
	u8 res9c[4];
	u32 tbptr2;
	u8 res9d[4];
	u32 tbptr3;
	u8 res9e[4];
	u32 tbptr4;
	u8 res9f[4];
	u32 tbptr5;
	u8 res9g[4];
	u32 tbptr6;
	u8 res9h[4];
	u32 tbptr7;
	u8 res9[64];
	u32 tbaseh;
	u32 tbase0;
	u8 res10a[4];
	u32 tbase1;
	u8 res10b[4];
	u32 tbase2;
	u8 res10c[4];
	u32 tbase3;
	u8 res10d[4];
	u32 tbase4;
	u8 res10e[4];
	u32 tbase5;
	u8 res10f[4];
	u32 tbase6;
	u8 res10g[4];
	u32 tbase7;
	u8 res10[192];
	u32 rctrl;
	u32 rstat;
	u8 res12[8];
	u32 rxic;
	u32 rqueue;
	u32 rir0;
	u32 rir1;
	u32 rir2;
	u32 rir3;
	u8 res13[8];
	u32 rbifx;
	u32 rqfar;
	u32 rqfcr;
	u32 rqfpr;
	u32 mrblr;
	u8 res14[56];
	u32 rbdbph;
	u8 res15a[4];
	u32 rbptr0;
	u8 res15b[4];
	u32 rbptr1;
	u8 res15c[4];
	u32 rbptr2;
	u8 res15d[4];
	u32 rbptr3;
	u8 res15e[4];
	u32 rbptr4;
	u8 res15f[4];
	u32 rbptr5;
	u8 res15g[4];
	u32 rbptr6;
	u8 res15h[4];
	u32 rbptr7;
	u8 res16[64];
	u32 rbaseh;
	u32 rbase0;
	u8 res17a[4];
	u32 rbase1;
	u8 res17b[4];
	u32 rbase2;
	u8 res17c[4];
	u32 rbase3;
	u8 res17d[4];
	u32 rbase4;
	u8 res17e[4];
	u32 rbase5;
	u8 res17f[4];
	u32 rbase6;
	u8 res17g[4];
	u32 rbase7;
	u8 res17[192];
	u32 maccfg1;
	u32 maccfg2;
	u32 ipgifg;
	u32 hafdup;
	u32 maxfrm;
	u8 res18[12];
	u8 gfar_mii_regs[24];
	u32 ifctrl;
	u32 ifstat;
	u32 macstnaddr1;
	u32 macstnaddr2;
	u32 mac01addr1;
	u32 mac01addr2;
	u32 mac02addr1;
	u32 mac02addr2;
	u32 mac03addr1;
	u32 mac03addr2;
	u32 mac04addr1;
	u32 mac04addr2;
	u32 mac05addr1;
	u32 mac05addr2;
	u32 mac06addr1;
	u32 mac06addr2;
	u32 mac07addr1;
	u32 mac07addr2;
	u32 mac08addr1;
	u32 mac08addr2;
	u32 mac09addr1;
	u32 mac09addr2;
	u32 mac10addr1;
	u32 mac10addr2;
	u32 mac11addr1;
	u32 mac11addr2;
	u32 mac12addr1;
	u32 mac12addr2;
	u32 mac13addr1;
	u32 mac13addr2;
	u32 mac14addr1;
	u32 mac14addr2;
	u32 mac15addr1;
	u32 mac15addr2;
	u8 res20[192];
	struct rmon_mib rmon;
	u32 rrej;
	u8 res21[188];
	u32 igaddr0;
	u32 igaddr1;
	u32 igaddr2;
	u32 igaddr3;
	u32 igaddr4;
	u32 igaddr5;
	u32 igaddr6;
	u32 igaddr7;
	u8 res22[96];
	u32 gaddr0;
	u32 gaddr1;
	u32 gaddr2;
	u32 gaddr3;
	u32 gaddr4;
	u32 gaddr5;
	u32 gaddr6;
	u32 gaddr7;
	u8 res23a[352];
	u32 fifocfg;
	u8 res23b[252];
	u8 res23c[248];
	u32 attr;
	u32 attreli;
	u32 rqprm0;
	u32 rqprm1;
	u32 rqprm2;
	u32 rqprm3;
	u32 rqprm4;
	u32 rqprm5;
	u32 rqprm6;
	u32 rqprm7;
	u8 res24[36];
	u32 rfbptr0;
	u8 res24a[4];
	u32 rfbptr1;
	u8 res24b[4];
	u32 rfbptr2;
	u8 res24c[4];
	u32 rfbptr3;
	u8 res24d[4];
	u32 rfbptr4;
	u8 res24e[4];
	u32 rfbptr5;
	u8 res24f[4];
	u32 rfbptr6;
	u8 res24g[4];
	u32 rfbptr7;
	u8 res24h[4];
	u8 res24x[556];
	u32 isrg0;
	u32 isrg1;
	u32 isrg2;
	u32 isrg3;
	u8 res25[16];
	u32 rxic0;
	u32 rxic1;
	u32 rxic2;
	u32 rxic3;
	u32 rxic4;
	u32 rxic5;
	u32 rxic6;
	u32 rxic7;
	u8 res26[32];
	u32 txic0;
	u32 txic1;
	u32 txic2;
	u32 txic3;
	u32 txic4;
	u32 txic5;
	u32 txic6;
	u32 txic7;
	u8 res27[208];
};

enum gfar_irqinfo_id {
	GFAR_TX = 0,
	GFAR_RX = 1,
	GFAR_ER = 2,
	GFAR_NUM_IRQS = 3,
};

struct fsl_pq_mii {
	u32 miimcfg;
	u32 miimcom;
	u32 miimadd;
	u32 miimcon;
	u32 miimstat;
	u32 miimind;
};

struct fsl_pq_mdio_priv {
	void *map;
	struct fsl_pq_mii *regs;
};

struct fsl_pq_mdio_data {
	unsigned int mii_offset;
	uint32_t * (*get_tbipa)(void *);
	void (*ucc_configure)(phys_addr_t, phys_addr_t);
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct ethtool_rx_list {
	struct list_head list;
	unsigned int count;
};

struct txbd8 {
	union {
		struct {
			__be16 status;
			__be16 length;
		};
		__be32 lstatus;
	};
	__be32 bufPtr;
};

struct txfcb {
	u8 flags;
	u8 ptp;
	u8 l4os;
	u8 l3os;
	__be16 phcs;
	__be16 vlctl;
};

struct rxbd8 {
	union {
		struct {
			__be16 status;
			__be16 length;
		};
		__be32 lstatus;
	};
	__be32 bufPtr;
};

struct rxfcb {
	__be16 flags;
	u8 rq;
	u8 pro;
	u16 reserved;
	__be16 vlctl;
};

struct gianfar_skb_cb {
	unsigned int bytes_sent;
};

struct gfar_extra_stats {
	atomic64_t rx_alloc_err;
	atomic64_t rx_large;
	atomic64_t rx_short;
	atomic64_t rx_nonoctet;
	atomic64_t rx_crcerr;
	atomic64_t rx_overrun;
	atomic64_t rx_bsy;
	atomic64_t rx_babr;
	atomic64_t rx_trunc;
	atomic64_t eberr;
	atomic64_t tx_babt;
	atomic64_t tx_underrun;
	atomic64_t tx_timeout;
};

enum {
	SQ_SG_MODE = 0,
	MQ_MG_MODE = 1,
};

enum gfar_poll_mode {
	GFAR_SQ_POLLING = 0,
	GFAR_MQ_POLLING = 1,
};

struct tx_q_stats {
	long unsigned int tx_packets;
	long unsigned int tx_bytes;
};

struct gfar_priv_grp;

struct gfar_priv_tx_q {
	spinlock_t txlock;
	struct txbd8 *tx_bd_base;
	struct txbd8 *cur_tx;
	unsigned int num_txbdfree;
	short unsigned int skb_curtx;
	short unsigned int tx_ring_size;
	struct tx_q_stats stats;
	struct gfar_priv_grp *grp;
	struct net_device *dev;
	struct sk_buff **tx_skbuff;
	struct txbd8 *dirty_tx;
	short unsigned int skb_dirtytx;
	short unsigned int qindex;
	unsigned int txcoalescing;
	long unsigned int txic;
	dma_addr_t tx_bd_dma_base;
	int: 32;
};

struct gfar_priv_rx_q;

struct gfar_private;

struct gfar_irqinfo;

struct gfar_priv_grp {
	spinlock_t grplock;
	int: 32;
	struct napi_struct napi_rx;
	struct napi_struct napi_tx;
	struct gfar *regs;
	struct gfar_priv_tx_q *tx_queue;
	struct gfar_priv_rx_q *rx_queue;
	unsigned int tstat;
	unsigned int rstat;
	struct gfar_private *priv;
	long unsigned int num_tx_queues;
	long unsigned int tx_bit_map;
	long unsigned int num_rx_queues;
	long unsigned int rx_bit_map;
	struct gfar_irqinfo *irqinfo[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct rx_q_stats {
	long unsigned int rx_packets;
	long unsigned int rx_bytes;
	long unsigned int rx_dropped;
};

struct gfar_rx_buff {
	dma_addr_t dma;
	struct page *page;
	unsigned int page_offset;
};

struct gfar_priv_rx_q {
	struct gfar_rx_buff *rx_buff;
	struct rxbd8 *rx_bd_base;
	struct net_device *ndev;
	struct device *dev;
	u16 rx_ring_size;
	u16 qindex;
	struct gfar_priv_grp *grp;
	u16 next_to_clean;
	u16 next_to_use;
	u16 next_to_alloc;
	struct sk_buff *skb;
	struct rx_q_stats stats;
	u32 *rfbptr;
	unsigned char rxcoalescing;
	long unsigned int rxic;
	dma_addr_t rx_bd_dma_base;
};

struct gfar_irqinfo {
	unsigned int irq;
	char name[22];
};

enum gfar_errata {
	GFAR_ERRATA_74 = 1,
	GFAR_ERRATA_76 = 2,
	GFAR_ERRATA_A002 = 4,
	GFAR_ERRATA_12 = 8,
};

struct gfar_private {
	struct device *dev;
	struct net_device *ndev;
	enum gfar_errata errata;
	u16 uses_rxfcb;
	u16 padding;
	u32 device_flags;
	int hwts_rx_en;
	int hwts_tx_en;
	struct gfar_priv_tx_q *tx_queue[8];
	struct gfar_priv_rx_q *rx_queue[8];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct gfar_priv_grp gfargrp[2];
	long unsigned int state;
	short unsigned int mode;
	short unsigned int poll_mode;
	unsigned int num_tx_queues;
	unsigned int num_rx_queues;
	unsigned int num_grps;
	int tx_actual_en;
	struct gfar_extra_stats extra_stats;
	phy_interface_t interface;
	struct device_node *phy_node;
	struct device_node *tbi_node;
	struct mii_bus *mii_bus;
	int oldspeed;
	int oldduplex;
	int oldlink;
	uint32_t msg_enable;
	struct work_struct reset_task;
	struct platform_device *ofdev;
	unsigned char extended_hash: 1;
	unsigned char bd_stash_en: 1;
	unsigned char rx_filer_enable: 1;
	unsigned char prio_sched_en: 1;
	unsigned char pause_aneg_en: 1;
	unsigned char tx_pause_en: 1;
	unsigned char rx_pause_en: 1;
	unsigned int total_tx_ring_size;
	unsigned int total_rx_ring_size;
	u32 rqueue;
	u32 tqueue;
	unsigned int rx_stash_size;
	unsigned int rx_stash_index;
	u32 cur_filer_idx;
	struct ethtool_rx_list rx_list;
	struct mutex rx_queue_access;
	u32 *hash_regs[16];
	int hash_width;
	u16 wol_opts;
	u16 wol_supported;
	unsigned int ftp_rqfpr[256];
	unsigned int ftp_rqfcr[256];
	int: 32;
};

enum gfar_dev_state {
	GFAR_DOWN = 1,
	GFAR_RESETTING = 2,
};

struct ctrl_regs {
	u32 tmr_ctrl;
	u32 tmr_tevent;
	u32 tmr_temask;
	u32 tmr_pevent;
	u32 tmr_pemask;
	u32 tmr_stat;
	u32 tmr_cnt_h;
	u32 tmr_cnt_l;
	u32 tmr_add;
	u32 tmr_acc;
	u32 tmr_prsc;
	u8 res1[4];
	u32 tmroff_h;
	u32 tmroff_l;
};

struct alarm_regs {
	u32 tmr_alarm1_h;
	u32 tmr_alarm1_l;
	u32 tmr_alarm2_h;
	u32 tmr_alarm2_l;
};

struct fiper_regs {
	u32 tmr_fiper1;
	u32 tmr_fiper2;
	u32 tmr_fiper3;
};

struct etts_regs {
	u32 tmr_etts1_h;
	u32 tmr_etts1_l;
	u32 tmr_etts2_h;
	u32 tmr_etts2_l;
};

struct ptp_qoriq_registers {
	struct ctrl_regs *ctrl_regs;
	struct alarm_regs *alarm_regs;
	struct fiper_regs *fiper_regs;
	struct etts_regs *etts_regs;
};

struct ptp_qoriq {
	void *base;
	struct ptp_qoriq_registers regs;
	spinlock_t lock;
	struct ptp_clock *clock;
	struct ptp_clock_info caps;
	struct resource *rsrc;
	struct dentry *debugfs_root;
	struct device *dev;
	bool extts_fifo_support;
	bool fiper3_support;
	int irq;
	int phc_index;
	u32 tclk_period;
	u32 tmr_prsc;
	u32 tmr_add;
	u32 cksel;
	u32 tmr_fiper1;
	u32 tmr_fiper2;
	u32 tmr_fiper3;
	u32 (*read)(unsigned int *);
	void (*write)(unsigned int *, u32);
};

struct ethtool_flow_spec_container {
	struct ethtool_rx_flow_spec fs;
	struct list_head list;
};

struct gfar_filer_entry {
	u32 ctrl;
	u32 prop;
};

struct filer_table {
	u32 index;
	struct gfar_filer_entry fe[530];
};

enum phy_reset_delays {
	PRE_DELAY = 0,
	PULSE = 1,
	POST_DELAY = 2,
	DELAYS_NUM = 3,
};

struct hix5hd2_desc {
	__le32 buff_addr;
	__le32 cmd;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct hix5hd2_desc_sw {
	struct hix5hd2_desc *desc;
	dma_addr_t phys_addr;
	unsigned int count;
	unsigned int size;
};

struct sg_desc;

struct hix5hd2_sg_desc_ring {
	struct sg_desc *desc;
	dma_addr_t phys_addr;
};

struct frags_info {
	__le32 addr;
	__le32 size;
};

struct sg_desc {
	__le32 total_len;
	__le32 resvd0;
	__le32 linear_addr;
	__le32 linear_len;
	struct frags_info frags[18];
};

struct hix5hd2_priv___2 {
	struct hix5hd2_desc_sw pool[4];
	struct hix5hd2_sg_desc_ring tx_ring;
	void *base;
	void *ctrl_base;
	struct sk_buff *tx_skb[1024];
	struct sk_buff *rx_skb[1024];
	struct device *dev;
	struct net_device *netdev;
	struct device_node *phy_node;
	phy_interface_t phy_mode;
	long unsigned int hw_cap;
	unsigned int speed;
	unsigned int duplex;
	struct clk *mac_core_clk;
	struct clk *mac_ifc_clk;
	struct reset_control *mac_core_rst;
	struct reset_control *mac_ifc_rst;
	struct reset_control *phy_rst;
	u32 phy_reset_delays[3];
	struct mii_bus *bus;
	struct napi_struct napi;
	struct work_struct tx_timeout_task;
};

enum e1000_mac_type {
	e1000_82571 = 0,
	e1000_82572 = 1,
	e1000_82573 = 2,
	e1000_82574 = 3,
	e1000_82583 = 4,
	e1000_80003es2lan = 5,
	e1000_ich8lan = 6,
	e1000_ich9lan = 7,
	e1000_ich10lan = 8,
	e1000_pchlan = 9,
	e1000_pch2lan = 10,
	e1000_pch_lpt = 11,
	e1000_pch_spt = 12,
	e1000_pch_cnp = 13,
	e1000_pch_tgp = 14,
	e1000_pch_adp = 15,
	e1000_pch_mtp = 16,
};

enum e1000_media_type {
	e1000_media_type_unknown = 0,
	e1000_media_type_copper = 1,
	e1000_media_type_fiber = 2,
	e1000_media_type_internal_serdes = 3,
	e1000_num_media_types = 4,
};

enum e1000_nvm_type {
	e1000_nvm_unknown = 0,
	e1000_nvm_none = 1,
	e1000_nvm_eeprom_spi = 2,
	e1000_nvm_flash_hw = 3,
	e1000_nvm_flash_sw = 4,
};

enum e1000_nvm_override {
	e1000_nvm_override_none = 0,
	e1000_nvm_override_spi_small = 1,
	e1000_nvm_override_spi_large = 2,
};

enum e1000_phy_type {
	e1000_phy_unknown = 0,
	e1000_phy_none = 1,
	e1000_phy_m88 = 2,
	e1000_phy_igp = 3,
	e1000_phy_igp_2 = 4,
	e1000_phy_gg82563 = 5,
	e1000_phy_igp_3 = 6,
	e1000_phy_ife = 7,
	e1000_phy_bm = 8,
	e1000_phy_82578 = 9,
	e1000_phy_82577 = 10,
	e1000_phy_82579 = 11,
	e1000_phy_i217 = 12,
};

enum e1000_bus_width {
	e1000_bus_width_unknown = 0,
	e1000_bus_width_pcie_x1 = 1,
	e1000_bus_width_pcie_x2 = 2,
	e1000_bus_width_pcie_x4 = 4,
	e1000_bus_width_pcie_x8 = 8,
	e1000_bus_width_32 = 9,
	e1000_bus_width_64 = 10,
	e1000_bus_width_reserved = 11,
};

enum e1000_1000t_rx_status {
	e1000_1000t_rx_status_not_ok = 0,
	e1000_1000t_rx_status_ok = 1,
	e1000_1000t_rx_status_undefined = 255,
};

enum e1000_rev_polarity {
	e1000_rev_polarity_normal = 0,
	e1000_rev_polarity_reversed = 1,
	e1000_rev_polarity_undefined = 255,
};

enum e1000_fc_mode {
	e1000_fc_none = 0,
	e1000_fc_rx_pause = 1,
	e1000_fc_tx_pause = 2,
	e1000_fc_full = 3,
	e1000_fc_default = 255,
};

enum e1000_ms_type {
	e1000_ms_hw_default = 0,
	e1000_ms_force_master = 1,
	e1000_ms_force_slave = 2,
	e1000_ms_auto = 3,
};

enum e1000_smart_speed {
	e1000_smart_speed_default = 0,
	e1000_smart_speed_on = 1,
	e1000_smart_speed_off = 2,
};

enum e1000_serdes_link_state {
	e1000_serdes_link_down = 0,
	e1000_serdes_link_autoneg_progress = 1,
	e1000_serdes_link_autoneg_complete = 2,
	e1000_serdes_link_forced_up = 3,
};

struct e1000_hw_stats {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 tor;
	u64 tot;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

struct e1000_phy_stats {
	u32 idle_errors;
	u32 receive_errors;
};

struct e1000_host_mng_dhcp_cookie {
	u32 signature;
	u8 status;
	u8 reserved0;
	u16 vlan_id;
	u32 reserved1;
	u16 reserved2;
	u8 reserved3;
	u8 checksum;
};

struct e1000_hw;

struct e1000_mac_operations {
	s32 (*id_led_init)(struct e1000_hw *);
	s32 (*blink_led)(struct e1000_hw *);
	bool (*check_mng_mode)(struct e1000_hw *);
	s32 (*check_for_link)(struct e1000_hw *);
	s32 (*cleanup_led)(struct e1000_hw *);
	void (*clear_hw_cntrs)(struct e1000_hw *);
	void (*clear_vfta)(struct e1000_hw *);
	s32 (*get_bus_info)(struct e1000_hw *);
	void (*set_lan_id)(struct e1000_hw *);
	s32 (*get_link_up_info)(struct e1000_hw *, u16 *, u16 *);
	s32 (*led_on)(struct e1000_hw *);
	s32 (*led_off)(struct e1000_hw *);
	void (*update_mc_addr_list)(struct e1000_hw *, u8 *, u32);
	s32 (*reset_hw)(struct e1000_hw *);
	s32 (*init_hw)(struct e1000_hw *);
	s32 (*setup_link)(struct e1000_hw *);
	s32 (*setup_physical_interface)(struct e1000_hw *);
	s32 (*setup_led)(struct e1000_hw *);
	void (*write_vfta)(struct e1000_hw *, u32, u32);
	void (*config_collision_dist)(struct e1000_hw *);
	int (*rar_set)(struct e1000_hw *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw *);
	u32 (*rar_get_count)(struct e1000_hw *);
};

struct e1000_mac_info {
	struct e1000_mac_operations ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type type;
	u32 collision_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	u32 mc_filter_type;
	u32 tx_packet_delta;
	u32 txcw;
	u16 current_ifs_val;
	u16 ifs_max_val;
	u16 ifs_min_val;
	u16 ifs_ratio;
	u16 ifs_step_size;
	u16 mta_reg_count;
	u32 mta_shadow[128];
	u16 rar_entry_count;
	u8 forced_speed_duplex;
	bool adaptive_ifs;
	bool has_fwsm;
	bool arc_subsystem_valid;
	bool autoneg;
	bool autoneg_failed;
	bool get_link_status;
	bool in_ifs_mode;
	bool serdes_has_link;
	bool tx_pkt_filtering;
	enum e1000_serdes_link_state serdes_link_state;
};

struct e1000_fc_info {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	u16 refresh_time;
	bool send_xon;
	bool strict_ieee;
	enum e1000_fc_mode current_mode;
	enum e1000_fc_mode requested_mode;
};

struct e1000_phy_operations {
	s32 (*acquire)(struct e1000_hw *);
	s32 (*cfg_on_link_up)(struct e1000_hw *);
	s32 (*check_polarity)(struct e1000_hw *);
	s32 (*check_reset_block)(struct e1000_hw *);
	s32 (*commit)(struct e1000_hw *);
	s32 (*force_speed_duplex)(struct e1000_hw *);
	s32 (*get_cfg_done)(struct e1000_hw *);
	s32 (*get_cable_length)(struct e1000_hw *);
	s32 (*get_info)(struct e1000_hw *);
	s32 (*set_page)(struct e1000_hw *, u16);
	s32 (*read_reg)(struct e1000_hw *, u32, u16 *);
	s32 (*read_reg_locked)(struct e1000_hw *, u32, u16 *);
	s32 (*read_reg_page)(struct e1000_hw *, u32, u16 *);
	void (*release)(struct e1000_hw *);
	s32 (*reset)(struct e1000_hw *);
	s32 (*set_d0_lplu_state)(struct e1000_hw *, bool);
	s32 (*set_d3_lplu_state)(struct e1000_hw *, bool);
	s32 (*write_reg)(struct e1000_hw *, u32, u16);
	s32 (*write_reg_locked)(struct e1000_hw *, u32, u16);
	s32 (*write_reg_page)(struct e1000_hw *, u32, u16);
	void (*power_up)(struct e1000_hw *);
	void (*power_down)(struct e1000_hw *);
};

struct e1000_phy_info {
	struct e1000_phy_operations ops;
	enum e1000_phy_type type;
	enum e1000_1000t_rx_status local_rx;
	enum e1000_1000t_rx_status remote_rx;
	enum e1000_ms_type ms_type;
	enum e1000_ms_type original_ms_type;
	enum e1000_rev_polarity cable_polarity;
	enum e1000_smart_speed smart_speed;
	u32 addr;
	u32 id;
	u32 reset_delay_us;
	u32 revision;
	enum e1000_media_type media_type;
	u16 autoneg_advertised;
	u16 autoneg_mask;
	u16 cable_length;
	u16 max_cable_length;
	u16 min_cable_length;
	u8 mdix;
	bool disable_polarity_correction;
	bool is_mdix;
	bool polarity_correction;
	bool speed_downgraded;
	bool autoneg_wait_to_complete;
};

struct e1000_nvm_operations {
	s32 (*acquire)(struct e1000_hw *);
	s32 (*read)(struct e1000_hw *, u16, u16, u16 *);
	void (*release)(struct e1000_hw *);
	void (*reload)(struct e1000_hw *);
	s32 (*update)(struct e1000_hw *);
	s32 (*valid_led_default)(struct e1000_hw *, u16 *);
	s32 (*validate)(struct e1000_hw *);
	s32 (*write)(struct e1000_hw *, u16, u16, u16 *);
};

struct e1000_nvm_info {
	struct e1000_nvm_operations ops;
	enum e1000_nvm_type type;
	enum e1000_nvm_override override;
	u32 flash_bank_size;
	u32 flash_base_addr;
	u16 word_size;
	u16 delay_usec;
	u16 address_bits;
	u16 opcode_bits;
	u16 page_size;
};

struct e1000_bus_info {
	enum e1000_bus_width width;
	u16 func;
};

struct e1000_dev_spec_82571 {
	bool laa_is_present;
	u32 smb_counter;
};

struct e1000_dev_spec_80003es2lan {
	bool mdic_wa_enable;
};

struct e1000_shadow_ram {
	u16 value;
	bool modified;
};

enum e1000_ulp_state {
	e1000_ulp_state_unknown = 0,
	e1000_ulp_state_off = 1,
	e1000_ulp_state_on = 2,
};

struct e1000_dev_spec_ich8lan {
	bool kmrn_lock_loss_workaround_enabled;
	struct e1000_shadow_ram shadow_ram[2048];
	bool nvm_k1_enabled;
	bool eee_disable;
	u16 eee_lp_ability;
	enum e1000_ulp_state ulp_state;
};

struct e1000_adapter;

struct e1000_hw {
	struct e1000_adapter *adapter;
	void *hw_addr;
	void *flash_address;
	struct e1000_mac_info mac;
	struct e1000_fc_info fc;
	struct e1000_phy_info phy;
	struct e1000_nvm_info nvm;
	struct e1000_bus_info bus;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	union {
		struct e1000_dev_spec_82571 e82571;
		struct e1000_dev_spec_80003es2lan e80003es2lan;
		struct e1000_dev_spec_ich8lan ich8lan;
	} dev_spec;
};

struct e1000_phy_regs {
	u16 bmcr;
	u16 bmsr;
	u16 advertise;
	u16 lpa;
	u16 expansion;
	u16 ctrl1000;
	u16 stat1000;
	u16 estatus;
};

struct e1000_buffer;

struct e1000_ring {
	struct e1000_adapter *adapter;
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	u16 next_to_use;
	u16 next_to_clean;
	void *head;
	void *tail;
	struct e1000_buffer *buffer_info;
	char name[21];
	u32 ims_val;
	u32 itr_val;
	void *itr_register;
	int set_itr;
	struct sk_buff *rx_skb_top;
};

struct e1000_info;

struct e1000_adapter {
	struct timer_list watchdog_timer;
	struct timer_list phy_info_timer;
	struct timer_list blink_timer;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	const struct e1000_info *ei;
	long unsigned int active_vlans[128];
	u32 bd_number;
	u32 rx_buffer_len;
	u16 mng_vlan_id;
	u16 link_speed;
	u16 link_duplex;
	u16 eeprom_vers;
	long unsigned int state;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	struct e1000_ring *tx_ring;
	u32 tx_fifo_limit;
	struct napi_struct napi;
	unsigned int uncorr_errors;
	unsigned int corr_errors;
	unsigned int restart_queue;
	u32 txd_cmd;
	bool detect_tx_hung;
	bool tx_hang_recheck;
	u8 tx_timeout_factor;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	int: 32;
	u64 tpt_old;
	u64 colc_old;
	u32 gotc;
	int: 32;
	u64 gotc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u32 tx_dma_failed;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	bool (*clean_rx)(struct e1000_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_ring *, int, gfp_t);
	struct e1000_ring *rx_ring;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	int: 32;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u64 rx_hdr_split;
	u32 gorc;
	int: 32;
	u64 gorc_old;
	u32 alloc_rx_buff_failed;
	u32 rx_dma_failed;
	u32 rx_hwtstamp_cleared;
	unsigned int rx_ps_pages;
	u16 rx_ps_bsize0;
	u32 max_frame_size;
	u32 min_frame_size;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw hw;
	spinlock_t stats64_lock;
	struct e1000_hw_stats stats;
	struct e1000_phy_info phy_info;
	struct e1000_phy_stats phy_stats;
	struct e1000_phy_regs phy_regs;
	struct e1000_ring test_tx_ring;
	struct e1000_ring test_rx_ring;
	u32 test_icr;
	u32 msg_enable;
	unsigned int num_vectors;
	struct msix_entry *msix_entries;
	int int_mode;
	u32 eiac_mask;
	u32 eeprom_wol;
	u32 wol;
	u32 pba;
	u32 max_hw_frame_size;
	bool fc_autoneg;
	unsigned int flags;
	unsigned int flags2;
	struct work_struct downshift_task;
	struct work_struct update_phy_task;
	struct work_struct print_hang_task;
	int phy_hang_count;
	u16 tx_ring_count;
	u16 rx_ring_count;
	struct hwtstamp_config hwtstamp_config;
	struct delayed_work systim_overflow_work;
	struct sk_buff *tx_hwtstamp_skb;
	long unsigned int tx_hwtstamp_start;
	struct work_struct tx_hwtstamp_work;
	spinlock_t systim_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct pm_qos_request pm_qos_req;
	s32 ptp_delta;
	u16 eee_advert;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct e1000_ps_page {
	struct page *page;
	int: 32;
	u64 dma;
};

struct e1000_buffer {
	dma_addr_t dma;
	struct sk_buff *skb;
	union {
		struct {
			long unsigned int time_stamp;
			u16 length;
			u16 next_to_watch;
			unsigned int segs;
			unsigned int bytecount;
			u16 mapped_as_page;
		};
		struct {
			struct e1000_ps_page *ps_pages;
			struct page *page;
		};
	};
};

struct e1000_info {
	enum e1000_mac_type mac;
	unsigned int flags;
	unsigned int flags2;
	u32 pba;
	u32 max_hw_frame_size;
	s32 (*get_variants)(struct e1000_adapter *);
	const struct e1000_mac_operations *mac_ops;
	const struct e1000_phy_operations *phy_ops;
	const struct e1000_nvm_operations *nvm_ops;
};

enum e1000_state_t {
	__E1000_TESTING = 0,
	__E1000_RESETTING = 1,
	__E1000_ACCESS_SHARED_RESOURCE = 2,
	__E1000_DOWN = 3,
};

struct ich8_hsfsts {
	u16 flcdone: 1;
	u16 flcerr: 1;
	u16 dael: 1;
	u16 berasesz: 2;
	u16 flcinprog: 1;
	u16 reserved1: 2;
	u16 reserved2: 6;
	u16 fldesvalid: 1;
	u16 flockdn: 1;
};

union ich8_hws_flash_status {
	struct ich8_hsfsts hsf_status;
	u16 regval;
};

struct ich8_hsflctl {
	u16 flcgo: 1;
	u16 flcycle: 2;
	u16 reserved: 5;
	u16 fldbcount: 2;
	u16 flockdn: 6;
};

union ich8_hws_flash_ctrl {
	struct ich8_hsflctl hsf_ctrl;
	u16 regval;
};

struct ich8_pr {
	u32 base: 13;
	u32 reserved1: 2;
	u32 rpe: 1;
	u32 limit: 13;
	u32 reserved2: 2;
	u32 wpe: 1;
};

union ich8_flash_protected_range {
	struct ich8_pr range;
	u32 regval;
};

struct e1000_host_mng_command_header {
	u8 command_id;
	u8 checksum;
	u16 reserved1;
	u16 reserved2;
	u16 command_length;
};

enum e1000_mng_mode {
	e1000_mng_mode_none = 0,
	e1000_mng_mode_asf = 1,
	e1000_mng_mode_pt = 2,
	e1000_mng_mode_ipmi = 3,
	e1000_mng_mode_host_if_only = 4,
};

struct e1000_opt_list {
	int i;
	char *str;
};

struct e1000_option {
	enum {
		enable_option = 0,
		range_option = 1,
		list_option = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			struct e1000_opt_list *p;
		} l;
	} arg;
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

union e1000_rx_desc_extended {
	struct {
		__le64 buffer_addr;
		__le64 reserved;
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

struct e1000_tx_desc {
	__le64 buffer_addr;
	union {
		__le32 data;
		struct {
			__le16 length;
			u8 cso;
			u8 cmd;
		} flags;
	} lower;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 css;
			__le16 special;
		} fields;
	} upper;
};

enum {
	NETDEV_STATS = 0,
	E1000_STATS = 1,
};

struct e1000_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	struct in6_addr saddr;
	struct in6_addr daddr;
};

union e1000_rx_desc_packet_split {
	struct {
		__le64 buffer_addr[4];
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length0;
			__le16 vlan;
		} middle;
		struct {
			__le16 header_status;
			__le16 length[3];
		} upper;
		__le64 reserved;
	} wb;
};

struct e1000_context_desc {
	union {
		__le32 ip_config;
		struct {
			u8 ipcss;
			u8 ipcso;
			__le16 ipcse;
		} ip_fields;
	} lower_setup;
	union {
		__le32 tcp_config;
		struct {
			u8 tucss;
			u8 tucso;
			__le16 tucse;
		} tcp_fields;
	} upper_setup;
	__le32 cmd_and_length;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 hdr_len;
			__le16 mss;
		} fields;
	} tcp_seg_setup;
};

enum e1000_boards {
	board_82571 = 0,
	board_82572 = 1,
	board_82573 = 2,
	board_82574 = 3,
	board_82583 = 4,
	board_80003es2lan = 5,
	board_ich8lan = 6,
	board_ich9lan = 7,
	board_ich10lan = 8,
	board_pchlan = 9,
	board_pch2lan = 10,
	board_pch_lpt = 11,
	board_pch_spt = 12,
	board_pch_cnp = 13,
};

enum latency_range {
	lowest_latency = 0,
	low_latency = 1,
	bulk_latency = 2,
	latency_invalid = 255,
};

struct e1000_reg_info {
	u32 ofs;
	char *name;
};

struct my_u0 {
	__le64 a;
	__le64 b;
};

struct my_u1 {
	__le64 a;
	__le64 b;
	__le64 c;
	__le64 d;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct tc_cbs_qopt_offload {
	u8 enable;
	s32 queue;
	s32 hicredit;
	s32 locredit;
	s32 idleslope;
	s32 sendslope;
};

struct tc_etf_qopt_offload {
	u8 enable;
	s32 queue;
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

enum e1000_mac_type___2 {
	e1000_undefined = 0,
	e1000_82575 = 1,
	e1000_82576 = 2,
	e1000_82580 = 3,
	e1000_i350 = 4,
	e1000_i354 = 5,
	e1000_i210 = 6,
	e1000_i211 = 7,
	e1000_num_macs = 8,
};

enum e1000_nvm_type___2 {
	e1000_nvm_unknown___2 = 0,
	e1000_nvm_none___2 = 1,
	e1000_nvm_eeprom_spi___2 = 2,
	e1000_nvm_flash_hw___2 = 3,
	e1000_nvm_invm = 4,
	e1000_nvm_flash_sw___2 = 5,
};

enum e1000_phy_type___2 {
	e1000_phy_unknown___2 = 0,
	e1000_phy_none___2 = 1,
	e1000_phy_m88___2 = 2,
	e1000_phy_igp___2 = 3,
	e1000_phy_igp_2___2 = 4,
	e1000_phy_gg82563___2 = 5,
	e1000_phy_igp_3___2 = 6,
	e1000_phy_ife___2 = 7,
	e1000_phy_82580 = 8,
	e1000_phy_i210 = 9,
	e1000_phy_bcm54616 = 10,
};

enum e1000_bus_type {
	e1000_bus_type_unknown = 0,
	e1000_bus_type_pci = 1,
	e1000_bus_type_pcix = 2,
	e1000_bus_type_pci_express = 3,
	e1000_bus_type_reserved = 4,
};

enum e1000_bus_speed {
	e1000_bus_speed_unknown = 0,
	e1000_bus_speed_33 = 1,
	e1000_bus_speed_66 = 2,
	e1000_bus_speed_100 = 3,
	e1000_bus_speed_120 = 4,
	e1000_bus_speed_133 = 5,
	e1000_bus_speed_2500 = 6,
	e1000_bus_speed_5000 = 7,
	e1000_bus_speed_reserved = 8,
};

struct e1000_hw_stats___2 {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 tor;
	u64 tot;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
	u64 cbtmpc;
	u64 htdpmc;
	u64 cbrdpc;
	u64 cbrmpc;
	u64 rpthc;
	u64 hgptc;
	u64 htcbdpc;
	u64 hgorc;
	u64 hgotc;
	u64 lenerrs;
	u64 scvpc;
	u64 hrmpc;
	u64 doosync;
	u64 o2bgptc;
	u64 o2bspc;
	u64 b2ospc;
	u64 b2ogprc;
};

struct e1000_sfp_flags {
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e10_base_bx10: 1;
	u8 e10_base_px: 1;
};

struct e1000_fw_version {
	u32 etrack_id;
	u16 eep_major;
	u16 eep_minor;
	u16 eep_build;
	u8 invm_major;
	u8 invm_minor;
	u8 invm_img_type;
	bool or_valid;
	u16 or_major;
	u16 or_build;
	u16 or_patch;
};

struct e1000_hw___2;

struct e1000_mac_operations___2 {
	s32 (*check_for_link)(struct e1000_hw___2 *);
	s32 (*reset_hw)(struct e1000_hw___2 *);
	s32 (*init_hw)(struct e1000_hw___2 *);
	bool (*check_mng_mode)(struct e1000_hw___2 *);
	s32 (*setup_physical_interface)(struct e1000_hw___2 *);
	void (*rar_set)(struct e1000_hw___2 *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw___2 *);
	s32 (*get_speed_and_duplex)(struct e1000_hw___2 *, u16 *, u16 *);
	s32 (*acquire_swfw_sync)(struct e1000_hw___2 *, u16);
	void (*release_swfw_sync)(struct e1000_hw___2 *, u16);
	s32 (*get_thermal_sensor_data)(struct e1000_hw___2 *);
	s32 (*init_thermal_sensor_thresh)(struct e1000_hw___2 *);
	void (*write_vfta)(struct e1000_hw___2 *, u32, u32);
};

struct e1000_thermal_diode_data {
	u8 location;
	u8 temp;
	u8 caution_thresh;
	u8 max_op_thresh;
};

struct e1000_thermal_sensor_data {
	struct e1000_thermal_diode_data sensor[3];
};

struct e1000_mac_info___2 {
	struct e1000_mac_operations___2 ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type___2 type;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	u32 mc_filter_type;
	u32 txcw;
	u16 mta_reg_count;
	u16 uta_reg_count;
	u32 mta_shadow[128];
	u16 rar_entry_count;
	u8 forced_speed_duplex;
	bool adaptive_ifs;
	bool arc_subsystem_valid;
	bool asf_firmware_present;
	bool autoneg;
	bool autoneg_failed;
	bool disable_hw_init_bits;
	bool get_link_status;
	bool ifs_params_forced;
	bool in_ifs_mode;
	bool report_tx_early;
	bool serdes_has_link;
	bool tx_pkt_filtering;
	struct e1000_thermal_sensor_data thermal_sensor_data;
};

struct e1000_fc_info___2 {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	bool send_xon;
	bool strict_ieee;
	enum e1000_fc_mode current_mode;
	enum e1000_fc_mode requested_mode;
};

struct e1000_phy_operations___2 {
	s32 (*acquire)(struct e1000_hw___2 *);
	s32 (*check_polarity)(struct e1000_hw___2 *);
	s32 (*check_reset_block)(struct e1000_hw___2 *);
	s32 (*force_speed_duplex)(struct e1000_hw___2 *);
	s32 (*get_cfg_done)(struct e1000_hw___2 *);
	s32 (*get_cable_length)(struct e1000_hw___2 *);
	s32 (*get_phy_info)(struct e1000_hw___2 *);
	s32 (*read_reg)(struct e1000_hw___2 *, u32, u16 *);
	void (*release)(struct e1000_hw___2 *);
	s32 (*reset)(struct e1000_hw___2 *);
	s32 (*set_d0_lplu_state)(struct e1000_hw___2 *, bool);
	s32 (*set_d3_lplu_state)(struct e1000_hw___2 *, bool);
	s32 (*write_reg)(struct e1000_hw___2 *, u32, u16);
	s32 (*read_i2c_byte)(struct e1000_hw___2 *, u8, u8, u8 *);
	s32 (*write_i2c_byte)(struct e1000_hw___2 *, u8, u8, u8);
};

struct e1000_phy_info___2 {
	struct e1000_phy_operations___2 ops;
	enum e1000_phy_type___2 type;
	enum e1000_1000t_rx_status local_rx;
	enum e1000_1000t_rx_status remote_rx;
	enum e1000_ms_type ms_type;
	enum e1000_ms_type original_ms_type;
	enum e1000_rev_polarity cable_polarity;
	enum e1000_smart_speed smart_speed;
	u32 addr;
	u32 id;
	u32 reset_delay_us;
	u32 revision;
	enum e1000_media_type media_type;
	u16 autoneg_advertised;
	u16 autoneg_mask;
	u16 cable_length;
	u16 max_cable_length;
	u16 min_cable_length;
	u16 pair_length[4];
	u8 mdix;
	bool disable_polarity_correction;
	bool is_mdix;
	bool polarity_correction;
	bool reset_disable;
	bool speed_downgraded;
	bool autoneg_wait_to_complete;
};

struct e1000_nvm_operations___2 {
	s32 (*acquire)(struct e1000_hw___2 *);
	s32 (*read)(struct e1000_hw___2 *, u16, u16, u16 *);
	void (*release)(struct e1000_hw___2 *);
	s32 (*write)(struct e1000_hw___2 *, u16, u16, u16 *);
	s32 (*update)(struct e1000_hw___2 *);
	s32 (*validate)(struct e1000_hw___2 *);
	s32 (*valid_led_default)(struct e1000_hw___2 *, u16 *);
};

struct e1000_nvm_info___2 {
	struct e1000_nvm_operations___2 ops;
	enum e1000_nvm_type___2 type;
	enum e1000_nvm_override override;
	u32 flash_bank_size;
	u32 flash_base_addr;
	u16 word_size;
	u16 delay_usec;
	u16 address_bits;
	u16 opcode_bits;
	u16 page_size;
};

struct e1000_bus_info___2 {
	enum e1000_bus_type type;
	enum e1000_bus_speed speed;
	enum e1000_bus_width width;
	u32 snoop;
	u16 func;
	u16 pci_cmd_word;
};

struct e1000_mbx_operations {
	s32 (*init_params)(struct e1000_hw___2 *);
	s32 (*read)(struct e1000_hw___2 *, u32 *, u16, u16, bool);
	s32 (*write)(struct e1000_hw___2 *, u32 *, u16, u16);
	s32 (*read_posted)(struct e1000_hw___2 *, u32 *, u16, u16);
	s32 (*write_posted)(struct e1000_hw___2 *, u32 *, u16, u16);
	s32 (*check_for_msg)(struct e1000_hw___2 *, u16);
	s32 (*check_for_ack)(struct e1000_hw___2 *, u16);
	s32 (*check_for_rst)(struct e1000_hw___2 *, u16);
	s32 (*unlock)(struct e1000_hw___2 *, u16);
};

struct e1000_mbx_stats {
	u32 msgs_tx;
	u32 msgs_rx;
	u32 acks;
	u32 reqs;
	u32 rsts;
};

struct e1000_mbx_info {
	struct e1000_mbx_operations ops;
	struct e1000_mbx_stats stats;
	u32 timeout;
	u32 usec_delay;
	u16 size;
};

struct e1000_dev_spec_82575 {
	bool sgmii_active;
	bool global_device_reset;
	bool eee_disable;
	bool clear_semaphore_once;
	struct e1000_sfp_flags eth_flags;
	bool module_plugged;
	u8 media_port;
	bool media_changed;
	bool mas_capable;
};

struct e1000_hw___2 {
	void *back;
	u8 *hw_addr;
	u8 *flash_address;
	long unsigned int io_base;
	struct e1000_mac_info___2 mac;
	struct e1000_fc_info___2 fc;
	struct e1000_phy_info___2 phy;
	struct e1000_nvm_info___2 nvm;
	struct e1000_bus_info___2 bus;
	struct e1000_mbx_info mbx;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	union {
		struct e1000_dev_spec_82575 _82575;
	} dev_spec;
	u16 device_id;
	u16 subsystem_vendor_id;
	u16 subsystem_device_id;
	u16 vendor_id;
	u8 revision_id;
};

struct e1000_info___2 {
	s32 (*get_invariants)(struct e1000_hw___2 *);
	struct e1000_mac_operations___2 *mac_ops;
	const struct e1000_phy_operations___2 *phy_ops;
	struct e1000_nvm_operations___2 *nvm_ops;
};

union e1000_adv_rx_desc {
	struct {
		__le64 pkt_addr;
		__le64 hdr_addr;
	} read;
	struct {
		struct {
			struct {
				__le16 pkt_info;
				__le16 hdr_info;
			} lo_dword;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

union e1000_adv_tx_desc {
	struct {
		__le64 buffer_addr;
		__le32 cmd_type_len;
		__le32 olinfo_status;
	} read;
	struct {
		__le64 rsvd;
		__le32 nxtseq_seed;
		__le32 status;
	} wb;
};

struct e1000_adv_tx_context_desc {
	__le32 vlan_macip_lens;
	__le32 seqnum_seed;
	__le32 type_tucmd_mlhl;
	__le32 mss_l4len_idx;
};

struct i2c_algo_bit_data {
	void *data;
	void (*setsda)(void *, int);
	void (*setscl)(void *, int);
	int (*getsda)(void *);
	int (*getscl)(void *);
	int (*pre_xfer)(struct i2c_adapter *);
	void (*post_xfer)(struct i2c_adapter *);
	int udelay;
	int timeout;
	bool can_do_atomic;
};

struct vf_data_storage {
	unsigned char vf_mac_addresses[6];
	u16 vf_mc_hashes[30];
	u16 num_vf_mc_hashes;
	u32 flags;
	long unsigned int last_nack;
	u16 pf_vlan;
	u16 pf_qos;
	u16 tx_rate;
	bool spoofchk_enabled;
	bool trusted;
};

struct vf_mac_filter {
	struct list_head l;
	int vf;
	bool free;
	u8 vf_mac[6];
};

enum igb_tx_flags {
	IGB_TX_FLAGS_VLAN = 1,
	IGB_TX_FLAGS_TSO = 2,
	IGB_TX_FLAGS_TSTAMP = 4,
	IGB_TX_FLAGS_IPV4 = 16,
	IGB_TX_FLAGS_CSUM = 32,
};

enum igb_tx_buf_type {
	IGB_TYPE_SKB = 0,
	IGB_TYPE_XDP = 1,
};

struct igb_tx_buffer {
	union e1000_adv_tx_desc *next_to_watch;
	long unsigned int time_stamp;
	enum igb_tx_buf_type type;
	union {
		struct sk_buff *skb;
		struct xdp_frame *xdpf;
	};
	unsigned int bytecount;
	u16 gso_segs;
	__be16 protocol;
	dma_addr_t dma;
	__u32 len;
	u32 tx_flags;
};

struct igb_rx_buffer {
	dma_addr_t dma;
	struct page *page;
	__u16 page_offset;
	__u16 pagecnt_bias;
};

struct igb_tx_queue_stats {
	u64 packets;
	u64 bytes;
	u64 restart_queue;
	u64 restart_queue2;
};

struct igb_rx_queue_stats {
	u64 packets;
	u64 bytes;
	u64 drops;
	u64 csum_err;
	u64 alloc_failed;
};

struct igb_ring;

struct igb_ring_container {
	struct igb_ring *ring;
	unsigned int total_bytes;
	unsigned int total_packets;
	u16 work_limit;
	u8 count;
	u8 itr;
};

struct igb_q_vector;

struct igb_ring {
	struct igb_q_vector *q_vector;
	struct net_device *netdev;
	struct bpf_prog *xdp_prog;
	struct device *dev;
	union {
		struct igb_tx_buffer *tx_buffer_info;
		struct igb_rx_buffer *rx_buffer_info;
	};
	void *desc;
	long unsigned int flags;
	void *tail;
	dma_addr_t dma;
	unsigned int size;
	u16 count;
	u8 queue_index;
	u8 reg_idx;
	bool launchtime_enable;
	bool cbs_enable;
	s32 idleslope;
	s32 sendslope;
	s32 hicredit;
	s32 locredit;
	u16 next_to_clean;
	u16 next_to_use;
	u16 next_to_alloc;
	union {
		struct {
			struct igb_tx_queue_stats tx_stats;
			struct u64_stats_sync tx_syncp;
			struct u64_stats_sync tx_syncp2;
		};
		struct {
			struct sk_buff *skb;
			int: 32;
			struct igb_rx_queue_stats rx_stats;
			struct u64_stats_sync rx_syncp;
			int: 32;
		};
	};
	struct xdp_rxq_info xdp_rxq;
};

struct igb_adapter;

struct igb_q_vector {
	struct igb_adapter *adapter;
	int cpu;
	u32 eims_value;
	u16 itr_val;
	u8 set_itr;
	void *itr_register;
	struct igb_ring_container rx;
	struct igb_ring_container tx;
	int: 32;
	struct napi_struct napi;
	struct callback_head rcu;
	char name[25];
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	struct igb_ring ring[0];
};

struct hwmon_buff;

struct igb_mac_addr;

struct igb_adapter {
	long unsigned int active_vlans[128];
	struct net_device *netdev;
	struct bpf_prog *xdp_prog;
	long unsigned int state;
	unsigned int flags;
	unsigned int num_q_vectors;
	struct msix_entry msix_entries[10];
	u32 rx_itr_setting;
	u32 tx_itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	u16 tx_work_limit;
	u32 tx_timeout_count;
	int num_tx_queues;
	struct igb_ring *tx_ring[16];
	int num_rx_queues;
	struct igb_ring *rx_ring[16];
	u32 max_frame_size;
	u32 min_frame_size;
	struct timer_list watchdog_timer;
	struct timer_list phy_info_timer;
	u16 mng_vlan_id;
	u32 bd_number;
	u32 wol;
	u32 en_mng_pt;
	u16 link_speed;
	u16 link_duplex;
	u8 *io_addr;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	bool fc_autoneg;
	u8 tx_timeout_factor;
	struct timer_list blink_timer;
	long unsigned int led_status;
	struct pci_dev *pdev;
	spinlock_t stats64_lock;
	int: 32;
	struct rtnl_link_stats64 stats64;
	struct e1000_hw___2 hw;
	struct e1000_hw_stats___2 stats;
	struct e1000_phy_info___2 phy_info;
	u32 test_icr;
	int: 32;
	int: 32;
	int: 32;
	struct igb_ring test_tx_ring;
	struct igb_ring test_rx_ring;
	int msg_enable;
	struct igb_q_vector *q_vector[8];
	u32 eims_enable_mask;
	u32 eims_other;
	u16 tx_ring_count;
	u16 rx_ring_count;
	unsigned int vfs_allocated_count;
	struct vf_data_storage *vf_data;
	int vf_rate_link_speed;
	u32 rss_queues;
	u32 wvbr;
	u32 *shadow_vfta;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	struct delayed_work ptp_overflow_work;
	struct work_struct ptp_tx_work;
	struct sk_buff *ptp_tx_skb;
	struct hwtstamp_config tstamp_config;
	long unsigned int ptp_tx_start;
	long unsigned int last_rx_ptp_check;
	long unsigned int last_rx_timestamp;
	unsigned int ptp_flags;
	spinlock_t tmreg_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	u32 rx_hwtstamp_cleared;
	bool pps_sys_wrap_on;
	struct ptp_pin_desc sdp_config[4];
	struct {
		struct timespec64 start;
		struct timespec64 period;
	} perout[2];
	char fw_version[32];
	struct hwmon_buff *igb_hwmon_buff;
	bool ets;
	struct i2c_algo_bit_data i2c_algo;
	struct i2c_adapter i2c_adap;
	struct i2c_client *i2c_client;
	u32 rss_indir_tbl_init;
	u8 rss_indir_tbl[128];
	long unsigned int link_check_timeout;
	int copper_tries;
	struct e1000_info___2 ei;
	u16 eee_advert;
	struct hlist_head nfc_filter_list;
	struct hlist_head cls_flower_list;
	unsigned int nfc_filter_count;
	spinlock_t nfc_lock;
	bool etype_bitmap[3];
	struct igb_mac_addr *mac_table;
	struct vf_mac_filter vf_macs;
	struct vf_mac_filter *vf_mac_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum e1000_ring_flags_t {
	IGB_RING_FLAG_RX_3K_BUFFER = 0,
	IGB_RING_FLAG_RX_BUILD_SKB_ENABLED = 1,
	IGB_RING_FLAG_RX_SCTP_CSUM = 2,
	IGB_RING_FLAG_RX_LB_VLAN_BSWAP = 3,
	IGB_RING_FLAG_TX_CTX_IDX = 4,
	IGB_RING_FLAG_TX_DETECT_HANG = 5,
};

struct hwmon_attr {
	struct device_attribute dev_attr;
	struct e1000_hw___2 *hw;
	struct e1000_thermal_diode_data *sensor;
	char name[12];
};

struct hwmon_buff {
	struct attribute_group group;
	const struct attribute_group *groups[2];
	struct attribute *attrs[13];
	struct hwmon_attr hwmon_list[12];
	unsigned int n_hwmon;
};

enum igb_filter_match_flags {
	IGB_FILTER_FLAG_ETHER_TYPE = 1,
	IGB_FILTER_FLAG_VLAN_TCI = 2,
	IGB_FILTER_FLAG_SRC_MAC_ADDR = 4,
	IGB_FILTER_FLAG_DST_MAC_ADDR = 8,
};

struct igb_nfc_input {
	u8 match_flags;
	__be16 etype;
	__be16 vlan_tci;
	u8 src_addr[6];
	u8 dst_addr[6];
};

struct igb_nfc_filter {
	struct hlist_node nfc_node;
	struct igb_nfc_input filter;
	long unsigned int cookie;
	u16 etype_reg_index;
	u16 sw_idx;
	u16 action;
};

struct igb_mac_addr {
	u8 addr[6];
	u8 queue;
	u8 state;
};

enum e1000_state_t___2 {
	__IGB_TESTING = 0,
	__IGB_RESETTING = 1,
	__IGB_DOWN = 2,
	__IGB_PTP_TX_IN_PROGRESS = 3,
};

enum igb_boards {
	board_82575 = 0,
};

enum queue_mode {
	QUEUE_MODE_STRICT_PRIORITY = 0,
	QUEUE_MODE_STREAM_RESERVATION = 1,
};

enum tx_queue_prio {
	TX_QUEUE_PRIO_HIGH = 0,
	TX_QUEUE_PRIO_LOW = 1,
};

struct igb_reg_info {
	u32 ofs;
	char *name;
};

struct my_u0___2 {
	u64 a;
	u64 b;
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

struct igb_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
};

enum igb_diagnostics_results {
	TEST_REG = 0,
	TEST_EEP = 1,
	TEST_IRQ = 2,
	TEST_LOOP = 3,
	TEST_LINK = 4,
};

struct igb_reg_test {
	u16 reg;
	u16 reg_offset;
	u16 array_len;
	u16 test_type;
	u32 mask;
	u32 write;
};

enum E1000_INVM_STRUCTURE_TYPE {
	E1000_INVM_UNINITIALIZED_STRUCTURE = 0,
	E1000_INVM_WORD_AUTOLOAD_STRUCTURE = 1,
	E1000_INVM_CSR_AUTOLOAD_STRUCTURE = 2,
	E1000_INVM_PHY_REGISTER_AUTOLOAD_STRUCTURE = 3,
	E1000_INVM_RSA_KEY_SHA256_STRUCTURE = 4,
	E1000_INVM_INVALIDATED_STRUCTURE = 15,
};

struct orion_mdio_dev {
	void *regs;
	struct clk *clk[4];
	int err_interrupt;
	wait_queue_head_t smi_busy_wait;
};

enum orion_mdio_bus_type {
	BUS_TYPE_SMI = 0,
	BUS_TYPE_XSMI = 1,
};

struct orion_mdio_ops {
	int (*is_done)(struct orion_mdio_dev *);
	unsigned int poll_interval_min;
	unsigned int poll_interval_max;
};

struct mv643xx_eth_shared_platform_data {
	struct mbus_dram_target_info *dram;
	int tx_csum_limit;
};

struct mv643xx_eth_platform_data {
	struct platform_device *shared;
	int port_number;
	int phy_addr;
	struct device_node *phy_node;
	u8 mac_addr[6];
	int speed;
	int duplex;
	int rx_queue_count;
	int tx_queue_count;
	int rx_queue_size;
	int tx_queue_size;
	long unsigned int rx_sram_addr;
	int rx_sram_size;
	long unsigned int tx_sram_addr;
	int tx_sram_size;
};

struct rx_desc {
	u32 cmd_sts;
	u16 buf_size;
	u16 byte_cnt;
	u32 buf_ptr;
	u32 next_desc_ptr;
};

struct tx_desc {
	u32 cmd_sts;
	u16 l4i_chk;
	u16 byte_cnt;
	u32 buf_ptr;
	u32 next_desc_ptr;
};

struct mv643xx_eth_shared_private {
	void *base;
	u32 win_protect;
	int extended_rx_coal_limit;
	int tx_bw_control;
	int tx_csum_limit;
	struct clk *clk;
};

struct mib_counters {
	u64 good_octets_received;
	u32 bad_octets_received;
	u32 internal_mac_transmit_err;
	u32 good_frames_received;
	u32 bad_frames_received;
	u32 broadcast_frames_received;
	u32 multicast_frames_received;
	u32 frames_64_octets;
	u32 frames_65_to_127_octets;
	u32 frames_128_to_255_octets;
	u32 frames_256_to_511_octets;
	u32 frames_512_to_1023_octets;
	u32 frames_1024_to_max_octets;
	u64 good_octets_sent;
	u32 good_frames_sent;
	u32 excessive_collision;
	u32 multicast_frames_sent;
	u32 broadcast_frames_sent;
	u32 unrec_mac_control_received;
	u32 fc_sent;
	u32 good_fc_received;
	u32 bad_fc_received;
	u32 undersize_received;
	u32 fragments_received;
	u32 oversize_received;
	u32 jabber_received;
	u32 mac_receive_error;
	u32 bad_crc_event;
	u32 collision;
	u32 late_collision;
	u32 rx_discard;
	u32 rx_overrun;
};

struct rx_queue {
	int index;
	int rx_ring_size;
	int rx_desc_count;
	int rx_curr_desc;
	int rx_used_desc;
	struct rx_desc *rx_desc_area;
	dma_addr_t rx_desc_dma;
	int rx_desc_area_size;
	struct sk_buff **rx_skb;
};

struct tx_queue {
	int index;
	int tx_ring_size;
	int tx_desc_count;
	int tx_curr_desc;
	int tx_used_desc;
	int tx_stop_threshold;
	int tx_wake_threshold;
	char *tso_hdrs;
	dma_addr_t tso_hdrs_dma;
	struct tx_desc *tx_desc_area;
	char *tx_desc_mapping;
	dma_addr_t tx_desc_dma;
	int tx_desc_area_size;
	struct sk_buff_head tx_skb;
	long unsigned int tx_packets;
	long unsigned int tx_bytes;
	long unsigned int tx_dropped;
};

struct mv643xx_eth_private {
	struct mv643xx_eth_shared_private *shared;
	void *base;
	int port_num;
	struct net_device *dev;
	struct timer_list mib_counters_timer;
	spinlock_t mib_counters_lock;
	struct mib_counters mib_counters;
	struct work_struct tx_timeout_task;
	struct napi_struct napi;
	u32 int_mask;
	u8 oom;
	u8 work_link;
	u8 work_tx;
	u8 work_tx_end;
	u8 work_rx;
	u8 work_rx_refill;
	int skb_size;
	int rx_ring_size;
	long unsigned int rx_desc_sram_addr;
	int rx_desc_sram_size;
	int rxq_count;
	struct timer_list rx_oom;
	struct rx_queue rxq[8];
	int tx_ring_size;
	long unsigned int tx_desc_sram_addr;
	int tx_desc_sram_size;
	int txq_count;
	struct tx_queue txq[8];
	struct clk *clk;
	unsigned int t_clk;
	int: 32;
};

struct mv643xx_eth_stats {
	char stat_string[32];
	int sizeof_stat;
	int netdev_off;
	int mp_off;
};

struct xdp_frame_bulk {
	int count;
	void *xa;
	void *q[16];
};

struct hwbm_pool {
	int size;
	int frag_size;
	int buf_num;
	int (*construct)(struct hwbm_pool *, void *);
	struct mutex buf_lock;
	void *priv;
};

enum mvneta_bm_type {
	MVNETA_BM_FREE = 0,
	MVNETA_BM_LONG = 1,
	MVNETA_BM_SHORT = 2,
};

struct mvneta_bm_pool;

struct mvneta_bm {
	void *reg_base;
	struct clk *clk;
	struct platform_device *pdev;
	struct gen_pool *bppi_pool;
	void *bppi_virt_addr;
	dma_addr_t bppi_phys_addr;
	struct mvneta_bm_pool *bm_pools;
};

struct mvneta_bm_pool {
	struct hwbm_pool hwbm_pool;
	u8 id;
	enum mvneta_bm_type type;
	int pkt_size;
	u32 buf_size;
	u32 *virt_addr;
	dma_addr_t phys_addr;
	u8 port_map;
	struct mvneta_bm *priv;
};

struct pp_alloc_cache {
	u32 count;
	void *cache[128];
};

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct pp_alloc_cache alloc;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct ptr_ring ring;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum {
	ETHTOOL_STAT_EEE_WAKEUP = 0,
	ETHTOOL_STAT_SKB_ALLOC_ERR = 1,
	ETHTOOL_STAT_REFILL_ERR = 2,
	ETHTOOL_XDP_REDIRECT = 3,
	ETHTOOL_XDP_PASS = 4,
	ETHTOOL_XDP_DROP = 5,
	ETHTOOL_XDP_TX = 6,
	ETHTOOL_XDP_TX_ERR = 7,
	ETHTOOL_XDP_XMIT = 8,
	ETHTOOL_XDP_XMIT_ERR = 9,
	ETHTOOL_MAX_STATS = 10,
};

struct mvneta_statistic {
	short unsigned int offset;
	short unsigned int type;
	const char name[32];
};

struct mvneta_stats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	u64 xdp_redirect;
	u64 xdp_pass;
	u64 xdp_drop;
	u64 xdp_xmit;
	u64 xdp_xmit_err;
	u64 xdp_tx;
	u64 xdp_tx_err;
};

struct mvneta_ethtool_stats {
	struct mvneta_stats ps;
	u64 skb_alloc_error;
	u64 refill_error;
};

struct mvneta_pcpu_stats {
	struct u64_stats_sync syncp;
	int: 32;
	struct mvneta_ethtool_stats es;
	u64 rx_dropped;
	u64 rx_errors;
};

struct mvneta_port;

struct mvneta_pcpu_port {
	struct mvneta_port *pp;
	int: 32;
	struct napi_struct napi;
	u32 cause_rx_tx;
	int: 32;
};

struct mvneta_rx_queue;

struct mvneta_tx_queue;

struct mvneta_port {
	u8 id;
	struct mvneta_pcpu_port *ports;
	struct mvneta_pcpu_stats *stats;
	long unsigned int state;
	int pkt_size;
	void *base;
	struct mvneta_rx_queue *rxqs;
	struct mvneta_tx_queue *txqs;
	struct net_device *dev;
	struct hlist_node node_online;
	struct hlist_node node_dead;
	int rxq_def;
	spinlock_t lock;
	bool is_stopped;
	u32 cause_rx_tx;
	int: 32;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct clk *clk;
	struct clk *clk_bus;
	u8 mcast_count[256];
	u16 tx_ring_size;
	u16 rx_ring_size;
	phy_interface_t phy_interface;
	struct device_node *dn;
	unsigned int tx_csum_limit;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	struct phy *comphy;
	struct mvneta_bm *bm_priv;
	struct mvneta_bm_pool *pool_long;
	struct mvneta_bm_pool *pool_short;
	int bm_win_id;
	bool eee_enabled;
	bool eee_active;
	bool tx_lpi_enabled;
	u64 ethtool_stats[42];
	u32 indir[1];
	bool neta_armada3700;
	u16 rx_offset_correction;
	const struct mbus_dram_target_info *dram_target_info;
	int: 32;
};

enum {
	__MVNETA_DOWN = 0,
};

struct mvneta_rx_desc;

struct mvneta_rx_queue {
	u8 id;
	int size;
	u32 pkts_coal;
	u32 time_coal;
	struct page_pool *page_pool;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xdp_rxq_info xdp_rxq;
	void **buf_virt_addr;
	struct mvneta_rx_desc *descs;
	dma_addr_t descs_phys;
	int last_desc;
	int next_desc_to_proc;
	int first_to_refill;
	u32 refill_num;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct mvneta_tx_buf;

struct mvneta_tx_desc;

struct mvneta_tx_queue {
	u8 id;
	int size;
	int count;
	int pending;
	int tx_stop_threshold;
	int tx_wake_threshold;
	struct mvneta_tx_buf *buf;
	int txq_put_index;
	int txq_get_index;
	u32 done_pkts_coal;
	struct mvneta_tx_desc *descs;
	dma_addr_t descs_phys;
	int last_desc;
	int next_desc_to_proc;
	char *tso_hdrs;
	dma_addr_t tso_hdrs_phys;
	cpumask_t affinity_mask;
};

struct mvneta_tx_desc {
	u32 command;
	u16 reserved1;
	u16 data_size;
	u32 buf_phys_addr;
	u32 reserved2;
	u32 reserved3[4];
};

struct mvneta_rx_desc {
	u32 status;
	u16 reserved1;
	u16 data_size;
	u32 buf_phys_addr;
	u32 reserved2;
	u32 buf_cookie;
	u16 reserved3;
	u16 reserved4;
	u32 reserved5;
	u32 reserved6;
};

enum mvneta_tx_buf_type {
	MVNETA_TYPE_SKB = 0,
	MVNETA_TYPE_XDP_TX = 1,
	MVNETA_TYPE_XDP_NDO = 2,
};

struct mvneta_tx_buf {
	enum mvneta_tx_buf_type type;
	union {
		struct xdp_frame *xdpf;
		struct sk_buff *skb;
	};
};

enum {
	IF_PORT_UNKNOWN = 0,
	IF_PORT_10BASE2 = 1,
	IF_PORT_10BASET = 2,
	IF_PORT_AUI = 3,
	IF_PORT_100BASET = 4,
	IF_PORT_100BASETX = 5,
	IF_PORT_100BASEFX = 6,
};

struct ks8851_rxctrl {
	u16 mchash[4];
	u16 rxcr1;
	u16 rxcr2;
};

union ks8851_tx_hdr {
	u8 txb[6];
	__le16 txw[3];
};

struct ks8851_net {
	struct net_device *netdev;
	spinlock_t statelock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union ks8851_tx_hdr txh;
	u8 rxd[8];
	u8 txd[8];
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 msg_enable;
	u16 tx_space;
	u8 fid;
	u16 rc_ier;
	u16 rc_rxqcr;
	u16 rc_ccr;
	struct mii_if_info mii;
	struct ks8851_rxctrl rxctrl;
	struct work_struct rxctrl_work;
	struct sk_buff_head txq;
	struct eeprom_93cx6 eeprom;
	struct regulator *vdd_reg;
	struct regulator *vdd_io;
	int gpio;
	void (*lock)(struct ks8851_net *, long unsigned int *);
	void (*unlock)(struct ks8851_net *, long unsigned int *);
	unsigned int (*rdreg16)(struct ks8851_net *, unsigned int);
	void (*wrreg16)(struct ks8851_net *, unsigned int, unsigned int);
	void (*rdfifo)(struct ks8851_net *, u8 *, unsigned int);
	void (*wrfifo)(struct ks8851_net *, struct sk_buff *, bool);
	netdev_tx_t (*start_xmit)(struct sk_buff *, struct net_device *);
	void (*rx_skb)(struct ks8851_net *, struct sk_buff *);
	void (*flush_tx_work)(struct ks8851_net *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ks8851_net_spi {
	struct ks8851_net ks8851;
	struct mutex lock;
	struct work_struct tx_work;
	struct spi_device *spidev;
	struct spi_message spi_msg1;
	struct spi_message spi_msg2;
	struct spi_transfer spi_xfer1;
	struct spi_transfer spi_xfer2[2];
	int: 32;
	int: 32;
};

struct vlan_ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

enum mac_version {
	RTL_GIGA_MAC_VER_02 = 0,
	RTL_GIGA_MAC_VER_03 = 1,
	RTL_GIGA_MAC_VER_04 = 2,
	RTL_GIGA_MAC_VER_05 = 3,
	RTL_GIGA_MAC_VER_06 = 4,
	RTL_GIGA_MAC_VER_07 = 5,
	RTL_GIGA_MAC_VER_08 = 6,
	RTL_GIGA_MAC_VER_09 = 7,
	RTL_GIGA_MAC_VER_10 = 8,
	RTL_GIGA_MAC_VER_11 = 9,
	RTL_GIGA_MAC_VER_12 = 10,
	RTL_GIGA_MAC_VER_13 = 11,
	RTL_GIGA_MAC_VER_14 = 12,
	RTL_GIGA_MAC_VER_16 = 13,
	RTL_GIGA_MAC_VER_17 = 14,
	RTL_GIGA_MAC_VER_18 = 15,
	RTL_GIGA_MAC_VER_19 = 16,
	RTL_GIGA_MAC_VER_20 = 17,
	RTL_GIGA_MAC_VER_21 = 18,
	RTL_GIGA_MAC_VER_22 = 19,
	RTL_GIGA_MAC_VER_23 = 20,
	RTL_GIGA_MAC_VER_24 = 21,
	RTL_GIGA_MAC_VER_25 = 22,
	RTL_GIGA_MAC_VER_26 = 23,
	RTL_GIGA_MAC_VER_27 = 24,
	RTL_GIGA_MAC_VER_28 = 25,
	RTL_GIGA_MAC_VER_29 = 26,
	RTL_GIGA_MAC_VER_30 = 27,
	RTL_GIGA_MAC_VER_31 = 28,
	RTL_GIGA_MAC_VER_32 = 29,
	RTL_GIGA_MAC_VER_33 = 30,
	RTL_GIGA_MAC_VER_34 = 31,
	RTL_GIGA_MAC_VER_35 = 32,
	RTL_GIGA_MAC_VER_36 = 33,
	RTL_GIGA_MAC_VER_37 = 34,
	RTL_GIGA_MAC_VER_38 = 35,
	RTL_GIGA_MAC_VER_39 = 36,
	RTL_GIGA_MAC_VER_40 = 37,
	RTL_GIGA_MAC_VER_41 = 38,
	RTL_GIGA_MAC_VER_42 = 39,
	RTL_GIGA_MAC_VER_43 = 40,
	RTL_GIGA_MAC_VER_44 = 41,
	RTL_GIGA_MAC_VER_45 = 42,
	RTL_GIGA_MAC_VER_46 = 43,
	RTL_GIGA_MAC_VER_47 = 44,
	RTL_GIGA_MAC_VER_48 = 45,
	RTL_GIGA_MAC_VER_49 = 46,
	RTL_GIGA_MAC_VER_50 = 47,
	RTL_GIGA_MAC_VER_51 = 48,
	RTL_GIGA_MAC_VER_52 = 49,
	RTL_GIGA_MAC_VER_60 = 50,
	RTL_GIGA_MAC_VER_61 = 51,
	RTL_GIGA_MAC_VER_63 = 52,
	RTL_GIGA_MAC_NONE = 53,
};

struct rtl8169_private;

typedef void (*rtl_fw_write_t)(struct rtl8169_private *, int, int);

struct ring_info {
	struct sk_buff *skb;
	u32 len;
};

struct rtl8169_tc_offsets {
	bool inited;
	int: 24;
	int: 32;
	__le64 tx_errors;
	__le32 tx_multi_collision;
	__le16 tx_aborted;
	__le16 rx_missed;
};

struct TxDesc;

struct RxDesc;

struct rtl8169_counters;

struct rtl_fw;

struct rtl8169_private {
	void *mmio_addr;
	struct pci_dev *pci_dev;
	struct net_device *dev;
	struct phy_device *phydev;
	struct napi_struct napi;
	enum mac_version mac_version;
	u32 cur_rx;
	u32 cur_tx;
	u32 dirty_tx;
	struct TxDesc *TxDescArray;
	struct RxDesc *RxDescArray;
	dma_addr_t TxPhyAddr;
	dma_addr_t RxPhyAddr;
	struct page *Rx_databuff[256];
	struct ring_info tx_skb[256];
	u16 cp_cmd;
	u32 irq_mask;
	struct clk *clk;
	struct {
		long unsigned int flags[1];
		struct work_struct work;
	} wk;
	unsigned int supports_gmii: 1;
	unsigned int aspm_manageable: 1;
	dma_addr_t counters_phys_addr;
	struct rtl8169_counters *counters;
	int: 32;
	struct rtl8169_tc_offsets tc_offset;
	u32 saved_wolopts;
	int eee_adv;
	const char *fw_name;
	struct rtl_fw *rtl_fw;
	u32 ocp_base;
	int: 32;
};

typedef int (*rtl_fw_read_t)(struct rtl8169_private *, int);

struct rtl_fw_phy_action {
	__le32 *code;
	size_t size;
};

struct rtl_fw {
	rtl_fw_write_t phy_write;
	rtl_fw_read_t phy_read;
	rtl_fw_write_t mac_mcu_write;
	rtl_fw_read_t mac_mcu_read;
	const struct firmware *fw;
	const char *fw_name;
	struct device *dev;
	char version[32];
	struct rtl_fw_phy_action phy_action;
};

enum rtl_registers {
	MAC0 = 0,
	MAC4 = 4,
	MAR0 = 8,
	CounterAddrLow = 16,
	CounterAddrHigh = 20,
	TxDescStartAddrLow = 32,
	TxDescStartAddrHigh = 36,
	TxHDescStartAddrLow = 40,
	TxHDescStartAddrHigh = 44,
	FLASH = 48,
	ERSR = 54,
	ChipCmd = 55,
	TxPoll = 56,
	IntrMask = 60,
	IntrStatus = 62,
	TxConfig = 64,
	RxConfig = 68,
	Cfg9346 = 80,
	Config0 = 81,
	Config1 = 82,
	Config2 = 83,
	Config3 = 84,
	Config4 = 85,
	Config5 = 86,
	PHYAR = 96,
	PHYstatus = 108,
	RxMaxSize = 218,
	CPlusCmd = 224,
	IntrMitigate = 226,
	RxDescAddrLow = 228,
	RxDescAddrHigh = 232,
	EarlyTxThres = 236,
	MaxTxPacketSize = 236,
	FuncEvent = 240,
	FuncEventMask = 244,
	FuncPresetState = 248,
	IBCR0 = 248,
	IBCR2 = 249,
	IBIMR0 = 250,
	IBISR0 = 251,
	FuncForceEvent = 252,
};

enum rtl8168_8101_registers {
	CSIDR = 100,
	CSIAR = 104,
	PMCH = 111,
	EPHYAR = 128,
	DLLPR = 208,
	DBG_REG = 209,
	TWSI = 210,
	MCU = 211,
	EFUSEAR = 220,
	MISC_1 = 242,
};

enum rtl8168_registers {
	LED_FREQ = 26,
	EEE_LED = 27,
	ERIDR = 112,
	ERIAR = 116,
	EPHY_RXER_NUM = 124,
	OCPDR = 176,
	OCPAR = 180,
	GPHY_OCP = 184,
	RDSAR1 = 208,
	MISC = 240,
};

enum rtl8125_registers {
	IntrMask_8125 = 56,
	IntrStatus_8125 = 60,
	TxPoll_8125 = 144,
	MAC0_BKP = 6624,
	EEE_TXIDLE_TIMER_8125 = 24648,
};

enum rtl_register_content {
	SYSErr = 32768,
	PCSTimeout = 16384,
	SWInt = 256,
	TxDescUnavail = 128,
	RxFIFOOver = 64,
	LinkChg = 32,
	RxOverflow = 16,
	TxErr = 8,
	TxOK = 4,
	RxErr = 2,
	RxOK = 1,
	RxRWT = 4194304,
	RxRES = 2097152,
	RxRUNT = 1048576,
	RxCRC = 524288,
	StopReq = 128,
	CmdReset = 16,
	CmdRxEnb = 8,
	CmdTxEnb = 4,
	RxBufEmpty = 1,
	HPQ = 128,
	NPQ = 64,
	FSWInt = 1,
	Cfg9346_Lock = 0,
	Cfg9346_Unlock = 192,
	AcceptErr = 32,
	AcceptRunt = 16,
	AcceptBroadcast = 8,
	AcceptMulticast = 4,
	AcceptMyPhys = 2,
	AcceptAllPhys = 1,
	TxInterFrameGapShift = 24,
	TxDMAShift = 8,
	LEDS1 = 128,
	LEDS0 = 64,
	Speed_down = 16,
	MEMMAP = 8,
	IOMAP = 4,
	VPD = 2,
	PMEnable = 1,
	ClkReqEn = 128,
	MSIEnable = 32,
	PCI_Clock_66MHz = 1,
	PCI_Clock_33MHz = 0,
	MagicPacket = 32,
	LinkUp = 16,
	Jumbo_En0 = 4,
	Rdy_to_L23 = 2,
	Beacon_en = 1,
	Jumbo_En1 = 2,
	BWF = 64,
	MWF = 32,
	UWF = 16,
	Spi_en = 8,
	LanWake = 2,
	PMEStatus = 1,
	ASPM_en = 1,
	EnableBist = 32768,
	Mac_dbgo_oe = 16384,
	EnAnaPLL = 16384,
	Normal_mode = 8192,
	Force_half_dup = 4096,
	Force_rxflow_en = 2048,
	Force_txflow_en = 1024,
	Cxpl_dbg_sel = 512,
	ASF = 256,
	PktCntrDisable = 128,
	Mac_dbgo_sel = 28,
	RxVlan = 64,
	RxChkSum = 32,
	PCIDAC = 16,
	PCIMulRW = 8,
	TBI_Enable = 128,
	TxFlowCtrl = 64,
	RxFlowCtrl = 32,
	_1000bpsF = 16,
	_100bps = 8,
	_10bps = 4,
	LinkStatus = 2,
	FullDup = 1,
	CounterReset = 1,
	CounterDump = 8,
	MagicPacket_v2 = 65536,
};

enum rtl_desc_bit {
	DescOwn = 2147483648,
	RingEnd = 1073741824,
	FirstFrag = 536870912,
	LastFrag = 268435456,
};

enum rtl_tx_desc_bit {
	TD_LSO = 134217728,
	TxVlanTag = 131072,
};

enum rtl_tx_desc_bit_0 {
	TD0_TCP_CS = 65536,
	TD0_UDP_CS = 131072,
	TD0_IP_CS = 262144,
};

enum rtl_tx_desc_bit_1 {
	TD1_GTSENV4 = 67108864,
	TD1_GTSENV6 = 33554432,
	TD1_IPv6_CS = 268435456,
	TD1_IPv4_CS = 536870912,
	TD1_TCP_CS = 1073741824,
	TD1_UDP_CS = 2147483648,
};

enum rtl_rx_desc_bit {
	PID1 = 262144,
	PID0 = 131072,
	IPFail = 65536,
	UDPFail = 32768,
	TCPFail = 16384,
	RxVlanTag = 65536,
};

struct TxDesc {
	__le32 opts1;
	__le32 opts2;
	__le64 addr;
};

struct RxDesc {
	__le32 opts1;
	__le32 opts2;
	__le64 addr;
};

struct rtl8169_counters {
	__le64 tx_packets;
	__le64 rx_packets;
	__le64 tx_errors;
	__le32 rx_errors;
	__le16 rx_missed;
	__le16 align_errors;
	__le32 tx_one_collision;
	__le32 tx_multi_collision;
	__le64 rx_unicast;
	__le64 rx_broadcast;
	__le32 rx_multicast;
	__le16 tx_aborted;
	__le16 tx_underun;
};

enum rtl_flag {
	RTL_FLAG_TASK_ENABLED = 0,
	RTL_FLAG_TASK_RESET_PENDING = 1,
	RTL_FLAG_MAX = 2,
};

typedef void (*rtl_generic_fct)(struct rtl8169_private *);

struct rtl_cond {
	bool (*check)(struct rtl8169_private *);
	const char *msg;
};

struct rtl_coalesce_info {
	u32 speed;
	u32 scale_nsecs[4];
};

struct ephy_info {
	unsigned int offset;
	u16 mask;
	u16 bits;
};

struct rtl_mac_info {
	u16 mask;
	u16 val;
	enum mac_version ver;
};

enum rtl_fw_opcode {
	PHY_READ = 0,
	PHY_DATA_OR = 1,
	PHY_DATA_AND = 2,
	PHY_BJMPN = 3,
	PHY_MDIO_CHG = 4,
	PHY_CLEAR_READCOUNT = 7,
	PHY_WRITE = 8,
	PHY_READCOUNT_EQ_SKIP = 9,
	PHY_COMP_EQ_SKIPN = 10,
	PHY_COMP_NEQ_SKIPN = 11,
	PHY_WRITE_PREVIOUS = 12,
	PHY_SKIPN = 13,
	PHY_DELAY_MS = 14,
};

struct fw_info {
	u32 magic;
	char version[32];
	__le32 fw_start;
	__le32 fw_len;
	u8 chksum;
} __attribute__((packed));

typedef void (*rtl_phy_cfg_fct)(struct rtl8169_private *, struct phy_device *);

struct phy_reg {
	u16 reg;
	u16 val;
};

struct sh_eth_plat_data {
	int phy;
	int phy_irq;
	phy_interface_t phy_interface;
	void (*set_mdio_gate)(void *);
	unsigned char mac_addr[6];
	unsigned int no_ether_link: 1;
	unsigned int ether_link_active_low: 1;
};

enum {
	EDSR = 0,
	EDMR = 1,
	EDTRR = 2,
	EDRRR = 3,
	EESR = 4,
	EESIPR = 5,
	TDLAR = 6,
	TDFAR = 7,
	TDFXR = 8,
	TDFFR = 9,
	RDLAR = 10,
	RDFAR = 11,
	RDFXR = 12,
	RDFFR = 13,
	TRSCER = 14,
	RMFCR = 15,
	TFTR = 16,
	FDR = 17,
	RMCR = 18,
	EDOCR = 19,
	TFUCR = 20,
	RFOCR = 21,
	RMIIMODE = 22,
	FCFTR = 23,
	RPADIR = 24,
	TRIMD = 25,
	RBWAR = 26,
	TBRAR = 27,
	ECMR = 28,
	ECSR = 29,
	ECSIPR = 30,
	PIR = 31,
	PSR = 32,
	RDMLR = 33,
	PIPR = 34,
	RFLR = 35,
	IPGR = 36,
	APR = 37,
	MPR = 38,
	PFTCR = 39,
	PFRCR = 40,
	RFCR = 41,
	RFCF = 42,
	TPAUSER = 43,
	TPAUSECR = 44,
	BCFR = 45,
	BCFRR = 46,
	GECMR = 47,
	BCULR = 48,
	MAHR = 49,
	MALR = 50,
	TROCR = 51,
	CDCR = 52,
	LCCR = 53,
	CNDCR = 54,
	CEFCR = 55,
	FRECR = 56,
	TSFRCR = 57,
	TLFRCR = 58,
	CERCR = 59,
	CEECR = 60,
	MAFCR = 61,
	RTRATE = 62,
	CSMR = 63,
	RMII_MII = 64,
	ARSTR = 65,
	TSU_CTRST = 66,
	TSU_FWEN0 = 67,
	TSU_FWEN1 = 68,
	TSU_FCM = 69,
	TSU_BSYSL0 = 70,
	TSU_BSYSL1 = 71,
	TSU_PRISL0 = 72,
	TSU_PRISL1 = 73,
	TSU_FWSL0 = 74,
	TSU_FWSL1 = 75,
	TSU_FWSLC = 76,
	TSU_QTAG0 = 77,
	TSU_QTAG1 = 78,
	TSU_QTAGM0 = 79,
	TSU_QTAGM1 = 80,
	TSU_FWSR = 81,
	TSU_FWINMK = 82,
	TSU_ADQT0 = 83,
	TSU_ADQT1 = 84,
	TSU_VTAG0 = 85,
	TSU_VTAG1 = 86,
	TSU_ADSBSY = 87,
	TSU_TEN = 88,
	TSU_POST1 = 89,
	TSU_POST2 = 90,
	TSU_POST3 = 91,
	TSU_POST4 = 92,
	TSU_ADRH0 = 93,
	TXNLCR0 = 94,
	TXALCR0 = 95,
	RXNLCR0 = 96,
	RXALCR0 = 97,
	FWNLCR0 = 98,
	FWALCR0 = 99,
	TXNLCR1 = 100,
	TXALCR1 = 101,
	RXNLCR1 = 102,
	RXALCR1 = 103,
	FWNLCR1 = 104,
	FWALCR1 = 105,
	SH_ETH_MAX_REGISTER_OFFSET = 106,
};

enum {
	SH_ETH_REG_GIGABIT = 0,
	SH_ETH_REG_FAST_RCAR = 1,
	SH_ETH_REG_FAST_SH4 = 2,
	SH_ETH_REG_FAST_SH3_SH2 = 3,
};

enum EDSR_BIT {
	EDSR_ENT = 1,
	EDSR_ENR = 2,
};

enum GECMR_BIT {
	GECMR_10 = 0,
	GECMR_100 = 4,
	GECMR_1000 = 1,
};

enum DMAC_M_BIT {
	EDMR_NBST = 128,
	EDMR_EL = 64,
	EDMR_DL1 = 32,
	EDMR_DL0 = 16,
	EDMR_SRST_GETHER = 3,
	EDMR_SRST_ETHER = 1,
};

enum DMAC_T_BIT {
	EDTRR_TRNS_GETHER = 3,
	EDTRR_TRNS_ETHER = 1,
};

enum EDRRR_R_BIT {
	EDRRR_R = 1,
};

enum TPAUSER_BIT {
	TPAUSER_TPAUSE = 65535,
	TPAUSER_UNLIMITED = 0,
};

enum PIR_BIT {
	PIR_MDI = 8,
	PIR_MDO = 4,
	PIR_MMD = 2,
	PIR_MDC = 1,
};

enum PHY_STATUS_BIT {
	PHY_ST_LINK = 1,
};

enum EESR_BIT {
	EESR_TWB1 = 2147483648,
	EESR_TWB = 1073741824,
	EESR_TC1 = 536870912,
	EESR_TUC = 268435456,
	EESR_ROC = 134217728,
	EESR_TABT = 67108864,
	EESR_RABT = 33554432,
	EESR_RFRMER = 16777216,
	EESR_ADE = 8388608,
	EESR_ECI = 4194304,
	EESR_FTC = 2097152,
	EESR_TDE = 1048576,
	EESR_TFE = 524288,
	EESR_FRC = 262144,
	EESR_RDE = 131072,
	EESR_RFE = 65536,
	EESR_CND = 2048,
	EESR_DLC = 1024,
	EESR_CD = 512,
	EESR_TRO = 256,
	EESR_RMAF = 128,
	EESR_CEEF = 64,
	EESR_CELF = 32,
	EESR_RRF = 16,
	EESR_RTLF = 8,
	EESR_RTSF = 4,
	EESR_PRE = 2,
	EESR_CERF = 1,
};

enum EESIPR_BIT {
	EESIPR_TWB1IP = 2147483648,
	EESIPR_TWBIP = 1073741824,
	EESIPR_TC1IP = 536870912,
	EESIPR_TUCIP = 268435456,
	EESIPR_ROCIP = 134217728,
	EESIPR_TABTIP = 67108864,
	EESIPR_RABTIP = 33554432,
	EESIPR_RFCOFIP = 16777216,
	EESIPR_ADEIP = 8388608,
	EESIPR_ECIIP = 4194304,
	EESIPR_FTCIP = 2097152,
	EESIPR_TDEIP = 1048576,
	EESIPR_TFUFIP = 524288,
	EESIPR_FRIP = 262144,
	EESIPR_RDEIP = 131072,
	EESIPR_RFOFIP = 65536,
	EESIPR_CNDIP = 2048,
	EESIPR_DLCIP = 1024,
	EESIPR_CDIP = 512,
	EESIPR_TROIP = 256,
	EESIPR_RMAFIP = 128,
	EESIPR_CEEFIP = 64,
	EESIPR_CELFIP = 32,
	EESIPR_RRFIP = 16,
	EESIPR_RTLFIP = 8,
	EESIPR_RTSFIP = 4,
	EESIPR_PREIP = 2,
	EESIPR_CERFIP = 1,
};

enum RD_STS_BIT {
	RD_RACT = 2147483648,
	RD_RDLE = 1073741824,
	RD_RFP1 = 536870912,
	RD_RFP0 = 268435456,
	RD_RFE = 134217728,
	RD_RFS10 = 512,
	RD_RFS9 = 256,
	RD_RFS8 = 128,
	RD_RFS7 = 64,
	RD_RFS6 = 32,
	RD_RFS5 = 16,
	RD_RFS4 = 8,
	RD_RFS3 = 4,
	RD_RFS2 = 2,
	RD_RFS1 = 1,
};

enum RD_LEN_BIT {
	RD_RFL = 65535,
	RD_RBL = 4294901760,
};

enum FCFTR_BIT {
	FCFTR_RFF2 = 262144,
	FCFTR_RFF1 = 131072,
	FCFTR_RFF0 = 65536,
	FCFTR_RFD2 = 4,
	FCFTR_RFD1 = 2,
	FCFTR_RFD0 = 1,
};

enum TD_STS_BIT {
	TD_TACT = 2147483648,
	TD_TDLE = 1073741824,
	TD_TFP1 = 536870912,
	TD_TFP0 = 268435456,
	TD_TFE = 134217728,
	TD_TWBI = 67108864,
};

enum RMCR_BIT {
	RMCR_RNC = 1,
};

enum FELIC_MODE_BIT {
	ECMR_TRCCM = 67108864,
	ECMR_RCSC = 8388608,
	ECMR_DPAD = 2097152,
	ECMR_RZPF = 1048576,
	ECMR_ZPF = 524288,
	ECMR_PFR = 262144,
	ECMR_RXF = 131072,
	ECMR_TXF = 65536,
	ECMR_MCT = 8192,
	ECMR_PRCEF = 4096,
	ECMR_MPDE = 512,
	ECMR_RE = 64,
	ECMR_TE = 32,
	ECMR_RTM = 16,
	ECMR_ILB = 8,
	ECMR_ELB = 4,
	ECMR_DM = 2,
	ECMR_PRM = 1,
};

enum ECSR_STATUS_BIT {
	ECSR_BRCRX = 32,
	ECSR_PSRTO = 16,
	ECSR_LCHNG = 4,
	ECSR_MPD = 2,
	ECSR_ICD = 1,
};

enum ECSIPR_STATUS_MASK_BIT {
	ECSIPR_BRCRXIP = 32,
	ECSIPR_PSRTOIP = 16,
	ECSIPR_LCHNGIP = 4,
	ECSIPR_MPDIP = 2,
	ECSIPR_ICDIP = 1,
};

enum DESC_I_BIT {
	DESC_I_TINT4 = 2048,
	DESC_I_TINT3 = 1024,
	DESC_I_TINT2 = 512,
	DESC_I_TINT1 = 256,
	DESC_I_RINT8 = 128,
	DESC_I_RINT5 = 16,
	DESC_I_RINT4 = 8,
	DESC_I_RINT3 = 4,
	DESC_I_RINT2 = 2,
	DESC_I_RINT1 = 1,
};

enum ARSTR_BIT {
	ARSTR_ARST = 1,
};

enum TSU_ADSBSY_BIT {
	TSU_ADSBSY_0 = 1,
};

enum TSU_FWSLC_BIT {
	TSU_FWSLC_POSTENU = 8192,
	TSU_FWSLC_POSTENL = 4096,
	TSU_FWSLC_CAMSEL03 = 128,
	TSU_FWSLC_CAMSEL02 = 64,
	TSU_FWSLC_CAMSEL01 = 32,
	TSU_FWSLC_CAMSEL00 = 16,
	TSU_FWSLC_CAMSEL13 = 8,
	TSU_FWSLC_CAMSEL12 = 4,
	TSU_FWSLC_CAMSEL11 = 2,
	TSU_FWSLC_CAMSEL10 = 1,
};

struct sh_eth_txdesc {
	u32 status;
	u32 len;
	u32 addr;
	u32 pad0;
};

struct sh_eth_rxdesc {
	u32 status;
	u32 len;
	u32 addr;
	u32 pad0;
};

struct sh_eth_cpu_data {
	int (*soft_reset)(struct net_device *);
	void (*chip_reset)(struct net_device *);
	void (*set_duplex)(struct net_device *);
	void (*set_rate)(struct net_device *);
	int register_type;
	u32 edtrr_trns;
	u32 eesipr_value;
	u32 ecsr_value;
	u32 ecsipr_value;
	u32 fdr_value;
	u32 fcftr_value;
	u32 tx_check;
	u32 eesr_err_check;
	u32 trscer_err_mask;
	long unsigned int irq_flags;
	unsigned int no_psr: 1;
	unsigned int apr: 1;
	unsigned int mpr: 1;
	unsigned int tpauser: 1;
	unsigned int gecmr: 1;
	unsigned int bculr: 1;
	unsigned int tsu: 1;
	unsigned int hw_swap: 1;
	unsigned int nbst: 1;
	unsigned int rpadir: 1;
	unsigned int no_trimd: 1;
	unsigned int no_ade: 1;
	unsigned int no_xdfar: 1;
	unsigned int xdfar_rw: 1;
	unsigned int csmr: 1;
	unsigned int rx_csum: 1;
	unsigned int select_mii: 1;
	unsigned int rmiimode: 1;
	unsigned int rtrate: 1;
	unsigned int magic: 1;
	unsigned int no_tx_cntrs: 1;
	unsigned int cexcr: 1;
	unsigned int dual_port: 1;
};

struct sh_eth_private {
	struct platform_device *pdev;
	struct sh_eth_cpu_data *cd;
	const u16 *reg_offset;
	void *addr;
	void *tsu_addr;
	struct clk *clk;
	u32 num_rx_ring;
	u32 num_tx_ring;
	dma_addr_t rx_desc_dma;
	dma_addr_t tx_desc_dma;
	struct sh_eth_rxdesc *rx_ring;
	struct sh_eth_txdesc *tx_ring;
	struct sk_buff **rx_skbuff;
	struct sk_buff **tx_skbuff;
	spinlock_t lock;
	u32 cur_rx;
	u32 dirty_rx;
	u32 cur_tx;
	u32 dirty_tx;
	u32 rx_buf_sz;
	struct napi_struct napi;
	bool irq_enabled;
	u32 phy_id;
	struct mii_bus *mii_bus;
	int link;
	phy_interface_t phy_interface;
	int msg_enable;
	int speed;
	int duplex;
	int port;
	int vlan_num_ids;
	unsigned int no_ether_link: 1;
	unsigned int ether_link_active_low: 1;
	unsigned int is_opened: 1;
	unsigned int wol_enabled: 1;
	int: 28;
	int: 32;
};

struct bb_info {
	void (*set_gate)(void *);
	struct mdiobb_ctrl ctrl;
	void *addr;
};

struct smsc911x_platform_config {
	unsigned int irq_polarity;
	unsigned int irq_type;
	unsigned int flags;
	unsigned int shift;
	phy_interface_t phy_interface;
	unsigned char mac[6];
};

struct smsc911x_data;

struct smsc911x_ops {
	u32 (*reg_read)(struct smsc911x_data *, u32);
	void (*reg_write)(struct smsc911x_data *, u32, u32);
	void (*rx_readfifo)(struct smsc911x_data *, unsigned int *, unsigned int);
	void (*tx_writefifo)(struct smsc911x_data *, unsigned int *, unsigned int);
};

struct smsc911x_data {
	void *ioaddr;
	unsigned int idrev;
	unsigned int generation;
	struct smsc911x_platform_config config;
	spinlock_t mac_lock;
	spinlock_t dev_lock;
	struct mii_bus *mii_bus;
	unsigned int using_extphy;
	int last_duplex;
	int last_carrier;
	u32 msg_enable;
	unsigned int gpio_setting;
	unsigned int gpio_orig_setting;
	struct net_device *dev;
	struct napi_struct napi;
	unsigned int software_irq_signal;
	char loopback_tx_pkt[64];
	char loopback_rx_pkt[64];
	unsigned int resetcount;
	unsigned int multicast_update_pending;
	unsigned int set_bits_mask;
	unsigned int clear_bits_mask;
	unsigned int hashhi;
	unsigned int hashlo;
	const struct smsc911x_ops *ops;
	struct regulator_bulk_data supplies[2];
	struct gpio_desc *reset_gpiod;
	struct clk *clk;
};

enum desc_id {
	AVE_DESCID_RX = 0,
	AVE_DESCID_TX = 1,
};

enum desc_state___2 {
	AVE_DESC_RX_PERMIT = 0,
	AVE_DESC_RX_SUSPEND = 1,
	AVE_DESC_START = 2,
	AVE_DESC_STOP = 3,
};

struct ave_desc {
	struct sk_buff *skbs;
	dma_addr_t skbs_dma;
	size_t skbs_dmalen;
};

struct ave_desc_info {
	u32 ndesc;
	u32 daddr;
	u32 proc_idx;
	u32 done_idx;
	struct ave_desc *desc;
};

struct ave_stats {
	struct u64_stats_sync syncp;
	int: 32;
	u64 packets;
	u64 bytes;
	u64 errors;
	u64 dropped;
	u64 collisions;
	u64 fifo_errors;
};

struct ave_soc_data;

struct ave_private {
	void *base;
	int irq;
	int phy_id;
	unsigned int desc_size;
	u32 msg_enable;
	int nclks;
	struct clk *clk[4];
	int nrsts;
	struct reset_control *rst[2];
	phy_interface_t phy_mode;
	struct phy_device *phydev;
	struct mii_bus *mdio;
	struct regmap *regmap;
	unsigned int pinmode_mask;
	unsigned int pinmode_val;
	u32 wolopts;
	struct ave_stats stats_rx;
	struct ave_stats stats_tx;
	struct net_device *ndev;
	int: 32;
	struct napi_struct napi_rx;
	struct napi_struct napi_tx;
	struct ave_desc_info rx;
	struct ave_desc_info tx;
	int pause_auto;
	int pause_rx;
	int pause_tx;
	const struct ave_soc_data *data;
};

struct ave_soc_data {
	bool is_desc_64bit;
	const char *clock_names[4];
	const char *reset_names[2];
	int (*get_pinmode)(struct ave_private *, phy_interface_t, u32);
};

struct tc_u32_key {
	__be32 mask;
	__be32 val;
	int off;
	int offmask;
};

struct tc_u32_sel {
	unsigned char flags;
	unsigned char offshift;
	unsigned char nkeys;
	__be16 offmask;
	__u16 off;
	short int offoff;
	short int hoff;
	__be32 hmask;
	struct tc_u32_key keys[0];
};

struct tc_taprio_sched_entry {
	u8 command;
	u32 gate_mask;
	u32 interval;
};

struct tc_taprio_qopt_offload {
	u8 enable;
	int: 24;
	int: 32;
	ktime_t base_time;
	u64 cycle_time;
	u64 cycle_time_extension;
	size_t num_entries;
	struct tc_taprio_sched_entry entries[0];
	int: 32;
};

struct tcf_exts {
	int action;
	int police;
};

struct tc_cls_u32_knode {
	struct tcf_exts *exts;
	struct tcf_result *res;
	struct tc_u32_sel *sel;
	u32 handle;
	u32 val;
	u32 mask;
	u32 link_handle;
	u8 fshift;
};

struct tc_cls_u32_hnode {
	u32 handle;
	u32 prio;
	unsigned int divisor;
};

enum tc_clsu32_command {
	TC_CLSU32_NEW_KNODE = 0,
	TC_CLSU32_REPLACE_KNODE = 1,
	TC_CLSU32_DELETE_KNODE = 2,
	TC_CLSU32_NEW_HNODE = 3,
	TC_CLSU32_REPLACE_HNODE = 4,
	TC_CLSU32_DELETE_HNODE = 5,
};

struct tc_cls_u32_offload {
	struct flow_cls_common_offload common;
	enum tc_clsu32_command command;
	union {
		struct tc_cls_u32_knode knode;
		struct tc_cls_u32_hnode hnode;
	};
};

struct stmmac_mdio_bus_data {
	unsigned int phy_mask;
	unsigned int has_xpcs;
	int *irqs;
	int probed_phy_irq;
	bool needs_reset;
};

struct stmmac_dma_cfg {
	int pbl;
	int txpbl;
	int rxpbl;
	bool pblx8;
	int fixed_burst;
	int mixed_burst;
	bool aal;
	bool eame;
};

struct stmmac_axi {
	bool axi_lpi_en;
	bool axi_xit_frm;
	u32 axi_wr_osr_lmt;
	u32 axi_rd_osr_lmt;
	bool axi_kbbe;
	u32 axi_blen[7];
	bool axi_fb;
	bool axi_mb;
	bool axi_rb;
};

struct stmmac_est {
	int enable;
	u32 btr_offset[2];
	u32 btr[2];
	u32 ctr[2];
	u32 ter;
	u32 gcl_unaligned[1024];
	u32 gcl[1024];
	u32 gcl_size;
};

struct stmmac_rxq_cfg {
	u8 mode_to_use;
	u32 chan;
	u8 pkt_route;
	bool use_prio;
	u32 prio;
};

struct stmmac_txq_cfg {
	u32 weight;
	u8 mode_to_use;
	u32 send_slope;
	u32 idle_slope;
	u32 high_credit;
	u32 low_credit;
	bool use_prio;
	u32 prio;
	int tbs_en;
};

struct mac_device_info;

struct plat_stmmacenet_data {
	int bus_id;
	int phy_addr;
	int interface;
	phy_interface_t phy_interface;
	struct stmmac_mdio_bus_data *mdio_bus_data;
	struct device_node *phy_node;
	struct device_node *phylink_node;
	struct device_node *mdio_node;
	struct stmmac_dma_cfg *dma_cfg;
	struct stmmac_est *est;
	int clk_csr;
	int has_gmac;
	int enh_desc;
	int tx_coe;
	int rx_coe;
	int bugged_jumbo;
	int pmt;
	int force_sf_dma_mode;
	int force_thresh_dma_mode;
	int riwt_off;
	int max_speed;
	int maxmtu;
	int multicast_filter_bins;
	int unicast_filter_entries;
	int tx_fifo_size;
	int rx_fifo_size;
	u32 addr64;
	u32 rx_queues_to_use;
	u32 tx_queues_to_use;
	u8 rx_sched_algorithm;
	u8 tx_sched_algorithm;
	struct stmmac_rxq_cfg rx_queues_cfg[8];
	struct stmmac_txq_cfg tx_queues_cfg[8];
	void (*fix_mac_speed)(void *, unsigned int);
	int (*serdes_powerup)(struct net_device *, void *);
	void (*serdes_powerdown)(struct net_device *, void *);
	int (*init)(struct platform_device *, void *);
	void (*exit)(struct platform_device *, void *);
	struct mac_device_info * (*setup)(void *);
	void *bsp_priv;
	struct clk *stmmac_clk;
	struct clk *pclk;
	struct clk *clk_ptp_ref;
	unsigned int clk_ptp_rate;
	unsigned int clk_ref_rate;
	s32 ptp_max_adj;
	struct reset_control *stmmac_rst;
	struct stmmac_axi *axi;
	int has_gmac4;
	bool has_sun8i;
	bool tso_en;
	int rss_en;
	int mac_port_sel_speed;
	bool en_tx_lpi_clockgating;
	int has_xgmac;
	bool vlan_fail_q_en;
	u8 vlan_fail_q;
	unsigned int eee_usecs_rate;
};

struct mii_regs {
	unsigned int addr;
	unsigned int data;
	unsigned int addr_shift;
	unsigned int reg_shift;
	unsigned int addr_mask;
	unsigned int reg_mask;
	unsigned int clk_csr_shift;
	unsigned int clk_csr_mask;
};

struct mac_link {
	u32 speed_mask;
	u32 speed10;
	u32 speed100;
	u32 speed1000;
	u32 speed2500;
	u32 duplex;
	struct {
		u32 speed2500;
		u32 speed5000;
		u32 speed10000;
	} xgmii;
	struct {
		u32 speed25000;
		u32 speed40000;
		u32 speed50000;
		u32 speed100000;
	} xlgmii;
};

struct stmmac_ops;

struct stmmac_desc_ops;

struct stmmac_dma_ops;

struct stmmac_mode_ops;

struct stmmac_hwtimestamp;

struct stmmac_tc_ops;

struct stmmac_mmc_ops;

struct mac_device_info {
	const struct stmmac_ops *mac;
	const struct stmmac_desc_ops *desc;
	const struct stmmac_dma_ops *dma;
	const struct stmmac_mode_ops *mode;
	const struct stmmac_hwtimestamp *ptp;
	const struct stmmac_tc_ops *tc;
	const struct stmmac_mmc_ops *mmc;
	const struct mdio_xpcs_ops *xpcs;
	struct mdio_xpcs_args xpcs_args;
	struct mii_regs mii;
	struct mac_link link;
	void *pcsr;
	unsigned int multicast_filter_bins;
	unsigned int unicast_filter_entries;
	unsigned int mcast_bits_log2;
	unsigned int rx_csum;
	unsigned int pcs;
	unsigned int pmt;
	unsigned int ps;
	unsigned int xlgmac;
	unsigned int num_vlan;
	u32 vlan_filter[32];
	unsigned int promisc;
	bool vlan_fail_q_en;
	u8 vlan_fail_q;
};

struct dma_desc {
	__le32 des0;
	__le32 des1;
	__le32 des2;
	__le32 des3;
};

struct dma_extended_desc {
	struct dma_desc basic;
	__le32 des4;
	__le32 des5;
	__le32 des6;
	__le32 des7;
};

struct dma_edesc {
	__le32 des4;
	__le32 des5;
	__le32 des6;
	__le32 des7;
	struct dma_desc basic;
};

struct stmmac_extra_stats;

struct stmmac_desc_ops {
	void (*init_rx_desc)(struct dma_desc *, int, int, int, int);
	void (*init_tx_desc)(struct dma_desc *, int, int);
	void (*prepare_tx_desc)(struct dma_desc *, int, int, bool, int, bool, bool, unsigned int);
	void (*prepare_tso_tx_desc)(struct dma_desc *, int, int, int, bool, bool, unsigned int, unsigned int);
	void (*set_tx_owner)(struct dma_desc *);
	int (*get_tx_owner)(struct dma_desc *);
	void (*release_tx_desc)(struct dma_desc *, int);
	void (*set_tx_ic)(struct dma_desc *);
	int (*get_tx_ls)(struct dma_desc *);
	int (*tx_status)(void *, struct stmmac_extra_stats *, struct dma_desc *, void *);
	int (*get_tx_len)(struct dma_desc *);
	void (*set_rx_owner)(struct dma_desc *, int);
	int (*get_rx_frame_len)(struct dma_desc *, int);
	int (*rx_status)(void *, struct stmmac_extra_stats *, struct dma_desc *);
	void (*rx_extended_status)(void *, struct stmmac_extra_stats *, struct dma_extended_desc *);
	void (*enable_tx_timestamp)(struct dma_desc *);
	int (*get_tx_timestamp_status)(struct dma_desc *);
	void (*get_timestamp)(void *, u32, u64 *);
	int (*get_rx_timestamp_status)(void *, void *, u32);
	void (*display_ring)(void *, unsigned int, bool);
	void (*set_mss)(struct dma_desc *, unsigned int);
	void (*get_addr)(struct dma_desc *, unsigned int *);
	void (*set_addr)(struct dma_desc *, dma_addr_t);
	void (*clear)(struct dma_desc *);
	int (*get_rx_hash)(struct dma_desc *, u32 *, enum pkt_hash_types *);
	void (*get_rx_header_len)(struct dma_desc *, unsigned int *);
	void (*set_sec_addr)(struct dma_desc *, dma_addr_t);
	void (*set_sarc)(struct dma_desc *, u32);
	void (*set_vlan_tag)(struct dma_desc *, u16, u16, u32);
	void (*set_vlan)(struct dma_desc *, u32);
	void (*set_tbs)(struct dma_edesc *, u32, u32);
};

struct stmmac_extra_stats {
	long unsigned int tx_underflow;
	long unsigned int tx_carrier;
	long unsigned int tx_losscarrier;
	long unsigned int vlan_tag;
	long unsigned int tx_deferred;
	long unsigned int tx_vlan;
	long unsigned int tx_jabber;
	long unsigned int tx_frame_flushed;
	long unsigned int tx_payload_error;
	long unsigned int tx_ip_header_error;
	long unsigned int rx_desc;
	long unsigned int sa_filter_fail;
	long unsigned int overflow_error;
	long unsigned int ipc_csum_error;
	long unsigned int rx_collision;
	long unsigned int rx_crc_errors;
	long unsigned int dribbling_bit;
	long unsigned int rx_length;
	long unsigned int rx_mii;
	long unsigned int rx_multicast;
	long unsigned int rx_gmac_overflow;
	long unsigned int rx_watchdog;
	long unsigned int da_rx_filter_fail;
	long unsigned int sa_rx_filter_fail;
	long unsigned int rx_missed_cntr;
	long unsigned int rx_overflow_cntr;
	long unsigned int rx_vlan;
	long unsigned int rx_split_hdr_pkt_n;
	long unsigned int tx_undeflow_irq;
	long unsigned int tx_process_stopped_irq;
	long unsigned int tx_jabber_irq;
	long unsigned int rx_overflow_irq;
	long unsigned int rx_buf_unav_irq;
	long unsigned int rx_process_stopped_irq;
	long unsigned int rx_watchdog_irq;
	long unsigned int tx_early_irq;
	long unsigned int fatal_bus_error_irq;
	long unsigned int rx_early_irq;
	long unsigned int threshold;
	long unsigned int tx_pkt_n;
	long unsigned int rx_pkt_n;
	long unsigned int normal_irq_n;
	long unsigned int rx_normal_irq_n;
	long unsigned int napi_poll;
	long unsigned int tx_normal_irq_n;
	long unsigned int tx_clean;
	long unsigned int tx_set_ic_bit;
	long unsigned int irq_receive_pmt_irq_n;
	long unsigned int mmc_tx_irq_n;
	long unsigned int mmc_rx_irq_n;
	long unsigned int mmc_rx_csum_offload_irq_n;
	long unsigned int irq_tx_path_in_lpi_mode_n;
	long unsigned int irq_tx_path_exit_lpi_mode_n;
	long unsigned int irq_rx_path_in_lpi_mode_n;
	long unsigned int irq_rx_path_exit_lpi_mode_n;
	long unsigned int phy_eee_wakeup_error_n;
	long unsigned int ip_hdr_err;
	long unsigned int ip_payload_err;
	long unsigned int ip_csum_bypassed;
	long unsigned int ipv4_pkt_rcvd;
	long unsigned int ipv6_pkt_rcvd;
	long unsigned int no_ptp_rx_msg_type_ext;
	long unsigned int ptp_rx_msg_type_sync;
	long unsigned int ptp_rx_msg_type_follow_up;
	long unsigned int ptp_rx_msg_type_delay_req;
	long unsigned int ptp_rx_msg_type_delay_resp;
	long unsigned int ptp_rx_msg_type_pdelay_req;
	long unsigned int ptp_rx_msg_type_pdelay_resp;
	long unsigned int ptp_rx_msg_type_pdelay_follow_up;
	long unsigned int ptp_rx_msg_type_announce;
	long unsigned int ptp_rx_msg_type_management;
	long unsigned int ptp_rx_msg_pkt_reserved_type;
	long unsigned int ptp_frame_type;
	long unsigned int ptp_ver;
	long unsigned int timestamp_dropped;
	long unsigned int av_pkt_rcvd;
	long unsigned int av_tagged_pkt_rcvd;
	long unsigned int vlan_tag_priority_val;
	long unsigned int l3_filter_match;
	long unsigned int l4_filter_match;
	long unsigned int l3_l4_filter_no_match;
	long unsigned int irq_pcs_ane_n;
	long unsigned int irq_pcs_link_n;
	long unsigned int irq_rgmii_n;
	long unsigned int pcs_link;
	long unsigned int pcs_duplex;
	long unsigned int pcs_speed;
	long unsigned int mtl_tx_status_fifo_full;
	long unsigned int mtl_tx_fifo_not_empty;
	long unsigned int mmtl_fifo_ctrl;
	long unsigned int mtl_tx_fifo_read_ctrl_write;
	long unsigned int mtl_tx_fifo_read_ctrl_wait;
	long unsigned int mtl_tx_fifo_read_ctrl_read;
	long unsigned int mtl_tx_fifo_read_ctrl_idle;
	long unsigned int mac_tx_in_pause;
	long unsigned int mac_tx_frame_ctrl_xfer;
	long unsigned int mac_tx_frame_ctrl_idle;
	long unsigned int mac_tx_frame_ctrl_wait;
	long unsigned int mac_tx_frame_ctrl_pause;
	long unsigned int mac_gmii_tx_proto_engine;
	long unsigned int mtl_rx_fifo_fill_level_full;
	long unsigned int mtl_rx_fifo_fill_above_thresh;
	long unsigned int mtl_rx_fifo_fill_below_thresh;
	long unsigned int mtl_rx_fifo_fill_level_empty;
	long unsigned int mtl_rx_fifo_read_ctrl_flush;
	long unsigned int mtl_rx_fifo_read_ctrl_read_data;
	long unsigned int mtl_rx_fifo_read_ctrl_status;
	long unsigned int mtl_rx_fifo_read_ctrl_idle;
	long unsigned int mtl_rx_fifo_ctrl_active;
	long unsigned int mac_rx_frame_ctrl_fifo;
	long unsigned int mac_gmii_rx_proto_engine;
	long unsigned int tx_tso_frames;
	long unsigned int tx_tso_nfrags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct dma_features;

struct stmmac_dma_ops {
	int (*reset)(void *);
	void (*init)(void *, struct stmmac_dma_cfg *, int);
	void (*init_chan)(void *, struct stmmac_dma_cfg *, u32);
	void (*init_rx_chan)(void *, struct stmmac_dma_cfg *, dma_addr_t, u32);
	void (*init_tx_chan)(void *, struct stmmac_dma_cfg *, dma_addr_t, u32);
	void (*axi)(void *, struct stmmac_axi *);
	void (*dump_regs)(void *, u32 *);
	void (*dma_rx_mode)(void *, int, u32, int, u8);
	void (*dma_tx_mode)(void *, int, u32, int, u8);
	void (*dma_diagnostic_fr)(void *, struct stmmac_extra_stats *, void *);
	void (*enable_dma_transmission)(void *);
	void (*enable_dma_irq)(void *, u32, bool, bool);
	void (*disable_dma_irq)(void *, u32, bool, bool);
	void (*start_tx)(void *, u32);
	void (*stop_tx)(void *, u32);
	void (*start_rx)(void *, u32);
	void (*stop_rx)(void *, u32);
	int (*dma_interrupt)(void *, struct stmmac_extra_stats *, u32);
	void (*get_hw_feature)(void *, struct dma_features *);
	void (*rx_watchdog)(void *, u32, u32);
	void (*set_tx_ring_len)(void *, u32, u32);
	void (*set_rx_ring_len)(void *, u32, u32);
	void (*set_rx_tail_ptr)(void *, u32, u32);
	void (*set_tx_tail_ptr)(void *, u32, u32);
	void (*enable_tso)(void *, bool, u32);
	void (*qmode)(void *, u32, u8);
	void (*set_bfsize)(void *, int, u32);
	void (*enable_sph)(void *, bool, u32);
	int (*enable_tbs)(void *, bool, u32);
};

struct dma_features {
	unsigned int mbps_10_100;
	unsigned int mbps_1000;
	unsigned int half_duplex;
	unsigned int hash_filter;
	unsigned int multi_addr;
	unsigned int pcs;
	unsigned int sma_mdio;
	unsigned int pmt_remote_wake_up;
	unsigned int pmt_magic_frame;
	unsigned int rmon;
	unsigned int time_stamp;
	unsigned int atime_stamp;
	unsigned int eee;
	unsigned int av;
	unsigned int hash_tb_sz;
	unsigned int tsoen;
	unsigned int tx_coe;
	unsigned int rx_coe;
	unsigned int rx_coe_type1;
	unsigned int rx_coe_type2;
	unsigned int rxfifo_over_2048;
	unsigned int number_rx_channel;
	unsigned int number_tx_channel;
	unsigned int number_rx_queues;
	unsigned int number_tx_queues;
	unsigned int pps_out_num;
	unsigned int enh_desc;
	unsigned int tx_fifo_size;
	unsigned int rx_fifo_size;
	unsigned int asp;
	unsigned int frpsel;
	unsigned int frpbs;
	unsigned int frpes;
	unsigned int addr64;
	unsigned int rssen;
	unsigned int vlhash;
	unsigned int sphen;
	unsigned int vlins;
	unsigned int dvlan;
	unsigned int l3l4fnum;
	unsigned int arpoffsel;
	unsigned int estwid;
	unsigned int estdep;
	unsigned int estsel;
	unsigned int fpesel;
	unsigned int tbssel;
};

struct rgmii_adv;

struct stmmac_safety_stats;

struct stmmac_tc_entry;

struct stmmac_pps_cfg;

struct stmmac_rss;

struct stmmac_ops {
	void (*core_init)(struct mac_device_info *, struct net_device *);
	void (*set_mac)(void *, bool);
	int (*rx_ipc)(struct mac_device_info *);
	void (*rx_queue_enable)(struct mac_device_info *, u8, u32);
	void (*rx_queue_prio)(struct mac_device_info *, u32, u32);
	void (*tx_queue_prio)(struct mac_device_info *, u32, u32);
	void (*rx_queue_routing)(struct mac_device_info *, u8, u32);
	void (*prog_mtl_rx_algorithms)(struct mac_device_info *, u32);
	void (*prog_mtl_tx_algorithms)(struct mac_device_info *, u32);
	void (*set_mtl_tx_queue_weight)(struct mac_device_info *, u32, u32);
	void (*map_mtl_to_dma)(struct mac_device_info *, u32, u32);
	void (*config_cbs)(struct mac_device_info *, u32, u32, u32, u32, u32);
	void (*dump_regs)(struct mac_device_info *, u32 *);
	int (*host_irq_status)(struct mac_device_info *, struct stmmac_extra_stats *);
	int (*host_mtl_irq_status)(struct mac_device_info *, u32);
	void (*set_filter)(struct mac_device_info *, struct net_device *);
	void (*flow_ctrl)(struct mac_device_info *, unsigned int, unsigned int, unsigned int, u32);
	void (*pmt)(struct mac_device_info *, long unsigned int);
	void (*set_umac_addr)(struct mac_device_info *, unsigned char *, unsigned int);
	void (*get_umac_addr)(struct mac_device_info *, unsigned char *, unsigned int);
	void (*set_eee_mode)(struct mac_device_info *, bool);
	void (*reset_eee_mode)(struct mac_device_info *);
	void (*set_eee_lpi_entry_timer)(struct mac_device_info *, int);
	void (*set_eee_timer)(struct mac_device_info *, int, int);
	void (*set_eee_pls)(struct mac_device_info *, int);
	void (*debug)(void *, struct stmmac_extra_stats *, u32, u32);
	void (*pcs_ctrl_ane)(void *, bool, bool, bool);
	void (*pcs_rane)(void *, bool);
	void (*pcs_get_adv_lp)(void *, struct rgmii_adv *);
	int (*safety_feat_config)(void *, unsigned int);
	int (*safety_feat_irq_status)(struct net_device *, void *, unsigned int, struct stmmac_safety_stats *);
	int (*safety_feat_dump)(struct stmmac_safety_stats *, int, long unsigned int *, const char **);
	int (*rxp_config)(void *, struct stmmac_tc_entry *, unsigned int);
	int (*flex_pps_config)(void *, int, struct stmmac_pps_cfg *, bool, u32, u32);
	void (*set_mac_loopback)(void *, bool);
	int (*rss_configure)(struct mac_device_info *, struct stmmac_rss *, u32);
	void (*update_vlan_hash)(struct mac_device_info *, u32, __le16, bool);
	void (*enable_vlan)(struct mac_device_info *, u32);
	int (*add_hw_vlan_rx_fltr)(struct net_device *, struct mac_device_info *, __be16, u16);
	int (*del_hw_vlan_rx_fltr)(struct net_device *, struct mac_device_info *, __be16, u16);
	void (*restore_hw_vlan_rx_fltr)(struct net_device *, struct mac_device_info *);
	int (*get_mac_tx_timestamp)(struct mac_device_info *, u64 *);
	void (*sarc_configure)(void *, int);
	int (*config_l3_filter)(struct mac_device_info *, u32, bool, bool, bool, bool, u32);
	int (*config_l4_filter)(struct mac_device_info *, u32, bool, bool, bool, bool, u32);
	void (*set_arp_offload)(struct mac_device_info *, bool, u32);
	int (*est_configure)(void *, struct stmmac_est *, unsigned int);
	void (*fpe_configure)(void *, u32, u32, bool);
};

struct rgmii_adv {
	unsigned int pause;
	unsigned int duplex;
	unsigned int lp_pause;
	unsigned int lp_duplex;
};

struct stmmac_safety_stats {
	long unsigned int mac_errors[32];
	long unsigned int mtl_errors[32];
	long unsigned int dma_errors[32];
};

struct stmmac_tc_entry {
	bool in_use;
	bool in_hw;
	bool is_last;
	bool is_frag;
	void *frag_ptr;
	unsigned int table_pos;
	u32 handle;
	u32 prio;
	struct {
		u32 match_data;
		u32 match_en;
		u8 af: 1;
		u8 rf: 1;
		u8 im: 1;
		u8 nc: 1;
		u8 res1: 4;
		u8 frame_offset;
		u8 ok_index;
		u8 dma_ch_no;
		u32 res2;
	} val;
};

struct stmmac_pps_cfg {
	bool available;
	int: 24;
	int: 32;
	struct timespec64 start;
	struct timespec64 period;
};

struct stmmac_rss {
	int enable;
	u8 key[40];
	u32 table[256];
};

struct stmmac_hwtimestamp {
	void (*config_hw_tstamping)(void *, u32);
	void (*config_sub_second_increment)(void *, u32, int, u32 *);
	int (*init_systime)(void *, u32, u32);
	int (*config_addend)(void *, u32);
	int (*adjust_systime)(void *, u32, u32, int, int);
	void (*get_systime)(void *, u64 *);
};

struct stmmac_mode_ops {
	void (*init)(void *, dma_addr_t, unsigned int, unsigned int);
	unsigned int (*is_jumbo_frm)(int, int);
	int (*jumbo_frm)(void *, struct sk_buff *, int);
	int (*set_16kib_bfsize)(int);
	void (*init_desc3)(struct dma_desc *);
	void (*refill_desc3)(void *, struct dma_desc *);
	void (*clean_desc3)(void *, struct dma_desc *);
};

struct stmmac_priv;

struct stmmac_tc_ops {
	int (*init)(struct stmmac_priv *);
	int (*setup_cls_u32)(struct stmmac_priv *, struct tc_cls_u32_offload *);
	int (*setup_cbs)(struct stmmac_priv *, struct tc_cbs_qopt_offload *);
	int (*setup_cls)(struct stmmac_priv *, struct flow_cls_offload *);
	int (*setup_taprio)(struct stmmac_priv *, struct tc_taprio_qopt_offload *);
	int (*setup_etf)(struct stmmac_priv *, struct tc_etf_qopt_offload *);
};

struct stmmac_rx_buffer;

struct stmmac_rx_queue {
	u32 rx_count_frames;
	u32 queue_index;
	struct page_pool *page_pool;
	struct stmmac_rx_buffer *buf_pool;
	struct stmmac_priv *priv_data;
	struct dma_extended_desc *dma_erx;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct dma_desc *dma_rx;
	unsigned int cur_rx;
	unsigned int dirty_rx;
	u32 rx_zeroc_thresh;
	dma_addr_t dma_rx_phy;
	u32 rx_tail_addr;
	unsigned int state_saved;
	struct {
		struct sk_buff *skb;
		unsigned int len;
		unsigned int error;
	} state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct stmmac_tx_info;

struct stmmac_tx_queue {
	u32 tx_count_frames;
	int tbs;
	struct hrtimer txtimer;
	u32 queue_index;
	struct stmmac_priv *priv_data;
	struct dma_extended_desc *dma_etx;
	struct dma_edesc *dma_entx;
	struct dma_desc *dma_tx;
	struct sk_buff **tx_skbuff;
	struct stmmac_tx_info *tx_skbuff_dma;
	unsigned int cur_tx;
	unsigned int dirty_tx;
	dma_addr_t dma_tx_phy;
	u32 tx_tail_addr;
	u32 mss;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct stmmac_channel {
	struct napi_struct rx_napi;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct napi_struct tx_napi;
	struct stmmac_priv *priv_data;
	spinlock_t lock;
	u32 index;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct stmmac_counters {
	unsigned int mmc_tx_octetcount_gb;
	unsigned int mmc_tx_framecount_gb;
	unsigned int mmc_tx_broadcastframe_g;
	unsigned int mmc_tx_multicastframe_g;
	unsigned int mmc_tx_64_octets_gb;
	unsigned int mmc_tx_65_to_127_octets_gb;
	unsigned int mmc_tx_128_to_255_octets_gb;
	unsigned int mmc_tx_256_to_511_octets_gb;
	unsigned int mmc_tx_512_to_1023_octets_gb;
	unsigned int mmc_tx_1024_to_max_octets_gb;
	unsigned int mmc_tx_unicast_gb;
	unsigned int mmc_tx_multicast_gb;
	unsigned int mmc_tx_broadcast_gb;
	unsigned int mmc_tx_underflow_error;
	unsigned int mmc_tx_singlecol_g;
	unsigned int mmc_tx_multicol_g;
	unsigned int mmc_tx_deferred;
	unsigned int mmc_tx_latecol;
	unsigned int mmc_tx_exesscol;
	unsigned int mmc_tx_carrier_error;
	unsigned int mmc_tx_octetcount_g;
	unsigned int mmc_tx_framecount_g;
	unsigned int mmc_tx_excessdef;
	unsigned int mmc_tx_pause_frame;
	unsigned int mmc_tx_vlan_frame_g;
	unsigned int mmc_rx_framecount_gb;
	unsigned int mmc_rx_octetcount_gb;
	unsigned int mmc_rx_octetcount_g;
	unsigned int mmc_rx_broadcastframe_g;
	unsigned int mmc_rx_multicastframe_g;
	unsigned int mmc_rx_crc_error;
	unsigned int mmc_rx_align_error;
	unsigned int mmc_rx_run_error;
	unsigned int mmc_rx_jabber_error;
	unsigned int mmc_rx_undersize_g;
	unsigned int mmc_rx_oversize_g;
	unsigned int mmc_rx_64_octets_gb;
	unsigned int mmc_rx_65_to_127_octets_gb;
	unsigned int mmc_rx_128_to_255_octets_gb;
	unsigned int mmc_rx_256_to_511_octets_gb;
	unsigned int mmc_rx_512_to_1023_octets_gb;
	unsigned int mmc_rx_1024_to_max_octets_gb;
	unsigned int mmc_rx_unicast_g;
	unsigned int mmc_rx_length_error;
	unsigned int mmc_rx_autofrangetype;
	unsigned int mmc_rx_pause_frames;
	unsigned int mmc_rx_fifo_overflow;
	unsigned int mmc_rx_vlan_frames_gb;
	unsigned int mmc_rx_watchdog_error;
	unsigned int mmc_rx_ipc_intr_mask;
	unsigned int mmc_rx_ipc_intr;
	unsigned int mmc_rx_ipv4_gd;
	unsigned int mmc_rx_ipv4_hderr;
	unsigned int mmc_rx_ipv4_nopay;
	unsigned int mmc_rx_ipv4_frag;
	unsigned int mmc_rx_ipv4_udsbl;
	unsigned int mmc_rx_ipv4_gd_octets;
	unsigned int mmc_rx_ipv4_hderr_octets;
	unsigned int mmc_rx_ipv4_nopay_octets;
	unsigned int mmc_rx_ipv4_frag_octets;
	unsigned int mmc_rx_ipv4_udsbl_octets;
	unsigned int mmc_rx_ipv6_gd_octets;
	unsigned int mmc_rx_ipv6_hderr_octets;
	unsigned int mmc_rx_ipv6_nopay_octets;
	unsigned int mmc_rx_ipv6_gd;
	unsigned int mmc_rx_ipv6_hderr;
	unsigned int mmc_rx_ipv6_nopay;
	unsigned int mmc_rx_udp_gd;
	unsigned int mmc_rx_udp_err;
	unsigned int mmc_rx_tcp_gd;
	unsigned int mmc_rx_tcp_err;
	unsigned int mmc_rx_icmp_gd;
	unsigned int mmc_rx_icmp_err;
	unsigned int mmc_rx_udp_gd_octets;
	unsigned int mmc_rx_udp_err_octets;
	unsigned int mmc_rx_tcp_gd_octets;
	unsigned int mmc_rx_tcp_err_octets;
	unsigned int mmc_rx_icmp_gd_octets;
	unsigned int mmc_rx_icmp_err_octets;
	unsigned int mmc_tx_fpe_fragment_cntr;
	unsigned int mmc_tx_hold_req_cntr;
	unsigned int mmc_rx_packet_assembly_err_cntr;
	unsigned int mmc_rx_packet_smd_err_cntr;
	unsigned int mmc_rx_packet_assembly_ok_cntr;
	unsigned int mmc_rx_fpe_fragment_cntr;
};

struct stmmac_flow_entry;

struct stmmac_priv {
	u32 tx_coal_frames;
	u32 tx_coal_timer;
	u32 rx_coal_frames;
	int tx_coalesce;
	int hwts_tx_en;
	bool tx_path_in_lpi_mode;
	bool tso;
	int sph;
	u32 sarc_type;
	unsigned int dma_buf_sz;
	unsigned int rx_copybreak;
	u32 rx_riwt;
	int hwts_rx_en;
	void *ioaddr;
	struct net_device *dev;
	struct device *device;
	struct mac_device_info *hw;
	int (*hwif_quirks)(struct stmmac_priv *);
	struct mutex lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct stmmac_rx_queue rx_queue[8];
	unsigned int dma_rx_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct stmmac_tx_queue tx_queue[8];
	unsigned int dma_tx_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct stmmac_channel channel[8];
	int speed;
	unsigned int flow_ctrl;
	unsigned int pause;
	struct mii_bus *mii;
	int mii_irq[32];
	struct phylink_config phylink_config;
	struct phylink *phylink;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct stmmac_extra_stats xstats;
	struct stmmac_safety_stats sstats;
	struct plat_stmmacenet_data *plat;
	struct dma_features dma_cap;
	struct stmmac_counters mmc;
	int hw_cap_support;
	int synopsys_id;
	u32 msg_enable;
	int wolopts;
	int wol_irq;
	int clk_csr;
	struct timer_list eee_ctrl_timer;
	int lpi_irq;
	int eee_enabled;
	int eee_active;
	int tx_lpi_timer;
	int tx_lpi_enabled;
	int eee_tw_timer;
	bool eee_sw_timer_en;
	unsigned int mode;
	unsigned int chain_mode;
	int extend_desc;
	struct hwtstamp_config tstamp_config;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_ops;
	unsigned int default_addend;
	u32 sub_second_inc;
	u32 systime_flags;
	u32 adv_ts;
	int use_riwt;
	int irq_wake;
	spinlock_t ptp_lock;
	void *mmcaddr;
	void *ptpaddr;
	long unsigned int active_vlans[128];
	struct dentry *dbgfs_dir;
	long unsigned int state;
	struct workqueue_struct *wq;
	struct work_struct service_task;
	unsigned int tc_entries_max;
	unsigned int tc_off_max;
	struct stmmac_tc_entry *tc_entries;
	unsigned int flow_entries_max;
	struct stmmac_flow_entry *flow_entries;
	int: 32;
	struct stmmac_pps_cfg pps[4];
	struct stmmac_rss rss;
	int: 32;
	int: 32;
	int: 32;
};

struct stmmac_mmc_ops {
	void (*ctrl)(void *, unsigned int);
	void (*intr_all_mask)(void *);
	void (*read)(void *, struct stmmac_counters *);
};

enum rx_frame_status {
	good_frame = 0,
	discard_frame = 1,
	csum_none = 2,
	llc_snap = 4,
	dma_own = 8,
	rx_not_ls = 16,
};

enum tx_frame_status {
	tx_done = 0,
	tx_not_ls = 1,
	tx_err = 2,
	tx_dma_own = 4,
};

enum dma_irq_status {
	tx_hard_error = 1,
	tx_hard_error_bump_tc = 2,
	handle_rx = 4,
	handle_tx = 8,
};

struct stmmac_resources {
	void *addr;
	const char *mac;
	int wol_irq;
	int lpi_irq;
	int irq;
};

struct stmmac_tx_info {
	dma_addr_t buf;
	bool map_as_page;
	unsigned int len;
	bool last_segment;
	bool is_jumbo;
};

struct stmmac_rx_buffer {
	struct page *page;
	struct page *sec_page;
	dma_addr_t addr;
	dma_addr_t sec_addr;
};

struct stmmac_flow_entry {
	long unsigned int cookie;
	long unsigned int action;
	u8 ip_proto;
	int in_use;
	int idx;
	int is_l4;
};

enum stmmac_state {
	STMMAC_DOWN = 0,
	STMMAC_RESET_REQUESTED = 1,
	STMMAC_RESETING = 2,
	STMMAC_SERVICE_SCHED = 3,
};

struct stmmac_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
};

enum power_event {
	pointer_reset = 2147483648,
	global_unicast = 512,
	wake_up_rx_frame = 64,
	magic_frame = 32,
	wake_up_frame_en = 4,
	magic_pkt_en = 2,
	power_down = 1,
};

enum ttc_control {
	DMA_CONTROL_TTC_64 = 0,
	DMA_CONTROL_TTC_128 = 16384,
	DMA_CONTROL_TTC_192 = 32768,
	DMA_CONTROL_TTC_256 = 49152,
	DMA_CONTROL_TTC_40 = 65536,
	DMA_CONTROL_TTC_32 = 81920,
	DMA_CONTROL_TTC_24 = 98304,
	DMA_CONTROL_TTC_16 = 114688,
};

enum rtc_control {
	DMA_CONTROL_RTC_64 = 0,
	DMA_CONTROL_RTC_32 = 8,
	DMA_CONTROL_RTC_96 = 16,
	DMA_CONTROL_RTC_128 = 24,
};

enum ttc_control___2 {
	DMA_CONTROL_TTC_DEFAULT = 0,
	DMA_CONTROL_TTC_64___2 = 16384,
	DMA_CONTROL_TTC_128___2 = 32768,
	DMA_CONTROL_TTC_256___2 = 49152,
	DMA_CONTROL_TTC_18 = 4194304,
	DMA_CONTROL_TTC_24___2 = 4210688,
	DMA_CONTROL_TTC_32___2 = 4227072,
	DMA_CONTROL_TTC_40___2 = 4243456,
	DMA_CONTROL_SE = 8,
	DMA_CONTROL_OSF = 4,
};

enum packets_types {
	PACKET_AVCPQ = 1,
	PACKET_PTPQ = 2,
	PACKET_DCBCPQ = 3,
	PACKET_UPQ = 4,
	PACKET_MCBCQ = 5,
};

struct stmmac_rx_routing {
	u32 reg_mask;
	u32 reg_shift;
};

enum dwmac4_irq_status {
	time_stamp_irq = 4096,
	mmc_rx_csum_offload_irq = 2048,
	mmc_tx_irq = 1024,
	mmc_rx_irq = 512,
	mmc_irq = 256,
	lpi_irq = 32,
	pmt_irq = 16,
};

struct dwmac5_error_desc {
	bool valid;
	const char *desc;
	const char *detailed_desc;
};

struct dwmac5_error {
	const struct dwmac5_error_desc *desc;
};

struct stmmac_regs_off {
	u32 ptp_off;
	u32 mmc_off;
};

struct stmmac_hwif_entry {
	bool gmac;
	bool gmac4;
	bool xgmac;
	u32 min_id;
	u32 dev_id;
	const struct stmmac_regs_off regs;
	const void *desc;
	const void *dma;
	const void *mac;
	const void *hwtimestamp;
	const void *mode;
	const void *tc;
	const void *mmc;
	int (*setup)(struct stmmac_priv *);
	int (*quirks)(struct stmmac_priv *);
};

enum {
	TC_TAPRIO_CMD_SET_GATES = 0,
	TC_TAPRIO_CMD_SET_AND_HOLD = 1,
	TC_TAPRIO_CMD_SET_AND_RELEASE = 2,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	int: 32;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_packed tcfa_bstats;
	struct gnet_stats_basic_packed tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_basic_cpu *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct dwxgmac3_error_desc {
	bool valid;
	const char *desc;
	const char *detailed_desc;
};

struct dwxgmac3_error {
	const struct dwxgmac3_error_desc *desc;
};

struct ipq806x_gmac {
	struct platform_device *pdev;
	struct regmap *nss_common;
	struct regmap *qsgmii_csr;
	uint32_t id;
	struct clk *core_clk;
	phy_interface_t phy_mode;
};

struct meson_dwmac {
	struct device *dev;
	void *reg;
};

struct meson8b_dwmac;

struct meson8b_dwmac_data {
	int (*set_phy_mode)(struct meson8b_dwmac *);
};

struct meson8b_dwmac {
	struct device *dev;
	void *regs;
	const struct meson8b_dwmac_data *data;
	phy_interface_t phy_mode;
	struct clk *rgmii_tx_clk;
	u32 tx_delay_ns;
	u32 rx_delay_ns;
	struct clk *timing_adj_clk;
};

struct meson8b_dwmac_clk_configs {
	struct clk_mux m250_mux;
	struct clk_divider m250_div;
	struct clk_fixed_factor fixed_div2;
	struct clk_gate rgmii_tx_en;
};

struct ethqos_emac_por {
	unsigned int offset;
	unsigned int value;
};

struct ethqos_emac_driver_data {
	const struct ethqos_emac_por *por;
	unsigned int num_por;
};

struct qcom_ethqos {
	struct platform_device *pdev;
	void *rgmii_base;
	unsigned int rgmii_clk_rate;
	struct clk *rgmii_clk;
	unsigned int speed;
	const struct ethqos_emac_por *por;
	unsigned int num_por;
};

struct rk_priv_data;

struct rk_gmac_ops {
	void (*set_to_rgmii)(struct rk_priv_data *, int, int);
	void (*set_to_rmii)(struct rk_priv_data *);
	void (*set_rgmii_speed)(struct rk_priv_data *, int);
	void (*set_rmii_speed)(struct rk_priv_data *, int);
	void (*integrated_phy_powerup)(struct rk_priv_data *);
};

struct rk_priv_data {
	struct platform_device *pdev;
	phy_interface_t phy_iface;
	struct regulator *regulator;
	bool suspended;
	const struct rk_gmac_ops *ops;
	bool clk_enabled;
	bool clock_input;
	bool integrated_phy;
	struct clk *clk_mac;
	struct clk *gmac_clkin;
	struct clk *mac_clk_rx;
	struct clk *mac_clk_tx;
	struct clk *clk_mac_ref;
	struct clk *clk_mac_refout;
	struct clk *clk_mac_speed;
	struct clk *aclk_mac;
	struct clk *pclk_mac;
	struct clk *clk_phy;
	struct reset_control *phy_reset;
	int tx_delay;
	int rx_delay;
	struct regmap *grf;
};

struct tse_pcs {
	struct device *dev;
	void *tse_pcs_base;
	void *sgmii_adapter_base;
	struct timer_list aneg_link_timer;
	int autoneg;
};

struct socfpga_dwmac;

struct socfpga_dwmac_ops {
	int (*set_phy_mode)(struct socfpga_dwmac *);
};

struct socfpga_dwmac {
	u32 reg_offset;
	u32 reg_shift;
	struct device *dev;
	struct regmap *sys_mgr_base_addr;
	struct reset_control *stmmac_rst;
	struct reset_control *stmmac_ocp_rst;
	void *splitter_base;
	bool f2h_ptp_ref_clk;
	struct tse_pcs pcs;
	const struct socfpga_dwmac_ops *ops;
};

struct sti_dwmac {
	phy_interface_t interface;
	bool ext_phyclk;
	u32 tx_retime_src;
	struct clk *clk;
	u32 ctrl_reg;
	int clk_sel_reg;
	struct regmap *regmap;
	bool gmac_en;
	u32 speed;
	void (*fix_retime_src)(void *, unsigned int);
};

struct sti_dwmac_of_data {
	void (*fix_retime_src)(void *, unsigned int);
};

enum {
	TX_RETIME_SRC_NA = 0,
	TX_RETIME_SRC_TXCLK = 1,
	TX_RETIME_SRC_CLK_125 = 2,
	TX_RETIME_SRC_PHYCLK = 3,
	TX_RETIME_SRC_CLKGEN = 4,
};

struct stm32_ops;

struct stm32_dwmac {
	struct clk *clk_tx;
	struct clk *clk_rx;
	struct clk *clk_eth_ck;
	struct clk *clk_ethstp;
	struct clk *syscfg_clk;
	int ext_phyclk;
	int enable_eth_ck;
	int eth_clk_sel_reg;
	int eth_ref_clk_sel_reg;
	int irq_pwr_wakeup;
	u32 mode_reg;
	struct regmap *regmap;
	u32 speed;
	const struct stm32_ops *ops;
	struct device *dev;
};

struct stm32_ops {
	int (*set_mode)(struct plat_stmmacenet_data *);
	int (*clk_prepare)(struct stm32_dwmac *, bool);
	int (*suspend)(struct stm32_dwmac *);
	void (*resume)(struct stm32_dwmac *);
	int (*parse_data)(struct stm32_dwmac *, struct device *);
	u32 syscfg_eth_mask;
};

struct sunxi_priv_data {
	phy_interface_t interface;
	int clk_enabled;
	struct clk *tx_clk;
	struct regulator *regulator;
};

struct emac_variant {
	u32 default_syscon_value;
	const struct reg_field *syscon_field;
	bool soc_has_internal_phy;
	bool support_mii;
	bool support_rmii;
	bool support_rgmii;
	u8 rx_delay_max;
	u8 tx_delay_max;
};

struct sunxi_priv_data___2 {
	struct clk *tx_clk;
	struct clk *ephy_clk;
	struct regulator *regulator;
	struct reset_control *rst_ephy;
	const struct emac_variant *variant;
	struct regmap_field *regmap_field;
	bool internal_phy_powered;
	bool use_internal_phy;
	void *mux_handle;
};

struct tegra_eqos {
	struct device *dev;
	void *regs;
	struct reset_control *rst;
	struct clk *clk_master;
	struct clk *clk_slave;
	struct clk *clk_tx;
	struct clk *clk_rx;
	struct gpio_desc *reset;
};

struct dwc_eth_dwmac_data {
	int (*probe)(struct platform_device *, struct plat_stmmacenet_data *, struct stmmac_resources *);
	int (*remove)(struct platform_device *);
};

struct imx_dwmac_ops {
	u32 addr_width;
	bool mac_rgmii_txclk_auto_adj;
	int (*set_intf_mode)(struct plat_stmmacenet_data *);
};

struct imx_priv_data {
	struct device *dev;
	struct clk *clk_tx;
	struct clk *clk_mem;
	struct regmap *intf_regmap;
	u32 intf_reg_off;
	bool rmii_refclk_ext;
	const struct imx_dwmac_ops *ops;
	struct plat_stmmacenet_data *plat_dat;
};

struct mdio_platform_data {
	long unsigned int bus_freq;
};

struct davinci_mdio_of_param {
	int autosuspend_delay_ms;
};

struct davinci_mdio_regs {
	u32 version;
	u32 control;
	u32 alive;
	u32 link;
	u32 linkintraw;
	u32 linkintmasked;
	u32 __reserved_0[2];
	u32 userintraw;
	u32 userintmasked;
	u32 userintmaskset;
	u32 userintmaskclr;
	u32 __reserved_1[20];
	struct {
		u32 access;
		u32 physel;
	} user[0];
};

struct davinci_mdio_data {
	struct mdio_platform_data pdata;
	struct davinci_mdio_regs *regs;
	struct clk *clk;
	struct device *dev;
	struct mii_bus *bus;
	bool active_in_suspend;
	long unsigned int access_time;
	bool skip_scan;
	u32 clk_div;
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct cpsw_ale_params {
	struct device *dev;
	void *ale_regs;
	long unsigned int ale_ageout;
	long unsigned int ale_entries;
	long unsigned int ale_ports;
	bool nu_switch_ale;
	u32 major_ver_mask;
	const char *dev_id;
	long unsigned int bus_freq;
};

struct ale_entry_fld;

struct cpsw_ale {
	struct cpsw_ale_params params;
	struct timer_list timer;
	long unsigned int ageout;
	u32 version;
	u32 features;
	u32 port_mask_bits;
	u32 port_num_bits;
	u32 vlan_field_bits;
	long unsigned int *p0_untag_vid_mask;
	const struct ale_entry_fld *vlan_entry_tbl;
};

struct ale_entry_fld {
	u8 start_bit;
	u8 num_bits;
	u8 flags;
};

enum cpsw_ale_control {
	ALE_ENABLE = 0,
	ALE_CLEAR = 1,
	ALE_AGEOUT = 2,
	ALE_P0_UNI_FLOOD = 3,
	ALE_VLAN_NOLEARN = 4,
	ALE_NO_PORT_VLAN = 5,
	ALE_OUI_DENY = 6,
	ALE_BYPASS = 7,
	ALE_RATE_LIMIT_TX = 8,
	ALE_VLAN_AWARE = 9,
	ALE_AUTH_ENABLE = 10,
	ALE_RATE_LIMIT = 11,
	ALE_PORT_STATE = 12,
	ALE_PORT_DROP_UNTAGGED = 13,
	ALE_PORT_DROP_UNKNOWN_VLAN = 14,
	ALE_PORT_NOLEARN = 15,
	ALE_PORT_NO_SA_UPDATE = 16,
	ALE_PORT_UNKNOWN_VLAN_MEMBER = 17,
	ALE_PORT_UNKNOWN_MCAST_FLOOD = 18,
	ALE_PORT_UNKNOWN_REG_MCAST_FLOOD = 19,
	ALE_PORT_UNTAGGED_EGRESS = 20,
	ALE_PORT_MACONLY = 21,
	ALE_PORT_MACONLY_CAF = 22,
	ALE_PORT_BCAST_LIMIT = 23,
	ALE_PORT_MCAST_LIMIT = 24,
	ALE_DEFAULT_THREAD_ID = 25,
	ALE_DEFAULT_THREAD_ENABLE = 26,
	ALE_NUM_CONTROLS = 27,
};

enum cpsw_ale_port_state {
	ALE_PORT_STATE_DISABLE = 0,
	ALE_PORT_STATE_BLOCK = 1,
	ALE_PORT_STATE_LEARN = 2,
	ALE_PORT_STATE_FORWARD = 3,
};

struct cpsw_wr_regs {
	u32 id_ver;
	u32 soft_reset;
	u32 control;
	u32 int_control;
	u32 rx_thresh_en;
	u32 rx_en;
	u32 tx_en;
	u32 misc_en;
	u32 mem_allign1[8];
	u32 rx_thresh_stat;
	u32 rx_stat;
	u32 tx_stat;
	u32 misc_stat;
	u32 mem_allign2[8];
	u32 rx_imax;
	u32 tx_imax;
};

struct cpsw_ss_regs {
	u32 id_ver;
	u32 control;
	u32 soft_reset;
	u32 stat_port_en;
	u32 ptype;
	u32 soft_idle;
	u32 thru_rate;
	u32 gap_thresh;
	u32 tx_start_wds;
	u32 flow_control;
	u32 vlan_ltype;
	u32 ts_ltype;
	u32 dlr_ltype;
};

struct cpsw_host_regs {
	u32 max_blks;
	u32 blk_cnt;
	u32 tx_in_ctl;
	u32 port_vlan;
	u32 tx_pri_map;
	u32 cpdma_tx_pri_map;
	u32 cpdma_rx_chan_map;
};

struct cpsw_slave_data {
	struct device_node *slave_node;
	struct device_node *phy_node;
	char phy_id[61];
	phy_interface_t phy_if;
	u8 mac_addr[6];
	u16 dual_emac_res_vlan;
	struct phy *ifphy;
	bool disabled;
};

struct cpsw_platform_data {
	struct cpsw_slave_data *slave_data;
	u32 ss_reg_ofs;
	u32 channels;
	u32 slaves;
	u32 active_slave;
	u32 bd_ram_size;
	u32 mac_control;
	u16 default_vlan;
	bool dual_emac;
};

struct cpsw_sl;

struct cpsw_slave {
	void *regs;
	int slave_num;
	u32 mac_control;
	struct cpsw_slave_data *data;
	struct phy_device *phy;
	struct net_device *ndev;
	u32 port_vlan;
	struct cpsw_sl *mac_sl;
};

struct cpdma_chan;

struct cpsw_vector {
	struct cpdma_chan *ch;
	int budget;
};

struct cpdma_ctlr;

struct cpts;

struct devlink___2;

struct cpsw_common {
	struct device *dev;
	struct cpsw_platform_data data;
	int: 32;
	struct napi_struct napi_rx;
	struct napi_struct napi_tx;
	struct cpsw_ss_regs *regs;
	struct cpsw_wr_regs *wr_regs;
	u8 *hw_stats;
	struct cpsw_host_regs *host_port_regs;
	u32 version;
	u32 coal_intvl;
	u32 bus_freq_mhz;
	int rx_packet_max;
	int descs_pool_size;
	struct cpsw_slave *slaves;
	struct cpdma_ctlr *dma;
	struct cpsw_vector txv[8];
	struct cpsw_vector rxv[8];
	struct cpsw_ale *ale;
	bool quirk_irq;
	bool rx_irq_disabled;
	bool tx_irq_disabled;
	u32 irqs_table[2];
	int misc_irq;
	struct cpts *cpts;
	struct devlink___2 *devlink;
	int rx_ch_num;
	int tx_ch_num;
	int speed;
	int usage_count;
	struct page_pool *page_pool[8];
	u8 br_members;
	struct net_device *hw_bridge_dev;
	bool ale_bypass;
	u8 base_mac[6];
};

struct cpsw_priv {
	struct net_device *ndev;
	struct device *dev;
	u32 msg_enable;
	u8 mac_addr[6];
	bool rx_pause;
	bool tx_pause;
	bool mqprio_hw;
	int fifo_bw[4];
	int shp_cfg_speed;
	int tx_ts_enabled;
	int rx_ts_enabled;
	struct bpf_prog *xdp_prog;
	int: 32;
	int: 32;
	struct xdp_rxq_info xdp_rxq[8];
	struct xdp_attachment_info xdpi;
	u32 emac_port;
	struct cpsw_common *cpsw;
	int offload_fwd_mark;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct addr_sync_ctx {
	struct net_device *ndev;
	const u8 *addr;
	int consumed;
	int flush;
};

struct cpsw_meta_xdp {
	struct net_device *ndev;
	int ch;
};

enum cpsw_sl_regs {
	CPSW_SL_IDVER = 0,
	CPSW_SL_MACCONTROL = 1,
	CPSW_SL_MACSTATUS = 2,
	CPSW_SL_SOFT_RESET = 3,
	CPSW_SL_RX_MAXLEN = 4,
	CPSW_SL_BOFFTEST = 5,
	CPSW_SL_RX_PAUSE = 6,
	CPSW_SL_TX_PAUSE = 7,
	CPSW_SL_EMCONTROL = 8,
	CPSW_SL_RX_PRI_MAP = 9,
	CPSW_SL_TX_GAP = 10,
};

enum {
	CPSW_SL_CTL_FULLDUPLEX = 1,
	CPSW_SL_CTL_LOOPBACK = 2,
	CPSW_SL_CTL_MTEST = 4,
	CPSW_SL_CTL_RX_FLOW_EN = 8,
	CPSW_SL_CTL_TX_FLOW_EN = 16,
	CPSW_SL_CTL_GMII_EN = 32,
	CPSW_SL_CTL_TX_PACE = 64,
	CPSW_SL_CTL_GIG = 128,
	CPSW_SL_CTL_XGIG = 256,
	CPSW_SL_CTL_TX_SHORT_GAP_EN = 1024,
	CPSW_SL_CTL_CMD_IDLE = 2048,
	CPSW_SL_CTL_CRC_TYPE = 4096,
	CPSW_SL_CTL_XGMII_EN = 8192,
	CPSW_SL_CTL_IFCTL_A = 32768,
	CPSW_SL_CTL_IFCTL_B = 65536,
	CPSW_SL_CTL_GIG_FORCE = 131072,
	CPSW_SL_CTL_EXT_EN = 262144,
	CPSW_SL_CTL_EXT_EN_RX_FLO = 524288,
	CPSW_SL_CTL_EXT_EN_TX_FLO = 1048576,
	CPSW_SL_CTL_TX_SG_LIM_EN = 2097152,
	CPSW_SL_CTL_RX_CEF_EN = 4194304,
	CPSW_SL_CTL_RX_CSF_EN = 8388608,
	CPSW_SL_CTL_RX_CMF_EN = 16777216,
	CPSW_SL_CTL_EXT_EN_XGIG = 33554432,
	CPSW_SL_CTL_FUNCS_COUNT = 33554433,
};

struct cpdma_params {
	struct device *dev;
	void *dmaregs;
	void *txhdp;
	void *rxhdp;
	void *txcp;
	void *rxcp;
	void *rxthresh;
	void *rxfree;
	int num_chan;
	bool has_soft_reset;
	int min_packet_size;
	dma_addr_t desc_mem_phys;
	dma_addr_t desc_hw_addr;
	int desc_mem_size;
	int desc_align;
	u32 bus_freq_mhz;
	u32 descs_pool_size;
	bool has_ext_regs;
};

struct cpdma_chan_stats {
	u32 head_enqueue;
	u32 tail_enqueue;
	u32 pad_enqueue;
	u32 misqueued;
	u32 desc_alloc_fail;
	u32 pad_alloc_fail;
	u32 runt_receive_buff;
	u32 runt_transmit_buff;
	u32 empty_dequeue;
	u32 busy_dequeue;
	u32 good_dequeue;
	u32 requeue;
	u32 teardown_dequeue;
};

typedef void (*cpdma_handler_fn)(void *, int, int);

enum cpdma_control {
	CPDMA_TX_RLIM = 0,
	CPDMA_CMD_IDLE = 1,
	CPDMA_COPY_ERROR_FRAMES = 2,
	CPDMA_RX_OFF_LEN_UPDATE = 3,
	CPDMA_RX_OWNERSHIP_FLIP = 4,
	CPDMA_TX_PRIO_FIXED = 5,
	CPDMA_STAT_IDLE = 6,
	CPDMA_STAT_TX_ERR_CHAN = 7,
	CPDMA_STAT_TX_ERR_CODE = 8,
	CPDMA_STAT_RX_ERR_CHAN = 9,
	CPDMA_STAT_RX_ERR_CODE = 10,
	CPDMA_RX_BUFFER_OFFSET = 11,
};

struct cpdma_desc {
	u32 hw_next;
	u32 hw_buffer;
	u32 hw_len;
	u32 hw_mode;
	void *sw_token;
	u32 sw_buffer;
	u32 sw_len;
};

struct cpdma_desc_pool {
	phys_addr_t phys;
	dma_addr_t hw_addr;
	void *iomap;
	void *cpumap;
	int desc_size;
	int mem_size;
	int num_desc;
	struct device *dev;
	struct gen_pool *gen_pool;
};

enum cpdma_state {
	CPDMA_STATE_IDLE = 0,
	CPDMA_STATE_ACTIVE = 1,
	CPDMA_STATE_TEARDOWN = 2,
};

struct cpdma_chan___2;

struct cpdma_ctlr___2 {
	enum cpdma_state state;
	struct cpdma_params params;
	struct device *dev;
	struct cpdma_desc_pool *pool;
	spinlock_t lock;
	struct cpdma_chan___2 *channels[64];
	int chan_num;
	int num_rx_desc;
	int num_tx_desc;
};

struct cpdma_chan___2 {
	struct cpdma_desc *head;
	struct cpdma_desc *tail;
	void *hdp;
	void *cp;
	void *rxfree;
	enum cpdma_state state;
	struct cpdma_ctlr___2 *ctlr;
	int chan_num;
	spinlock_t lock;
	int count;
	u32 desc_num;
	u32 mask;
	cpdma_handler_fn handler;
	enum dma_data_direction dir;
	struct cpdma_chan_stats stats;
	int int_set;
	int int_clear;
	int td;
	int weight;
	u32 rate_factor;
	u32 rate;
};

struct cpdma_control_info {
	u32 reg;
	u32 shift;
	u32 mask;
	int access;
};

struct submit_info {
	struct cpdma_chan___2 *chan;
	int directed;
	void *token;
	void *data_virt;
	dma_addr_t data_dma;
	int len;
};

enum {
	CPSW_ALE_F_STATUS_REG = 1,
	CPSW_ALE_F_HW_AUTOAGING = 2,
	CPSW_ALE_F_COUNT = 3,
};

struct cpsw_ale_dev_id {
	const char *dev_id;
	u32 features;
	u32 tbl_entries;
	u32 major_ver_mask;
	bool nu_switch_ale;
	const struct ale_entry_fld *vlan_entry_tbl;
};

enum {
	ALE_ENT_VID_MEMBER_LIST = 0,
	ALE_ENT_VID_UNREG_MCAST_MSK = 1,
	ALE_ENT_VID_REG_MCAST_MSK = 2,
	ALE_ENT_VID_FORCE_UNTAGGED_MSK = 3,
	ALE_ENT_VID_UNREG_MCAST_IDX = 4,
	ALE_ENT_VID_REG_MCAST_IDX = 5,
	ALE_ENT_VID_LAST = 6,
};

struct ale_control_info {
	const char *name;
	int offset;
	int port_offset;
	int shift;
	int port_shift;
	int bits;
};

enum {
	TC_MQPRIO_MODE_DCB = 0,
	TC_MQPRIO_MODE_CHANNEL = 1,
	__TC_MQPRIO_MODE_MAX = 2,
};

struct tc_mqprio_qopt {
	__u8 num_tc;
	__u8 prio_tc_map[16];
	__u8 hw;
	__u16 count[16];
	__u16 offset[16];
};

struct tc_mqprio_qopt_offload {
	struct tc_mqprio_qopt qopt;
	u16 mode;
	u16 shaper;
	u32 flags;
	int: 32;
	u64 min_rate[16];
	u64 max_rate[16];
};

enum {
	CPSW_RX_VLAN_ENCAP_HDR_PKT_VLAN_TAG = 0,
	CPSW_RX_VLAN_ENCAP_HDR_PKT_RESERV = 1,
	CPSW_RX_VLAN_ENCAP_HDR_PKT_PRIO_TAG = 2,
	CPSW_RX_VLAN_ENCAP_HDR_PKT_UNTAG = 3,
};

struct cpsw_sl___2 {
	struct device *dev;
	void *sl_base;
	const u16 *regs;
	u32 control_features;
	u32 idle_mask;
};

struct cpsw_sl_dev_id {
	const char *device_id;
	const u16 *regs;
	const u32 control_features;
	const u32 regs_offset;
	const u32 idle_mask;
};

struct cpsw_hw_stats {
	u32 rxgoodframes;
	u32 rxbroadcastframes;
	u32 rxmulticastframes;
	u32 rxpauseframes;
	u32 rxcrcerrors;
	u32 rxaligncodeerrors;
	u32 rxoversizedframes;
	u32 rxjabberframes;
	u32 rxundersizedframes;
	u32 rxfragments;
	u32 __pad_0[2];
	u32 rxoctets;
	u32 txgoodframes;
	u32 txbroadcastframes;
	u32 txmulticastframes;
	u32 txpauseframes;
	u32 txdeferredframes;
	u32 txcollisionframes;
	u32 txsinglecollframes;
	u32 txmultcollframes;
	u32 txexcessivecollisions;
	u32 txlatecollisions;
	u32 txunderrun;
	u32 txcarriersenseerrors;
	u32 txoctets;
	u32 octetframes64;
	u32 octetframes65t127;
	u32 octetframes128t255;
	u32 octetframes256t511;
	u32 octetframes512t1023;
	u32 octetframes1024tup;
	u32 netoctets;
	u32 rxsofoverruns;
	u32 rxmofoverruns;
	u32 rxdmaoverruns;
};

struct cpsw_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

enum {
	CPSW_STATS = 0,
	CPDMA_RX_STATS = 1,
	CPDMA_TX_STATS = 2,
};

struct net_local {
	struct net_device *ndev;
	bool tx_ping_pong;
	bool rx_ping_pong;
	u32 next_tx_buf_to_use;
	u32 next_rx_buf_to_use;
	void *base_addr;
	spinlock_t reset_lock;
	struct sk_buff *deferred_skb;
	struct phy_device *phy_dev;
	struct device_node *phy_node;
	struct mii_bus *mii_bus;
	int last_link;
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

enum pegasus_registers {
	EthCtrl0 = 0,
	EthCtrl1 = 1,
	EthCtrl2 = 2,
	EthID = 16,
	Reg1d = 29,
	EpromOffset = 32,
	EpromData = 33,
	EpromCtrl = 35,
	PhyAddr = 37,
	PhyData = 38,
	PhyCtrl = 40,
	UsbStst = 42,
	EthTxStat0 = 43,
	EthTxStat1 = 44,
	EthRxStat = 45,
	WakeupControl = 120,
	Reg7b = 123,
	Gpio0 = 126,
	Gpio1 = 127,
	Reg81 = 129,
};

struct pegasus {
	struct usb_device *usb;
	struct usb_interface *intf;
	struct net_device *net;
	struct mii_if_info mii;
	unsigned int flags;
	unsigned int features;
	u32 msg_enable;
	u32 wolopts;
	int dev_index;
	int intr_interval;
	struct tasklet_struct rx_tl;
	struct delayed_work carrier_check;
	struct urb *rx_urb;
	struct urb *tx_urb;
	struct urb *intr_urb;
	struct sk_buff *rx_skb;
	int chip;
	unsigned char intr_buff[8];
	__u8 tx_buff[1536];
	__u8 eth_regs[4];
	__u8 phy;
	__u8 gpio_res;
};

typedef struct pegasus pegasus_t;

struct usb_eth_dev {
	char *name;
	__u16 vendor;
	__u16 device;
	__u32 private;
};

struct driver_info;

struct usbnet {
	struct usb_device *udev;
	struct usb_interface *intf;
	const struct driver_info *driver_info;
	const char *driver_name;
	void *driver_priv;
	wait_queue_head_t wait;
	struct mutex phy_mutex;
	unsigned char suspend_count;
	unsigned char pkt_cnt;
	unsigned char pkt_err;
	short unsigned int rx_qlen;
	short unsigned int tx_qlen;
	unsigned int can_dma_sg: 1;
	unsigned int in;
	unsigned int out;
	struct usb_host_endpoint *status;
	unsigned int maxpacket;
	struct timer_list delay;
	const char *padding_pkt;
	struct net_device *net;
	int msg_enable;
	long unsigned int data[5];
	u32 xid;
	u32 hard_mtu;
	size_t rx_urb_size;
	struct mii_if_info mii;
	struct sk_buff_head rxq;
	struct sk_buff_head txq;
	struct sk_buff_head done;
	struct sk_buff_head rxq_pause;
	struct urb *interrupt;
	unsigned int interrupt_count;
	struct mutex interrupt_mutex;
	struct usb_anchor deferred;
	struct tasklet_struct bh;
	struct work_struct kevent;
	long unsigned int flags;
	u32 rx_speed;
	u32 tx_speed;
};

struct driver_info {
	char *description;
	int flags;
	int (*bind)(struct usbnet *, struct usb_interface *);
	void (*unbind)(struct usbnet *, struct usb_interface *);
	int (*reset)(struct usbnet *);
	int (*stop)(struct usbnet *);
	int (*check_connect)(struct usbnet *);
	int (*manage_power)(struct usbnet *, int);
	void (*status)(struct usbnet *, struct urb *);
	int (*link_reset)(struct usbnet *);
	int (*rx_fixup)(struct usbnet *, struct sk_buff *);
	struct sk_buff * (*tx_fixup)(struct usbnet *, struct sk_buff *, gfp_t);
	void (*recover)(struct usbnet *);
	int (*early_init)(struct usbnet *);
	void (*indication)(struct usbnet *, void *, int);
	void (*set_rx_mode)(struct usbnet *);
	int in;
	int out;
	long unsigned int data;
};

struct asix_data {
	u8 multi_filter[8];
	u8 mac_addr[6];
	u8 phymode;
	u8 ledmode;
	u8 res;
};

struct asix_rx_fixup_info {
	struct sk_buff *ax_skb;
	u32 header;
	u16 remaining;
	bool split_head;
};

struct asix_common_private {
	void (*resume)(struct usbnet *);
	void (*suspend)(struct usbnet *);
	u16 presvd_phy_advertise;
	u16 presvd_phy_bmcr;
	struct asix_rx_fixup_info rx_fixup_info;
};

struct ax88172_int_data {
	__le16 res1;
	u8 link;
	__le16 res2;
	u8 status;
	__le16 res3;
} __attribute__((packed));

enum skb_state {
	illegal = 0,
	tx_start = 1,
	tx_done___2 = 2,
	rx_start = 3,
	rx_done = 4,
	rx_cleanup = 5,
	unlink_start = 6,
};

struct skb_data {
	struct urb *urb;
	struct usbnet *dev;
	enum skb_state state;
	long int length;
	long unsigned int packets;
};

struct ax88172a_private {
	struct mii_bus *mdio;
	struct phy_device *phydev;
	char phy_name[20];
	u16 phy_addr;
	u16 oldmode;
	int use_embdphy;
	struct asix_rx_fixup_info rx_fixup_info;
};

struct ax88179_data {
	u8 eee_enabled;
	u8 eee_active;
	u16 rxctl;
	u16 reserved;
};

struct ax88179_int_data {
	__le32 intdata1;
	__le32 intdata2;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_notification {
	__u8 bmRequestType;
	__u8 bNotificationType;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct cdc_state {
	struct usb_cdc_header_desc *header;
	struct usb_cdc_union_desc *u;
	struct usb_cdc_ether_desc *ether;
	struct usb_interface *control;
	struct usb_interface *data;
};

struct smsc75xx_priv {
	struct usbnet *dev;
	u32 rfe_ctl;
	u32 wolopts;
	u32 multicast_hash_table[16];
	struct mutex dataport_mutex;
	spinlock_t rfe_ctl_lock;
	struct work_struct set_multicast;
	u8 suspend_flags;
};

struct smsc95xx_priv {
	u32 mac_cr;
	u32 hash_hi;
	u32 hash_lo;
	u32 wolopts;
	spinlock_t mac_cr_lock;
	u8 features;
	u8 suspend_flags;
	struct mii_bus *mdiobus;
	struct phy_device *phydev;
};

struct nc_header {
	__le16 hdr_len;
	__le16 packet_len;
	__le16 packet_id;
};

struct nc_trailer {
	__le16 packet_id;
};

struct usb_cdc_speed_change {
	__le32 DLBitRRate;
	__le32 ULBitRate;
};

struct usb_cdc_ncm_ntb_parameters {
	__le16 wLength;
	__le16 bmNtbFormatsSupported;
	__le32 dwNtbInMaxSize;
	__le16 wNdpInDivisor;
	__le16 wNdpInPayloadRemainder;
	__le16 wNdpInAlignment;
	__le16 wPadding1;
	__le32 dwNtbOutMaxSize;
	__le16 wNdpOutDivisor;
	__le16 wNdpOutPayloadRemainder;
	__le16 wNdpOutAlignment;
	__le16 wNtbOutMaxDatagrams;
};

struct usb_cdc_ncm_nth16 {
	__le32 dwSignature;
	__le16 wHeaderLength;
	__le16 wSequence;
	__le16 wBlockLength;
	__le16 wNdpIndex;
};

struct usb_cdc_ncm_nth32 {
	__le32 dwSignature;
	__le16 wHeaderLength;
	__le16 wSequence;
	__le32 dwBlockLength;
	__le32 dwNdpIndex;
};

struct usb_cdc_ncm_dpe16 {
	__le16 wDatagramIndex;
	__le16 wDatagramLength;
};

struct usb_cdc_ncm_ndp16 {
	__le32 dwSignature;
	__le16 wLength;
	__le16 wNextNdpIndex;
	struct usb_cdc_ncm_dpe16 dpe16[0];
};

struct usb_cdc_ncm_dpe32 {
	__le32 dwDatagramIndex;
	__le32 dwDatagramLength;
};

struct usb_cdc_ncm_ndp32 {
	__le32 dwSignature;
	__le16 wLength;
	__le16 wReserved6;
	__le32 dwNextNdpIndex;
	__le32 dwReserved12;
	struct usb_cdc_ncm_dpe32 dpe32[0];
};

struct cdc_ncm_ctx {
	struct usb_cdc_ncm_ntb_parameters ncm_parm;
	int: 32;
	struct hrtimer tx_timer;
	struct tasklet_struct bh;
	const struct usb_cdc_ncm_desc *func_desc;
	const struct usb_cdc_mbim_desc *mbim_desc;
	const struct usb_cdc_mbim_extended_desc *mbim_extended_desc;
	const struct usb_cdc_ether_desc *ether_desc;
	struct usb_interface *control;
	struct usb_interface *data;
	struct sk_buff *tx_curr_skb;
	struct sk_buff *tx_rem_skb;
	__le32 tx_rem_sign;
	spinlock_t mtx;
	atomic_t stop;
	int drvflags;
	u32 timer_interval;
	u32 max_ndp_size;
	u8 is_ndp16;
	union {
		struct usb_cdc_ncm_ndp16 *delayed_ndp16;
		struct usb_cdc_ncm_ndp32 *delayed_ndp32;
	};
	u32 tx_timer_pending;
	u32 tx_curr_frame_num;
	u32 rx_max;
	u32 tx_max;
	u32 tx_curr_size;
	u32 tx_low_mem_max_cnt;
	u32 tx_low_mem_val;
	u32 max_datagram_size;
	u16 tx_max_datagrams;
	u16 tx_remainder;
	u16 tx_modulus;
	u16 tx_ndp_modulus;
	u16 tx_seq;
	u16 rx_seq;
	u16 min_tx_pkt;
	u32 tx_curr_frame_payload;
	u32 tx_reason_ntb_full;
	u32 tx_reason_ndp_full;
	u32 tx_reason_timeout;
	u32 tx_reason_max_datagram;
	int: 32;
	u64 tx_overhead;
	u64 tx_ntbs;
	u64 rx_overhead;
	u64 rx_ntbs;
};

struct cdc_ncm_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

struct net_failover_info {
	struct net_device *primary_dev;
	struct net_device *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
	int: 32;
};

struct cdrom_msf {
	__u8 cdmsf_min0;
	__u8 cdmsf_sec0;
	__u8 cdmsf_frame0;
	__u8 cdmsf_min1;
	__u8 cdmsf_sec1;
	__u8 cdmsf_frame1;
};

struct cdrom_volctrl {
	__u8 channel0;
	__u8 channel1;
	__u8 channel2;
	__u8 channel3;
};

struct cdrom_subchnl {
	__u8 cdsc_format;
	__u8 cdsc_audiostatus;
	__u8 cdsc_adr: 4;
	__u8 cdsc_ctrl: 4;
	__u8 cdsc_trk;
	__u8 cdsc_ind;
	union cdrom_addr cdsc_absaddr;
	union cdrom_addr cdsc_reladdr;
};

struct cdrom_read_audio {
	union cdrom_addr addr;
	__u8 addr_format;
	int nframes;
	__u8 *buf;
};

struct cdrom_blk {
	unsigned int from;
	short unsigned int len;
};

struct dvd_layer {
	__u8 book_version: 4;
	__u8 book_type: 4;
	__u8 min_rate: 4;
	__u8 disc_size: 4;
	__u8 layer_type: 4;
	__u8 track_path: 1;
	__u8 nlayers: 2;
	char: 1;
	__u8 track_density: 4;
	__u8 linear_density: 4;
	__u8 bca: 1;
	__u32 start_sector;
	__u32 end_sector;
	__u32 end_sector_l0;
};

struct dvd_physical {
	__u8 type;
	__u8 layer_num;
	struct dvd_layer layer[4];
};

struct dvd_copyright {
	__u8 type;
	__u8 layer_num;
	__u8 cpst;
	__u8 rmi;
};

struct dvd_disckey {
	__u8 type;
	unsigned int agid: 2;
	__u8 value[2048];
};

struct dvd_bca {
	__u8 type;
	int len;
	__u8 value[188];
};

struct dvd_manufact {
	__u8 type;
	__u8 layer_num;
	int len;
	__u8 value[2048];
};

typedef union {
	__u8 type;
	struct dvd_physical physical;
	struct dvd_copyright copyright;
	struct dvd_disckey disckey;
	struct dvd_bca bca;
	struct dvd_manufact manufact;
} dvd_struct;

typedef __u8 dvd_key[5];

typedef __u8 dvd_challenge[10];

struct dvd_lu_send_agid {
	__u8 type;
	unsigned int agid: 2;
};

struct dvd_host_send_challenge {
	__u8 type;
	unsigned int agid: 2;
	dvd_challenge chal;
};

struct dvd_send_key {
	__u8 type;
	unsigned int agid: 2;
	dvd_key key;
};

struct dvd_lu_send_challenge {
	__u8 type;
	unsigned int agid: 2;
	dvd_challenge chal;
};

struct dvd_lu_send_title_key {
	__u8 type;
	unsigned int agid: 2;
	dvd_key title_key;
	int lba;
	unsigned int cpm: 1;
	unsigned int cp_sec: 1;
	unsigned int cgms: 2;
};

struct dvd_lu_send_asf {
	__u8 type;
	unsigned int agid: 2;
	unsigned int asf: 1;
};

struct dvd_host_send_rpcstate {
	__u8 type;
	__u8 pdrc;
};

struct dvd_lu_send_rpcstate {
	__u8 type: 2;
	__u8 vra: 3;
	__u8 ucca: 3;
	__u8 region_mask;
	__u8 rpc_scheme;
};

typedef union {
	__u8 type;
	struct dvd_lu_send_agid lsa;
	struct dvd_host_send_challenge hsc;
	struct dvd_send_key lsk;
	struct dvd_lu_send_challenge lsc;
	struct dvd_send_key hsk;
	struct dvd_lu_send_title_key lstk;
	struct dvd_lu_send_asf lsasf;
	struct dvd_host_send_rpcstate hrpcs;
	struct dvd_lu_send_rpcstate lrpcs;
} dvd_authinfo;

struct mrw_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u8 write: 1;
	__u8 reserved2: 7;
	__u8 reserved3;
	__u8 reserved4;
	__u8 reserved5;
};

struct rwrt_feature_desc {
	__be16 feature_code;
	__u8 curr: 1;
	__u8 persistent: 1;
	__u8 feature_version: 4;
	__u8 reserved1: 2;
	__u8 add_len;
	__u32 last_lba;
	__u32 block_size;
	__u16 blocking;
	__u8 page_present: 1;
	__u8 reserved2: 7;
	__u8 reserved3;
};

typedef struct {
	__be16 disc_information_length;
	__u8 disc_status: 2;
	__u8 border_status: 2;
	__u8 erasable: 1;
	__u8 reserved1: 3;
	__u8 n_first_track;
	__u8 n_sessions_lsb;
	__u8 first_track_lsb;
	__u8 last_track_lsb;
	__u8 mrw_status: 2;
	__u8 dbit: 1;
	__u8 reserved2: 2;
	__u8 uru: 1;
	__u8 dbc_v: 1;
	__u8 did_v: 1;
	__u8 disc_type;
	__u8 n_sessions_msb;
	__u8 first_track_msb;
	__u8 last_track_msb;
	__u32 disc_id;
	__u32 lead_in;
	__u32 lead_out;
	__u8 disc_bar_code[8];
	__u8 reserved3;
	__u8 n_opc;
} disc_information;

typedef struct {
	__be16 track_information_length;
	__u8 track_lsb;
	__u8 session_lsb;
	__u8 reserved1;
	__u8 track_mode: 4;
	__u8 copy: 1;
	__u8 damage: 1;
	__u8 reserved2: 2;
	__u8 data_mode: 4;
	__u8 fp: 1;
	__u8 packet: 1;
	__u8 blank: 1;
	__u8 rt: 1;
	__u8 nwa_v: 1;
	__u8 lra_v: 1;
	__u8 reserved3: 6;
	__be32 track_start;
	__be32 next_writable;
	__be32 free_blocks;
	__be32 fixed_packet_size;
	__be32 track_size;
	__be32 last_rec_address;
} track_information;

struct mode_page_header {
	__be16 mode_data_length;
	__u8 medium_type;
	__u8 reserved1;
	__u8 reserved2;
	__u8 reserved3;
	__be16 desc_length;
};

typedef struct {
	int data;
	int audio;
	int cdi;
	int xa;
	long int error;
} tracktype;

struct cdrom_mechstat_header {
	__u8 curslot: 5;
	__u8 changer_state: 2;
	__u8 fault: 1;
	__u8 reserved1: 4;
	__u8 door_open: 1;
	__u8 mech_state: 3;
	__u8 curlba[3];
	__u8 nslots;
	__u16 slot_tablelen;
};

struct cdrom_slot {
	__u8 change: 1;
	__u8 reserved1: 6;
	__u8 disc_present: 1;
	__u8 reserved2[3];
};

struct cdrom_changer_info {
	struct cdrom_mechstat_header hdr;
	struct cdrom_slot slots[256];
};

struct modesel_head {
	__u8 reserved1;
	__u8 medium;
	__u8 reserved2;
	__u8 block_desc_length;
	__u8 density;
	__u8 number_of_blocks_hi;
	__u8 number_of_blocks_med;
	__u8 number_of_blocks_lo;
	__u8 reserved3;
	__u8 block_length_hi;
	__u8 block_length_med;
	__u8 block_length_lo;
};

typedef struct {
	__u16 report_key_length;
	__u8 reserved1;
	__u8 reserved2;
	__u8 ucca: 3;
	__u8 vra: 3;
	__u8 type_code: 2;
	__u8 region_mask;
	__u8 rpc_scheme;
	__u8 reserved3;
} rpc_state_t;

struct cdrom_sysctl_settings {
	char info[1000];
	int autoclose;
	int autoeject;
	int debug;
	int lock;
	int check;
};

enum cdrom_print_option {
	CTL_NAME = 0,
	CTL_SPEED = 1,
	CTL_SLOTS = 2,
	CTL_CAPABILITY = 3,
};

struct usb_otg_caps {
	u16 otg_rev;
	bool hnp_support;
	bool srp_support;
	bool adp_support;
};

struct usb_conn_info {
	struct device *dev;
	struct usb_role_switch *role_sw;
	enum usb_role last_role;
	struct regulator *vbus;
	struct delayed_work dw_det;
	long unsigned int debounce_jiffies;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	int id_irq;
	int vbus_irq;
	struct power_supply_desc desc;
	struct power_supply *charger;
};

struct ulpi_ops {
	int (*read)(struct device *, u8);
	int (*write)(struct device *, u8, u8);
};

struct ulpi_device_id {
	__u16 vendor;
	__u16 product;
	kernel_ulong_t driver_data;
};

struct ulpi {
	struct ulpi_device_id id;
	const struct ulpi_ops *ops;
	int: 32;
	struct device dev;
};

struct ulpi_driver {
	const struct ulpi_device_id *id_table;
	int (*probe)(struct ulpi *);
	void (*remove)(struct ulpi *);
	struct device_driver driver;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

struct giveback_urb_bh {
	bool running;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy_roothub;

struct hc_driver;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool___2 *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

typedef u32 usb_port_location_t;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
};

struct usb_dev_state;

struct usb_port {
	struct usb_device *child;
	int: 32;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_otg_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bmAttributes;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

struct api_context {
	struct completion done;
	int status;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_class {
	struct kref kref;
	struct class *class;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usb_dev_state___2 {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state___2 *ps;
};

struct async {
	struct list_head asynclist;
	struct usb_dev_state___2 *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE = 1,
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct class_info {
	int class;
	char *class_name;
};

struct usb_phy_roothub___2 {
	struct phy *phy;
	struct list_head list;
};

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

struct phy_devm {
	struct usb_phy *phy;
	struct notifier_block *nb;
};

enum ux500_musb_vbus_id_status {
	UX500_MUSB_NONE = 0,
	UX500_MUSB_VBUS = 1,
	UX500_MUSB_ID = 2,
	UX500_MUSB_CHARGER = 3,
	UX500_MUSB_ENUMERATED = 4,
	UX500_MUSB_RIDA = 5,
	UX500_MUSB_RIDB = 6,
	UX500_MUSB_RIDC = 7,
	UX500_MUSB_PREPARE = 8,
	UX500_MUSB_CLEAN = 9,
};

enum ab8500_usb_link_status {
	USB_LINK_NOT_CONFIGURED_8500 = 0,
	USB_LINK_STD_HOST_NC_8500 = 1,
	USB_LINK_STD_HOST_C_NS_8500 = 2,
	USB_LINK_STD_HOST_C_S_8500 = 3,
	USB_LINK_HOST_CHG_NM_8500 = 4,
	USB_LINK_HOST_CHG_HS_8500 = 5,
	USB_LINK_HOST_CHG_HS_CHIRP_8500 = 6,
	USB_LINK_DEDICATED_CHG_8500 = 7,
	USB_LINK_ACA_RID_A_8500 = 8,
	USB_LINK_ACA_RID_B_8500 = 9,
	USB_LINK_ACA_RID_C_NM_8500 = 10,
	USB_LINK_ACA_RID_C_HS_8500 = 11,
	USB_LINK_ACA_RID_C_HS_CHIRP_8500 = 12,
	USB_LINK_HM_IDGND_8500 = 13,
	USB_LINK_RESERVED_8500 = 14,
	USB_LINK_NOT_VALID_LINK_8500 = 15,
};

enum ab8505_usb_link_status {
	USB_LINK_NOT_CONFIGURED_8505 = 0,
	USB_LINK_STD_HOST_NC_8505 = 1,
	USB_LINK_STD_HOST_C_NS_8505 = 2,
	USB_LINK_STD_HOST_C_S_8505 = 3,
	USB_LINK_CDP_8505 = 4,
	USB_LINK_RESERVED0_8505 = 5,
	USB_LINK_RESERVED1_8505 = 6,
	USB_LINK_DEDICATED_CHG_8505 = 7,
	USB_LINK_ACA_RID_A_8505 = 8,
	USB_LINK_ACA_RID_B_8505 = 9,
	USB_LINK_ACA_RID_C_NM_8505 = 10,
	USB_LINK_RESERVED2_8505 = 11,
	USB_LINK_RESERVED3_8505 = 12,
	USB_LINK_HM_IDGND_8505 = 13,
	USB_LINK_CHARGERPORT_NOT_OK_8505 = 14,
	USB_LINK_CHARGER_DM_HIGH_8505 = 15,
	USB_LINK_PHYEN_NO_VBUS_NO_IDGND_8505 = 16,
	USB_LINK_STD_UPSTREAM_NO_IDGNG_NO_VBUS_8505 = 17,
	USB_LINK_STD_UPSTREAM_8505 = 18,
	USB_LINK_CHARGER_SE1_8505 = 19,
	USB_LINK_CARKIT_CHGR_1_8505 = 20,
	USB_LINK_CARKIT_CHGR_2_8505 = 21,
	USB_LINK_ACA_DOCK_CHGR_8505 = 22,
	USB_LINK_SAMSUNG_BOOT_CBL_PHY_EN_8505 = 23,
	USB_LINK_SAMSUNG_BOOT_CBL_PHY_DISB_8505 = 24,
	USB_LINK_SAMSUNG_UART_CBL_PHY_EN_8505 = 25,
	USB_LINK_SAMSUNG_UART_CBL_PHY_DISB_8505 = 26,
	USB_LINK_MOTOROLA_FACTORY_CBL_PHY_EN_8505 = 27,
};

enum ab8500_usb_mode {
	USB_IDLE = 0,
	USB_PERIPHERAL = 1,
	USB_HOST = 2,
	USB_DEDICATED_CHG = 3,
	USB_UART = 4,
};

struct ab8500_usb {
	struct usb_phy phy;
	struct device *dev;
	struct ab8500 *ab8500;
	unsigned int vbus_draw;
	struct work_struct phy_dis_work;
	enum ab8500_usb_mode mode;
	struct clk *sysclk;
	struct regulator *v_ape;
	struct regulator *v_musb;
	struct regulator *v_ulpi;
	int saved_v_ulpi;
	int previous_link_status_state;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_sleep;
	bool enabled_charging_detection;
	unsigned int flags;
};

struct tegra_phy_soc_config {
	bool utmi_pll_config_in_car_module;
	bool has_hostpc;
	bool requires_usbmode_setup;
	bool requires_extra_tuning_parameters;
};

struct tegra_utmip_config {
	u8 hssync_start_delay;
	u8 elastic_limit;
	u8 idle_wait_delay;
	u8 term_range_adj;
	bool xcvr_setup_use_fuses;
	u8 xcvr_setup;
	u8 xcvr_lsfslew;
	u8 xcvr_lsrslew;
	u8 xcvr_hsslew;
	u8 hssquelch_level;
	u8 hsdiscon_level;
};

enum tegra_usb_phy_port_speed {
	TEGRA_USB_PHY_PORT_SPEED_FULL = 0,
	TEGRA_USB_PHY_PORT_SPEED_LOW = 1,
	TEGRA_USB_PHY_PORT_SPEED_HIGH = 2,
};

struct tegra_xtal_freq;

struct tegra_usb_phy {
	int instance;
	const struct tegra_xtal_freq *freq;
	void *regs;
	void *pad_regs;
	struct clk *clk;
	struct clk *pll_u;
	struct clk *pad_clk;
	struct regulator *vbus;
	enum usb_dr_mode mode;
	void *config;
	const struct tegra_phy_soc_config *soc_config;
	struct usb_phy *ulpi;
	struct usb_phy u_phy;
	bool is_legacy_phy;
	bool is_ulpi_phy;
	struct gpio_desc *reset_gpio;
	struct reset_control *pad_rst;
	bool powered_on;
};

struct tegra_xtal_freq {
	unsigned int freq;
	u8 enable_delay;
	u8 stable_count;
	u8 active_delay;
	u8 xtal_freq_count;
	u16 debounce;
};

struct usb_ep;

struct usb_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	struct scatterlist *sg;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id: 16;
	unsigned int is_last: 1;
	unsigned int no_interrupt: 1;
	unsigned int zero: 1;
	unsigned int short_not_ok: 1;
	unsigned int dma_mapped: 1;
	void (*complete)(struct usb_ep *, struct usb_request *);
	void *context;
	struct list_head list;
	unsigned int frame_number;
	int status;
	unsigned int actual;
};

struct usb_ep_caps {
	unsigned int type_control: 1;
	unsigned int type_iso: 1;
	unsigned int type_bulk: 1;
	unsigned int type_int: 1;
	unsigned int dir_in: 1;
	unsigned int dir_out: 1;
};

struct usb_ep_ops;

struct usb_ep {
	void *driver_data;
	const char *name;
	const struct usb_ep_ops *ops;
	struct list_head ep_list;
	struct usb_ep_caps caps;
	bool claimed;
	bool enabled;
	unsigned int maxpacket: 16;
	unsigned int maxpacket_limit: 16;
	unsigned int max_streams: 16;
	unsigned int mult: 2;
	unsigned int maxburst: 5;
	u8 address;
	const struct usb_endpoint_descriptor *desc;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
};

struct usb_ep_ops {
	int (*enable)(struct usb_ep *, const struct usb_endpoint_descriptor *);
	int (*disable)(struct usb_ep *);
	void (*dispose)(struct usb_ep *);
	struct usb_request * (*alloc_request)(struct usb_ep *, gfp_t);
	void (*free_request)(struct usb_ep *, struct usb_request *);
	int (*queue)(struct usb_ep *, struct usb_request *, gfp_t);
	int (*dequeue)(struct usb_ep *, struct usb_request *);
	int (*set_halt)(struct usb_ep *, int);
	int (*set_wedge)(struct usb_ep *);
	int (*fifo_status)(struct usb_ep *);
	void (*fifo_flush)(struct usb_ep *);
};

struct usb_dcd_config_params {
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
	__u8 besl_baseline;
	__u8 besl_deep;
};

struct usb_gadget_driver;

struct usb_gadget_ops {
	int (*get_frame)(struct usb_gadget *);
	int (*wakeup)(struct usb_gadget *);
	int (*set_selfpowered)(struct usb_gadget *, int);
	int (*vbus_session)(struct usb_gadget *, int);
	int (*vbus_draw)(struct usb_gadget *, unsigned int);
	int (*pullup)(struct usb_gadget *, int);
	int (*ioctl)(struct usb_gadget *, unsigned int, long unsigned int);
	void (*get_config_params)(struct usb_gadget *, struct usb_dcd_config_params *);
	int (*udc_start)(struct usb_gadget *, struct usb_gadget_driver *);
	int (*udc_stop)(struct usb_gadget *);
	void (*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
	struct usb_ep * (*match_ep)(struct usb_gadget *, struct usb_endpoint_descriptor *, struct usb_ss_ep_comp_descriptor *);
};

struct usb_udc;

struct usb_gadget {
	struct work_struct work;
	struct usb_udc *udc;
	const struct usb_gadget_ops *ops;
	struct usb_ep *ep0;
	struct list_head ep_list;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_device_state state;
	const char *name;
	int: 32;
	struct device dev;
	unsigned int isoch_delay;
	unsigned int out_epnum;
	unsigned int in_epnum;
	unsigned int mA;
	struct usb_otg_caps *otg_caps;
	unsigned int sg_supported: 1;
	unsigned int is_otg: 1;
	unsigned int is_a_peripheral: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int a_hnp_support: 1;
	unsigned int a_alt_hnp_support: 1;
	unsigned int hnp_polling_support: 1;
	unsigned int host_request_flag: 1;
	unsigned int quirk_ep_out_aligned_size: 1;
	unsigned int quirk_altset_not_supp: 1;
	unsigned int quirk_stall_not_supp: 1;
	unsigned int quirk_zlp_not_supp: 1;
	unsigned int quirk_avoids_skb_reserve: 1;
	unsigned int is_selfpowered: 1;
	unsigned int deactivated: 1;
	unsigned int connected: 1;
	unsigned int lpm_capable: 1;
	int irq;
	int: 32;
};

struct usb_gadget_driver {
	char *function;
	enum usb_device_speed max_speed;
	int (*bind)(struct usb_gadget *, struct usb_gadget_driver *);
	void (*unbind)(struct usb_gadget *);
	int (*setup)(struct usb_gadget *, const struct usb_ctrlrequest *);
	void (*disconnect)(struct usb_gadget *);
	void (*suspend)(struct usb_gadget *);
	void (*resume)(struct usb_gadget *);
	void (*reset)(struct usb_gadget *);
	struct device_driver driver;
	char *udc_name;
	struct list_head pending;
	unsigned int match_existing_only: 1;
};

struct gpio_vbus_data {
	struct gpio_desc *vbus_gpiod;
	struct gpio_desc *pullup_gpiod;
	struct usb_phy phy;
	struct device *dev;
	struct regulator *vbus_draw;
	int vbus_draw_enabled;
	unsigned int mA;
	struct delayed_work work;
	int vbus;
	int irq;
};

struct isp1301 {
	struct usb_phy phy;
	struct mutex mutex;
	struct i2c_client *client;
};

struct mxs_phy_data {
	unsigned int flags;
};

struct mxs_phy {
	struct usb_phy phy;
	struct clk *clk;
	const struct mxs_phy_data *data;
	struct regmap *regmap_anatop;
	int port_id;
	u32 tx_reg_set;
	u32 tx_reg_mask;
};

struct ulpi_info {
	unsigned int id;
	char *name;
};

struct dwc3;

struct dwc3_event_buffer {
	void *buf;
	void *cache;
	unsigned int length;
	unsigned int lpos;
	unsigned int count;
	unsigned int flags;
	dma_addr_t dma;
	struct dwc3 *dwc;
};

struct dwc3_ep;

struct dwc3_trb;

struct dwc3_request {
	struct usb_request request;
	struct list_head list;
	struct dwc3_ep *dep;
	struct scatterlist *sg;
	struct scatterlist *start_sg;
	unsigned int num_pending_sgs;
	unsigned int num_queued_sgs;
	unsigned int remaining;
	unsigned int status;
	u8 epnum;
	struct dwc3_trb *trb;
	dma_addr_t trb_dma;
	unsigned int num_trbs;
	unsigned int needs_extra_trb: 1;
	unsigned int direction: 1;
	unsigned int mapped: 1;
};

struct ulpi___2;

enum dwc3_ep0_next {
	DWC3_EP0_UNKNOWN = 0,
	DWC3_EP0_COMPLETE = 1,
	DWC3_EP0_NRDY_DATA = 2,
	DWC3_EP0_NRDY_STATUS = 3,
};

enum dwc3_ep0_state {
	EP0_UNCONNECTED = 0,
	EP0_SETUP_PHASE = 1,
	EP0_DATA_PHASE = 2,
	EP0_STATUS_PHASE = 3,
};

enum dwc3_link_state {
	DWC3_LINK_STATE_U0 = 0,
	DWC3_LINK_STATE_U1 = 1,
	DWC3_LINK_STATE_U2 = 2,
	DWC3_LINK_STATE_U3 = 3,
	DWC3_LINK_STATE_SS_DIS = 4,
	DWC3_LINK_STATE_RX_DET = 5,
	DWC3_LINK_STATE_SS_INACT = 6,
	DWC3_LINK_STATE_POLL = 7,
	DWC3_LINK_STATE_RECOV = 8,
	DWC3_LINK_STATE_HRESET = 9,
	DWC3_LINK_STATE_CMPLY = 10,
	DWC3_LINK_STATE_LPBK = 11,
	DWC3_LINK_STATE_RESET = 14,
	DWC3_LINK_STATE_RESUME = 15,
	DWC3_LINK_STATE_MASK = 15,
};

struct dwc3_hwparams {
	u32 hwparams0;
	u32 hwparams1;
	u32 hwparams2;
	u32 hwparams3;
	u32 hwparams4;
	u32 hwparams5;
	u32 hwparams6;
	u32 hwparams7;
	u32 hwparams8;
};

struct dwc3 {
	struct work_struct drd_work;
	struct dwc3_trb *ep0_trb;
	void *bounce;
	void *scratchbuf;
	u8 *setup_buf;
	dma_addr_t ep0_trb_addr;
	dma_addr_t bounce_addr;
	dma_addr_t scratch_addr;
	struct dwc3_request ep0_usb_req;
	struct completion ep0_in_setup;
	spinlock_t lock;
	struct device *dev;
	struct device *sysdev;
	struct platform_device *xhci;
	struct resource xhci_resources[2];
	struct dwc3_event_buffer *ev_buf;
	struct dwc3_ep *eps[32];
	struct usb_gadget *gadget;
	struct usb_gadget_driver *gadget_driver;
	struct clk_bulk_data *clks;
	int num_clks;
	struct reset_control *reset;
	struct usb_phy *usb2_phy;
	struct usb_phy *usb3_phy;
	struct phy *usb2_generic_phy;
	struct phy *usb3_generic_phy;
	bool phys_ready;
	struct ulpi___2 *ulpi;
	bool ulpi_ready;
	void *regs;
	size_t regs_size;
	enum usb_dr_mode dr_mode;
	u32 current_dr_role;
	u32 desired_dr_role;
	struct extcon_dev *edev;
	struct notifier_block edev_nb;
	enum usb_phy_interface hsphy_mode;
	struct usb_role_switch *role_sw;
	enum usb_dr_mode role_switch_default_mode;
	u32 fladj;
	u32 irq_gadget;
	u32 otg_irq;
	u32 current_otg_role;
	u32 desired_otg_role;
	bool otg_restart_host;
	u32 nr_scratch;
	u32 u1u2;
	u32 maximum_speed;
	u32 ip;
	u32 revision;
	u32 version_type;
	enum dwc3_ep0_next ep0_next_event;
	enum dwc3_ep0_state ep0state;
	enum dwc3_link_state link_state;
	u16 u2sel;
	u16 u2pel;
	u8 u1sel;
	u8 u1pel;
	u8 speed;
	u8 num_eps;
	struct dwc3_hwparams hwparams;
	struct dentry *root;
	struct debugfs_regset32 *regset;
	u32 dbg_lsp_select;
	u8 test_mode;
	u8 test_mode_nr;
	u8 lpm_nyet_threshold;
	u8 hird_threshold;
	u8 rx_thr_num_pkt_prd;
	u8 rx_max_burst_prd;
	u8 tx_thr_num_pkt_prd;
	u8 tx_max_burst_prd;
	const char *hsphy_interface;
	unsigned int connected: 1;
	unsigned int delayed_status: 1;
	unsigned int ep0_bounced: 1;
	unsigned int ep0_expect_in: 1;
	unsigned int has_hibernation: 1;
	unsigned int sysdev_is_parent: 1;
	unsigned int has_lpm_erratum: 1;
	unsigned int is_utmi_l1_suspend: 1;
	unsigned int is_fpga: 1;
	unsigned int pending_events: 1;
	unsigned int pullups_connected: 1;
	unsigned int setup_packet_pending: 1;
	unsigned int three_stage_setup: 1;
	unsigned int dis_start_transfer_quirk: 1;
	unsigned int usb3_lpm_capable: 1;
	unsigned int usb2_lpm_disable: 1;
	unsigned int disable_scramble_quirk: 1;
	unsigned int u2exit_lfps_quirk: 1;
	unsigned int u2ss_inp3_quirk: 1;
	unsigned int req_p1p2p3_quirk: 1;
	unsigned int del_p1p2p3_quirk: 1;
	unsigned int del_phy_power_chg_quirk: 1;
	unsigned int lfps_filter_quirk: 1;
	unsigned int rx_detect_poll_quirk: 1;
	unsigned int dis_u3_susphy_quirk: 1;
	unsigned int dis_u2_susphy_quirk: 1;
	unsigned int dis_enblslpm_quirk: 1;
	unsigned int dis_u1_entry_quirk: 1;
	unsigned int dis_u2_entry_quirk: 1;
	unsigned int dis_rxdet_inp3_quirk: 1;
	unsigned int dis_u2_freeclk_exists_quirk: 1;
	unsigned int dis_del_phy_power_chg_quirk: 1;
	unsigned int dis_tx_ipgap_linecheck_quirk: 1;
	unsigned int parkmode_disable_ss_quirk: 1;
	unsigned int tx_de_emphasis_quirk: 1;
	unsigned int tx_de_emphasis: 2;
	unsigned int dis_metastability_quirk: 1;
	unsigned int dis_split_quirk: 1;
	u16 imod_interval;
};

struct dwc3_ep {
	struct usb_ep endpoint;
	struct list_head cancelled_list;
	struct list_head pending_list;
	struct list_head started_list;
	void *regs;
	struct dwc3_trb *trb_pool;
	dma_addr_t trb_pool_dma;
	struct dwc3 *dwc;
	u32 saved_state;
	unsigned int flags;
	u8 trb_enqueue;
	u8 trb_dequeue;
	u8 number;
	u8 type;
	u8 resource_index;
	u32 frame_number;
	u32 interval;
	char name[20];
	unsigned int direction: 1;
	unsigned int stream_capable: 1;
	u8 combo_num;
	int start_cmd_status;
};

struct dwc3_trb {
	u32 bpl;
	u32 bph;
	u32 size;
	u32 ctrl;
};

struct dwc3_event_type {
	u32 is_devspec: 1;
	u32 type: 7;
	u32 reserved8_31: 24;
};

struct dwc3_event_depevt {
	u32 one_bit: 1;
	u32 endpoint_number: 5;
	u32 endpoint_event: 4;
	u32 reserved11_10: 2;
	u32 status: 4;
	u32 parameters: 16;
};

struct dwc3_event_devt {
	u32 one_bit: 1;
	u32 device_event: 7;
	u32 type: 4;
	u32 reserved15_12: 4;
	u32 event_info: 9;
	u32 reserved31_25: 7;
};

struct dwc3_event_gevt {
	u32 one_bit: 1;
	u32 device_event: 7;
	u32 phy_port_number: 4;
	u32 reserved31_12: 20;
};

union dwc3_event {
	u32 raw;
	struct dwc3_event_type type;
	struct dwc3_event_depevt depevt;
	struct dwc3_event_devt devt;
	struct dwc3_event_gevt gevt;
};

struct dwc3_gadget_ep_cmd_params {
	u32 param2;
	u32 param1;
	u32 param0;
};

struct trace_event_raw_dwc3_log_io {
	struct trace_entry ent;
	void *base;
	u32 offset;
	u32 value;
	char __data[0];
};

struct trace_event_raw_dwc3_log_event {
	struct trace_entry ent;
	u32 event;
	u32 ep0state;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_dwc3_log_ctrl {
	struct trace_entry ent;
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_dwc3_log_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct dwc3_request *req;
	unsigned int actual;
	unsigned int length;
	int status;
	int zero;
	int short_not_ok;
	int no_interrupt;
	char __data[0];
};

struct trace_event_raw_dwc3_log_generic_cmd {
	struct trace_entry ent;
	unsigned int cmd;
	u32 param;
	int status;
	char __data[0];
};

struct trace_event_raw_dwc3_log_gadget_ep_cmd {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int cmd;
	u32 param0;
	u32 param1;
	u32 param2;
	int cmd_status;
	char __data[0];
};

struct trace_event_raw_dwc3_log_trb {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct dwc3_trb *trb;
	u32 allocated;
	u32 queued;
	u32 bpl;
	u32 bph;
	u32 size;
	u32 ctrl;
	u32 type;
	u32 enqueue;
	u32 dequeue;
	char __data[0];
};

struct trace_event_raw_dwc3_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int maxpacket;
	unsigned int maxpacket_limit;
	unsigned int max_streams;
	unsigned int maxburst;
	unsigned int flags;
	unsigned int direction;
	u8 trb_enqueue;
	u8 trb_dequeue;
	char __data[0];
};

struct trace_event_data_offsets_dwc3_log_io {};

struct trace_event_data_offsets_dwc3_log_event {
	u32 str;
};

struct trace_event_data_offsets_dwc3_log_ctrl {
	u32 str;
};

struct trace_event_data_offsets_dwc3_log_request {
	u32 name;
};

struct trace_event_data_offsets_dwc3_log_generic_cmd {};

struct trace_event_data_offsets_dwc3_log_gadget_ep_cmd {
	u32 name;
};

struct trace_event_data_offsets_dwc3_log_trb {
	u32 name;
};

struct trace_event_data_offsets_dwc3_log_ep {
	u32 name;
};

typedef void (*btf_trace_dwc3_readl)(void *, void *, u32, u32);

typedef void (*btf_trace_dwc3_writel)(void *, void *, u32, u32);

typedef void (*btf_trace_dwc3_event)(void *, u32, struct dwc3 *);

typedef void (*btf_trace_dwc3_ctrl_req)(void *, struct usb_ctrlrequest *);

typedef void (*btf_trace_dwc3_alloc_request)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_free_request)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_ep_queue)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_ep_dequeue)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_gadget_giveback)(void *, struct dwc3_request *);

typedef void (*btf_trace_dwc3_gadget_generic_cmd)(void *, unsigned int, u32, int);

typedef void (*btf_trace_dwc3_gadget_ep_cmd)(void *, struct dwc3_ep *, unsigned int, struct dwc3_gadget_ep_cmd_params *, int);

typedef void (*btf_trace_dwc3_prepare_trb)(void *, struct dwc3_ep *, struct dwc3_trb *);

typedef void (*btf_trace_dwc3_complete_trb)(void *, struct dwc3_ep *, struct dwc3_trb *);

typedef void (*btf_trace_dwc3_gadget_ep_enable)(void *, struct dwc3_ep *);

typedef void (*btf_trace_dwc3_gadget_ep_disable)(void *, struct dwc3_ep *);

struct timing {
	u8 u1sel;
	u8 u1pel;
	__le16 u2sel;
	__le16 u2pel;
};

struct dwc3_ep_file_map {
	const char name[25];
	const struct file_operations * const fops;
};

enum dwc3_omap_utmi_mode {
	DWC3_OMAP_UTMI_MODE_UNKNOWN = 0,
	DWC3_OMAP_UTMI_MODE_HW = 1,
	DWC3_OMAP_UTMI_MODE_SW = 2,
};

struct dwc3_omap {
	struct device *dev;
	int irq;
	void *base;
	u32 utmi_otg_ctrl;
	u32 utmi_otg_offset;
	u32 irqmisc_offset;
	u32 irq_eoi_offset;
	u32 debug_offset;
	u32 irq0_offset;
	struct extcon_dev *edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct regulator *vbus_reg;
};

enum omap_dwc3_vbus_id_status {
	OMAP_DWC3_ID_FLOAT = 0,
	OMAP_DWC3_ID_GROUND = 1,
	OMAP_DWC3_VBUS_OFF = 2,
	OMAP_DWC3_VBUS_VALID = 3,
};

struct dwc3_exynos_driverdata {
	const char *clk_names[4];
	int num_clks;
	int suspend_clk_idx;
};

struct dwc3_exynos {
	struct device *dev;
	const char **clk_names;
	struct clk *clks[4];
	int num_clks;
	int suspend_clk_idx;
	struct regulator *vdd33;
	struct regulator *vdd10;
};

struct dwc3_haps {
	struct platform_device *dwc3;
	struct pci_dev *pci;
};

struct dwc3_keystone {
	struct device *dev;
	void *usbss;
	struct phy *usb3_phy;
};

struct dwc3_meson_g12a;

struct dwc3_meson_g12a_drvdata {
	bool otg_switch_supported;
	bool otg_phy_host_port_disable;
	struct clk_bulk_data *clks;
	int num_clks;
	const char * const *phy_names;
	int num_phys;
	int (*setup_regmaps)(struct dwc3_meson_g12a *, void *);
	int (*usb2_init_phy)(struct dwc3_meson_g12a *, int, enum phy_mode);
	int (*set_phy_mode)(struct dwc3_meson_g12a *, int, enum phy_mode);
	int (*usb_init)(struct dwc3_meson_g12a *);
	int (*usb_post_init)(struct dwc3_meson_g12a *);
};

struct dwc3_meson_g12a {
	struct device *dev;
	struct regmap *u2p_regmap[3];
	struct regmap *usb_glue_regmap;
	struct reset_control *reset;
	struct phy *phys[3];
	enum usb_dr_mode otg_mode;
	enum phy_mode otg_phy_mode;
	unsigned int usb2_ports;
	unsigned int usb3_ports;
	struct regulator *vbus;
	struct usb_role_switch_desc switch_desc;
	struct usb_role_switch *role_switch;
	const struct dwc3_meson_g12a_drvdata *drvdata;
};

struct dwc3_of_simple {
	struct device *dev;
	struct clk_bulk_data *clks;
	int num_clocks;
	struct reset_control *resets;
	bool need_reset;
};

struct st_dwc3 {
	struct device *dev;
	void *glue_base;
	struct regmap *regmap;
	int syscfg_reg_off;
	enum usb_dr_mode dr_mode;
	struct reset_control *rstc_pwrdn;
	struct reset_control *rstc_rst;
};

struct icc_path;

struct dwc3_acpi_pdata {
	u32 qscratch_base_offset;
	u32 qscratch_base_size;
	u32 dwc3_core_base_size;
	int hs_phy_irq_index;
	int dp_hs_phy_irq_index;
	int dm_hs_phy_irq_index;
	int ss_phy_irq_index;
};

struct dwc3_qcom {
	struct device *dev;
	void *qscratch_base;
	struct platform_device *dwc3;
	struct clk **clks;
	int num_clocks;
	struct reset_control *resets;
	int hs_phy_irq;
	int dp_hs_phy_irq;
	int dm_hs_phy_irq;
	int ss_phy_irq;
	struct extcon_dev *edev;
	struct extcon_dev *host_edev;
	struct notifier_block vbus_nb;
	struct notifier_block host_nb;
	const struct dwc3_acpi_pdata *acpi_pdata;
	enum usb_dr_mode mode;
	bool is_suspended;
	bool pm_suspended;
	struct icc_path *icc_path_ddr;
	struct icc_path *icc_path_apps;
};

struct dwc2_dma_desc {
	u32 status;
	u32 buf;
};

struct dwc2_hsotg;

struct dwc2_hsotg_req;

struct dwc2_hsotg_ep {
	struct usb_ep ep;
	struct list_head queue;
	struct dwc2_hsotg *parent;
	struct dwc2_hsotg_req *req;
	struct dentry *debugfs;
	long unsigned int total_data;
	unsigned int size_loaded;
	unsigned int last_load;
	unsigned int fifo_load;
	short unsigned int fifo_size;
	short unsigned int fifo_index;
	unsigned char dir_in;
	unsigned char index;
	unsigned char mc;
	u16 interval;
	unsigned int halted: 1;
	unsigned int periodic: 1;
	unsigned int isochronous: 1;
	unsigned int send_zlp: 1;
	unsigned int target_frame;
	bool frame_overrun;
	dma_addr_t desc_list_dma;
	struct dwc2_dma_desc *desc_list;
	u8 desc_count;
	unsigned int next_desc;
	unsigned int compl_desc;
	char name[10];
};

struct dwc2_hw_params {
	unsigned int op_mode: 3;
	unsigned int arch: 2;
	unsigned int dma_desc_enable: 1;
	unsigned int enable_dynamic_fifo: 1;
	unsigned int en_multiple_tx_fifo: 1;
	unsigned int rx_fifo_size: 16;
	char: 8;
	unsigned int host_nperio_tx_fifo_size: 16;
	unsigned int dev_nperio_tx_fifo_size: 16;
	unsigned int host_perio_tx_fifo_size: 16;
	unsigned int nperio_tx_q_depth: 3;
	unsigned int host_perio_tx_q_depth: 3;
	unsigned int dev_token_q_depth: 5;
	char: 5;
	unsigned int max_transfer_size: 26;
	char: 6;
	unsigned int max_packet_count: 11;
	unsigned int host_channels: 5;
	unsigned int hs_phy_type: 2;
	unsigned int fs_phy_type: 2;
	unsigned int i2c_enable: 1;
	unsigned int acg_enable: 1;
	unsigned int num_dev_ep: 4;
	unsigned int num_dev_in_eps: 4;
	char: 2;
	unsigned int num_dev_perio_in_ep: 4;
	unsigned int total_fifo_size: 16;
	unsigned int power_optimized: 1;
	unsigned int hibernation: 1;
	unsigned int utmi_phy_data_width: 2;
	unsigned int lpm_mode: 1;
	unsigned int ipg_isoc_en: 1;
	unsigned int service_interval_mode: 1;
	u32 snpsid;
	u32 dev_ep_dirs;
	u32 g_tx_fifo_size[16];
};

struct dwc2_core_params {
	u8 otg_cap;
	u8 phy_type;
	u8 speed;
	u8 phy_utmi_width;
	bool phy_ulpi_ddr;
	bool phy_ulpi_ext_vbus;
	bool enable_dynamic_fifo;
	bool en_multiple_tx_fifo;
	bool i2c_enable;
	bool acg_enable;
	bool ulpi_fs_ls;
	bool ts_dline;
	bool reload_ctl;
	bool uframe_sched;
	bool external_id_pin_ctl;
	int power_down;
	bool lpm;
	bool lpm_clock_gating;
	bool besl;
	bool hird_threshold_en;
	bool service_interval;
	u8 hird_threshold;
	bool activate_stm_fs_transceiver;
	bool activate_stm_id_vb_detection;
	bool ipg_isoc_en;
	u16 max_packet_count;
	u32 max_transfer_size;
	u32 ahbcfg;
	u32 ref_clk_per;
	u16 sof_cnt_wkup_alert;
	bool host_dma;
	bool dma_desc_enable;
	bool dma_desc_fs_enable;
	bool host_support_fs_ls_low_power;
	bool host_ls_low_power_phy_clk;
	bool oc_disable;
	u8 host_channels;
	u16 host_rx_fifo_size;
	u16 host_nperio_tx_fifo_size;
	u16 host_perio_tx_fifo_size;
	bool g_dma;
	bool g_dma_desc;
	u32 g_rx_fifo_size;
	u32 g_np_tx_fifo_size;
	u32 g_tx_fifo_size[16];
	bool change_speed_quirk;
};

enum dwc2_lx_state {
	DWC2_L0 = 0,
	DWC2_L1 = 1,
	DWC2_L2 = 2,
	DWC2_L3 = 3,
};

struct dwc2_gregs_backup {
	u32 gotgctl;
	u32 gintmsk;
	u32 gahbcfg;
	u32 gusbcfg;
	u32 grxfsiz;
	u32 gnptxfsiz;
	u32 gi2cctl;
	u32 glpmcfg;
	u32 pcgcctl;
	u32 pcgcctl1;
	u32 gdfifocfg;
	u32 gpwrdn;
	bool valid;
};

struct dwc2_dregs_backup {
	u32 dcfg;
	u32 dctl;
	u32 daintmsk;
	u32 diepmsk;
	u32 doepmsk;
	u32 diepctl[16];
	u32 dieptsiz[16];
	u32 diepdma[16];
	u32 doepctl[16];
	u32 doeptsiz[16];
	u32 doepdma[16];
	u32 dtxfsiz[16];
	bool valid;
};

struct dwc2_hregs_backup {
	u32 hcfg;
	u32 haintmsk;
	u32 hcintmsk[16];
	u32 hprt0;
	u32 hfir;
	u32 hptxfsiz;
	bool valid;
};

union dwc2_hcd_internal_flags {
	u32 d32;
	struct {
		unsigned int port_connect_status_change: 1;
		unsigned int port_connect_status: 1;
		unsigned int port_reset_change: 1;
		unsigned int port_enable_change: 1;
		unsigned int port_suspend_change: 1;
		unsigned int port_over_current_change: 1;
		unsigned int port_l1_change: 1;
		unsigned int reserved: 25;
	} b;
};

enum dwc2_ep0_state {
	DWC2_EP0_SETUP = 0,
	DWC2_EP0_DATA_IN = 1,
	DWC2_EP0_DATA_OUT = 2,
	DWC2_EP0_STATUS_IN = 3,
	DWC2_EP0_STATUS_OUT = 4,
};

struct dwc2_hsotg_plat;

struct dwc2_host_chan;

struct dwc2_hsotg {
	struct device *dev;
	void *regs;
	struct dwc2_hw_params hw_params;
	struct dwc2_core_params params;
	enum usb_otg_state op_state;
	enum usb_dr_mode dr_mode;
	struct usb_role_switch *role_sw;
	unsigned int hcd_enabled: 1;
	unsigned int gadget_enabled: 1;
	unsigned int ll_hw_enabled: 1;
	unsigned int hibernated: 1;
	unsigned int reset_phy_on_wake: 1;
	unsigned int need_phy_for_wake: 1;
	unsigned int phy_off_for_suspend: 1;
	u16 frame_number;
	struct phy *phy;
	struct usb_phy *uphy;
	struct dwc2_hsotg_plat *plat;
	struct regulator_bulk_data supplies[2];
	struct regulator *vbus_supply;
	struct regulator *usb33d;
	spinlock_t lock;
	void *priv;
	int irq;
	struct clk *clk;
	struct reset_control *reset;
	struct reset_control *reset_ecc;
	unsigned int queuing_high_bandwidth: 1;
	unsigned int srp_success: 1;
	struct workqueue_struct *wq_otg;
	struct work_struct wf_otg;
	struct timer_list wkp_timer;
	enum dwc2_lx_state lx_state;
	struct dwc2_gregs_backup gr_backup;
	struct dwc2_dregs_backup dr_backup;
	struct dwc2_hregs_backup hr_backup;
	struct dentry *debug_root;
	struct debugfs_regset32 *regset;
	bool needs_byte_swap;
	union dwc2_hcd_internal_flags flags;
	struct list_head non_periodic_sched_inactive;
	struct list_head non_periodic_sched_waiting;
	struct list_head non_periodic_sched_active;
	struct list_head *non_periodic_qh_ptr;
	struct list_head periodic_sched_inactive;
	struct list_head periodic_sched_ready;
	struct list_head periodic_sched_assigned;
	struct list_head periodic_sched_queued;
	struct list_head split_order;
	u16 periodic_usecs;
	long unsigned int hs_periodic_bitmap[25];
	u16 periodic_qh_count;
	bool bus_suspended;
	bool new_connection;
	u16 last_frame_num;
	struct list_head free_hc_list;
	int periodic_channels;
	int non_periodic_channels;
	int available_host_channels;
	struct dwc2_host_chan *hc_ptr_array[16];
	u8 *status_buf;
	dma_addr_t status_buf_dma;
	struct delayed_work start_work;
	struct delayed_work reset_work;
	struct work_struct phy_reset_work;
	u8 otg_port;
	u32 *frame_list;
	dma_addr_t frame_list_dma;
	u32 frame_list_sz;
	struct kmem_cache *desc_gen_cache;
	struct kmem_cache *desc_hsisoc_cache;
	struct kmem_cache *unaligned_cache;
	struct usb_gadget_driver *driver;
	int fifo_mem;
	unsigned int dedicated_fifos: 1;
	unsigned char num_of_eps;
	u32 fifo_map;
	struct usb_request *ep0_reply;
	struct usb_request *ctrl_req;
	void *ep0_buff;
	void *ctrl_buff;
	enum dwc2_ep0_state ep0_state;
	unsigned int delayed_status: 1;
	u8 test_mode;
	dma_addr_t setup_desc_dma[2];
	struct dwc2_dma_desc *setup_desc[2];
	dma_addr_t ctrl_in_desc_dma;
	struct dwc2_dma_desc *ctrl_in_desc;
	dma_addr_t ctrl_out_desc_dma;
	struct dwc2_dma_desc *ctrl_out_desc;
	struct usb_gadget gadget;
	unsigned int enabled: 1;
	unsigned int connected: 1;
	unsigned int remote_wakeup_allowed: 1;
	struct dwc2_hsotg_ep *eps_in[16];
	struct dwc2_hsotg_ep *eps_out[16];
	int: 32;
};

struct dwc2_hsotg_req {
	struct usb_request req;
	struct list_head queue;
	void *saved_req_buf;
};

enum dwc2_halt_status {
	DWC2_HC_XFER_NO_HALT_STATUS = 0,
	DWC2_HC_XFER_COMPLETE = 1,
	DWC2_HC_XFER_URB_COMPLETE = 2,
	DWC2_HC_XFER_ACK = 3,
	DWC2_HC_XFER_NAK = 4,
	DWC2_HC_XFER_NYET = 5,
	DWC2_HC_XFER_STALL = 6,
	DWC2_HC_XFER_XACT_ERR = 7,
	DWC2_HC_XFER_FRAME_OVERRUN = 8,
	DWC2_HC_XFER_BABBLE_ERR = 9,
	DWC2_HC_XFER_DATA_TOGGLE_ERR = 10,
	DWC2_HC_XFER_AHB_ERR = 11,
	DWC2_HC_XFER_PERIODIC_INCOMPLETE = 12,
	DWC2_HC_XFER_URB_DEQUEUE = 13,
};

struct dwc2_qh;

struct dwc2_host_chan {
	u8 hc_num;
	unsigned int dev_addr: 7;
	unsigned int ep_num: 4;
	unsigned int ep_is_in: 1;
	unsigned int speed: 4;
	unsigned int ep_type: 2;
	char: 6;
	unsigned int max_packet: 11;
	unsigned int data_pid_start: 2;
	unsigned int multi_count: 2;
	u8 *xfer_buf;
	dma_addr_t xfer_dma;
	dma_addr_t align_buf;
	u32 xfer_len;
	u32 xfer_count;
	u16 start_pkt_count;
	u8 xfer_started;
	u8 do_ping;
	u8 error_state;
	u8 halt_on_queue;
	u8 halt_pending;
	u8 do_split;
	u8 complete_split;
	u8 hub_addr;
	u8 hub_port;
	u8 xact_pos;
	u8 requests;
	u8 schinfo;
	u16 ntd;
	enum dwc2_halt_status halt_status;
	u32 hcint;
	struct dwc2_qh *qh;
	struct list_head hc_list_entry;
	dma_addr_t desc_list_addr;
	u32 desc_list_sz;
	struct list_head split_order_list_entry;
};

struct dwc2_hs_transfer_time {
	u32 start_schedule_us;
	u16 duration_us;
};

struct dwc2_tt;

struct dwc2_qh {
	struct dwc2_hsotg *hsotg;
	u8 ep_type;
	u8 ep_is_in;
	u16 maxp;
	u16 maxp_mult;
	u8 dev_speed;
	u8 data_toggle;
	u8 ping_state;
	u8 do_split;
	u8 td_first;
	u8 td_last;
	u16 host_us;
	u16 device_us;
	u16 host_interval;
	u16 device_interval;
	u16 next_active_frame;
	u16 start_active_frame;
	s16 num_hs_transfers;
	struct dwc2_hs_transfer_time hs_transfers[8];
	u32 ls_start_schedule_slice;
	u16 ntd;
	u8 *dw_align_buf;
	dma_addr_t dw_align_buf_dma;
	struct list_head qtd_list;
	struct dwc2_host_chan *channel;
	struct list_head qh_list_entry;
	struct dwc2_dma_desc *desc_list;
	dma_addr_t desc_list_dma;
	u32 desc_list_sz;
	u32 *n_bytes;
	struct timer_list unreserve_timer;
	struct hrtimer wait_timer;
	struct dwc2_tt *dwc_tt;
	int ttport;
	unsigned int tt_buffer_dirty: 1;
	unsigned int unreserve_pending: 1;
	unsigned int schedule_low_speed: 1;
	unsigned int want_wait: 1;
	unsigned int wait_timer_cancel: 1;
	int: 27;
	int: 32;
};

struct dwc2_tt {
	int refcount;
	struct usb_tt *usb_tt;
	long unsigned int periodic_bitmaps[0];
};

enum dwc2_hsotg_dmamode {
	S3C_HSOTG_DMA_NONE = 0,
	S3C_HSOTG_DMA_ONLY = 1,
	S3C_HSOTG_DMA_DRV = 2,
};

struct dwc2_hsotg_plat {
	enum dwc2_hsotg_dmamode dma;
	unsigned int is_osc: 1;
	int phy_type;
	int (*phy_init)(struct platform_device *, int);
	int (*phy_exit)(struct platform_device *, int);
};

struct dwc2_hcd_pipe_info {
	u8 dev_addr;
	u8 ep_num;
	u8 pipe_type;
	u8 pipe_dir;
	u16 maxp;
	u16 maxp_mult;
};

struct dwc2_hcd_iso_packet_desc {
	u32 offset;
	u32 length;
	u32 actual_length;
	u32 status;
};

struct dwc2_qtd;

struct dwc2_hcd_urb {
	void *priv;
	struct dwc2_qtd *qtd;
	void *buf;
	dma_addr_t dma;
	void *setup_packet;
	dma_addr_t setup_dma;
	u32 length;
	u32 actual_length;
	u32 status;
	u32 error_count;
	u32 packet_count;
	u32 flags;
	u16 interval;
	struct dwc2_hcd_pipe_info pipe_info;
	struct dwc2_hcd_iso_packet_desc iso_descs[0];
};

enum dwc2_control_phase {
	DWC2_CONTROL_SETUP = 0,
	DWC2_CONTROL_DATA = 1,
	DWC2_CONTROL_STATUS = 2,
};

struct dwc2_qtd {
	enum dwc2_control_phase control_phase;
	u8 in_process;
	u8 data_toggle;
	u8 complete_split;
	u8 isoc_split_pos;
	u16 isoc_frame_index;
	u16 isoc_split_offset;
	u16 isoc_td_last;
	u16 isoc_td_first;
	u32 ssplit_out_xfer_count;
	u8 error_count;
	u8 n_desc;
	u16 isoc_frame_index_last;
	u16 num_naks;
	struct dwc2_hcd_urb *urb;
	struct dwc2_qh *qh;
	struct list_head qtd_list_entry;
};

enum dwc2_transaction_type {
	DWC2_TRANSACTION_NONE = 0,
	DWC2_TRANSACTION_PERIODIC = 1,
	DWC2_TRANSACTION_NON_PERIODIC = 2,
	DWC2_TRANSACTION_ALL = 3,
};

struct wrapper_priv_data {
	struct dwc2_hsotg *hsotg;
};

struct isp1760_qh;

struct isp1760_qtd;

struct isp1760_slotinfo {
	struct isp1760_qh *qh;
	struct isp1760_qtd *qtd;
	long unsigned int timestamp;
};

struct isp1760_memory_chunk {
	unsigned int start;
	unsigned int size;
	unsigned int free;
};

enum isp1760_queue_head_types {
	QH_CONTROL = 0,
	QH_BULK = 1,
	QH_INTERRUPT = 2,
	QH_END = 3,
};

struct isp1760_hcd {
	struct usb_hcd *hcd;
	u32 hcs_params;
	spinlock_t lock;
	struct isp1760_slotinfo atl_slots[32];
	int atl_done_map;
	struct isp1760_slotinfo int_slots[32];
	int int_done_map;
	struct isp1760_memory_chunk memory_pool[56];
	struct list_head qh_list[3];
	unsigned int periodic_size;
	unsigned int i_thresh;
	long unsigned int reset_done;
	long unsigned int next_statechange;
};

enum isp1760_ctrl_state {
	ISP1760_CTRL_SETUP = 0,
	ISP1760_CTRL_DATA_IN = 1,
	ISP1760_CTRL_DATA_OUT = 2,
	ISP1760_CTRL_STATUS = 3,
};

struct isp1760_udc;

struct isp1760_ep {
	struct isp1760_udc *udc;
	struct usb_ep ep;
	struct list_head queue;
	unsigned int addr;
	unsigned int maxpacket;
	char name[7];
	const struct usb_endpoint_descriptor *desc;
	bool rx_pending;
	bool halted;
	bool wedged;
};

struct isp1760_device;

struct isp1760_udc {
	struct isp1760_device *isp;
	int irq;
	char *irqname;
	void *regs;
	struct usb_gadget_driver *driver;
	int: 32;
	struct usb_gadget gadget;
	spinlock_t lock;
	struct timer_list vbus_timer;
	struct isp1760_ep ep[15];
	enum isp1760_ctrl_state ep0_state;
	u8 ep0_dir;
	u16 ep0_length;
	bool connected;
	unsigned int devstatus;
};

struct isp1760_device {
	struct device *dev;
	void *regs;
	unsigned int devflags;
	struct gpio_desc *rst_gpio;
	struct isp1760_hcd hcd;
	int: 32;
	struct isp1760_udc udc;
};

struct isp1760_platform_data {
	unsigned int is_isp1761: 1;
	unsigned int bus_width_16: 1;
	unsigned int port1_otg: 1;
	unsigned int analog_oc: 1;
	unsigned int dack_polarity_high: 1;
	unsigned int dreq_polarity_high: 1;
};

struct isp1760_qh {
	struct list_head qh_list;
	struct list_head qtd_list;
	u32 toggle;
	u32 ping;
	int slot;
	int tt_buffer_dirty;
};

struct isp1760_qtd {
	u8 packet_type;
	void *data_buffer;
	u32 payload_addr;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
	size_t actual_length;
	u32 status;
};

typedef __u32 __dw;

struct ptd {
	__dw dw0;
	__dw dw1;
	__dw dw2;
	__dw dw3;
	__dw dw4;
	__dw dw5;
	__dw dw6;
	__dw dw7;
};

struct urb_listitem {
	struct list_head urb_list;
	struct urb *urb;
};

struct isp1760_request {
	struct usb_request req;
	struct list_head queue;
	struct isp1760_ep *ep;
	unsigned int packet_size;
};

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct ehci_per_sched {
	struct usb_device *udev;
	struct usb_host_endpoint *ep;
	struct list_head ps_list;
	u16 tt_usecs;
	u16 cs_mask;
	u16 period;
	u16 phase;
	u8 bw_phase;
	u8 phase_uf;
	u8 usecs;
	u8 c_usecs;
	u8 bw_uperiod;
	u8 bw_period;
};

enum ehci_rh_state {
	EHCI_RH_HALTED = 0,
	EHCI_RH_SUSPENDED = 1,
	EHCI_RH_RUNNING = 2,
	EHCI_RH_STOPPING = 3,
};

enum ehci_hrtimer_event {
	EHCI_HRTIMER_POLL_ASS = 0,
	EHCI_HRTIMER_POLL_PSS = 1,
	EHCI_HRTIMER_POLL_DEAD = 2,
	EHCI_HRTIMER_UNLINK_INTR = 3,
	EHCI_HRTIMER_FREE_ITDS = 4,
	EHCI_HRTIMER_ACTIVE_UNLINK = 5,
	EHCI_HRTIMER_START_UNLINK_INTR = 6,
	EHCI_HRTIMER_ASYNC_UNLINKS = 7,
	EHCI_HRTIMER_IAA_WATCHDOG = 8,
	EHCI_HRTIMER_DISABLE_PERIODIC = 9,
	EHCI_HRTIMER_DISABLE_ASYNC = 10,
	EHCI_HRTIMER_IO_WATCHDOG = 11,
	EHCI_HRTIMER_NUM_EVENTS = 12,
};

struct ehci_caps;

struct ehci_regs;

struct ehci_dbg_port;

struct ehci_qh;

union ehci_shadow;

struct ehci_itd;

struct ehci_sitd;

struct ehci_hcd {
	enum ehci_hrtimer_event next_hrtimer_event;
	unsigned int enabled_hrtimer_events;
	ktime_t hr_timeouts[12];
	struct hrtimer hrtimer;
	int PSS_poll_count;
	int ASS_poll_count;
	int died_poll_count;
	struct ehci_caps *caps;
	struct ehci_regs *regs;
	struct ehci_dbg_port *debug;
	__u32 hcs_params;
	spinlock_t lock;
	enum ehci_rh_state rh_state;
	bool scanning: 1;
	bool need_rescan: 1;
	bool intr_unlinking: 1;
	bool iaa_in_progress: 1;
	bool async_unlinking: 1;
	bool shutdown: 1;
	struct ehci_qh *qh_scan_next;
	struct ehci_qh *async;
	struct ehci_qh *dummy;
	struct list_head async_unlink;
	struct list_head async_idle;
	unsigned int async_unlink_cycle;
	unsigned int async_count;
	__le32 old_current;
	__le32 old_token;
	unsigned int periodic_size;
	__le32 *periodic;
	dma_addr_t periodic_dma;
	struct list_head intr_qh_list;
	unsigned int i_thresh;
	union ehci_shadow *pshadow;
	struct list_head intr_unlink_wait;
	struct list_head intr_unlink;
	unsigned int intr_unlink_wait_cycle;
	unsigned int intr_unlink_cycle;
	unsigned int now_frame;
	unsigned int last_iso_frame;
	unsigned int intr_count;
	unsigned int isoc_count;
	unsigned int periodic_count;
	unsigned int uframe_periodic_max;
	struct list_head cached_itd_list;
	struct ehci_itd *last_itd_to_free;
	struct list_head cached_sitd_list;
	struct ehci_sitd *last_sitd_to_free;
	long unsigned int reset_done[15];
	long unsigned int bus_suspended;
	long unsigned int companion_ports;
	long unsigned int owned_ports;
	long unsigned int port_c_suspend;
	long unsigned int suspended_ports;
	long unsigned int resuming_ports;
	struct dma_pool___2 *qh_pool;
	struct dma_pool___2 *qtd_pool;
	struct dma_pool___2 *itd_pool;
	struct dma_pool___2 *sitd_pool;
	unsigned int random_frame;
	long unsigned int next_statechange;
	int: 32;
	ktime_t last_periodic_enable;
	u32 command;
	unsigned int no_selective_suspend: 1;
	unsigned int has_fsl_port_bug: 1;
	unsigned int has_fsl_hs_errata: 1;
	unsigned int has_fsl_susp_errata: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_capbase: 1;
	unsigned int has_amcc_usb23: 1;
	unsigned int need_io_watchdog: 1;
	unsigned int amd_pll_fix: 1;
	unsigned int use_dummy_qh: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int frame_index_bug: 1;
	unsigned int need_oc_pp_cycle: 1;
	unsigned int imx28_write_fix: 1;
	__le32 *ohci_hcctrl_reg;
	unsigned int has_hostpc: 1;
	unsigned int has_tdi_phy_lpm: 1;
	unsigned int has_ppcd: 1;
	u8 sbrn;
	u8 bandwidth[64];
	u8 tt_budget[64];
	struct list_head tt_list;
	long unsigned int priv[0];
};

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	u32 port_status[0];
	u32 reserved3[9];
	u32 usbmode;
	u32 reserved4[6];
	u32 hostpc[0];
	u32 reserved5[17];
	u32 usbmode_ex;
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_fstn;

union ehci_shadow {
	struct ehci_qh *qh;
	struct ehci_itd *itd;
	struct ehci_sitd *sitd;
	struct ehci_fstn *fstn;
	__le32 *hw_next;
	void *ptr;
};

struct ehci_qh_hw;

struct ehci_qtd;

struct ehci_qh {
	struct ehci_qh_hw *hw;
	dma_addr_t qh_dma;
	union ehci_shadow qh_next;
	struct list_head qtd_list;
	struct list_head intr_node;
	struct ehci_qtd *dummy;
	struct list_head unlink_node;
	struct ehci_per_sched ps;
	unsigned int unlink_cycle;
	u8 qh_state;
	u8 xacterrs;
	u8 unlink_reason;
	u8 gap_uf;
	unsigned int is_out: 1;
	unsigned int clearing_tt: 1;
	unsigned int dequeue_during_giveback: 1;
	unsigned int should_be_inactive: 1;
};

struct ehci_iso_stream;

struct ehci_itd {
	__le32 hw_next;
	__le32 hw_transaction[8];
	__le32 hw_bufp[7];
	__le32 hw_bufp_hi[7];
	dma_addr_t itd_dma;
	union ehci_shadow itd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head itd_list;
	unsigned int frame;
	unsigned int pg;
	unsigned int index[8];
	int: 32;
};

struct ehci_sitd {
	__le32 hw_next;
	__le32 hw_fullspeed_ep;
	__le32 hw_uframe;
	__le32 hw_results;
	__le32 hw_buf[2];
	__le32 hw_backpointer;
	__le32 hw_buf_hi[2];
	dma_addr_t sitd_dma;
	union ehci_shadow sitd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head sitd_list;
	unsigned int frame;
	unsigned int index;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_qtd {
	__le32 hw_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	dma_addr_t qtd_dma;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_fstn {
	__le32 hw_next;
	__le32 hw_prev;
	dma_addr_t fstn_dma;
	union ehci_shadow fstn_next;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_qh_hw {
	__le32 hw_next;
	__le32 hw_info1;
	__le32 hw_info2;
	__le32 hw_current;
	__le32 hw_qtd_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_iso_packet {
	u64 bufp;
	__le32 transaction;
	u8 cross;
	u32 buf1;
	int: 32;
};

struct ehci_iso_sched {
	struct list_head td_list;
	unsigned int span;
	unsigned int first_packet;
	struct ehci_iso_packet packet[0];
};

struct ehci_iso_stream {
	struct ehci_qh_hw *hw;
	u8 bEndpointAddress;
	u8 highspeed;
	struct list_head td_list;
	struct list_head free_list;
	struct ehci_per_sched ps;
	unsigned int next_uframe;
	__le32 splits;
	u16 uperiod;
	u16 maxp;
	unsigned int bandwidth;
	__le32 buf0;
	__le32 buf1;
	__le32 buf2;
	__le32 address;
};

struct ehci_tt {
	u16 bandwidth[8];
	struct list_head tt_list;
	struct list_head ps_list;
	struct usb_tt *usb_tt;
	int tt_port;
};

struct ehci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct usb_ehci_pdata {
	int caps_offset;
	unsigned int has_tt: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int no_io_watchdog: 1;
	unsigned int reset_on_resume: 1;
	unsigned int dma_mask_64: 1;
	int (*power_on)(struct platform_device *);
	void (*power_off)(struct platform_device *);
	void (*power_suspend)(struct platform_device *);
	int (*pre_setup)(struct usb_hcd *);
};

struct ehci_platform_priv {
	struct clk *clks[4];
	struct reset_control *rsts;
	bool reset_on_resume;
	bool quirk_poll;
	struct timer_list poll_timer;
	struct delayed_work poll_work;
};

enum orion_ehci_phy_ver {
	EHCI_PHY_ORION = 0,
	EHCI_PHY_DD = 1,
	EHCI_PHY_KW = 2,
	EHCI_PHY_NA = 3,
};

struct orion_ehci_data {
	enum orion_ehci_phy_ver phy_version;
};

struct orion_ehci_hcd {
	struct clk *clk;
	struct phy *phy;
};

struct spear_ehci {
	struct clk *clk;
};

struct st_ehci_platform_priv {
	struct clk *clks[3];
	struct clk *clk48;
	struct reset_control *rst;
	struct reset_control *pwr;
	struct phy *phy;
};

struct exynos_ehci_hcd {
	struct clk *clk;
	struct device_node *of_node;
	struct phy *phy[3];
	bool legacy_phy;
};

struct atmel_ehci_priv {
	struct clk *iclk;
	struct clk *uclk;
	bool clocked;
};

struct tegra_ehci_soc_config {
	bool has_hostpc;
};

struct tegra_ehci_hcd {
	struct clk *clk;
	struct reset_control *rst;
	int port_resuming;
	bool needs_double_reset;
};

struct dma_aligned_buffer {
	void *kmalloc_ptr;
	void *old_xfer_buffer;
	u8 data[0];
};

typedef __u32 __hc32;

typedef __u16 __hc16;

struct td;

struct ed {
	__hc32 hwINFO;
	__hc32 hwTailP;
	__hc32 hwHeadP;
	__hc32 hwNextED;
	dma_addr_t dma;
	struct td *dummy;
	struct ed *ed_next;
	struct ed *ed_prev;
	struct list_head td_list;
	struct list_head in_use_list;
	u8 state;
	u8 type;
	u8 branch;
	u16 interval;
	u16 load;
	u16 last_iso;
	u16 tick;
	unsigned int takeback_wdh_cnt;
	struct td *pending_td;
	int: 32;
	int: 32;
	int: 32;
};

struct td {
	__hc32 hwINFO;
	__hc32 hwCBP;
	__hc32 hwNextTD;
	__hc32 hwBE;
	__hc16 hwPSW[2];
	__u8 index;
	struct ed *ed;
	struct td *td_hash;
	struct td *next_dl_td;
	struct urb *urb;
	dma_addr_t td_dma;
	dma_addr_t data_dma;
	struct list_head td_list;
	int: 32;
	int: 32;
};

struct ohci_hcca {
	__hc32 int_table[32];
	__hc32 frame_no;
	__hc32 done_head;
	u8 reserved_for_hc[116];
	u8 what[4];
};

struct ohci_roothub_regs {
	__hc32 a;
	__hc32 b;
	__hc32 status;
	__hc32 portstatus[15];
};

struct ohci_regs {
	__hc32 revision;
	__hc32 control;
	__hc32 cmdstatus;
	__hc32 intrstatus;
	__hc32 intrenable;
	__hc32 intrdisable;
	__hc32 hcca;
	__hc32 ed_periodcurrent;
	__hc32 ed_controlhead;
	__hc32 ed_controlcurrent;
	__hc32 ed_bulkhead;
	__hc32 ed_bulkcurrent;
	__hc32 donehead;
	__hc32 fminterval;
	__hc32 fmremaining;
	__hc32 fmnumber;
	__hc32 periodicstart;
	__hc32 lsthresh;
	struct ohci_roothub_regs roothub;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct urb_priv {
	struct ed *ed;
	u16 length;
	u16 td_cnt;
	struct list_head pending;
	struct td *td[0];
};

typedef struct urb_priv urb_priv_t;

enum ohci_rh_state {
	OHCI_RH_HALTED = 0,
	OHCI_RH_SUSPENDED = 1,
	OHCI_RH_RUNNING = 2,
};

struct ohci_hcd {
	spinlock_t lock;
	struct ohci_regs *regs;
	struct ohci_hcca *hcca;
	dma_addr_t hcca_dma;
	struct ed *ed_rm_list;
	struct ed *ed_bulktail;
	struct ed *ed_controltail;
	struct ed *periodic[32];
	void (*start_hnp)(struct ohci_hcd *);
	struct dma_pool___2 *td_cache;
	struct dma_pool___2 *ed_cache;
	struct td *td_hash[64];
	struct td *dl_start;
	struct td *dl_end;
	struct list_head pending;
	struct list_head eds_in_use;
	enum ohci_rh_state rh_state;
	int num_ports;
	int load[32];
	u32 hc_control;
	long unsigned int next_statechange;
	u32 fminterval;
	unsigned int autostop: 1;
	unsigned int working: 1;
	unsigned int restart_work: 1;
	long unsigned int flags;
	unsigned int prev_frame_no;
	unsigned int wdh_cnt;
	unsigned int prev_wdh_cnt;
	u32 prev_donehead;
	struct timer_list io_watchdog;
	struct work_struct nec_work;
	struct dentry *debug_dir;
	int: 32;
	long unsigned int priv[0];
};

struct ohci_driver_overrides {
	const char *product_desc;
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
};

struct debug_buffer {
	ssize_t (*fill_func)(struct debug_buffer *);
	struct ohci_hcd *ohci;
	struct mutex mutex;
	size_t count;
	char *page;
};

struct usb_ohci_pdata {
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int no_big_frame_no: 1;
	unsigned int num_ports;
	int (*power_on)(struct platform_device *);
	void (*power_off)(struct platform_device *);
	void (*power_suspend)(struct platform_device *);
};

struct ohci_platform_priv {
	struct clk *clks[3];
	struct reset_control *resets;
};

struct spear_ohci {
	struct clk *clk;
};

struct st_ohci_platform_priv {
	struct clk *clks[3];
	struct clk *clk48;
	struct reset_control *rst;
	struct reset_control *pwr;
	struct phy *phy;
};

struct at91_usbh_data {
	struct gpio_desc *vbus_pin[3];
	struct gpio_desc *overcurrent_pin[3];
	u8 ports;
	u8 overcurrent_supported;
	u8 overcurrent_status[3];
	u8 overcurrent_changed[3];
};

struct ohci_at91_priv {
	struct clk *iclk;
	struct clk *fclk;
	struct clk *hclk;
	bool clocked;
	bool wakeup;
	struct regmap *sfr_regmap;
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

union xhci_trb;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_generic_trb {
	__le32 field[4];
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_ring;

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

struct xhci_segment;

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int err_count;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int num_trbs_free_temp;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_hcd;

struct xhci_virt_ep {
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct timer_list stop_cmd_timer;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
	unsigned int erst_size;
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
	u32 irq_pending;
	u32 irq_control;
	u32 erst_size;
	u64 erst_base;
	u64 erst_dequeue;
};

struct xhci_bus_state {
	long unsigned int bus_suspended;
	long unsigned int next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	long unsigned int resume_done[31];
	long unsigned int resuming_ports;
	long unsigned int rexit_ports;
	struct completion rexit_done[31];
	struct completion u3exit_done[31];
};

struct xhci_port;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_device_context_array;

struct xhci_scratchpad;

struct xhci_virt_device;

struct xhci_root_port_bw_info;

struct xhci_port_cap;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	struct xhci_intr_reg *ir_set;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u8 sbrn;
	u16 hci_version;
	u8 max_slots;
	u8 max_interrupters;
	u8 max_ports;
	u8 isoc_threshold;
	u32 imod_interval;
	int event_ring_max;
	int page_size;
	int page_shift;
	int msix_count;
	struct clk *clk;
	struct clk *reg_clk;
	struct reset_control *reset;
	struct xhci_device_context_array *dcbaa;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_scratchpad *scratchpad;
	struct list_head lpm_failed_devs;
	struct mutex mutex;
	struct xhci_command *lpm_command;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool___2 *device_pool;
	struct dma_pool___2 *segment_pool;
	struct dma_pool___2 *small_streams_pool;
	struct dma_pool___2 *medium_streams_pool;
	unsigned int xhc_state;
	u32 command;
	struct s3_save s3;
	long long unsigned int quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	u32 *ext_caps;
	unsigned int num_ext_caps;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	long unsigned int priv[0];
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_tt_bw_info;

struct xhci_virt_device {
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	u8 fake_port;
	u8 real_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	long unsigned int flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
	int: 32;
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *first_trb;
	union xhci_trb *last_trb;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
};

struct xhci_dequeue_state {
	struct xhci_segment *new_deq_seg;
	union xhci_trb *new_deq_ptr;
	int new_cycle_state;
	unsigned int stream_id;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct urb_priv___2 {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
};

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
};

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_STALLED = 5,
};

struct xhci_dbc;

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
};

struct dbc_driver;

struct xhci_dbc {
	spinlock_t lock;
	struct device *dev;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	const struct dbc_driver *driver;
	void *priv;
};

struct dbc_driver {
	int (*configure)(struct xhci_dbc *);
	void (*disconnect)(struct xhci_dbc *);
};

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_dbc *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	int slot_id;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	int: 32;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	u8 fake_port;
	u8 real_port;
	u16 current_mel;
	char __data[0];
	int: 32;
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	int: 32;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
	int: 32;
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	char __data[0];
	int: 32;
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	dma_addr_t enq_seg;
	dma_addr_t deq_seg;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 portnum;
	u32 portsc;
	char __data[0];
};

struct trace_event_raw_xhci_log_doorbell {
	struct trace_entry ent;
	u32 slot;
	u32 doorbell;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
};

struct trace_event_data_offsets_xhci_log_trb {};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xhci_log_urb {};

struct trace_event_data_offsets_xhci_log_ep_ctx {};

struct trace_event_data_offsets_xhci_log_slot_ctx {};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_portsc {};

struct trace_event_data_offsets_xhci_log_doorbell {};

struct trace_event_data_offsets_xhci_dbc_log_request {};

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_handle_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_get_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_hub_status_data)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_ep_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_host_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct xhci_ep_priv {
	char name[32];
	struct dentry *root;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *show_ring;
	unsigned int stream_id;
};

struct xhci_slot_priv {
	char name[32];
	struct dentry *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct xhci_driver_data {
	u64 quirks;
	const char *firmware;
	int: 32;
};

struct xhci_plat_priv {
	const char *firmware_name;
	int: 32;
	long long unsigned int quirks;
	int (*plat_setup)(struct usb_hcd *);
	void (*plat_start)(struct usb_hcd *);
	int (*init_quirk)(struct usb_hcd *);
	int (*suspend_quirk)(struct usb_hcd *);
	int (*resume_quirk)(struct usb_hcd *);
	int: 32;
};

enum {
	US_FL_SINGLE_LUN = 1,
	US_FL_NEED_OVERRIDE = 2,
	US_FL_SCM_MULT_TARG = 4,
	US_FL_FIX_INQUIRY = 8,
	US_FL_FIX_CAPACITY = 16,
	US_FL_IGNORE_RESIDUE = 32,
	US_FL_BULK32 = 64,
	US_FL_NOT_LOCKABLE = 128,
	US_FL_GO_SLOW = 256,
	US_FL_NO_WP_DETECT = 512,
	US_FL_MAX_SECTORS_64 = 1024,
	US_FL_IGNORE_DEVICE = 2048,
	US_FL_CAPACITY_HEURISTICS = 4096,
	US_FL_MAX_SECTORS_MIN = 8192,
	US_FL_BULK_IGNORE_TAG = 16384,
	US_FL_SANE_SENSE = 32768,
	US_FL_CAPACITY_OK = 65536,
	US_FL_BAD_SENSE = 131072,
	US_FL_NO_READ_DISC_INFO = 262144,
	US_FL_NO_READ_CAPACITY_16 = 524288,
	US_FL_INITIAL_READ10 = 1048576,
	US_FL_WRITE_CACHE = 2097152,
	US_FL_NEEDS_CAP16 = 4194304,
	US_FL_IGNORE_UAS = 8388608,
	US_FL_BROKEN_FUA = 16777216,
	US_FL_NO_ATA_1X = 33554432,
	US_FL_NO_REPORT_OPCODES = 67108864,
	US_FL_MAX_SECTORS_240 = 134217728,
	US_FL_NO_REPORT_LUNS = 268435456,
	US_FL_ALWAYS_SYNC = 536870912,
	US_FL_NO_SAME = 1073741824,
};

struct us_data;

struct us_unusual_dev {
	const char *vendorName;
	const char *productName;
	__u8 useProtocol;
	__u8 useTransport;
	int (*initFunction)(struct us_data *);
};

typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef int (*trans_reset)(struct us_data *);

typedef void (*proto_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef void (*extra_data_destructor)(void *);

typedef void (*pm_hook)(struct us_data *, int);

struct us_data {
	struct mutex dev_mutex;
	struct usb_device *pusb_dev;
	struct usb_interface *pusb_intf;
	const struct us_unusual_dev *unusual_dev;
	long unsigned int fflags;
	long unsigned int dflags;
	unsigned int send_bulk_pipe;
	unsigned int recv_bulk_pipe;
	unsigned int send_ctrl_pipe;
	unsigned int recv_ctrl_pipe;
	unsigned int recv_intr_pipe;
	char *transport_name;
	char *protocol_name;
	__le32 bcs_signature;
	u8 subclass;
	u8 protocol;
	u8 max_lun;
	u8 ifnum;
	u8 ep_bInterval;
	trans_cmnd transport;
	trans_reset transport_reset;
	proto_cmnd proto_handler;
	struct scsi_cmnd *srb;
	unsigned int tag;
	char scsi_name[32];
	struct urb *current_urb;
	struct usb_ctrlrequest *cr;
	struct usb_sg_request current_sg;
	unsigned char *iobuf;
	dma_addr_t iobuf_dma;
	struct task_struct *ctl_thread;
	struct completion cmnd_ready;
	struct completion notify;
	wait_queue_head_t delay_wait;
	struct delayed_work scan_dwork;
	void *extra;
	extra_data_destructor extra_destructor;
	pm_hook suspend_resume_hook;
	int use_last_sector_hacks;
	int last_sector_retries;
};

enum xfer_buf_dir {
	TO_XFER_BUF = 0,
	FROM_XFER_BUF = 1,
};

struct bulk_cb_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 DataTransferLength;
	__u8 Flags;
	__u8 Lun;
	__u8 Length;
	__u8 CDB[16];
};

struct bulk_cs_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 Residue;
	__u8 Status;
};

struct swoc_info {
	__u8 rev;
	__u8 reserved[8];
	__u16 LinuxSKU;
	__u16 LinuxVer;
	__u8 reserved2[47];
} __attribute__((packed));

struct ignore_entry {
	u16 vid;
	u16 pid;
	u16 bcdmin;
	u16 bcdmax;
};

enum usb3503_mode {
	USB3503_MODE_UNKNOWN = 0,
	USB3503_MODE_HUB = 1,
	USB3503_MODE_STANDBY = 2,
};

struct usb3503_platform_data {
	enum usb3503_mode initial_mode;
	u8 port_off_mask;
};

struct usb3503 {
	enum usb3503_mode mode;
	struct regmap *regmap;
	struct device *dev;
	struct clk *clk;
	u8 port_off_mask;
	struct gpio_desc *intn;
	struct gpio_desc *reset;
	struct gpio_desc *connect;
	bool secondary_ref_clk;
};

struct out_pin {
	u32 enable_mask;
	u32 value_mask;
	u32 changed_mask;
	u32 clr_changed_mask;
	struct gpio_desc *gpiod;
	const char *name;
};

struct brcmstb_usb_pinmap_data;

struct in_pin {
	u32 enable_mask;
	u32 value_mask;
	struct gpio_desc *gpiod;
	const char *name;
	struct brcmstb_usb_pinmap_data *pdata;
};

struct brcmstb_usb_pinmap_data {
	void *regs;
	int in_count;
	struct in_pin *in_pins;
	int out_count;
	struct out_pin *out_pins;
};

struct ci_hdrc;

struct ci_hdrc_cable {
	bool connected;
	bool changed;
	bool enabled;
	struct extcon_dev *edev;
	struct ci_hdrc *ci;
	struct notifier_block nb;
};

struct hw_bank {
	unsigned int lpm;
	resource_size_t phys;
	void *abs;
	void *cap;
	void *op;
	size_t size;
	void *regmap[38];
};

enum ci_role {
	CI_ROLE_HOST = 0,
	CI_ROLE_GADGET = 1,
	CI_ROLE_END = 2,
};

struct otg_fsm_ops;

struct otg_fsm {
	int id;
	int adp_change;
	int power_up;
	int a_srp_det;
	int a_vbus_vld;
	int b_conn;
	int a_bus_resume;
	int a_bus_suspend;
	int a_conn;
	int b_se0_srp;
	int b_ssend_srp;
	int b_sess_vld;
	int test_device;
	int a_bus_drop;
	int a_bus_req;
	int b_bus_req;
	int a_sess_vld;
	int b_bus_resume;
	int b_bus_suspend;
	int drv_vbus;
	int loc_conn;
	int loc_sof;
	int adp_prb;
	int adp_sns;
	int data_pulse;
	int a_set_b_hnp_en;
	int b_srp_done;
	int b_hnp_enable;
	int a_clr_err;
	int a_bus_drop_inf;
	int a_bus_req_inf;
	int a_clr_err_inf;
	int b_bus_req_inf;
	int a_suspend_req_inf;
	int a_wait_vrise_tmout;
	int a_wait_vfall_tmout;
	int a_wait_bcon_tmout;
	int a_aidl_bdis_tmout;
	int b_ase0_brst_tmout;
	int a_bidl_adis_tmout;
	struct otg_fsm_ops *ops;
	struct usb_otg *otg;
	int protocol;
	struct mutex lock;
	u8 *host_req_flag;
	struct delayed_work hnp_polling_work;
	bool state_changed;
};

enum otg_fsm_timer {
	A_WAIT_VRISE = 0,
	A_WAIT_VFALL = 1,
	A_WAIT_BCON = 2,
	A_AIDL_BDIS = 3,
	B_ASE0_BRST = 4,
	A_BIDL_ADIS = 5,
	B_AIDL_BDIS = 6,
	B_SE0_SRP = 7,
	B_SRP_FAIL = 8,
	A_WAIT_ENUM = 9,
	B_DATA_PLS = 10,
	B_SSEND_SRP = 11,
	NUM_OTG_FSM_TIMERS = 12,
};

struct ci_hw_qh;

struct td_node;

struct ci_hw_ep {
	struct usb_ep ep;
	u8 dir;
	u8 num;
	u8 type;
	char name[16];
	struct {
		struct list_head queue;
		struct ci_hw_qh *ptr;
		dma_addr_t dma;
	} qh;
	int wedge;
	struct ci_hdrc *ci;
	spinlock_t *lock;
	struct dma_pool___2 *td_pool;
	struct td_node *pending_td;
};

enum ci_revision {
	CI_REVISION_1X = 10,
	CI_REVISION_20 = 20,
	CI_REVISION_21 = 21,
	CI_REVISION_22 = 22,
	CI_REVISION_23 = 23,
	CI_REVISION_24 = 24,
	CI_REVISION_25 = 25,
	CI_REVISION_25_PLUS = 26,
	CI_REVISION_UNKNOWN = 99,
};

struct ci_role_driver;

struct ci_hdrc_platform_data;

struct ci_hdrc {
	struct device *dev;
	spinlock_t lock;
	struct hw_bank hw_bank;
	int irq;
	struct ci_role_driver *roles[2];
	enum ci_role role;
	bool is_otg;
	struct usb_otg otg;
	struct otg_fsm fsm;
	int: 32;
	struct hrtimer otg_fsm_hrtimer;
	ktime_t hr_timeouts[12];
	unsigned int enabled_otg_timer_bits;
	enum otg_fsm_timer next_otg_timer;
	struct usb_role_switch *role_switch;
	struct work_struct work;
	struct workqueue_struct *wq;
	struct dma_pool___2 *qh_pool;
	struct dma_pool___2 *td_pool;
	struct usb_gadget gadget;
	struct usb_gadget_driver *driver;
	enum usb_device_state resume_state;
	unsigned int hw_ep_max;
	struct ci_hw_ep ci_hw_ep[32];
	u32 ep0_dir;
	struct ci_hw_ep *ep0out;
	struct ci_hw_ep *ep0in;
	struct usb_request *status;
	bool setaddr;
	u8 address;
	u8 remote_wakeup;
	u8 suspended;
	u8 test_mode;
	struct ci_hdrc_platform_data *platdata;
	int vbus_active;
	struct ulpi___2 *ulpi;
	struct ulpi_ops ulpi_ops;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_hcd *hcd;
	struct dentry *debugfs;
	bool id_event;
	bool b_sess_valid_event;
	bool imx28_write_fix;
	bool supports_runtime_pm;
	bool in_lpm;
	bool wakeup_int;
	enum ci_revision rev;
	int: 32;
};

struct ci_hdrc_platform_data {
	const char *name;
	uintptr_t capoffset;
	unsigned int power_budget;
	struct phy *phy;
	struct usb_phy *usb_phy;
	enum usb_phy_interface phy_mode;
	long unsigned int flags;
	enum usb_dr_mode dr_mode;
	int (*notify_event)(struct ci_hdrc *, unsigned int);
	struct regulator *reg_vbus;
	struct usb_otg_caps ci_otg_caps;
	bool tpl_support;
	u32 itc_setting;
	u32 ahb_burst_config;
	u32 tx_burst_size;
	u32 rx_burst_size;
	struct ci_hdrc_cable vbus_extcon;
	struct ci_hdrc_cable id_extcon;
	u32 phy_clkgate_delay_us;
	struct pinctrl *pctl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_host;
	struct pinctrl_state *pins_device;
};

struct otg_fsm_ops {
	void (*chrg_vbus)(struct otg_fsm *, int);
	void (*drv_vbus)(struct otg_fsm *, int);
	void (*loc_conn)(struct otg_fsm *, int);
	void (*loc_sof)(struct otg_fsm *, int);
	void (*start_pulse)(struct otg_fsm *);
	void (*start_adp_prb)(struct otg_fsm *);
	void (*start_adp_sns)(struct otg_fsm *);
	void (*add_timer)(struct otg_fsm *, enum otg_fsm_timer);
	void (*del_timer)(struct otg_fsm *, enum otg_fsm_timer);
	int (*start_host)(struct otg_fsm *, int);
	int (*start_gadget)(struct otg_fsm *, int);
};

enum ci_hw_regs {
	CAP_CAPLENGTH = 0,
	CAP_HCCPARAMS = 1,
	CAP_DCCPARAMS = 2,
	CAP_TESTMODE = 3,
	CAP_LAST = 3,
	OP_USBCMD = 4,
	OP_USBSTS = 5,
	OP_USBINTR = 6,
	OP_DEVICEADDR = 7,
	OP_ENDPTLISTADDR = 8,
	OP_TTCTRL = 9,
	OP_BURSTSIZE = 10,
	OP_ULPI_VIEWPORT = 11,
	OP_PORTSC = 12,
	OP_DEVLC = 13,
	OP_OTGSC = 14,
	OP_USBMODE = 15,
	OP_ENDPTSETUPSTAT = 16,
	OP_ENDPTPRIME = 17,
	OP_ENDPTFLUSH = 18,
	OP_ENDPTSTAT = 19,
	OP_ENDPTCOMPLETE = 20,
	OP_ENDPTCTRL = 21,
	OP_LAST = 37,
};

struct ci_hw_td {
	__le32 next;
	__le32 token;
	__le32 page[5];
};

struct ci_hw_qh {
	__le32 cap;
	__le32 curr;
	struct ci_hw_td td;
	__le32 RESERVED;
	struct usb_ctrlrequest setup;
};

struct td_node {
	struct list_head td;
	dma_addr_t dma;
	struct ci_hw_td *ptr;
	int td_remaining_size;
};

struct ci_role_driver {
	int (*start)(struct ci_hdrc *);
	void (*stop)(struct ci_hdrc *);
	irqreturn_t (*irq)(struct ci_hdrc *);
	const char *name;
};

struct ci_hw_req {
	struct usb_request req;
	struct list_head queue;
	struct list_head tds;
};

struct trace_event_raw_ci_log {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_ci_log_trb {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct td_node *td;
	struct usb_request *req;
	dma_addr_t dma;
	s32 td_remaining_size;
	u32 next;
	u32 token;
	u32 type;
	char __data[0];
};

struct trace_event_data_offsets_ci_log {
	u32 name;
	u32 msg;
};

struct trace_event_data_offsets_ci_log_trb {
	u32 name;
};

typedef void (*btf_trace_ci_log)(void *, struct ci_hdrc *, struct va_format *);

typedef void (*btf_trace_ci_prepare_td)(void *, struct ci_hw_ep *, struct ci_hw_req *, struct td_node *);

typedef void (*btf_trace_ci_complete_td)(void *, struct ci_hw_ep *, struct ci_hw_req *, struct td_node *);

struct ehci_ci_priv {
	struct regulator *reg_vbus;
	bool enabled;
};

struct ci_hdrc_usb2_priv {
	struct platform_device *ci_pdev;
	struct clk *clk;
};

struct ci_hdrc_msm {
	struct platform_device *ci;
	struct clk *core_clk;
	struct clk *iface_clk;
	struct clk *fs_clk;
	struct ci_hdrc_platform_data pdata;
	struct reset_controller_dev rcdev;
	bool secondary_phy;
	bool hsic;
	void *base;
};

struct imx_usbmisc_data {
	struct device *dev;
	int index;
	unsigned int disable_oc: 1;
	unsigned int oc_pol_active_low: 1;
	unsigned int oc_pol_configured: 1;
	unsigned int pwr_pol: 1;
	unsigned int evdo: 1;
	unsigned int ulpi: 1;
	unsigned int hsic: 1;
	unsigned int ext_id: 1;
	unsigned int ext_vbus: 1;
	struct usb_phy *usb_phy;
	enum usb_dr_mode available_role;
	int emp_curr_control;
	int dc_vol_level_adjust;
};

struct ci_hdrc_imx_platform_flag {
	unsigned int flags;
};

struct ci_hdrc_imx_data {
	struct usb_phy *phy;
	struct platform_device *ci_pdev;
	struct clk *clk;
	struct imx_usbmisc_data *usbmisc_data;
	bool supports_runtime_pm;
	bool override_phy_control;
	bool in_lpm;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_hsic_active;
	struct regulator *hsic_pad_regulator;
	bool need_three_clks;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_per;
	struct pm_qos_request pm_qos_req;
	const struct ci_hdrc_imx_platform_flag *plat_data;
};

struct usbmisc_ops {
	int (*init)(struct imx_usbmisc_data *);
	int (*post)(struct imx_usbmisc_data *);
	int (*set_wakeup)(struct imx_usbmisc_data *, bool);
	int (*hsic_set_connect)(struct imx_usbmisc_data *);
	int (*hsic_set_clk)(struct imx_usbmisc_data *, bool);
	int (*charger_detection)(struct imx_usbmisc_data *);
};

struct imx_usbmisc {
	void *base;
	spinlock_t lock;
	const struct usbmisc_ops *ops;
};

struct tegra_udc {
	struct ci_hdrc_platform_data data;
	struct platform_device *dev;
	struct usb_phy *phy;
	struct clk *clk;
};

struct tegra_udc_soc_info {
	long unsigned int flags;
};

struct usb_udc {
	struct usb_gadget_driver *driver;
	struct usb_gadget *gadget;
	struct device dev;
	struct list_head list;
	bool vbus;
	int: 24;
	int: 32;
};

struct trace_event_raw_udc_log_gadget {
	struct trace_entry ent;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_device_state state;
	unsigned int mA;
	unsigned int sg_supported;
	unsigned int is_otg;
	unsigned int is_a_peripheral;
	unsigned int b_hnp_enable;
	unsigned int a_hnp_support;
	unsigned int hnp_polling_support;
	unsigned int host_request_flag;
	unsigned int quirk_ep_out_aligned_size;
	unsigned int quirk_altset_not_supp;
	unsigned int quirk_stall_not_supp;
	unsigned int quirk_zlp_not_supp;
	unsigned int is_selfpowered;
	unsigned int deactivated;
	unsigned int connected;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int maxpacket;
	unsigned int maxpacket_limit;
	unsigned int max_streams;
	unsigned int mult;
	unsigned int maxburst;
	u8 address;
	bool claimed;
	bool enabled;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_req {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int length;
	unsigned int actual;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id;
	unsigned int no_interrupt;
	unsigned int zero;
	unsigned int short_not_ok;
	int status;
	int ret;
	struct usb_request *req;
	char __data[0];
};

struct trace_event_data_offsets_udc_log_gadget {};

struct trace_event_data_offsets_udc_log_ep {
	u32 name;
};

struct trace_event_data_offsets_udc_log_req {
	u32 name;
};

typedef void (*btf_trace_usb_gadget_frame_number)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_wakeup)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_set_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_clear_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_draw)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_deactivate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_activate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_ep_set_maxpacket_limit)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_enable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_disable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_clear_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_wedge)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_status)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_flush)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_alloc_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_free_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_queue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_dequeue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_gadget_giveback_request)(void *, struct usb_ep *, struct usb_request *, int);

struct extcon_specific_cable_nb {
	struct notifier_block *user_nb;
	int cable_index;
	struct extcon_dev *edev;
	long unsigned int previous_value;
};

struct udc_csrs {
	u32 sca;
	u32 ne[9];
};

struct udc_regs {
	u32 cfg;
	u32 ctl;
	u32 sts;
	u32 irqsts;
	u32 irqmsk;
	u32 ep_irqsts;
	u32 ep_irqmsk;
};

struct udc_ep_regs {
	u32 ctl;
	u32 sts;
	u32 bufin_framenum;
	u32 bufout_maxpkt;
	u32 subptr;
	u32 desptr;
	u32 reserved;
	u32 confirm;
};

struct udc_stp_dma {
	u32 status;
	u32 _reserved;
	u32 data12;
	u32 data34;
};

struct udc_data_dma {
	u32 status;
	u32 _reserved;
	u32 bufptr;
	u32 next;
};

struct udc_request {
	struct usb_request req;
	unsigned int dma_going: 1;
	unsigned int dma_done: 1;
	dma_addr_t td_phys;
	struct udc_data_dma *td_data;
	struct udc_data_dma *td_data_last;
	struct list_head queue;
	unsigned int chain_len;
};

struct udc;

struct udc_ep {
	struct usb_ep ep;
	struct udc_ep_regs *regs;
	u32 *txfifo;
	u32 *dma;
	dma_addr_t td_phys;
	dma_addr_t td_stp_dma;
	struct udc_stp_dma *td_stp;
	struct udc_data_dma *td;
	struct udc_request *req;
	unsigned int req_used;
	unsigned int req_completed;
	struct udc_request *bna_dummy_req;
	unsigned int bna_occurred;
	unsigned int naking;
	struct udc *dev;
	struct list_head queue;
	unsigned int halted;
	unsigned int cancel_transfer;
	unsigned int num: 5;
	unsigned int fifo_depth: 14;
	unsigned int in: 1;
};

struct udc {
	struct usb_gadget gadget;
	spinlock_t lock;
	struct udc_ep ep[32];
	struct usb_gadget_driver *driver;
	unsigned int stall_ep0in: 1;
	unsigned int waiting_zlp_ack_ep0in: 1;
	unsigned int set_cfg_not_acked: 1;
	unsigned int data_ep_enabled: 1;
	unsigned int data_ep_queued: 1;
	unsigned int sys_suspended: 1;
	unsigned int connected;
	u16 chiprev;
	struct pci_dev *pdev;
	struct udc_csrs *csr;
	struct udc_regs *regs;
	struct udc_ep_regs *ep_regs;
	u32 *rxfifo;
	u32 *txfifo;
	struct dma_pool___2 *data_requests;
	struct dma_pool___2 *stp_requests;
	long unsigned int phys_addr;
	void *virt_addr;
	unsigned int irq;
	u16 cur_config;
	u16 cur_intf;
	u16 cur_alt;
	struct device *dev;
	struct phy *udc_phy;
	struct extcon_dev *edev;
	struct extcon_specific_cable_nb extcon_nb;
	struct notifier_block nb;
	struct delayed_work drd_work;
	struct workqueue_struct *drd_wq;
	u32 conn_type;
	int: 32;
};

union udc_setup_data {
	u32 data[2];
	struct usb_ctrlrequest request;
};

struct amd5536udc;

struct bdc_bd {
	__le32 offset[4];
};

struct bdc_sr {
	__le32 offset[4];
};

struct bd_table {
	struct bdc_bd *start_bd;
	dma_addr_t dma;
};

struct bd_list {
	struct bd_table **bd_table_array;
	int num_tabs;
	int max_bdi;
	int eqp_bdi;
	int hwd_bdi;
	int num_bds_table;
};

struct bdc_req;

struct bd_transfer {
	struct bdc_req *req;
	int start_bdi;
	int next_hwd_bdi;
	int num_bds;
};

struct bdc_ep;

struct bdc_req {
	struct usb_request usb_req;
	struct list_head queue;
	struct bdc_ep *ep;
	struct bd_transfer bd_xfr;
	int epnum;
};

struct bdc;

struct bdc_ep {
	struct usb_ep usb_ep;
	struct list_head queue;
	struct bdc *bdc;
	u8 ep_type;
	u8 dir;
	u8 ep_num;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
	const struct usb_endpoint_descriptor *desc;
	unsigned int flags;
	char name[20];
	struct bd_list bd_list;
	bool ignore_next_sr;
};

struct bdc_scratchpad {
	dma_addr_t sp_dma;
	void *buff;
	u32 size;
};

struct srr {
	struct bdc_sr *sr_bds;
	u16 eqp_index;
	u16 dqp_index;
	dma_addr_t dma_addr;
};

enum bdc_ep0_state {
	WAIT_FOR_SETUP = 0,
	WAIT_FOR_DATA_START = 1,
	WAIT_FOR_DATA_XMIT = 2,
	WAIT_FOR_STATUS_START = 3,
	WAIT_FOR_STATUS_XMIT = 4,
	STATUS_PENDING = 5,
};

struct bdc {
	struct usb_gadget gadget;
	struct usb_gadget_driver *gadget_driver;
	struct device *dev;
	spinlock_t lock;
	struct phy **phys;
	int num_phys;
	unsigned int num_eps;
	struct bdc_ep **bdc_ep_array;
	void *regs;
	struct bdc_scratchpad scratchpad;
	u32 sp_buff_size;
	struct srr srr;
	struct usb_ctrlrequest setup_pkt;
	struct bdc_req ep0_req;
	struct bdc_req status_req;
	enum bdc_ep0_state ep0_state;
	bool delayed_status;
	bool zlp_needed;
	bool reinit;
	bool pullup;
	u32 devstatus;
	int irq;
	void *mem;
	u32 dev_addr;
	struct dma_pool___2 *bd_table_pool;
	u8 test_mode;
	void (*sr_handler[2])(struct bdc *, struct bdc_sr *);
	void (*sr_xsf_ep0[3])(struct bdc *, struct bdc_sr *);
	unsigned char ep0_response_buff[6];
	struct delayed_work func_wake_notify;
	struct clk *clk;
};

enum bdc_link_state {
	BDC_LINK_STATE_U0 = 0,
	BDC_LINK_STATE_U3 = 3,
	BDC_LINK_STATE_RX_DET = 5,
	BDC_LINK_STATE_RESUME = 15,
};

struct usb_role_switch {
	struct device dev;
	struct mutex lock;
	enum usb_role role;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	int: 32;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
	int: 32;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct serport___2 {
	struct tty_struct *tty;
	wait_queue_head_t wait;
	struct serio *serio;
	struct serio_device_id id;
	spinlock_t lock;
	long unsigned int flags;
};

struct amba_kmi_port {
	struct serio *io;
	struct clk *clk;
	void *base;
	unsigned int irq;
	unsigned int divisor;
	unsigned int open;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct input_led {
	struct led_classdev cdev;
	struct input_handle *handle;
	unsigned int code;
};

struct input_leds {
	struct input_handle handle;
	unsigned int num_leds;
	struct input_led leds[0];
};

struct js_event {
	__u32 time;
	__s16 value;
	__u8 type;
	__u8 number;
};

struct js_corr {
	__s32 coef[8];
	__s16 prec;
	__u16 type;
};

struct JS_DATA_TYPE {
	__s32 buttons;
	__s32 x;
	__s32 y;
};

struct JS_DATA_SAVE_TYPE_32 {
	__s32 JS_TIMEOUT;
	__s32 BUSY;
	__s32 JS_EXPIRETIME;
	__s32 JS_TIMELIMIT;
	struct JS_DATA_TYPE JS_SAVE;
	struct JS_DATA_TYPE JS_CORR;
};

struct joydev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	int: 32;
	struct device dev;
	struct cdev cdev;
	bool exist;
	struct js_corr corr[64];
	struct JS_DATA_SAVE_TYPE_32 glue;
	int nabs;
	int nkey;
	__u16 keymap[512];
	__u16 keypam[512];
	__u8 absmap[64];
	__u8 abspam[64];
	__s16 abs[64];
};

struct joydev_client {
	struct js_event buffer[64];
	int head;
	int tail;
	int startup;
	spinlock_t buffer_lock;
	struct fasync_struct *fasync;
	struct joydev *joydev;
	struct list_head node;
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	int: 32;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[16];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	u32 function_row_physmap[24];
	int num_function_row_keys;
};

struct bcm_kp {
	void *base;
	int irq;
	struct clk *clk;
	struct input_dev *input_dev;
	long unsigned int last_state[2];
	unsigned int n_rows;
	unsigned int n_cols;
	u32 kpcr;
	u32 kpior;
	u32 kpemr;
	u32 imr0_val;
	u32 imr1_val;
};

struct gpio_keys_button {
	unsigned int code;
	int gpio;
	int active_low;
	const char *desc;
	unsigned int type;
	int wakeup;
	int wakeup_event_action;
	int debounce_interval;
	bool can_disable;
	int value;
	unsigned int irq;
};

struct gpio_keys_platform_data {
	const struct gpio_keys_button *buttons;
	int nbuttons;
	unsigned int poll_interval;
	unsigned int rep: 1;
	int (*enable)(struct device *);
	void (*disable)(struct device *);
	const char *name;
};

struct gpio_button_data {
	const struct gpio_keys_button *button;
	struct input_dev *input;
	struct gpio_desc *gpiod;
	short unsigned int *code;
	struct timer_list release_timer;
	unsigned int release_delay;
	struct delayed_work work;
	unsigned int software_debounce;
	unsigned int irq;
	unsigned int wakeup_trigger_type;
	spinlock_t lock;
	bool disabled;
	bool key_pressed;
	bool suspended;
};

struct gpio_keys_drvdata {
	const struct gpio_keys_platform_data *pdata;
	struct input_dev *input;
	struct mutex disable_lock;
	short unsigned int *keymap;
	struct gpio_button_data data[0];
};

struct kbd_platform_data {
	const struct matrix_keymap_data *keymap;
	bool rep;
	unsigned int mode;
	unsigned int suspended_rate;
};

struct spear_kbd {
	struct input_dev *input;
	void *io_base;
	struct clk *clk;
	unsigned int irq;
	unsigned int mode;
	unsigned int suspended_rate;
	short unsigned int last_key;
	short unsigned int keycodes[256];
	bool rep;
	bool irq_wake_enabled;
	u32 mode_ctl_reg;
};

struct st_keyscan {
	void *base;
	int irq;
	struct clk *clk;
	struct input_dev *input_dev;
	long unsigned int last_state;
	unsigned int n_rows;
	unsigned int n_cols;
	unsigned int debounce_us;
};

enum tegra_pin_type {
	PIN_CFG_IGNORE = 0,
	PIN_CFG_COL = 1,
	PIN_CFG_ROW = 2,
};

struct tegra_kbc_hw_support {
	int max_rows;
	int max_columns;
};

struct tegra_kbc_pin_cfg {
	enum tegra_pin_type type;
	unsigned char num;
};

struct tegra_kbc {
	struct device *dev;
	unsigned int debounce_cnt;
	unsigned int repeat_cnt;
	struct tegra_kbc_pin_cfg pin_cfg[24];
	const struct matrix_keymap_data *keymap_data;
	bool wakeup;
	void *mmio;
	struct input_dev *idev;
	int irq;
	spinlock_t lock;
	unsigned int repoll_dly;
	long unsigned int cp_dly_jiffies;
	unsigned int cp_to_wkup_dly;
	bool use_fn_map;
	bool use_ghost_filter;
	bool keypress_caused_wake;
	short unsigned int keycode[256];
	short unsigned int current_keys[8];
	unsigned int num_pressed_keys;
	u32 wakeup_key;
	struct timer_list timer;
	struct clk *clk;
	struct reset_control *rst;
	const struct tegra_kbc_hw_support *hw_support;
	int max_keys;
	int num_rows_and_columns;
};

enum tp_mode {
	IAP_MODE = 1,
	MAIN_MODE = 2,
};

struct elan_transport_ops {
	int (*initialize)(struct i2c_client *);
	int (*sleep_control)(struct i2c_client *, bool);
	int (*power_control)(struct i2c_client *, bool);
	int (*set_mode)(struct i2c_client *, u8);
	int (*calibrate)(struct i2c_client *);
	int (*calibrate_result)(struct i2c_client *, u8 *);
	int (*get_baseline_data)(struct i2c_client *, bool, u8 *);
	int (*get_version)(struct i2c_client *, u8, bool, u8 *);
	int (*get_sm_version)(struct i2c_client *, u8, u16 *, u8 *, u8 *);
	int (*get_checksum)(struct i2c_client *, bool, u16 *);
	int (*get_product_id)(struct i2c_client *, u16 *);
	int (*get_max)(struct i2c_client *, unsigned int *, unsigned int *);
	int (*get_resolution)(struct i2c_client *, u8 *, u8 *);
	int (*get_num_traces)(struct i2c_client *, unsigned int *, unsigned int *);
	int (*iap_get_mode)(struct i2c_client *, enum tp_mode *);
	int (*iap_reset)(struct i2c_client *);
	int (*prepare_fw_update)(struct i2c_client *, u16, u8, u16);
	int (*write_fw_block)(struct i2c_client *, u16, const u8 *, u16, int);
	int (*finish_fw_update)(struct i2c_client *, struct completion *);
	int (*get_report_features)(struct i2c_client *, u8, unsigned int *, unsigned int *);
	int (*get_report)(struct i2c_client *, u8 *, unsigned int);
	int (*get_pressure_adjustment)(struct i2c_client *, int *);
	int (*get_pattern)(struct i2c_client *, u8 *);
};

struct elan_tp_data {
	struct i2c_client *client;
	struct input_dev *input;
	struct input_dev *tp_input;
	struct regulator *vcc;
	const struct elan_transport_ops *ops;
	struct completion fw_completion;
	bool in_fw_update;
	struct mutex sysfs_mutex;
	unsigned int max_x;
	unsigned int max_y;
	unsigned int width_x;
	unsigned int width_y;
	unsigned int x_res;
	unsigned int y_res;
	u8 pattern;
	u16 product_id;
	u8 fw_version;
	u8 sm_version;
	u8 iap_version;
	u16 fw_checksum;
	unsigned int report_features;
	unsigned int report_len;
	int pressure_adjustment;
	u8 mode;
	u16 ic_type;
	u16 fw_validpage_count;
	u16 fw_page_size;
	u32 fw_signature_address;
	bool irq_wake;
	u8 min_baseline;
	u8 max_baseline;
	bool baseline_ready;
	u8 clickpad;
	bool middle_button;
};

enum psmouse_state {
	PSMOUSE_IGNORE = 0,
	PSMOUSE_INITIALIZING = 1,
	PSMOUSE_RESYNCING = 2,
	PSMOUSE_CMD_MODE = 3,
	PSMOUSE_ACTIVATED = 4,
};

typedef enum {
	PSMOUSE_BAD_DATA = 0,
	PSMOUSE_GOOD_DATA = 1,
	PSMOUSE_FULL_PACKET = 2,
} psmouse_ret_t;

enum psmouse_scale {
	PSMOUSE_SCALE11 = 0,
	PSMOUSE_SCALE21 = 1,
};

enum psmouse_type {
	PSMOUSE_NONE = 0,
	PSMOUSE_PS2 = 1,
	PSMOUSE_PS2PP = 2,
	PSMOUSE_THINKPS = 3,
	PSMOUSE_GENPS = 4,
	PSMOUSE_IMPS = 5,
	PSMOUSE_IMEX = 6,
	PSMOUSE_SYNAPTICS = 7,
	PSMOUSE_ALPS = 8,
	PSMOUSE_LIFEBOOK = 9,
	PSMOUSE_TRACKPOINT = 10,
	PSMOUSE_TOUCHKIT_PS2 = 11,
	PSMOUSE_CORTRON = 12,
	PSMOUSE_HGPK = 13,
	PSMOUSE_ELANTECH = 14,
	PSMOUSE_FSP = 15,
	PSMOUSE_SYNAPTICS_RELATIVE = 16,
	PSMOUSE_CYPRESS = 17,
	PSMOUSE_FOCALTECH = 18,
	PSMOUSE_VMMOUSE = 19,
	PSMOUSE_BYD = 20,
	PSMOUSE_SYNAPTICS_SMBUS = 21,
	PSMOUSE_ELANTECH_SMBUS = 22,
	PSMOUSE_AUTO = 23,
};

struct psmouse;

struct psmouse_protocol {
	enum psmouse_type type;
	bool maxproto;
	bool ignore_parity;
	bool try_passthru;
	bool smbus_companion;
	const char *name;
	const char *alias;
	int (*detect)(struct psmouse *, bool);
	int (*init)(struct psmouse *);
};

struct psmouse {
	void *private;
	struct input_dev *dev;
	struct ps2dev ps2dev;
	struct delayed_work resync_work;
	const char *vendor;
	const char *name;
	const struct psmouse_protocol *protocol;
	unsigned char packet[8];
	unsigned char badbyte;
	unsigned char pktcnt;
	unsigned char pktsize;
	unsigned char oob_data_type;
	unsigned char extra_buttons;
	bool acks_disable_command;
	unsigned int model;
	long unsigned int last;
	long unsigned int out_of_sync_cnt;
	long unsigned int num_resyncs;
	enum psmouse_state state;
	char devname[64];
	char phys[32];
	unsigned int rate;
	unsigned int resolution;
	unsigned int resetafter;
	unsigned int resync_time;
	bool smartscroll;
	psmouse_ret_t (*protocol_handler)(struct psmouse *);
	void (*set_rate)(struct psmouse *, unsigned int);
	void (*set_resolution)(struct psmouse *, unsigned int);
	void (*set_scale)(struct psmouse *, enum psmouse_scale);
	int (*reconnect)(struct psmouse *);
	int (*fast_reconnect)(struct psmouse *);
	void (*disconnect)(struct psmouse *);
	void (*cleanup)(struct psmouse *);
	int (*poll)(struct psmouse *);
	void (*pt_activate)(struct psmouse *);
	void (*pt_deactivate)(struct psmouse *);
};

struct psmouse_attribute {
	struct device_attribute dattr;
	void *data;
	ssize_t (*show)(struct psmouse *, void *, char *);
	ssize_t (*set)(struct psmouse *, void *, const char *, size_t);
	bool protect;
};

struct rmi_2d_axis_alignment {
	bool swap_axes;
	bool flip_x;
	bool flip_y;
	u16 clip_x_low;
	u16 clip_y_low;
	u16 clip_x_high;
	u16 clip_y_high;
	u16 offset_x;
	u16 offset_y;
	u8 delta_x_threshold;
	u8 delta_y_threshold;
};

enum rmi_sensor_type {
	rmi_sensor_default = 0,
	rmi_sensor_touchscreen = 1,
	rmi_sensor_touchpad = 2,
};

struct rmi_2d_sensor_platform_data {
	struct rmi_2d_axis_alignment axis_align;
	enum rmi_sensor_type sensor_type;
	int x_mm;
	int y_mm;
	int disable_report_mask;
	u16 rezero_wait;
	bool topbuttonpad;
	bool kernel_tracking;
	int dmax;
	int dribble;
	int palm_detect;
};

struct rmi_gpio_data {
	bool buttonpad;
	bool trackstick_buttons;
	bool disable;
};

enum rmi_reg_state {
	RMI_REG_STATE_DEFAULT = 0,
	RMI_REG_STATE_OFF = 1,
	RMI_REG_STATE_ON = 2,
};

struct rmi_f01_power_management {
	enum rmi_reg_state nosleep;
	u8 wakeup_threshold;
	u8 doze_holdoff;
	u8 doze_interval;
};

struct rmi_device_platform_data_spi {
	u32 block_delay_us;
	u32 split_read_block_delay_us;
	u32 read_delay_us;
	u32 write_delay_us;
	u32 split_read_byte_delay_us;
	u32 pre_delay_us;
	u32 post_delay_us;
	u8 bits_per_word;
	u16 mode;
	void *cs_assert_data;
	int (*cs_assert)(const void *, const bool);
};

struct rmi_device_platform_data {
	int reset_delay_ms;
	int irq;
	struct rmi_device_platform_data_spi spi_data;
	struct rmi_2d_sensor_platform_data sensor_pdata;
	struct rmi_f01_power_management power_management;
	struct rmi_gpio_data gpio_data;
};

enum synaptics_pkt_type {
	SYN_NEWABS = 0,
	SYN_NEWABS_STRICT = 1,
	SYN_NEWABS_RELAXED = 2,
	SYN_OLDABS = 3,
};

struct synaptics_hw_state {
	int x;
	int y;
	int z;
	int w;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int up: 1;
	unsigned int down: 1;
	u8 ext_buttons;
	s8 scroll;
};

struct synaptics_device_info {
	u32 model_id;
	u32 firmware_id;
	u32 board_id;
	u32 capabilities;
	u32 ext_cap;
	u32 ext_cap_0c;
	u32 ext_cap_10;
	u32 identity;
	u32 x_res;
	u32 y_res;
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
};

struct synaptics_data {
	struct synaptics_device_info info;
	enum synaptics_pkt_type pkt_type;
	u8 mode;
	int scroll;
	bool absolute_mode;
	bool disable_gesture;
	struct serio *pt_port;
	struct synaptics_hw_state agm;
	unsigned int agm_count;
	long unsigned int press_start;
	bool press;
	bool report_press;
	bool is_forcepad;
};

struct min_max_quirk {
	const char * const *pnp_ids;
	struct {
		u32 min;
		u32 max;
	} board_id;
	u32 x_min;
	u32 x_max;
	u32 y_min;
	u32 y_max;
};

enum {
	SYNAPTICS_INTERTOUCH_NOT_SET = 4294967295,
	SYNAPTICS_INTERTOUCH_OFF = 0,
	SYNAPTICS_INTERTOUCH_ON = 1,
};

struct focaltech_finger_state {
	bool active;
	bool valid;
	unsigned int x;
	unsigned int y;
};

struct focaltech_hw_state {
	struct focaltech_finger_state fingers[5];
	unsigned int width;
	bool pressed;
};

struct focaltech_data {
	unsigned int x_max;
	unsigned int y_max;
	struct focaltech_hw_state state;
};

enum SS4_PACKET_ID {
	SS4_PACKET_ID_IDLE = 0,
	SS4_PACKET_ID_ONE = 1,
	SS4_PACKET_ID_TWO = 2,
	SS4_PACKET_ID_MULTI = 3,
	SS4_PACKET_ID_STICK = 4,
};

enum V7_PACKET_ID {
	V7_PACKET_ID_IDLE = 0,
	V7_PACKET_ID_TWO = 1,
	V7_PACKET_ID_MULTI = 2,
	V7_PACKET_ID_NEW = 3,
	V7_PACKET_ID_UNKNOWN = 4,
};

struct alps_protocol_info {
	u16 version;
	u8 byte0;
	u8 mask0;
	unsigned int flags;
};

struct alps_model_info {
	u8 signature[3];
	struct alps_protocol_info protocol_info;
};

struct alps_nibble_commands {
	int command;
	unsigned char data;
};

struct alps_bitmap_point {
	int start_bit;
	int num_bits;
};

struct alps_fields {
	unsigned int x_map;
	unsigned int y_map;
	unsigned int fingers;
	int pressure;
	struct input_mt_pos st;
	struct input_mt_pos mt[4];
	unsigned int first_mp: 1;
	unsigned int is_mp: 1;
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int ts_left: 1;
	unsigned int ts_right: 1;
	unsigned int ts_middle: 1;
};

struct alps_data {
	struct psmouse *psmouse;
	struct input_dev *dev2;
	struct input_dev *dev3;
	char phys2[32];
	char phys3[32];
	struct delayed_work dev3_register_work;
	const struct alps_nibble_commands *nibble_commands;
	int addr_command;
	u16 proto_version;
	u8 byte0;
	u8 mask0;
	u8 dev_id[3];
	u8 fw_ver[3];
	int flags;
	int x_max;
	int y_max;
	int x_bits;
	int y_bits;
	unsigned int x_res;
	unsigned int y_res;
	int (*hw_init)(struct psmouse *);
	void (*process_packet)(struct psmouse *);
	int (*decode_fields)(struct alps_fields *, unsigned char *, struct psmouse *);
	void (*set_abs_params)(struct alps_data *, struct input_dev *);
	int prev_fin;
	int multi_packet;
	int second_touch;
	unsigned char multi_data[6];
	struct alps_fields f;
	u8 quirks;
	struct timer_list timer;
};

struct byd_data {
	struct timer_list timer;
	struct psmouse *psmouse;
	s32 abs_x;
	s32 abs_y;
	volatile long unsigned int last_touch_time;
	bool btn_left;
	bool btn_right;
	bool touch;
};

struct finger_pos {
	unsigned int x;
	unsigned int y;
};

struct elantech_device_info {
	unsigned char capabilities[3];
	unsigned char samples[3];
	unsigned char debug;
	unsigned char hw_version;
	unsigned char pattern;
	unsigned int fw_version;
	unsigned int ic_version;
	unsigned int product_id;
	unsigned int x_min;
	unsigned int y_min;
	unsigned int x_max;
	unsigned int y_max;
	unsigned int x_res;
	unsigned int y_res;
	unsigned int x_traces;
	unsigned int y_traces;
	unsigned int width;
	unsigned int bus;
	bool paritycheck;
	bool jumpy_cursor;
	bool reports_pressure;
	bool crc_enabled;
	bool set_hw_resolution;
	bool has_trackpoint;
	bool has_middle_button;
	int (*send_cmd)(struct psmouse *, unsigned char, unsigned char *);
};

struct elantech_data {
	struct input_dev *tp_dev;
	char tp_phys[32];
	unsigned char reg_07;
	unsigned char reg_10;
	unsigned char reg_11;
	unsigned char reg_20;
	unsigned char reg_21;
	unsigned char reg_22;
	unsigned char reg_23;
	unsigned char reg_24;
	unsigned char reg_25;
	unsigned char reg_26;
	unsigned int single_finger_reports;
	unsigned int y_max;
	unsigned int width;
	struct finger_pos mt[5];
	unsigned char parity[256];
	struct elantech_device_info info;
	void (*original_set_rate)(struct psmouse *, unsigned int);
};

struct elantech_attr_data {
	size_t field_offset;
	unsigned char reg;
};

enum {
	ELANTECH_SMBUS_NOT_SET = 4294967295,
	ELANTECH_SMBUS_OFF = 0,
	ELANTECH_SMBUS_ON = 1,
};

struct ps2pp_info {
	u8 model;
	u8 kind;
	u16 features;
};

struct trackpoint_data {
	u8 variant_id;
	u8 firmware_id;
	u8 sensitivity;
	u8 speed;
	u8 inertia;
	u8 reach;
	u8 draghys;
	u8 mindrag;
	u8 thresh;
	u8 upthresh;
	u8 ztime;
	u8 jenks;
	u8 drift_time;
	bool press_to_select;
	bool skipback;
	bool ext_dev;
};

struct trackpoint_attr_data {
	size_t field_offset;
	u8 command;
	u8 mask;
	bool inverted;
	u8 power_on_default;
};

struct cytp_contact {
	int x;
	int y;
	int z;
};

struct cytp_report_data {
	int contact_cnt;
	struct cytp_contact contacts[2];
	unsigned int left: 1;
	unsigned int right: 1;
	unsigned int middle: 1;
	unsigned int tap: 1;
};

struct cytp_data {
	int fw_version;
	int pkt_size;
	int mode;
	int tp_min_pressure;
	int tp_max_pressure;
	int tp_width;
	int tp_high;
	int tp_max_abs_x;
	int tp_max_abs_y;
	int tp_res_x;
	int tp_res_y;
	int tp_metrics_supported;
};

struct psmouse_smbus_dev {
	struct i2c_board_info board;
	struct psmouse *psmouse;
	struct i2c_client *client;
	struct list_head node;
	bool dead;
	bool need_deactivate;
};

struct psmouse_smbus_removal_work {
	struct work_struct work;
	struct i2c_client *client;
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct stmpe_touch {
	struct stmpe *stmpe;
	struct input_dev *idev;
	struct delayed_work work;
	struct device *dev;
	struct touchscreen_properties prop;
	u8 ave_ctrl;
	u8 touch_det_delay;
	u8 settling;
	u8 fraction_z;
	u8 i_drive;
};

struct sun4i_ts_data {
	struct device *dev;
	struct input_dev *input;
	void *base;
	unsigned int irq;
	bool ignore_fifo_data;
	int temp_data;
	int temp_offset;
	int temp_step;
};

struct sirfsoc_pwrc_drvdata {
	u32 pwrc_base;
	struct input_dev *input;
	struct delayed_work work;
};

struct stpmic1_onkey {
	struct input_dev *input_dev;
	int irq_falling;
	int irq_rising;
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
	int: 32;
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	int: 32;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct ac100_clkout {
	struct clk_hw hw;
	struct regmap *regmap;
	u8 offset;
};

struct ac100_rtc_dev {
	struct rtc_device *rtc;
	struct device *dev;
	struct regmap *regmap;
	int irq;
	long unsigned int alarm;
	struct clk_hw *rtc_32k_clk;
	struct ac100_clkout clks[3];
	struct clk_hw_onecell_data *clk_data;
};

struct as3722_rtc {
	struct rtc_device *rtc;
	struct device *dev;
	struct as3722 *as3722;
	int alarm_irq;
	bool irq_enable;
};

struct brcmstb_waketmr {
	struct rtc_device *rtc;
	struct device *dev;
	void *base;
	int irq;
	struct notifier_block reboot_notifier;
	struct clk *clk;
	u32 rate;
};

struct wktmr_time {
	u32 sec;
	u32 pre;
};

struct ds1307_platform_data {
	u8 trickle_charger_setup;
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

enum ds_type {
	unknown_ds_type = 0,
	ds_1307 = 1,
	ds_1308 = 2,
	ds_1337 = 3,
	ds_1338 = 4,
	ds_1339 = 5,
	ds_1340 = 6,
	ds_1341 = 7,
	ds_1388 = 8,
	ds_3231 = 9,
	m41t0 = 10,
	m41t00 = 11,
	m41t11 = 12,
	mcp794xx = 13,
	rx_8025 = 14,
	rx_8130 = 15,
	last_ds_type = 16,
};

struct ds1307 {
	enum ds_type type;
	long unsigned int flags;
	struct device *dev;
	struct regmap *regmap;
	const char *name;
	struct rtc_device *rtc;
	struct clk_hw clks[2];
};

struct chip_desc {
	unsigned int alarm: 1;
	u16 nvram_offset;
	u16 nvram_size;
	u8 offset;
	u8 century_reg;
	u8 century_enable_bit;
	u8 century_bit;
	u8 bbsqi_bit;
	irq_handler_t irq_handler;
	const struct rtc_class_ops *rtc_ops;
	u16 trickle_charger_reg;
	u8 (*do_trickle_setup)(struct ds1307 *, u32, bool);
	bool requires_trickle_resistor;
	bool charge_default;
};

enum {
	DS3231_CLK_SQW = 0,
	DS3231_CLK_32KHZ = 1,
};

enum max77686_rtc_reg {
	MAX77686_RTC_INT = 0,
	MAX77686_RTC_INTM = 1,
	MAX77686_RTC_CONTROLM = 2,
	MAX77686_RTC_CONTROL = 3,
	MAX77686_RTC_UPDATE0 = 4,
	MAX77686_WTSR_SMPL_CNTL = 6,
	MAX77686_RTC_SEC = 7,
	MAX77686_RTC_MIN = 8,
	MAX77686_RTC_HOUR = 9,
	MAX77686_RTC_WEEKDAY = 10,
	MAX77686_RTC_MONTH = 11,
	MAX77686_RTC_YEAR = 12,
	MAX77686_RTC_DATE = 13,
	MAX77686_ALARM1_SEC = 14,
	MAX77686_ALARM1_MIN = 15,
	MAX77686_ALARM1_HOUR = 16,
	MAX77686_ALARM1_WEEKDAY = 17,
	MAX77686_ALARM1_MONTH = 18,
	MAX77686_ALARM1_YEAR = 19,
	MAX77686_ALARM1_DATE = 20,
	MAX77686_ALARM2_SEC = 21,
	MAX77686_ALARM2_MIN = 22,
	MAX77686_ALARM2_HOUR = 23,
	MAX77686_ALARM2_WEEKDAY = 24,
	MAX77686_ALARM2_MONTH = 25,
	MAX77686_ALARM2_YEAR = 26,
	MAX77686_ALARM2_DATE = 27,
};

enum max77686_irq {
	MAX77686_PMICIRQ_PWRONF = 0,
	MAX77686_PMICIRQ_PWRONR = 1,
	MAX77686_PMICIRQ_JIGONBF = 2,
	MAX77686_PMICIRQ_JIGONBR = 3,
	MAX77686_PMICIRQ_ACOKBF = 4,
	MAX77686_PMICIRQ_ACOKBR = 5,
	MAX77686_PMICIRQ_ONKEY1S = 6,
	MAX77686_PMICIRQ_MRSTB = 7,
	MAX77686_PMICIRQ_140C = 8,
	MAX77686_PMICIRQ_120C = 9,
	MAX77686_RTCIRQ_RTC60S = 0,
	MAX77686_RTCIRQ_RTCA1 = 1,
	MAX77686_RTCIRQ_RTCA2 = 2,
	MAX77686_RTCIRQ_SMPL = 3,
	MAX77686_RTCIRQ_RTC1S = 4,
	MAX77686_RTCIRQ_WTSR = 5,
};

enum {
	RTC_SEC = 0,
	RTC_MIN = 1,
	RTC_HOUR = 2,
	RTC_WEEKDAY = 3,
	RTC_MONTH = 4,
	RTC_YEAR = 5,
	RTC_DATE = 6,
	RTC_NR_TIME = 7,
};

struct max77686_rtc_driver_data {
	long unsigned int delay;
	u8 mask;
	const unsigned int *map;
	bool alarm_enable_reg;
	int rtc_i2c_addr;
	bool rtc_irq_from_platform;
	int alarm_pending_status_reg;
	const struct regmap_irq_chip *rtc_irq_chip;
	const struct regmap_config *regmap_config;
};

struct max77686_rtc_info {
	struct device *dev;
	struct i2c_client *rtc;
	struct rtc_device *rtc_dev;
	struct mutex lock;
	struct regmap *regmap;
	struct regmap *rtc_regmap;
	const struct max77686_rtc_driver_data *drv_data;
	struct regmap_irq_chip_data *rtc_irq_data;
	int rtc_irq;
	int virq;
	int rtc_24hr_mode;
};

enum MAX77686_RTC_OP {
	MAX77686_RTC_WRITE = 0,
	MAX77686_RTC_READ = 1,
};

enum max77686_rtc_reg_offset {
	REG_RTC_CONTROLM = 0,
	REG_RTC_CONTROL = 1,
	REG_RTC_UPDATE0 = 2,
	REG_WTSR_SMPL_CNTL = 3,
	REG_RTC_SEC = 4,
	REG_RTC_MIN = 5,
	REG_RTC_HOUR = 6,
	REG_RTC_WEEKDAY = 7,
	REG_RTC_MONTH = 8,
	REG_RTC_YEAR = 9,
	REG_RTC_DATE = 10,
	REG_ALARM1_SEC = 11,
	REG_ALARM1_MIN = 12,
	REG_ALARM1_HOUR = 13,
	REG_ALARM1_WEEKDAY = 14,
	REG_ALARM1_MONTH = 15,
	REG_ALARM1_YEAR = 16,
	REG_ALARM1_DATE = 17,
	REG_ALARM2_SEC = 18,
	REG_ALARM2_MIN = 19,
	REG_ALARM2_HOUR = 20,
	REG_ALARM2_WEEKDAY = 21,
	REG_ALARM2_MONTH = 22,
	REG_ALARM2_YEAR = 23,
	REG_ALARM2_DATE = 24,
	REG_RTC_AE1 = 25,
	REG_RTC_END = 26,
};

enum {
	MAX8907_IRQ_VCHG_DC_OVP = 0,
	MAX8907_IRQ_VCHG_DC_F = 1,
	MAX8907_IRQ_VCHG_DC_R = 2,
	MAX8907_IRQ_VCHG_THM_OK_R = 3,
	MAX8907_IRQ_VCHG_THM_OK_F = 4,
	MAX8907_IRQ_VCHG_MBATTLOW_F = 5,
	MAX8907_IRQ_VCHG_MBATTLOW_R = 6,
	MAX8907_IRQ_VCHG_RST = 7,
	MAX8907_IRQ_VCHG_DONE = 8,
	MAX8907_IRQ_VCHG_TOPOFF = 9,
	MAX8907_IRQ_VCHG_TMR_FAULT = 10,
	MAX8907_IRQ_GPM_RSTIN = 0,
	MAX8907_IRQ_GPM_MPL = 1,
	MAX8907_IRQ_GPM_SW_3SEC = 2,
	MAX8907_IRQ_GPM_EXTON_F = 3,
	MAX8907_IRQ_GPM_EXTON_R = 4,
	MAX8907_IRQ_GPM_SW_1SEC = 5,
	MAX8907_IRQ_GPM_SW_F = 6,
	MAX8907_IRQ_GPM_SW_R = 7,
	MAX8907_IRQ_GPM_SYSCKEN_F = 8,
	MAX8907_IRQ_GPM_SYSCKEN_R = 9,
	MAX8907_IRQ_RTC_ALARM1 = 0,
	MAX8907_IRQ_RTC_ALARM0 = 1,
};

enum {
	RTC_SEC___2 = 0,
	RTC_MIN___2 = 1,
	RTC_HOUR___2 = 2,
	RTC_WEEKDAY___2 = 3,
	RTC_DATE___2 = 4,
	RTC_MONTH___2 = 5,
	RTC_YEAR1 = 6,
	RTC_YEAR2 = 7,
};

struct max8907_rtc {
	struct max8907 *max8907;
	struct regmap *regmap;
	struct rtc_device *rtc_dev;
	int irq;
};

struct rtc_plat_data {
	struct rtc_device *rtc;
	void *ioaddr;
	int irq;
	struct clk *clk;
};

struct palmas_rtc {
	struct rtc_device *rtc;
	struct device *dev;
	unsigned int irq;
};

struct pl031_vendor_data {
	struct rtc_class_ops ops;
	bool clockwatch;
	bool st_weekday;
	long unsigned int irqflags;
	int: 32;
	time64_t range_min;
	timeu64_t range_max;
};

struct pl031_local {
	struct pl031_vendor_data *vendor;
	struct rtc_device *rtc;
	void *base;
};

struct spear_rtc_config {
	struct rtc_device *rtc;
	struct clk *clk;
	spinlock_t lock;
	void *ioaddr;
	unsigned int irq_wake;
};

struct st_rtc {
	struct rtc_device *rtc_dev;
	struct rtc_wkalrm alarm;
	struct clk *clk;
	long unsigned int clkrate;
	void *ioaddr;
	bool irq_enabled: 1;
	spinlock_t lock;
	short int irq;
};

struct stm32_rtc_registers {
	u16 tr;
	u16 dr;
	u16 cr;
	u16 isr;
	u16 prer;
	u16 alrmar;
	u16 wpr;
	u16 sr;
	u16 scr;
	u16 verr;
};

struct stm32_rtc_events {
	u32 alra;
};

struct stm32_rtc;

struct stm32_rtc_data {
	const struct stm32_rtc_registers regs;
	const struct stm32_rtc_events events;
	void (*clear_events)(struct stm32_rtc *, unsigned int);
	bool has_pclk;
	bool need_dbp;
	bool has_wakeirq;
};

struct stm32_rtc {
	struct rtc_device *rtc_dev;
	void *base;
	struct regmap *dbp;
	unsigned int dbp_reg;
	unsigned int dbp_mask;
	struct clk *pclk;
	struct clk *rtc_ck;
	const struct stm32_rtc_data *data;
	int irq_alarm;
	int wakeirq_alarm;
};

struct sun6i_rtc_clk_data {
	long unsigned int rc_osc_rate;
	unsigned int fixed_prescaler: 16;
	unsigned int has_prescaler: 1;
	unsigned int has_out_clk: 1;
	unsigned int export_iosc: 1;
	unsigned int has_losc_en: 1;
	unsigned int has_auto_swt: 1;
};

struct sun6i_rtc_dev {
	struct rtc_device *rtc;
	const struct sun6i_rtc_clk_data *data;
	void *base;
	int irq;
	long unsigned int alarm;
	struct clk_hw hw;
	struct clk_hw *int_osc;
	struct clk *losc;
	struct clk *ext_losc;
	spinlock_t lock;
};

struct sunxi_rtc_data_year {
	unsigned int min;
	unsigned int max;
	unsigned int mask;
	unsigned char leap_shift;
};

struct sunxi_rtc_dev {
	struct rtc_device *rtc;
	struct device *dev;
	const struct sunxi_rtc_data_year *data_year;
	void *base;
	int irq;
};

struct tegra_rtc_info {
	struct platform_device *pdev;
	struct rtc_device *rtc;
	void *base;
	struct clk *clk;
	int irq;
	spinlock_t lock;
};

struct tps6586x_rtc {
	struct device *dev;
	struct rtc_device *rtc;
	int irq;
	bool irq_en;
};

struct tps65910_rtc {
	struct rtc_device *rtc;
	int irq;
};

enum twl_class {
	TWL_4030 = 0,
	TWL_6030 = 1,
};

enum {
	REG_SECONDS_REG = 0,
	REG_MINUTES_REG = 1,
	REG_HOURS_REG = 2,
	REG_DAYS_REG = 3,
	REG_MONTHS_REG = 4,
	REG_YEARS_REG = 5,
	REG_WEEKS_REG = 6,
	REG_ALARM_SECONDS_REG = 7,
	REG_ALARM_MINUTES_REG = 8,
	REG_ALARM_HOURS_REG = 9,
	REG_ALARM_DAYS_REG = 10,
	REG_ALARM_MONTHS_REG = 11,
	REG_ALARM_YEARS_REG = 12,
	REG_RTC_CTRL_REG = 13,
	REG_RTC_STATUS_REG = 14,
	REG_RTC_INTERRUPTS_REG = 15,
	REG_RTC_COMP_LSB_REG = 16,
	REG_RTC_COMP_MSB_REG = 17,
};

struct twl_rtc {
	struct device *dev;
	struct rtc_device *rtc;
	u8 *reg_map;
	unsigned char rtc_irq_bits;
	bool wake_enabled;
	unsigned char irqstat;
	enum twl_class class;
};

struct vt8500_rtc {
	void *regbase;
	int irq_alarm;
	struct rtc_device *rtc;
	spinlock_t lock;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
};

struct trace_event_data_offsets_i2c_result {};

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

struct i2c_dummy_devres {
	struct i2c_client *client;
};

struct class_compat___2;

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_smbus_alert_setup {
	int irq;
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

struct i2c_smbus_alert {
	struct work_struct alert;
	struct i2c_client *ara;
};

struct alert_data {
	short unsigned int addr;
	enum i2c_alert_protocol type;
	unsigned int data;
};

struct i2c_slave_host_notify_status {
	u8 index;
	u8 addr;
};

struct i2c_smbus_ioctl_data {
	__u8 read_write;
	__u8 command;
	__u32 size;
	union i2c_smbus_data *data;
};

struct i2c_rdwr_ioctl_data {
	struct i2c_msg *msgs;
	__u32 nmsgs;
};

struct i2c_dev {
	struct list_head list;
	struct i2c_adapter *adap;
	int: 32;
	struct device dev;
	struct cdev cdev;
	int: 32;
};

struct i2c_mux_core {
	struct i2c_adapter *parent;
	struct device *dev;
	unsigned int mux_locked: 1;
	unsigned int arbitrator: 1;
	unsigned int gate: 1;
	void *priv;
	int (*select)(struct i2c_mux_core *, u32);
	int (*deselect)(struct i2c_mux_core *, u32);
	int num_adapters;
	int max_adapters;
	struct i2c_adapter *adapter[0];
};

struct i2c_mux_priv {
	struct i2c_adapter adap;
	struct i2c_algorithm algo;
	struct i2c_mux_core *muxc;
	u32 chan_id;
	int: 32;
};

struct bcm2835_i2c_dev {
	struct device *dev;
	void *regs;
	int irq;
	int: 32;
	struct i2c_adapter adapter;
	struct completion completion;
	struct i2c_msg *curr_msg;
	struct clk *bus_clk;
	int num_msgs;
	u32 msg_err;
	u8 *msg_buf;
	size_t msg_buf_remaining;
};

struct clk_bcm2835_i2c {
	struct clk_hw hw;
	struct bcm2835_i2c_dev *i2c_dev;
};

enum i2c_slave_read_status {
	I2C_SLAVE_RX_FIFO_EMPTY = 0,
	I2C_SLAVE_RX_START = 1,
	I2C_SLAVE_RX_DATA = 2,
	I2C_SLAVE_RX_END = 3,
};

enum bcm_iproc_i2c_type {
	IPROC_I2C = 0,
	IPROC_I2C_NIC = 1,
};

struct bcm_iproc_i2c_dev {
	struct device *device;
	enum bcm_iproc_i2c_type type;
	int irq;
	void *base;
	void *idm_base;
	u32 ape_addr_mask;
	spinlock_t idm_lock;
	int: 32;
	struct i2c_adapter adapter;
	unsigned int bus_speed;
	struct completion done;
	int xfer_is_done;
	struct i2c_msg *msg;
	struct i2c_client *slave;
	unsigned int tx_bytes;
	unsigned int rx_bytes;
	unsigned int thld_bytes;
	int: 32;
};

enum cdns_i2c_mode {
	CDNS_I2C_MODE_SLAVE = 0,
	CDNS_I2C_MODE_MASTER = 1,
};

enum cdns_i2c_slave_state {
	CDNS_I2C_SLAVE_STATE_IDLE = 0,
	CDNS_I2C_SLAVE_STATE_SEND = 1,
	CDNS_I2C_SLAVE_STATE_RECV = 2,
};

struct cdns_i2c {
	struct device *dev;
	void *membase;
	struct i2c_adapter adap;
	struct i2c_msg *p_msg;
	int err_status;
	struct completion xfer_done;
	unsigned char *p_send_buf;
	unsigned char *p_recv_buf;
	unsigned int send_count;
	unsigned int recv_count;
	unsigned int curr_recv_count;
	int irq;
	long unsigned int input_clk;
	unsigned int i2c_clk;
	unsigned int bus_hold_flag;
	struct clk *clk;
	struct notifier_block clk_rate_change_nb;
	u32 quirks;
	u16 ctrl_reg_diva_divb;
	struct i2c_client *slave;
	enum cdns_i2c_mode dev_mode;
	enum cdns_i2c_slave_state slave_state;
};

struct davinci_i2c_platform_data {
	unsigned int bus_freq;
	unsigned int bus_delay;
	bool gpio_recovery;
	bool has_pfunc;
};

struct davinci_i2c_dev {
	struct device *dev;
	void *base;
	struct completion cmd_complete;
	struct clk *clk;
	int cmd_err;
	u8 *buf;
	size_t buf_len;
	int irq;
	int stop;
	u8 terminate;
	int: 24;
	int: 32;
	struct i2c_adapter adapter;
	struct notifier_block freq_transition;
	struct davinci_i2c_platform_data *pdata;
};

struct dw_i2c_dev {
	struct device *dev;
	struct regmap *map;
	struct regmap *sysmap;
	void *base;
	void *ext;
	struct completion cmd_complete;
	struct clk *clk;
	struct clk *pclk;
	struct reset_control *rst;
	struct i2c_client *slave;
	u32 (*get_clk_rate_khz)(struct dw_i2c_dev *);
	int cmd_err;
	struct i2c_msg *msgs;
	int msgs_num;
	int msg_write_idx;
	u32 tx_buf_len;
	u8 *tx_buf;
	int msg_read_idx;
	u32 rx_buf_len;
	u8 *rx_buf;
	int msg_err;
	unsigned int status;
	u32 abort_source;
	int irq;
	u32 flags;
	struct i2c_adapter adapter;
	u32 functionality;
	u32 master_cfg;
	u32 slave_cfg;
	unsigned int tx_fifo_depth;
	unsigned int rx_fifo_depth;
	int rx_outstanding;
	struct i2c_timings timings;
	u32 sda_hold_time;
	u16 ss_hcnt;
	u16 ss_lcnt;
	u16 fs_hcnt;
	u16 fs_lcnt;
	u16 fp_hcnt;
	u16 fp_lcnt;
	u16 hs_hcnt;
	u16 hs_lcnt;
	int (*acquire_lock)();
	void (*release_lock)();
	bool shared_with_punit;
	void (*disable)(struct dw_i2c_dev *);
	void (*disable_int)(struct dw_i2c_dev *);
	int (*init)(struct dw_i2c_dev *);
	int (*set_sda_hold_time)(struct dw_i2c_dev *);
	int mode;
	struct i2c_bus_recovery_info rinfo;
	bool suspended;
	int: 24;
	int: 32;
};

struct dw_i2c_platform_data {
	unsigned int i2c_scl_freq;
};

enum i2c_type_exynos {
	I2C_TYPE_EXYNOS5 = 0,
	I2C_TYPE_EXYNOS7 = 1,
};

struct exynos_hsi2c_variant;

struct exynos5_i2c {
	struct i2c_adapter adap;
	struct i2c_msg *msg;
	struct completion msg_complete;
	unsigned int msg_ptr;
	unsigned int irq;
	void *regs;
	struct clk *clk;
	struct device *dev;
	int state;
	spinlock_t lock;
	int trans_done;
	unsigned int op_clock;
	const struct exynos_hsi2c_variant *variant;
	int: 32;
};

struct exynos_hsi2c_variant {
	unsigned int fifo_depth;
	enum i2c_type_exynos hw;
};

struct imxi2c_platform_data {
	u32 bitrate;
};

struct imx_i2c_clk_pair {
	u16 div;
	u16 val;
};

enum imx_i2c_type {
	IMX1_I2C = 0,
	IMX21_I2C = 1,
	VF610_I2C = 2,
};

struct imx_i2c_hwdata {
	enum imx_i2c_type devtype;
	unsigned int regshift;
	struct imx_i2c_clk_pair *clk_div;
	unsigned int ndivs;
	unsigned int i2sr_clr_opcode;
	unsigned int i2cr_ien_opcode;
};

struct imx_i2c_dma {
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_using;
	struct completion cmd_complete;
	dma_addr_t dma_buf;
	unsigned int dma_len;
	enum dma_transfer_direction dma_transfer_dir;
	enum dma_data_direction dma_data_dir;
};

struct imx_i2c_struct {
	struct i2c_adapter adapter;
	struct clk *clk;
	struct notifier_block clk_change_nb;
	void *base;
	wait_queue_head_t queue;
	long unsigned int i2csr;
	unsigned int disable_delay;
	int stopped;
	unsigned int ifdr;
	unsigned int cur_clk;
	unsigned int bitrate;
	const struct imx_i2c_hwdata *hwdata;
	struct i2c_bus_recovery_info rinfo;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_pins_default;
	struct pinctrl_state *pinctrl_pins_gpio;
	struct imx_i2c_dma *dma;
	struct i2c_client *slave;
	int: 32;
};

enum {
	TOKEN_END = 0,
	TOKEN_START = 1,
	TOKEN_SLAVE_ADDR_WRITE = 2,
	TOKEN_SLAVE_ADDR_READ = 3,
	TOKEN_DATA = 4,
	TOKEN_DATA_LAST = 5,
	TOKEN_STOP = 6,
};

enum {
	STATE_IDLE = 0,
	STATE_READ = 1,
	STATE_WRITE = 2,
};

struct meson_i2c_data {
	unsigned char div_factor;
};

struct meson_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	void *regs;
	struct clk *clk;
	struct i2c_msg *msg;
	int state;
	bool last;
	int count;
	int pos;
	int error;
	spinlock_t lock;
	struct completion done;
	u32 tokens[2];
	int num_tokens;
	const struct meson_i2c_data *data;
};

struct mv64xxx_i2c_pdata {
	u32 freq_m;
	u32 freq_n;
	u32 timeout;
};

enum {
	MV64XXX_I2C_STATE_INVALID = 0,
	MV64XXX_I2C_STATE_IDLE = 1,
	MV64XXX_I2C_STATE_WAITING_FOR_START_COND = 2,
	MV64XXX_I2C_STATE_WAITING_FOR_RESTART = 3,
	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK = 4,
	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK = 5,
	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK = 6,
	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA = 7,
};

enum {
	MV64XXX_I2C_ACTION_INVALID = 0,
	MV64XXX_I2C_ACTION_CONTINUE = 1,
	MV64XXX_I2C_ACTION_SEND_RESTART = 2,
	MV64XXX_I2C_ACTION_SEND_ADDR_1 = 3,
	MV64XXX_I2C_ACTION_SEND_ADDR_2 = 4,
	MV64XXX_I2C_ACTION_SEND_DATA = 5,
	MV64XXX_I2C_ACTION_RCV_DATA = 6,
	MV64XXX_I2C_ACTION_RCV_DATA_STOP = 7,
	MV64XXX_I2C_ACTION_SEND_STOP = 8,
};

struct mv64xxx_i2c_regs {
	u8 addr;
	u8 ext_addr;
	u8 data;
	u8 control;
	u8 status;
	u8 clock;
	u8 soft_reset;
};

struct mv64xxx_i2c_data {
	struct i2c_msg *msgs;
	int num_msgs;
	int irq;
	u32 state;
	u32 action;
	u32 aborting;
	u32 cntl_bits;
	void *reg_base;
	struct mv64xxx_i2c_regs reg_offsets;
	u32 addr1;
	u32 addr2;
	u32 bytes_left;
	u32 byte_posn;
	u32 send_stop;
	u32 block;
	int rc;
	u32 freq_m;
	u32 freq_n;
	struct clk *clk;
	struct clk *reg_clk;
	wait_queue_head_t waitq;
	spinlock_t lock;
	struct i2c_msg *msg;
	struct i2c_adapter adapter;
	bool offload_enabled;
	bool errata_delay;
	struct reset_control *rstc;
	bool irq_clear_inverted;
	bool clk_n_base_0;
	struct i2c_bus_recovery_info rinfo;
};

enum i2c_freq_mode {
	I2C_FREQ_MODE_STANDARD = 0,
	I2C_FREQ_MODE_FAST = 1,
	I2C_FREQ_MODE_HIGH_SPEED = 2,
	I2C_FREQ_MODE_FAST_PLUS = 3,
};

struct i2c_vendor_data {
	bool has_mtdws;
	u32 fifodepth;
};

enum i2c_status {
	I2C_NOP = 0,
	I2C_ON_GOING = 1,
	I2C_OK = 2,
	I2C_ABORT = 3,
};

enum i2c_operation {
	I2C_NO_OPERATION = 255,
	I2C_WRITE = 0,
	I2C_READ = 1,
};

struct i2c_nmk_client {
	short unsigned int slave_adr;
	long unsigned int count;
	unsigned char *buffer;
	long unsigned int xfer_bytes;
	enum i2c_operation operation;
};

struct nmk_i2c_dev {
	struct i2c_vendor_data *vendor;
	struct amba_device *adev;
	struct i2c_adapter adap;
	int irq;
	void *virtbase;
	struct clk *clk;
	struct i2c_nmk_client cli;
	u32 clk_freq;
	unsigned char tft;
	unsigned char rft;
	int timeout;
	enum i2c_freq_mode sm;
	int stop;
	struct completion xfer_complete;
	int result;
};

struct omap_i2c_bus_platform_data {
	u32 clkrate;
	u32 rev;
	u32 flags;
	void (*set_mpu_wkup_lat)(struct device *, long int);
};

enum {
	OMAP_I2C_REV_REG = 0,
	OMAP_I2C_IE_REG = 1,
	OMAP_I2C_STAT_REG = 2,
	OMAP_I2C_IV_REG = 3,
	OMAP_I2C_WE_REG = 4,
	OMAP_I2C_SYSS_REG = 5,
	OMAP_I2C_BUF_REG = 6,
	OMAP_I2C_CNT_REG = 7,
	OMAP_I2C_DATA_REG = 8,
	OMAP_I2C_SYSC_REG = 9,
	OMAP_I2C_CON_REG = 10,
	OMAP_I2C_OA_REG = 11,
	OMAP_I2C_SA_REG = 12,
	OMAP_I2C_PSC_REG = 13,
	OMAP_I2C_SCLL_REG = 14,
	OMAP_I2C_SCLH_REG = 15,
	OMAP_I2C_SYSTEST_REG = 16,
	OMAP_I2C_BUFSTAT_REG = 17,
	OMAP_I2C_IP_V2_REVNB_LO = 18,
	OMAP_I2C_IP_V2_REVNB_HI = 19,
	OMAP_I2C_IP_V2_IRQSTATUS_RAW = 20,
	OMAP_I2C_IP_V2_IRQENABLE_SET = 21,
	OMAP_I2C_IP_V2_IRQENABLE_CLR = 22,
};

struct omap_i2c_dev {
	struct device *dev;
	void *base;
	int irq;
	int reg_shift;
	struct completion cmd_complete;
	struct resource *ioarea;
	u32 latency;
	void (*set_mpu_wkup_lat)(struct device *, long int);
	u32 speed;
	u32 flags;
	u16 scheme;
	u16 cmd_err;
	u8 *buf;
	u8 *regs;
	size_t buf_len;
	int: 32;
	struct i2c_adapter adapter;
	u8 threshold;
	u8 fifo_size;
	u32 rev;
	unsigned int b_hw: 1;
	unsigned int bb_valid: 1;
	unsigned int receiver: 1;
	u16 iestate;
	u16 pscstate;
	u16 scllstate;
	u16 sclhstate;
	u16 syscstate;
	u16 westate;
	u16 errata;
};

struct riic_dev {
	void *base;
	u8 *buf;
	struct i2c_msg *msg;
	int bytes_left;
	int err;
	int is_last;
	struct completion msg_done;
	struct i2c_adapter adapter;
	struct clk *clk;
	int: 32;
};

struct riic_irq_desc {
	int res_num;
	irq_handler_t isr;
	char *name;
};

enum {
	REG_CON_MOD_TX = 0,
	REG_CON_MOD_REGISTER_TX = 1,
	REG_CON_MOD_RX = 2,
	REG_CON_MOD_REGISTER_RX = 3,
};

struct i2c_spec_values {
	long unsigned int min_hold_start_ns;
	long unsigned int min_low_ns;
	long unsigned int min_high_ns;
	long unsigned int min_setup_start_ns;
	long unsigned int max_data_hold_ns;
	long unsigned int min_data_setup_ns;
	long unsigned int min_setup_stop_ns;
	long unsigned int min_hold_buffer_ns;
};

struct rk3x_i2c_calced_timings {
	long unsigned int div_low;
	long unsigned int div_high;
	unsigned int tuning;
};

enum rk3x_i2c_state {
	STATE_IDLE___2 = 0,
	STATE_START = 1,
	STATE_READ___2 = 2,
	STATE_WRITE___2 = 3,
	STATE_STOP = 4,
};

struct rk3x_i2c_soc_data {
	int grf_offset;
	int (*calc_timings)(long unsigned int, struct i2c_timings *, struct rk3x_i2c_calced_timings *);
};

struct rk3x_i2c {
	struct i2c_adapter adap;
	struct device *dev;
	const struct rk3x_i2c_soc_data *soc_data;
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_rate_nb;
	struct i2c_timings t;
	spinlock_t lock;
	wait_queue_head_t wait;
	bool busy;
	struct i2c_msg *msg;
	u8 addr;
	unsigned int mode;
	bool is_last_msg;
	enum rk3x_i2c_state state;
	unsigned int processed;
	int error;
};

struct s3c2410_platform_i2c {
	int bus_num;
	unsigned int flags;
	unsigned int slave_addr;
	long unsigned int frequency;
	unsigned int sda_delay;
	void (*cfg_gpio)(struct platform_device *);
};

enum s3c24xx_i2c_state {
	STATE_IDLE___3 = 0,
	STATE_START___2 = 1,
	STATE_READ___3 = 2,
	STATE_WRITE___3 = 3,
	STATE_STOP___2 = 4,
};

struct s3c24xx_i2c {
	wait_queue_head_t wait;
	kernel_ulong_t quirks;
	struct i2c_msg *msg;
	unsigned int msg_num;
	unsigned int msg_idx;
	unsigned int msg_ptr;
	unsigned int tx_setup;
	unsigned int irq;
	enum s3c24xx_i2c_state state;
	long unsigned int clkrate;
	void *regs;
	struct clk *clk;
	struct device *dev;
	int: 32;
	struct i2c_adapter adap;
	struct s3c2410_platform_i2c *pdata;
	struct gpio_desc *gpios[2];
	struct pinctrl *pctrl;
	struct regmap *sysreg;
	unsigned int sys_i2c_cfg;
};

typedef u8 u_int8_t;

typedef u16 u_int16_t;

enum sh_mobile_i2c_op {
	OP_START = 0,
	OP_TX_FIRST = 1,
	OP_TX = 2,
	OP_TX_STOP = 3,
	OP_TX_TO_RX = 4,
	OP_RX = 5,
	OP_RX_STOP = 6,
	OP_RX_STOP_DATA = 7,
};

struct sh_mobile_i2c_data {
	struct device *dev;
	void *reg;
	struct i2c_adapter adap;
	long unsigned int bus_speed;
	unsigned int clks_per_count;
	struct clk *clk;
	u_int8_t icic;
	u_int8_t flags;
	u_int16_t iccl;
	u_int16_t icch;
	spinlock_t lock;
	wait_queue_head_t wait;
	struct i2c_msg *msg;
	int pos;
	int sr;
	bool send_stop;
	bool stop_after_dma;
	bool atomic_xfer;
	struct resource *res;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	struct scatterlist sg;
	enum dma_data_direction dma_direction;
	u8 *dma_buf;
	int: 32;
};

struct sh_mobile_dt_config {
	int clks_per_count;
	int (*setup)(struct sh_mobile_i2c_data *);
};

struct sirfsoc_i2c {
	void *base;
	struct clk *clk;
	u32 cmd_ptr;
	u8 *buf;
	u32 msg_len;
	u32 finished_len;
	u32 read_cmd_len;
	int msg_read;
	int err_status;
	u32 sda_delay;
	u32 clk_div;
	int last;
	struct completion done;
	struct i2c_adapter adapter;
};

enum st_i2c_mode {
	I2C_MODE_STANDARD = 0,
	I2C_MODE_FAST = 1,
	I2C_MODE_END = 2,
};

struct st_i2c_timings {
	u32 rate;
	u32 rep_start_hold;
	u32 rep_start_setup;
	u32 start_hold;
	u32 data_setup_time;
	u32 stop_setup_time;
	u32 bus_free_time;
	u32 sda_pulse_min_limit;
};

struct st_i2c_client {
	u8 addr;
	u32 count;
	u32 xfered;
	u8 *buf;
	int result;
	bool stop;
};

struct st_i2c_dev {
	struct i2c_adapter adap;
	struct device *dev;
	void *base;
	struct completion complete;
	int irq;
	struct clk *clk;
	int mode;
	u32 scl_min_width_us;
	u32 sda_min_width_us;
	struct st_i2c_client client;
	bool busy;
};

struct stm32_i2c_dma {
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_using;
	dma_addr_t dma_buf;
	unsigned int dma_len;
	enum dma_transfer_direction dma_transfer_dir;
	enum dma_data_direction dma_data_dir;
	struct completion dma_complete;
};

enum {
	STM32F7_SLAVE_HOSTNOTIFY = 0,
	STM32F7_SLAVE_7_10_BITS_ADDR = 1,
	STM32F7_SLAVE_7_BITS_ADDR = 2,
	STM32F7_I2C_MAX_SLAVE = 3,
};

struct stm32f7_i2c_regs {
	u32 cr1;
	u32 cr2;
	u32 oar1;
	u32 oar2;
	u32 tmgr;
};

struct stm32f7_i2c_spec {
	u32 rate;
	u32 fall_max;
	u32 rise_max;
	u32 hddat_min;
	u32 vddat_max;
	u32 sudat_min;
	u32 l_min;
	u32 h_min;
};

struct stm32f7_i2c_setup {
	u32 speed_freq;
	u32 clock_src;
	u32 rise_time;
	u32 fall_time;
	u8 dnf;
	bool analog_filter;
	u32 fmp_clr_offset;
};

struct stm32f7_i2c_timings {
	struct list_head node;
	u8 presc;
	u8 scldel;
	u8 sdadel;
	u8 sclh;
	u8 scll;
};

struct stm32f7_i2c_msg {
	u16 addr;
	u32 count;
	u8 *buf;
	int result;
	bool stop;
	bool smbus;
	int size;
	char read_write;
	int: 24;
	u8 smbus_buf[35];
};

struct stm32f7_i2c_dev {
	struct i2c_adapter adap;
	struct device *dev;
	void *base;
	struct completion complete;
	struct clk *clk;
	unsigned int bus_rate;
	struct i2c_msg *msg;
	unsigned int msg_num;
	unsigned int msg_id;
	struct stm32f7_i2c_msg f7_msg;
	struct stm32f7_i2c_setup setup;
	struct stm32f7_i2c_timings timing;
	struct i2c_client *slave[3];
	struct i2c_client *slave_running;
	struct stm32f7_i2c_regs backup_regs;
	u32 slave_dir;
	bool master_mode;
	struct stm32_i2c_dma *dma;
	bool use_dma;
	struct regmap *regmap;
	u32 fmp_sreg;
	u32 fmp_creg;
	u32 fmp_mask;
	bool wakeup_src;
	bool smbus_mode;
	struct i2c_client *host_notify_client;
};

struct p2wi {
	struct i2c_adapter adapter;
	struct completion complete;
	unsigned int status;
	void *regs;
	struct clk *clk;
	struct reset_control *rstc;
	int slave_addr;
	int: 32;
};

enum msg_end_type {
	MSG_END_STOP = 0,
	MSG_END_REPEAT_START = 1,
	MSG_END_CONTINUE = 2,
};

struct tegra_i2c_hw_feature {
	bool has_continue_xfer_support;
	bool has_per_pkt_xfer_complete_irq;
	bool has_config_load_reg;
	u32 clk_divisor_hs_mode;
	u32 clk_divisor_std_mode;
	u32 clk_divisor_fast_mode;
	u32 clk_divisor_fast_plus_mode;
	bool has_multi_master_mode;
	bool has_slcg_override_reg;
	bool has_mst_fifo;
	const struct i2c_adapter_quirks *quirks;
	bool supports_bus_clear;
	bool has_apb_dma;
	u32 tlow_std_mode;
	u32 thigh_std_mode;
	u32 tlow_fast_fastplus_mode;
	u32 thigh_fast_fastplus_mode;
	u32 setup_hold_time_std_mode;
	u32 setup_hold_time_fast_fast_plus_mode;
	u32 setup_hold_time_hs_mode;
	bool has_interface_timing_reg;
};

struct tegra_i2c_dev {
	struct device *dev;
	int: 32;
	struct i2c_adapter adapter;
	const struct tegra_i2c_hw_feature *hw;
	struct reset_control *rst;
	unsigned int cont_id;
	unsigned int irq;
	phys_addr_t base_phys;
	void *base;
	struct clk_bulk_data clocks[2];
	unsigned int nclocks;
	struct clk *div_clk;
	u32 bus_clk_rate;
	struct completion msg_complete;
	size_t msg_buf_remaining;
	int msg_err;
	u8 *msg_buf;
	struct completion dma_complete;
	struct dma_chan *tx_dma_chan;
	struct dma_chan *rx_dma_chan;
	unsigned int dma_buf_size;
	dma_addr_t dma_phys;
	void *dma_buf;
	bool multimaster_mode;
	bool atomic_mode;
	bool dma_mode;
	bool msg_read;
	bool is_dvc;
	bool is_vi;
	int: 16;
	int: 32;
};

struct uniphier_i2c_priv {
	struct completion comp;
	struct i2c_adapter adap;
	void *membase;
	struct clk *clk;
	unsigned int busy_cnt;
	unsigned int clk_cycle;
};

struct uniphier_fi2c_priv {
	struct completion comp;
	struct i2c_adapter adap;
	void *membase;
	struct clk *clk;
	unsigned int len;
	u8 *buf;
	u32 enabled_irqs;
	int error;
	unsigned int flags;
	unsigned int busy_cnt;
	unsigned int clk_cycle;
	spinlock_t lock;
};

struct xiic_i2c_platform_data {
	u8 num_devices;
	const struct i2c_board_info *devices;
};

enum xilinx_i2c_state {
	STATE_DONE = 0,
	STATE_ERROR = 1,
	STATE_START___3 = 2,
};

enum xiic_endian {
	LITTLE = 0,
	BIG = 1,
};

struct xiic_i2c {
	struct device *dev;
	void *base;
	wait_queue_head_t wait;
	int: 32;
	struct i2c_adapter adap;
	struct i2c_msg *tx_msg;
	struct mutex lock;
	unsigned int tx_pos;
	unsigned int nmsgs;
	struct i2c_msg *rx_msg;
	int rx_pos;
	enum xiic_endian endianness;
	struct clk *clk;
	enum xilinx_i2c_state state;
	bool singlemaster;
};

enum rcar_i2c_type {
	I2C_RCAR_GEN1 = 0,
	I2C_RCAR_GEN2 = 1,
	I2C_RCAR_GEN3 = 2,
};

struct rcar_i2c_priv {
	void *io;
	int: 32;
	struct i2c_adapter adap;
	struct i2c_msg *msg;
	int msgs_left;
	struct clk *clk;
	wait_queue_head_t wait;
	int pos;
	u32 icccr;
	u32 flags;
	u8 recovery_icmcr;
	enum rcar_i2c_type devtype;
	struct i2c_client *slave;
	struct resource *res;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	struct scatterlist sg;
	enum dma_data_direction dma_direction;
	struct reset_control *rstc;
	int irq;
	struct i2c_client *host_notify_client;
};

enum bcm_kona_cmd_t {
	BCM_CMD_NOACTION = 0,
	BCM_CMD_START = 1,
	BCM_CMD_RESTART = 2,
	BCM_CMD_STOP = 3,
};

enum bus_speed_index {
	BCM_SPD_100K = 0,
	BCM_SPD_400K = 1,
	BCM_SPD_1MHZ = 2,
};

enum hs_bus_speed_index {
	BCM_SPD_3P4MHZ = 0,
};

struct bus_speed_cfg {
	uint8_t time_m;
	uint8_t time_n;
	uint8_t prescale;
	uint8_t time_p;
	uint8_t no_div;
	uint8_t time_div;
};

struct hs_bus_speed_cfg {
	uint8_t hs_hold;
	uint8_t hs_high_phase;
	uint8_t hs_setup;
	uint8_t prescale;
	uint8_t time_p;
	uint8_t no_div;
	uint8_t time_div;
};

struct bcm_kona_i2c_dev {
	struct device *device;
	void *base;
	int irq;
	struct clk *external_clk;
	struct i2c_adapter adapter;
	struct completion done;
	const struct bus_speed_cfg *std_cfg;
	const struct hs_bus_speed_cfg *hs_cfg;
};

struct bsc_regs {
	u32 chip_address;
	u32 data_in[8];
	u32 cnt_reg;
	u32 ctl_reg;
	u32 iic_enable;
	u32 data_out[8];
	u32 ctlhi_reg;
	u32 scl_param;
};

struct bsc_clk_param {
	u32 hz;
	u32 scl_mask;
	u32 div_mask;
};

enum bsc_xfer_cmd {
	CMD_WR = 0,
	CMD_RD = 1,
	CMD_WR_NOACK = 2,
	CMD_RD_NOACK = 3,
};

enum bus_speeds {
	SPD_375K = 0,
	SPD_390K = 1,
	SPD_187K = 2,
	SPD_200K = 3,
	SPD_93K = 4,
	SPD_97K = 5,
	SPD_46K = 6,
	SPD_50K = 7,
};

struct brcmstb_i2c_dev {
	struct device *device;
	void *base;
	int irq;
	struct bsc_regs *bsc_regmap;
	struct i2c_adapter adapter;
	struct completion done;
	u32 clk_freq_hz;
	int data_regsz;
};

struct of_changeset {
	struct list_head entries;
};

struct i2c_demux_pinctrl_chan {
	struct device_node *parent_np;
	struct i2c_adapter *parent_adap;
	struct of_changeset chgset;
};

struct i2c_demux_pinctrl_priv {
	int cur_chan;
	int num_chan;
	struct device *dev;
	const char *bus_name;
	struct i2c_adapter cur_adap;
	struct i2c_algorithm algo;
	struct i2c_demux_pinctrl_chan chan[0];
	int: 32;
};

enum pca_type {
	pca_9540 = 0,
	pca_9542 = 1,
	pca_9543 = 2,
	pca_9544 = 3,
	pca_9545 = 4,
	pca_9546 = 5,
	pca_9547 = 6,
	pca_9548 = 7,
	pca_9846 = 8,
	pca_9847 = 9,
	pca_9848 = 10,
	pca_9849 = 11,
};

enum muxtype {
	pca954x_ismux = 0,
	pca954x_isswi = 1,
};

struct chip_desc___2 {
	u8 nchans;
	u8 enable;
	u8 has_irq;
	enum muxtype muxtype;
	struct i2c_device_identity id;
};

struct pca954x {
	const struct chip_desc___2 *chip;
	u8 last_chan;
	s32 idle_state;
	struct i2c_client *client;
	struct irq_domain *irq;
	unsigned int irq_mask;
	raw_spinlock_t lock;
};

struct i2c_mux_pinctrl {
	struct pinctrl *pinctrl;
	struct pinctrl_state *states[0];
};

struct eeprom_data {
	struct bin_attribute bin;
	spinlock_t buffer_lock;
	u16 buffer_idx;
	u16 address_mask;
	u8 num_address_bytes;
	u8 idx_write_cnt;
	bool read_only;
	u8 buffer[0];
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	int: 32;
};

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct cdev cdev;
	struct device *dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
	int: 32;
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
	int: 32;
};

struct ptp_clock___2 {
	struct posix_clock clock;
	int: 32;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	int: 32;
	struct timestamp_event_queue tsevq;
	struct mutex tsevq_mux;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int rsv[12];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

struct ptp_dte {
	void *regs;
	struct ptp_clock *ptp_clk;
	struct ptp_clock_info caps;
	struct device *dev;
	u32 ts_ovf_last;
	u32 ts_wrap_cnt;
	spinlock_t lock;
	u32 reg_val[4];
};

struct as3722_poweroff {
	struct device *dev;
	struct as3722 *as3722;
};

enum wakeup_type {
	AT91_SHDW_WKMODE0_NONE = 0,
	AT91_SHDW_WKMODE0_HIGH = 1,
	AT91_SHDW_WKMODE0_LOW = 2,
	AT91_SHDW_WKMODE0_ANYLEVEL = 3,
};

struct shdwc {
	struct clk *sclk;
	void *shdwc_base;
	void *mpddrc_base;
};

enum reset_type {
	RESET_TYPE_GENERAL = 0,
	RESET_TYPE_WAKEUP = 1,
	RESET_TYPE_WATCHDOG = 2,
	RESET_TYPE_SOFTWARE = 3,
	RESET_TYPE_USER = 4,
	RESET_TYPE_CPU_FAIL = 6,
	RESET_TYPE_XTAL_FAIL = 7,
	RESET_TYPE_ULP2 = 8,
};

struct at91_reset {
	void *rstc_base;
	void *ramc_base[2];
	struct clk *sclk;
	struct notifier_block nb;
	u32 args;
	u32 ramc_lpr;
};

struct shdwc_reg_config {
	u8 wkup_pin_input;
	u8 mr_rtcwk_shift;
	u8 mr_rttwk_shift;
	u8 sr_rtcwk_shift;
	u8 sr_rttwk_shift;
};

struct pmc_reg_config {
	u8 mckr;
};

struct reg_config {
	struct shdwc_reg_config shdwc;
	struct pmc_reg_config pmc;
};

struct shdwc___2 {
	const struct reg_config *rcfg;
	struct clk *sclk;
	void *shdwc_base;
	void *mpddrc_base;
	void *pmc_base;
};

struct reset_reg_mask {
	u32 rst_src_en_mask;
	u32 sw_mstr_rst_mask;
};

struct gpio_restart {
	struct gpio_desc *reset_gpio;
	struct notifier_block restart_handler;
	u32 active_delay_ms;
	u32 inactive_delay_ms;
	u32 wait_delay_ms;
};

struct reset_syscfg {
	struct regmap *regmap;
	unsigned int offset_rst;
	unsigned int mask_rst;
	unsigned int offset_rst_msk;
	unsigned int mask_rst_msk;
};

enum vexpress_reset_func {
	FUNC_RESET = 0,
	FUNC_SHUTDOWN = 1,
	FUNC_REBOOT = 2,
};

struct syscon_reboot_context {
	struct regmap *map;
	u32 offset;
	u32 value;
	u32 mask;
	struct notifier_block restart_handler;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_battery_info {
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	int factory_internal_resistance_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

struct act8945a_charger {
	struct power_supply *psy;
	struct power_supply_desc desc;
	struct regmap *regmap;
	struct work_struct work;
	bool init_done;
	struct gpio_desc *lbo_gpio;
	struct gpio_desc *chglev_gpio;
};

struct sbs_platform_data {
	u32 i2c_retry_count;
	u32 poll_retry_count;
};

enum {
	REG_MANUFACTURER_DATA = 0,
	REG_BATTERY_MODE = 1,
	REG_TEMPERATURE = 2,
	REG_VOLTAGE = 3,
	REG_CURRENT_NOW = 4,
	REG_CURRENT_AVG = 5,
	REG_MAX_ERR = 6,
	REG_CAPACITY = 7,
	REG_TIME_TO_EMPTY = 8,
	REG_TIME_TO_FULL = 9,
	REG_STATUS = 10,
	REG_CAPACITY_LEVEL = 11,
	REG_CYCLE_COUNT = 12,
	REG_SERIAL_NUMBER = 13,
	REG_REMAINING_CAPACITY = 14,
	REG_REMAINING_CAPACITY_CHARGE = 15,
	REG_FULL_CHARGE_CAPACITY = 16,
	REG_FULL_CHARGE_CAPACITY_CHARGE = 17,
	REG_DESIGN_CAPACITY = 18,
	REG_DESIGN_CAPACITY_CHARGE = 19,
	REG_DESIGN_VOLTAGE_MIN = 20,
	REG_DESIGN_VOLTAGE_MAX = 21,
	REG_CHEMISTRY = 22,
	REG_MANUFACTURER = 23,
	REG_MODEL_NAME = 24,
	REG_CHARGE_CURRENT = 25,
	REG_CHARGE_VOLTAGE = 26,
};

enum sbs_capacity_mode {
	CAPACITY_MODE_AMPS = 0,
	CAPACITY_MODE_WATTS = 32768,
};

struct chip_data___2 {
	enum power_supply_property psp;
	u8 addr;
	int min_value;
	int max_value;
};

struct sbs_info {
	struct i2c_client *client;
	struct power_supply *power_supply;
	bool is_present;
	struct gpio_desc *gpio_detect;
	bool charger_broadcasts;
	int last_state;
	int poll_time;
	u32 i2c_retry_count;
	u32 poll_retry_count;
	struct delayed_work work;
	struct mutex mode_lock;
	u32 flags;
};

struct tps65090_charger {
	struct device *dev;
	int ac_online;
	int prev_ac_online;
	int irq;
	struct task_struct *poll_task;
	bool passive_mode;
	struct power_supply *ac;
	struct tps65090_platform_data *pdata;
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

struct hwmon_device {
	const char *name;
	int: 32;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
	int: 32;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

enum chips___2 {
	lm90 = 0,
	adm1032 = 1,
	lm99 = 2,
	lm86 = 3,
	max6657 = 4,
	max6659 = 5,
	adt7461 = 6,
	max6680 = 7,
	max6646 = 8,
	w83l771 = 9,
	max6696 = 10,
	sa56004 = 11,
	g781 = 12,
	tmp451 = 13,
	max6654 = 14,
};

struct lm90_params {
	u32 flags;
	u16 alert_alarms;
	u8 max_convrate;
	u8 reg_local_ext;
};

enum lm90_temp8_reg_index {
	LOCAL_LOW = 0,
	LOCAL_HIGH = 1,
	LOCAL_CRIT = 2,
	REMOTE_CRIT = 3,
	LOCAL_EMERG = 4,
	REMOTE_EMERG = 5,
	REMOTE2_CRIT = 6,
	REMOTE2_EMERG = 7,
	TEMP8_REG_NUM = 8,
};

enum lm90_temp11_reg_index {
	REMOTE_TEMP = 0,
	REMOTE_LOW = 1,
	REMOTE_HIGH = 2,
	REMOTE_OFFSET = 3,
	LOCAL_TEMP = 4,
	REMOTE2_TEMP = 5,
	REMOTE2_LOW = 6,
	REMOTE2_HIGH = 7,
	TEMP11_REG_NUM = 8,
};

struct lm90_data {
	struct i2c_client *client;
	u32 channel_config[4];
	struct hwmon_channel_info temp_info;
	const struct hwmon_channel_info *info[3];
	struct hwmon_chip_info chip;
	struct mutex update_lock;
	bool valid;
	long unsigned int last_updated;
	int kind;
	u32 flags;
	unsigned int update_interval;
	u8 config;
	u8 config_orig;
	u8 convrate_orig;
	u16 alert_alarms;
	u8 max_convrate;
	u8 reg_local_ext;
	s8 temp8[8];
	s16 temp11[8];
	u8 temp_hyst;
	u16 alarms;
};

struct reg {
	u8 high;
	u8 low;
};

struct lm95245_data {
	struct regmap *regmap;
	struct mutex update_lock;
	int interval;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct devfreq_dev_status {
	long unsigned int total_time;
	long unsigned int busy_time;
	long unsigned int current_frequency;
	void *private_data;
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_get_power {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	long unsigned int freq;
	u32 __data_loc_load;
	size_t load_len;
	u32 dynamic_power;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_limit {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_devfreq_get_power {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int freq;
	u32 busy_time;
	u32 total_time;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_devfreq_limit {
	struct trace_entry ent;
	u32 __data_loc_type;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

struct trace_event_data_offsets_thermal_power_cpu_get_power {
	u32 cpumask;
	u32 load;
};

struct trace_event_data_offsets_thermal_power_cpu_limit {
	u32 cpumask;
};

struct trace_event_data_offsets_thermal_power_devfreq_get_power {
	u32 type;
};

struct trace_event_data_offsets_thermal_power_devfreq_limit {
	u32 type;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_thermal_power_cpu_get_power)(void *, const struct cpumask *, long unsigned int, u32 *, size_t, u32);

typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, long unsigned int, u32);

typedef void (*btf_trace_thermal_power_devfreq_get_power)(void *, struct thermal_cooling_device *, struct devfreq_dev_status *, long unsigned int, u32);

typedef void (*btf_trace_thermal_power_devfreq_limit)(void *, struct thermal_cooling_device *, long unsigned int, long unsigned int, u32);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct thermal_trip {
	struct device_node *np;
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
};

struct __thermal_cooling_bind_param {
	struct device_node *cooling_device;
	long unsigned int min;
	long unsigned int max;
};

struct __thermal_bind_params {
	struct __thermal_cooling_bind_param *tcbp;
	unsigned int count;
	unsigned int trip_id;
	unsigned int usage;
};

struct __thermal_zone {
	int passive_delay;
	int polling_delay;
	int slope;
	int offset;
	int ntrips;
	struct thermal_trip *trips;
	int num_tbps;
	struct __thermal_bind_params *tbps;
	void *sensor_data;
	const struct thermal_zone_of_device_ops *ops;
};

struct time_in_idle {
	u64 time;
	u64 timestamp;
};

struct cpufreq_cooling_device {
	int id;
	u32 last_load;
	unsigned int cpufreq_state;
	unsigned int max_level;
	struct em_perf_domain *em;
	struct cpufreq_policy *policy;
	struct list_head node;
	struct time_in_idle *idle_time;
	struct freq_qos_request qos_req;
};

enum devfreq_timer {
	DEVFREQ_TIMER_DEFERRABLE = 0,
	DEVFREQ_TIMER_DELAYED = 1,
	DEVFREQ_TIMER_NUM = 2,
};

struct devfreq_dev_profile {
	long unsigned int initial_freq;
	unsigned int polling_ms;
	enum devfreq_timer timer;
	int (*target)(struct device *, long unsigned int *, u32);
	int (*get_dev_status)(struct device *, struct devfreq_dev_status *);
	int (*get_cur_freq)(struct device *, long unsigned int *);
	void (*exit)(struct device *);
	long unsigned int *freq_table;
	unsigned int max_state;
};

struct devfreq_stats {
	unsigned int total_trans;
	unsigned int *trans_table;
	u64 *time_in_state;
	int: 32;
	u64 last_update;
};

struct devfreq_governor;

struct devfreq {
	struct list_head node;
	struct mutex lock;
	int: 32;
	struct device dev;
	struct devfreq_dev_profile *profile;
	const struct devfreq_governor *governor;
	struct notifier_block nb;
	struct delayed_work work;
	long unsigned int previous_freq;
	struct devfreq_dev_status last_status;
	void *data;
	struct dev_pm_qos_request user_min_freq_req;
	struct dev_pm_qos_request user_max_freq_req;
	long unsigned int scaling_min_freq;
	long unsigned int scaling_max_freq;
	bool stop_polling;
	long unsigned int suspend_freq;
	long unsigned int resume_freq;
	atomic_t suspend_count;
	struct devfreq_stats stats;
	struct srcu_notifier_head transition_notifier_list;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct devfreq_governor {
	struct list_head node;
	const char name[16];
	const u64 attrs;
	const u64 flags;
	int (*get_target_freq)(struct devfreq *, long unsigned int *);
	int (*event_handler)(struct devfreq *, unsigned int, void *);
};

struct devfreq_cooling_power {
	int (*get_real_power)(struct devfreq *, u32 *, long unsigned int, long unsigned int);
};

struct devfreq_cooling_device {
	int id;
	struct thermal_cooling_device *cdev;
	struct devfreq *devfreq;
	long unsigned int cooling_state;
	u32 *freq_table;
	size_t max_state;
	struct devfreq_cooling_power *power_ops;
	u32 res_util;
	int capped_state;
	struct dev_pm_qos_request req_max_freq;
	struct em_perf_domain *em_pd;
};

struct ns_thermal {
	struct thermal_zone_device *tz;
	void *pvtmon;
};

struct sr_thermal;

struct sr_tmon {
	struct thermal_zone_device *tz;
	unsigned int crit_temp;
	unsigned int tmon_id;
	struct sr_thermal *priv;
};

struct sr_thermal {
	void *regs;
	unsigned int max_crit_temp;
	struct sr_tmon tmon[6];
};

enum tshut_mode {
	TSHUT_MODE_CRU = 0,
	TSHUT_MODE_GPIO = 1,
};

enum tshut_polarity {
	TSHUT_LOW_ACTIVE = 0,
	TSHUT_HIGH_ACTIVE = 1,
};

enum sensor_id {
	SENSOR_CPU = 0,
	SENSOR_GPU = 1,
};

enum adc_sort_mode {
	ADC_DECREMENT = 0,
	ADC_INCREMENT = 1,
};

struct tsadc_table;

struct chip_tsadc_table {
	const struct tsadc_table *id;
	unsigned int length;
	u32 data_mask;
	enum adc_sort_mode mode;
};

struct tsadc_table {
	u32 code;
	int temp;
};

struct rockchip_tsadc_chip {
	int chn_id[2];
	int chn_num;
	int tshut_temp;
	enum tshut_mode tshut_mode;
	enum tshut_polarity tshut_polarity;
	void (*initialize)(struct regmap *, void *, enum tshut_polarity);
	void (*irq_ack)(void *);
	void (*control)(void *, bool);
	int (*get_temp)(const struct chip_tsadc_table *, int, void *, int *);
	int (*set_alarm_temp)(const struct chip_tsadc_table *, int, void *, int);
	int (*set_tshut_temp)(const struct chip_tsadc_table *, int, void *, int);
	void (*set_tshut_mode)(int, void *, enum tshut_mode);
	struct chip_tsadc_table table;
};

struct rockchip_thermal_data;

struct rockchip_thermal_sensor {
	struct rockchip_thermal_data *thermal;
	struct thermal_zone_device *tzd;
	int id;
};

struct rockchip_thermal_data {
	const struct rockchip_tsadc_chip *chip;
	struct platform_device *pdev;
	struct reset_control *reset;
	struct rockchip_thermal_sensor sensors[2];
	struct clk *clk;
	struct clk *pclk;
	struct regmap *grf;
	void *regs;
	int tshut_temp;
	enum tshut_mode tshut_mode;
	enum tshut_polarity tshut_polarity;
};

struct rcar_thermal_common {
	void *base;
	struct device *dev;
	struct list_head head;
	spinlock_t lock;
};

struct rcar_thermal_chip {
	unsigned int use_of_thermal: 1;
	unsigned int has_filonoff: 1;
	unsigned int irq_per_ch: 1;
	unsigned int needs_suspend_resume: 1;
	unsigned int nirqs;
	unsigned int ctemp_bands;
};

struct rcar_thermal_priv {
	void *base;
	struct rcar_thermal_common *common;
	struct thermal_zone_device *zone;
	const struct rcar_thermal_chip *chip;
	struct delayed_work work;
	struct mutex lock;
	struct list_head list;
	int id;
};

enum soc_type {
	SOC_ARCH_EXYNOS3250 = 1,
	SOC_ARCH_EXYNOS4210 = 2,
	SOC_ARCH_EXYNOS4412 = 3,
	SOC_ARCH_EXYNOS5250 = 4,
	SOC_ARCH_EXYNOS5260 = 5,
	SOC_ARCH_EXYNOS5420 = 6,
	SOC_ARCH_EXYNOS5420_TRIMINFO = 7,
	SOC_ARCH_EXYNOS5433 = 8,
	SOC_ARCH_EXYNOS7 = 9,
};

struct exynos_tmu_data {
	int id;
	void *base;
	void *base_second;
	int irq;
	enum soc_type soc;
	struct work_struct irq_work;
	struct mutex lock;
	struct clk *clk;
	struct clk *clk_sec;
	struct clk *sclk;
	u32 cal_type;
	u32 efuse_value;
	u32 min_efuse_value;
	u32 max_efuse_value;
	u16 temp_error1;
	u16 temp_error2;
	u8 gain;
	u8 reference_voltage;
	struct regulator *regulator;
	struct thermal_zone_device *tzd;
	unsigned int ntrip;
	bool enabled;
	void (*tmu_set_trip_temp)(struct exynos_tmu_data *, int, u8);
	void (*tmu_set_trip_hyst)(struct exynos_tmu_data *, int, u8, u8);
	void (*tmu_initialize)(struct platform_device *);
	void (*tmu_control)(struct platform_device *, bool);
	int (*tmu_read)(struct exynos_tmu_data *);
	void (*tmu_set_emulation)(struct exynos_tmu_data *, int);
	void (*tmu_clear_irqs)(struct exynos_tmu_data *);
};

struct db8500_thermal_zone {
	struct thermal_zone_device *tz;
	enum thermal_trend trend;
	long unsigned int interpolated_temp;
	unsigned int cur_index;
};

struct armada_thermal_data;

struct armada_thermal_priv {
	struct device *dev;
	struct regmap *syscon;
	char zone_name[20];
	struct mutex update_lock;
	struct armada_thermal_data *data;
	struct thermal_zone_device *overheat_sensor;
	int interrupt_source;
	int current_channel;
	long int current_threshold;
	long int current_hysteresis;
};

struct armada_thermal_data {
	void (*init)(struct platform_device *, struct armada_thermal_priv *);
	int: 32;
	s64 coef_b;
	s64 coef_m;
	u32 coef_div;
	bool inverted;
	bool signed_sample;
	unsigned int temp_shift;
	unsigned int temp_mask;
	unsigned int thresh_shift;
	unsigned int hyst_shift;
	unsigned int hyst_mask;
	u32 is_valid_bit;
	unsigned int syscon_control0_off;
	unsigned int syscon_control1_off;
	unsigned int syscon_status_off;
	unsigned int dfx_irq_cause_off;
	unsigned int dfx_irq_mask_off;
	unsigned int dfx_overheat_irq;
	unsigned int dfx_server_irq_mask_off;
	unsigned int dfx_server_irq_en;
	unsigned int cpu_nr;
	int: 32;
};

enum drvtype {
	LEGACY = 0,
	SYSCON = 1,
};

struct armada_drvdata {
	enum drvtype type;
	union {
		struct armada_thermal_priv *priv;
		struct thermal_zone_device *tz;
	} data;
};

struct armada_thermal_sensor {
	struct armada_thermal_priv *priv;
	int id;
};

enum imx_thermal_trip {
	IMX_TRIP_PASSIVE = 0,
	IMX_TRIP_CRITICAL = 1,
	IMX_TRIP_NUM = 2,
};

struct thermal_soc_data {
	u32 version;
	u32 sensor_ctrl;
	u32 power_down_mask;
	u32 measure_temp_mask;
	u32 measure_freq_ctrl;
	u32 measure_freq_mask;
	u32 measure_freq_shift;
	u32 temp_data;
	u32 temp_value_mask;
	u32 temp_value_shift;
	u32 temp_valid_mask;
	u32 panic_alarm_ctrl;
	u32 panic_alarm_mask;
	u32 panic_alarm_shift;
	u32 high_alarm_ctrl;
	u32 high_alarm_mask;
	u32 high_alarm_shift;
	u32 low_alarm_ctrl;
	u32 low_alarm_mask;
	u32 low_alarm_shift;
};

struct imx_thermal_data {
	struct cpufreq_policy *policy;
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	struct regmap *tempmon;
	u32 c1;
	u32 c2;
	int temp_passive;
	int temp_critical;
	int temp_max;
	int alarm_temp;
	int last_temp;
	bool irq_enabled;
	int irq;
	struct clk *thermal_clk;
	const struct thermal_soc_data *socdata;
	const char *temp_grade;
};

struct temp_sensor_registers {
	u32 temp_sensor_ctrl;
	u32 bgap_tempsoff_mask;
	u32 bgap_soc_mask;
	u32 bgap_eocz_mask;
	u32 bgap_dtemp_mask;
	u32 bgap_mask_ctrl;
	u32 mask_hot_mask;
	u32 mask_cold_mask;
	u32 mask_counter_delay_mask;
	u32 mask_freeze_mask;
	u32 bgap_mode_ctrl;
	u32 mode_ctrl_mask;
	u32 bgap_counter;
	u32 counter_mask;
	u32 bgap_threshold;
	u32 threshold_thot_mask;
	u32 threshold_tcold_mask;
	u32 tshut_threshold;
	u32 tshut_hot_mask;
	u32 tshut_cold_mask;
	u32 bgap_status;
	u32 status_hot_mask;
	u32 status_cold_mask;
	u32 ctrl_dtemp_1;
	u32 ctrl_dtemp_2;
	u32 bgap_efuse;
};

struct temp_sensor_data {
	u32 tshut_hot;
	u32 tshut_cold;
	u32 t_hot;
	u32 t_cold;
	u32 min_freq;
	u32 max_freq;
};

struct temp_sensor_regval {
	u32 bg_mode_ctrl;
	u32 bg_ctrl;
	u32 bg_counter;
	u32 bg_threshold;
	u32 tshut_threshold;
	void *data;
};

struct ti_bandgap_data;

struct ti_bandgap {
	struct device *dev;
	void *base;
	const struct ti_bandgap_data *conf;
	struct temp_sensor_regval *regval;
	struct clk *fclock;
	struct clk *div_clk;
	spinlock_t lock;
	int irq;
	struct gpio_desc *tshut_gpiod;
	u32 clk_rate;
	struct notifier_block nb;
	unsigned int is_suspended: 1;
};

struct ti_temp_sensor {
	struct temp_sensor_data *ts_data;
	struct temp_sensor_registers *registers;
	char *domain;
	const int slope_pcb;
	const int constant_pcb;
	int (*register_cooling)(struct ti_bandgap *, int);
	int (*unregister_cooling)(struct ti_bandgap *, int);
};

struct ti_bandgap_data {
	unsigned int features;
	const int *conv_table;
	u32 adc_start_val;
	u32 adc_end_val;
	char *fclock_name;
	char *div_ck_name;
	int sensor_count;
	int (*report_temperature)(struct ti_bandgap *, int);
	int (*expose_sensor)(struct ti_bandgap *, int, char *);
	int (*remove_sensor)(struct ti_bandgap *, int);
	struct ti_temp_sensor sensors[0];
};

enum st_thermal_regfield_ids {
	INT_THRESH_HI = 0,
	TEMP_PWR = 0,
	DCORRECT = 1,
	OVERFLOW = 2,
	DATA = 3,
	INT_ENABLE = 4,
	MAX_REGFIELDS___2 = 5,
};

enum st_thermal_power_state {
	POWER_OFF = 0,
	POWER_ON = 1,
};

struct st_thermal_sensor;

struct st_thermal_sensor_ops {
	int (*power_ctrl)(struct st_thermal_sensor *, enum st_thermal_power_state);
	int (*alloc_regfields)(struct st_thermal_sensor *);
	int (*regmap_init)(struct st_thermal_sensor *);
	int (*register_enable_irq)(struct st_thermal_sensor *);
	int (*enable_irq)(struct st_thermal_sensor *);
};

struct st_thermal_compat_data;

struct st_thermal_sensor {
	struct device *dev;
	struct thermal_zone_device *thermal_dev;
	const struct st_thermal_sensor_ops *ops;
	const struct st_thermal_compat_data *cdata;
	struct clk *clk;
	struct regmap *regmap;
	struct regmap_field *pwr;
	struct regmap_field *dcorrect;
	struct regmap_field *overflow;
	struct regmap_field *temp_data;
	struct regmap_field *int_thresh_hi;
	struct regmap_field *int_enable;
	int irq;
	void *mmio_base;
};

struct st_thermal_compat_data {
	char *sys_compat;
	const struct reg_field *reg_fields;
	const struct st_thermal_sensor_ops *ops;
	unsigned int calibration_val;
	int temp_adjust_val;
	int crit_temp;
};

struct stm_thermal_sensor {
	struct device *dev;
	struct thermal_zone_device *th_dev;
	enum thermal_device_mode mode;
	struct clk *clk;
	unsigned int low_temp_enabled;
	unsigned int high_temp_enabled;
	int irq;
	void *base;
	int t0;
	int fmt0;
	int ramp_coeff;
};

struct hisi_thermal_data;

struct hisi_thermal_sensor {
	struct hisi_thermal_data *data;
	struct thermal_zone_device *tzd;
	const char *irq_name;
	uint32_t id;
	uint32_t thres_temp;
};

struct hisi_thermal_ops;

struct hisi_thermal_data {
	const struct hisi_thermal_ops *ops;
	struct hisi_thermal_sensor *sensor;
	struct platform_device *pdev;
	struct clk *clk;
	void *regs;
	int nr_sensors;
};

struct hisi_thermal_ops {
	int (*get_temp)(struct hisi_thermal_sensor *);
	int (*enable_sensor)(struct hisi_thermal_sensor *);
	int (*disable_sensor)(struct hisi_thermal_sensor *);
	int (*irq_handler)(struct hisi_thermal_sensor *);
	int (*probe)(struct hisi_thermal_data *);
};

enum {
	VTS1 = 0,
	VTS2 = 1,
	VTS3 = 2,
	VTS4 = 3,
	VTS5 = 4,
	VTSABB = 5,
	MAX_NUM_VTS = 6,
};

enum mtk_thermal_version {
	MTK_THERMAL_V1 = 1,
	MTK_THERMAL_V2 = 2,
};

struct thermal_bank_cfg {
	unsigned int num_sensors;
	const int *sensors;
};

struct mtk_thermal;

struct mtk_thermal_bank {
	struct mtk_thermal *mt;
	int id;
};

struct mtk_thermal_data;

struct mtk_thermal {
	struct device *dev;
	void *thermal_base;
	struct clk *clk_peri_therm;
	struct clk *clk_auxadc;
	struct mutex lock;
	s32 adc_ge;
	s32 adc_oe;
	s32 degc_cali;
	s32 o_slope;
	s32 o_slope_sign;
	s32 vts[6];
	const struct mtk_thermal_data *conf;
	struct mtk_thermal_bank banks[8];
};

struct mtk_thermal_data {
	s32 num_banks;
	s32 num_sensors;
	s32 auxadc_channel;
	const int *vts_index;
	const int *sensor_mux_values;
	const int *msr;
	const int *adcpnp;
	const int cali_val;
	const int num_controller;
	const int *controller_offset;
	bool need_switch_bank;
	struct thermal_bank_cfg bank_data[8];
	enum mtk_thermal_version version;
};

struct uniphier_tm_soc_data {
	u32 map_base;
	u32 block_base;
	u32 tmod_setup_addr;
};

struct uniphier_tm_dev {
	struct regmap *regmap;
	struct device *dev;
	bool alert_en[3];
	struct thermal_zone_device *tz_dev;
	const struct uniphier_tm_soc_data *data;
};

struct amlogic_thermal_soc_calib_data {
	int A;
	int B;
	int m;
	int n;
};

struct amlogic_thermal_data {
	int u_efuse_off;
	const struct amlogic_thermal_soc_calib_data *calibration_parameters;
	const struct regmap_config *regmap_config;
};

struct amlogic_thermal {
	struct platform_device *pdev;
	const struct amlogic_thermal_data *data;
	struct regmap *regmap;
	struct regmap *sec_ao_map;
	struct clk *clk;
	struct thermal_zone_device *tzd;
	u32 trim_info;
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	int: 32;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct sp805_wdt {
	struct watchdog_device wdd;
	spinlock_t lock;
	void *base;
	struct clk *clk;
	int: 32;
	u64 rate;
	struct amba_device *adev;
	unsigned int load_val;
};

struct at91wdt {
	struct watchdog_device wdd;
	void *base;
	long unsigned int next_heartbeat;
	struct timer_list timer;
	u32 mr;
	u32 mr_mask;
	long unsigned int heartbeat;
	bool nowayout;
	unsigned int irq;
	struct clk *sclk;
};

struct sama5d4_wdt {
	struct watchdog_device wdd;
	void *reg_base;
	u32 mr;
	u32 ir;
	long unsigned int last_ping;
	bool need_irq;
	bool sam9x60_support;
};

enum dw_wdt_rmod {
	DW_WDT_RMOD_RESET = 1,
	DW_WDT_RMOD_IRQ = 2,
};

struct dw_wdt_timeout {
	u32 top_val;
	unsigned int sec;
	unsigned int msec;
};

struct dw_wdt {
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	long unsigned int rate;
	enum dw_wdt_rmod rmod;
	struct dw_wdt_timeout timeouts[16];
	struct watchdog_device wdd;
	struct reset_control *rst;
	u32 control;
	u32 timeout;
	struct dentry *dbgfs_dir;
};

struct orion_watchdog;

struct orion_watchdog_data {
	int wdt_counter_offset;
	int wdt_enable_bit;
	int rstout_enable_bit;
	int rstout_mask_bit;
	int (*clock_init)(struct platform_device *, struct orion_watchdog *);
	int (*enabled)(struct orion_watchdog *);
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
};

struct orion_watchdog {
	struct watchdog_device wdt;
	void *reg;
	void *rstout;
	void *rstout_mask;
	long unsigned int clk_rate;
	struct clk *clk;
	const struct orion_watchdog_data *data;
};

struct sunxi_wdt_reg {
	u8 wdt_ctrl;
	u8 wdt_cfg;
	u8 wdt_mode;
	u8 wdt_timeout_shift;
	u8 wdt_reset_mask;
	u8 wdt_reset_val;
};

struct sunxi_wdt_dev {
	struct watchdog_device wdt_dev;
	void *wdt_base;
	const struct sunxi_wdt_reg *wdt_regs;
};

struct rn5t618_wdt {
	struct watchdog_device wdt_dev;
	struct rn5t618 *rn5t618;
};

struct imx2_wdt_device {
	struct clk *clk;
	struct regmap *regmap;
	struct watchdog_device wdog;
	bool ext_reset;
};

enum prcmu_wdog_id {
	PRCMU_WDOG_ALL = 0,
	PRCMU_WDOG_CPU1 = 1,
	PRCMU_WDOG_CPU2 = 2,
};

struct bcm2835_wdt {
	void *base;
	spinlock_t lock;
};

struct st_wdog_syscfg {
	unsigned int reset_type_reg;
	unsigned int reset_type_mask;
	unsigned int enable_reg;
	unsigned int enable_mask;
};

struct st_wdog {
	void *base;
	struct device *dev;
	struct regmap *regmap;
	struct st_wdog_syscfg *syscfg;
	struct clk *clk;
	long unsigned int clkrate;
	bool warm_reset;
};

struct bcm_kona_wdt {
	void *base;
	int resolution;
	spinlock_t lock;
};

struct meson_wdt_data {
	unsigned int enable;
	unsigned int terminal_count_mask;
	unsigned int count_unit;
};

struct meson_wdt_dev {
	struct watchdog_device wdt_dev;
	void *wdt_base;
	const struct meson_wdt_data *data;
};

struct dc_wdt {
	void *base;
	struct clk *clk;
	spinlock_t lock;
};

struct aspeed_wdt {
	struct watchdog_device wdd;
	void *base;
	u32 ctrl;
};

struct aspeed_wdt_config {
	u32 ext_pulse_width_mask;
};

struct stm32_iwdg_data {
	bool has_pclk;
	u32 max_prescaler;
};

struct stm32_iwdg {
	struct watchdog_device wdd;
	const struct stm32_iwdg_data *data;
	void *regs;
	struct clk *clk_lsi;
	struct clk *clk_pclk;
	unsigned int rate;
};

struct xwdt_device {
	void *base;
	u32 wdt_interval;
	spinlock_t spinlock;
	struct watchdog_device xilinx_wdt_wdd;
	struct clk *clk;
};

struct bcm47xx_wdt {
	u32 (*timer_set)(struct bcm47xx_wdt *, u32);
	u32 (*timer_set_ms)(struct bcm47xx_wdt *, u32);
	u32 max_timer_ms;
	void *driver_data;
	struct watchdog_device wdd;
	struct timer_list soft_timer;
	atomic_t soft_ticks;
};

struct stpmic1_wdt {
	struct stpmic1 *pmic;
	struct watchdog_device wdtdev;
};

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

struct dev_pm_opp___2;

struct dev_pm_set_opp_data;

struct opp_table___2 {
	struct list_head node;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node *np;
	long unsigned int clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	struct dev_pm_opp___2 *suspend_opp;
	struct mutex genpd_virt_dev_lock;
	struct device **genpd_virt_devs;
	struct opp_table___2 **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	struct clk *clk;
	struct regulator **regulators;
	int regulator_count;
	struct icc_path **paths;
	unsigned int path_count;
	bool enabled;
	bool genpd_performance_state;
	bool is_genpd;
	int (*set_opp)(struct dev_pm_set_opp_data *);
	struct dev_pm_set_opp_data *set_opp_data;
	struct dentry *dentry;
	char dentry_name[255];
};

struct dev_pm_opp_supply;

struct dev_pm_opp_icc_bw;

struct dev_pm_opp___2 {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	unsigned int pstate;
	long unsigned int rate;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	struct dev_pm_opp_icc_bw *bandwidth;
	long unsigned int clock_latency_ns;
	struct dev_pm_opp___2 **required_opps;
	struct opp_table___2 *opp_table;
	struct device_node *np;
	struct dentry *dentry;
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
	OPP_EVENT_ADJUST_VOLTAGE = 4,
};

struct dev_pm_opp_supply {
	long unsigned int u_volt;
	long unsigned int u_volt_min;
	long unsigned int u_volt_max;
	long unsigned int u_amp;
};

struct dev_pm_opp_icc_bw {
	u32 avg;
	u32 peak;
};

struct dev_pm_opp_info {
	long unsigned int rate;
	struct dev_pm_opp_supply *supplies;
};

struct dev_pm_set_opp_data {
	struct dev_pm_opp_info old_opp;
	struct dev_pm_opp_info new_opp;
	struct regulator **regulators;
	unsigned int regulator_count;
	struct clk *clk;
	struct device *dev;
};

struct opp_device {
	struct list_head node;
	const struct device *dev;
	struct dentry *dentry;
};

struct em_data_callback {};

struct ti_opp_supply_optimum_voltage_table {
	unsigned int reference_uv;
	unsigned int optimized_uv;
};

struct ti_opp_supply_data {
	struct ti_opp_supply_optimum_voltage_table *vdd_table;
	u32 num_vdd_table;
	u32 vdd_absolute_max_voltage_uv;
};

struct ti_opp_supply_of_data {
	const u8 flags;
	const u32 efuse_voltage_mask;
	const bool efuse_voltage_uv;
};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, long unsigned int, long unsigned int, long unsigned int);
	unsigned int (*resolve_freq)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	void (*stop_cpu)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
};

struct cpufreq_stats {
	unsigned int total_trans;
	int: 32;
	long long unsigned int last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	int: 32;
	long long unsigned int reset_time;
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_data {
	struct gov_attr_set attr_set;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
	int: 32;
};

struct cpufreq_dt_platform_data {
	bool have_governor_per_policy;
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
};

struct private_data {
	struct list_head node;
	cpumask_var_t cpus;
	struct device *cpu_dev;
	struct opp_table *opp_table;
	struct cpufreq_frequency_table *freq_table;
	bool have_static_opps;
};

struct pmap {
	unsigned int mode;
	unsigned int p1;
	unsigned int p2;
	unsigned int state;
};

struct private_data___2 {
	void *base;
	void *avs_intr_base;
	struct device *dev;
	struct completion done;
	struct semaphore sem;
	struct pmap pmap;
	int host_irq;
};

enum IMX6_CPUFREQ_CLKS {
	ARM = 0,
	PLL1_SYS = 1,
	STEP = 2,
	PLL1_SW = 3,
	PLL2_PFD2_396M = 4,
	PLL2_BUS = 5,
	SECONDARY_SEL = 6,
};

struct tegra124_cpufreq_priv {
	struct clk *cpu_clk;
	struct clk *pllp_clk;
	struct clk *pllx_clk;
	struct clk *dfll_clk;
	struct platform_device *cpufreq_dt_pdev;
};

struct ti_cpufreq_data;

struct ti_cpufreq_soc_data {
	const char * const *reg_names;
	long unsigned int (*efuse_xlate)(struct ti_cpufreq_data *, long unsigned int);
	long unsigned int efuse_fallback;
	long unsigned int efuse_offset;
	long unsigned int efuse_mask;
	long unsigned int efuse_shift;
	long unsigned int rev_offset;
	bool multi_regulator;
};

struct ti_cpufreq_data {
	struct device *cpu_dev;
	struct device_node *opp_node;
	struct regmap *syscon;
	const struct ti_cpufreq_soc_data *soc_data;
	struct opp_table *opp_table;
};

struct cpu_data {
	struct clk **pclk;
	struct cpufreq_frequency_table *table;
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_driver_kobj {
	struct cpuidle_driver *drv;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_driver_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_driver *, char *);
	ssize_t (*store)(struct cpuidle_driver *, const char *, size_t);
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct cpuidle_coupled {
	cpumask_t coupled_cpus;
	int requested_state[16];
	atomic_t ready_waiting_counts;
	atomic_t abort_barrier;
	int online_count;
	int refcnt;
	int prevent;
};

enum tegra_state {
	TEGRA_C1 = 0,
	TEGRA_C7 = 1,
	TEGRA_CC6 = 2,
	TEGRA_STATE_COUNT = 3,
};

struct mmc_cid {
	unsigned int manfid;
	char prod_name[8];
	unsigned char prv;
	unsigned int serial;
	short unsigned int oemid;
	short unsigned int year;
	unsigned char hwrev;
	unsigned char fwrev;
	unsigned char month;
};

struct mmc_csd {
	unsigned char structure;
	unsigned char mmca_vsn;
	short unsigned int cmdclass;
	short unsigned int taac_clks;
	unsigned int taac_ns;
	unsigned int c_size;
	unsigned int r2w_factor;
	unsigned int max_dtr;
	unsigned int erase_size;
	unsigned int read_blkbits;
	unsigned int write_blkbits;
	unsigned int capacity;
	unsigned int read_partial: 1;
	unsigned int read_misalign: 1;
	unsigned int write_partial: 1;
	unsigned int write_misalign: 1;
	unsigned int dsr_imp: 1;
};

struct mmc_ext_csd {
	u8 rev;
	u8 erase_group_def;
	u8 sec_feature_support;
	u8 rel_sectors;
	u8 rel_param;
	bool enhanced_rpmb_supported;
	u8 part_config;
	u8 cache_ctrl;
	u8 rst_n_function;
	u8 max_packed_writes;
	u8 max_packed_reads;
	u8 packed_event_en;
	unsigned int part_time;
	unsigned int sa_timeout;
	unsigned int generic_cmd6_time;
	unsigned int power_off_longtime;
	u8 power_off_notification;
	unsigned int hs_max_dtr;
	unsigned int hs200_max_dtr;
	unsigned int sectors;
	unsigned int hc_erase_size;
	unsigned int hc_erase_timeout;
	unsigned int sec_trim_mult;
	unsigned int sec_erase_mult;
	unsigned int trim_timeout;
	bool partition_setting_completed;
	int: 24;
	int: 32;
	long long unsigned int enhanced_area_offset;
	unsigned int enhanced_area_size;
	unsigned int cache_size;
	bool hpi_en;
	bool hpi;
	unsigned int hpi_cmd;
	bool bkops;
	bool man_bkops_en;
	bool auto_bkops_en;
	unsigned int data_sector_size;
	unsigned int data_tag_unit_size;
	unsigned int boot_ro_lock;
	bool boot_ro_lockable;
	bool ffu_capable;
	bool cmdq_en;
	bool cmdq_support;
	unsigned int cmdq_depth;
	u8 fwrev[8];
	u8 raw_exception_status;
	u8 raw_partition_support;
	u8 raw_rpmb_size_mult;
	u8 raw_erased_mem_count;
	u8 strobe_support;
	u8 raw_ext_csd_structure;
	u8 raw_card_type;
	u8 raw_driver_strength;
	u8 out_of_int_time;
	u8 raw_pwr_cl_52_195;
	u8 raw_pwr_cl_26_195;
	u8 raw_pwr_cl_52_360;
	u8 raw_pwr_cl_26_360;
	u8 raw_s_a_timeout;
	u8 raw_hc_erase_gap_size;
	u8 raw_erase_timeout_mult;
	u8 raw_hc_erase_grp_size;
	u8 raw_sec_trim_mult;
	u8 raw_sec_erase_mult;
	u8 raw_sec_feature_support;
	u8 raw_trim_mult;
	u8 raw_pwr_cl_200_195;
	u8 raw_pwr_cl_200_360;
	u8 raw_pwr_cl_ddr_52_195;
	u8 raw_pwr_cl_ddr_52_360;
	u8 raw_pwr_cl_ddr_200_360;
	u8 raw_bkops_status;
	u8 raw_sectors[4];
	u8 pre_eol_info;
	u8 device_life_time_est_typ_a;
	u8 device_life_time_est_typ_b;
	unsigned int feature_support;
};

struct sd_scr {
	unsigned char sda_vsn;
	unsigned char sda_spec3;
	unsigned char sda_spec4;
	unsigned char sda_specx;
	unsigned char bus_widths;
	unsigned char cmds;
};

struct sd_ssr {
	unsigned int au;
	unsigned int erase_timeout;
	unsigned int erase_offset;
};

struct sd_switch_caps {
	unsigned int hs_max_dtr;
	unsigned int uhs_max_dtr;
	unsigned int sd3_bus_mode;
	unsigned int sd3_drv_type;
	unsigned int sd3_curr_limit;
};

struct sdio_cccr {
	unsigned int sdio_vsn;
	unsigned int sd_vsn;
	unsigned int multi_block: 1;
	unsigned int low_speed: 1;
	unsigned int wide_bus: 1;
	unsigned int high_power: 1;
	unsigned int high_speed: 1;
	unsigned int disable_cd: 1;
};

struct sdio_cis {
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int blksize;
	unsigned int max_dtr;
};

struct mmc_part {
	u64 size;
	unsigned int part_cfg;
	char name[20];
	bool force_ro;
	unsigned int area_type;
};

struct mmc_host;

struct sdio_func;

struct sdio_func_tuple;

struct mmc_card {
	struct mmc_host *host;
	int: 32;
	struct device dev;
	u32 ocr;
	unsigned int rca;
	unsigned int type;
	unsigned int state;
	unsigned int quirks;
	unsigned int quirk_max_rate;
	bool reenable_cmdq;
	unsigned int erase_size;
	unsigned int erase_shift;
	unsigned int pref_erase;
	unsigned int eg_boundary;
	unsigned int erase_arg;
	u8 erased_byte;
	u32 raw_cid[4];
	u32 raw_csd[4];
	u32 raw_scr[2];
	u32 raw_ssr[16];
	struct mmc_cid cid;
	struct mmc_csd csd;
	int: 32;
	struct mmc_ext_csd ext_csd;
	struct sd_scr scr;
	struct sd_ssr ssr;
	struct sd_switch_caps sw_caps;
	unsigned int sdio_funcs;
	atomic_t sdio_funcs_probed;
	struct sdio_cccr cccr;
	struct sdio_cis cis;
	struct sdio_func *sdio_func[7];
	struct sdio_func *sdio_single_irq;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	unsigned int sd_bus_speed;
	unsigned int mmc_avail_type;
	unsigned int drive_strength;
	struct dentry *debugfs_root;
	struct mmc_part part[7];
	unsigned int nr_parts;
	unsigned int bouncesz;
	struct workqueue_struct *complete_wq;
	int: 32;
};

typedef unsigned int mmc_pm_flag_t;

struct mmc_ios {
	unsigned int clock;
	short unsigned int vdd;
	unsigned int power_delay_ms;
	unsigned char bus_mode;
	unsigned char chip_select;
	unsigned char power_mode;
	unsigned char bus_width;
	unsigned char timing;
	unsigned char signal_voltage;
	unsigned char drv_type;
	bool enhanced_strobe;
};

struct mmc_ctx {
	struct task_struct *task;
};

struct mmc_slot {
	int cd_irq;
	bool cd_wake_enabled;
	void *handler_priv;
};

struct mmc_supply {
	struct regulator *vmmc;
	struct regulator *vqmmc;
};

struct mmc_host_ops;

struct mmc_pwrseq;

struct mmc_bus_ops;

struct mmc_request;

struct mmc_cqe_ops;

struct mmc_host {
	struct device *parent;
	int: 32;
	struct device class_dev;
	int index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq *pwrseq;
	unsigned int f_min;
	unsigned int f_max;
	unsigned int f_init;
	u32 ocr_avail;
	u32 ocr_avail_sdio;
	u32 ocr_avail_sd;
	u32 ocr_avail_mmc;
	struct notifier_block pm_notify;
	struct wakeup_source *ws;
	u32 max_current_330;
	u32 max_current_300;
	u32 max_current_180;
	u32 caps;
	u32 caps2;
	int fixed_drv_type;
	mmc_pm_flag_t pm_caps;
	unsigned int max_seg_size;
	short unsigned int max_segs;
	short unsigned int unused;
	unsigned int max_req_size;
	unsigned int max_blk_size;
	unsigned int max_blk_count;
	unsigned int max_busy_timeout;
	spinlock_t lock;
	struct mmc_ios ios;
	unsigned int use_spi_crc: 1;
	unsigned int claimed: 1;
	unsigned int bus_dead: 1;
	unsigned int doing_init_tune: 1;
	unsigned int can_retune: 1;
	unsigned int doing_retune: 1;
	unsigned int retune_now: 1;
	unsigned int retune_paused: 1;
	unsigned int use_blk_mq: 1;
	unsigned int retune_crc_disable: 1;
	unsigned int can_dma_map_merge: 1;
	int rescan_disable;
	int rescan_entered;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct timer_list retune_timer;
	bool trigger_card_event;
	struct mmc_card *card;
	wait_queue_head_t wq;
	struct mmc_ctx *claimer;
	int claim_cnt;
	struct mmc_ctx default_ctx;
	struct delayed_work detect;
	int detect_change;
	struct mmc_slot slot;
	const struct mmc_bus_ops *bus_ops;
	unsigned int bus_refs;
	unsigned int sdio_irqs;
	struct task_struct *sdio_irq_thread;
	struct delayed_work sdio_irq_work;
	bool sdio_irq_pending;
	atomic_t sdio_irq_thread_abort;
	mmc_pm_flag_t pm_flags;
	struct led_trigger *led;
	bool regulator_enabled;
	struct mmc_supply supply;
	struct dentry *debugfs_root;
	struct mmc_request *ongoing_mrq;
	unsigned int actual_clock;
	unsigned int slotno;
	int dsr_req;
	u32 dsr;
	const struct mmc_cqe_ops *cqe_ops;
	void *cqe_private;
	int cqe_qdepth;
	bool cqe_enabled;
	bool cqe_on;
	bool hsq_enabled;
	int: 8;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct mmc_data;

struct mmc_command {
	u32 opcode;
	u32 arg;
	u32 resp[4];
	unsigned int flags;
	unsigned int retries;
	int error;
	unsigned int busy_timeout;
	struct mmc_data *data;
	struct mmc_request *mrq;
};

struct mmc_data {
	unsigned int timeout_ns;
	unsigned int timeout_clks;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int blk_addr;
	int error;
	unsigned int flags;
	unsigned int bytes_xfered;
	struct mmc_command *stop;
	struct mmc_request *mrq;
	unsigned int sg_len;
	int sg_count;
	struct scatterlist *sg;
	s32 host_cookie;
};

struct mmc_request {
	struct mmc_command *sbc;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command *stop;
	struct completion completion;
	struct completion cmd_completion;
	void (*done)(struct mmc_request *);
	void (*recovery_notifier)(struct mmc_request *);
	struct mmc_host *host;
	bool cap_cmd_during_tfr;
	int tag;
};

struct mmc_host_ops {
	void (*post_req)(struct mmc_host *, struct mmc_request *, int);
	void (*pre_req)(struct mmc_host *, struct mmc_request *);
	void (*request)(struct mmc_host *, struct mmc_request *);
	int (*request_atomic)(struct mmc_host *, struct mmc_request *);
	void (*set_ios)(struct mmc_host *, struct mmc_ios *);
	int (*get_ro)(struct mmc_host *);
	int (*get_cd)(struct mmc_host *);
	void (*enable_sdio_irq)(struct mmc_host *, int);
	void (*ack_sdio_irq)(struct mmc_host *);
	void (*init_card)(struct mmc_host *, struct mmc_card *);
	int (*start_signal_voltage_switch)(struct mmc_host *, struct mmc_ios *);
	int (*card_busy)(struct mmc_host *);
	int (*execute_tuning)(struct mmc_host *, u32);
	int (*prepare_hs400_tuning)(struct mmc_host *, struct mmc_ios *);
	int (*hs400_prepare_ddr)(struct mmc_host *);
	void (*hs400_downgrade)(struct mmc_host *);
	void (*hs400_complete)(struct mmc_host *);
	void (*hs400_enhanced_strobe)(struct mmc_host *, struct mmc_ios *);
	int (*select_drive_strength)(struct mmc_card *, unsigned int, int, int, int *);
	void (*hw_reset)(struct mmc_host *);
	void (*card_event)(struct mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*init_sd_express)(struct mmc_host *, struct mmc_ios *);
};

struct mmc_cqe_ops {
	int (*cqe_enable)(struct mmc_host *, struct mmc_card *);
	void (*cqe_disable)(struct mmc_host *);
	int (*cqe_request)(struct mmc_host *, struct mmc_request *);
	void (*cqe_post_req)(struct mmc_host *, struct mmc_request *);
	void (*cqe_off)(struct mmc_host *);
	int (*cqe_wait_for_idle)(struct mmc_host *);
	bool (*cqe_timeout)(struct mmc_host *, struct mmc_request *, bool *);
	void (*cqe_recovery_start)(struct mmc_host *);
	void (*cqe_recovery_finish)(struct mmc_host *);
};

struct mmc_pwrseq_ops;

struct mmc_pwrseq {
	const struct mmc_pwrseq_ops *ops;
	struct device *dev;
	struct list_head pwrseq_node;
	struct module *owner;
};

struct mmc_bus_ops {
	void (*remove)(struct mmc_host *);
	void (*detect)(struct mmc_host *);
	int (*pre_suspend)(struct mmc_host *);
	int (*suspend)(struct mmc_host *);
	int (*resume)(struct mmc_host *);
	int (*runtime_suspend)(struct mmc_host *);
	int (*runtime_resume)(struct mmc_host *);
	int (*alive)(struct mmc_host *);
	int (*shutdown)(struct mmc_host *);
	int (*hw_reset)(struct mmc_host *);
	int (*sw_reset)(struct mmc_host *);
};

struct trace_event_raw_mmc_request_start {
	struct trace_entry ent;
	u32 cmd_opcode;
	u32 cmd_arg;
	unsigned int cmd_flags;
	unsigned int cmd_retries;
	u32 stop_opcode;
	u32 stop_arg;
	unsigned int stop_flags;
	unsigned int stop_retries;
	u32 sbc_opcode;
	u32 sbc_arg;
	unsigned int sbc_flags;
	unsigned int sbc_retries;
	unsigned int blocks;
	unsigned int blk_addr;
	unsigned int blksz;
	unsigned int data_flags;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mmc_request_done {
	struct trace_entry ent;
	u32 cmd_opcode;
	int cmd_err;
	u32 cmd_resp[4];
	unsigned int cmd_retries;
	u32 stop_opcode;
	int stop_err;
	u32 stop_resp[4];
	unsigned int stop_retries;
	u32 sbc_opcode;
	int sbc_err;
	u32 sbc_resp[4];
	unsigned int sbc_retries;
	unsigned int bytes_xfered;
	int data_err;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_mmc_request_start {
	u32 name;
};

struct trace_event_data_offsets_mmc_request_done {
	u32 name;
};

typedef void (*btf_trace_mmc_request_start)(void *, struct mmc_host *, struct mmc_request *);

typedef void (*btf_trace_mmc_request_done)(void *, struct mmc_host *, struct mmc_request *);

struct mmc_pwrseq_ops {
	void (*pre_power_on)(struct mmc_host *);
	void (*post_power_on)(struct mmc_host *);
	void (*power_off)(struct mmc_host *);
	void (*reset)(struct mmc_host *);
};

enum mmc_busy_cmd {
	MMC_BUSY_CMD6 = 0,
	MMC_BUSY_ERASE = 1,
	MMC_BUSY_HPI = 2,
};

struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

struct mmc_fixup {
	const char *name;
	int: 32;
	u64 rev_start;
	u64 rev_end;
	unsigned int manfid;
	short unsigned int oemid;
	u16 cis_vendor;
	u16 cis_device;
	unsigned int ext_csd_rev;
	void (*vendor_fixup)(struct mmc_card *, int);
	int data;
};

typedef void sdio_irq_handler_t(struct sdio_func *);

struct sdio_func {
	struct mmc_card *card;
	int: 32;
	struct device dev;
	sdio_irq_handler_t *irq_handler;
	unsigned int num;
	unsigned char class;
	short unsigned int vendor;
	short unsigned int device;
	unsigned int max_blksize;
	unsigned int cur_blksize;
	unsigned int enable_timeout;
	unsigned int state;
	u8 *tmpbuf;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	int: 32;
};

struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

struct sdio_device_id {
	__u8 class;
	__u16 vendor;
	__u16 device;
	kernel_ulong_t driver_data;
};

struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;
	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);
	struct device_driver drv;
};

typedef int tpl_parse_t(struct mmc_card *, struct sdio_func *, const unsigned char *, unsigned int);

struct cis_tpl {
	unsigned char code;
	unsigned char min_size;
	tpl_parse_t *parse;
};

struct mmc_gpio {
	struct gpio_desc *ro_gpio;
	struct gpio_desc *cd_gpio;
	irqreturn_t (*cd_gpio_isr)(int, void *);
	char *ro_label;
	char *cd_label;
	u32 cd_debounce_delay_ms;
};

struct mmc_pwrseq_simple {
	struct mmc_pwrseq pwrseq;
	bool clk_enabled;
	u32 post_power_on_delay_ms;
	u32 power_off_delay_us;
	struct clk *ext_clk;
	struct gpio_descs *reset_gpios;
};

struct mmc_pwrseq_emmc {
	struct mmc_pwrseq pwrseq;
	struct notifier_block reset_nb;
	struct gpio_desc *reset_gpio;
};

struct mmc_ioc_cmd {
	int write_flag;
	int is_acmd;
	__u32 opcode;
	__u32 arg;
	__u32 response[4];
	unsigned int flags;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int postsleep_min_us;
	unsigned int postsleep_max_us;
	unsigned int data_timeout_ns;
	unsigned int cmd_timeout_ms;
	__u32 __pad;
	__u64 data_ptr;
};

struct mmc_ioc_multi_cmd {
	__u64 num_of_cmds;
	struct mmc_ioc_cmd cmds[0];
};

enum mmc_issued {
	MMC_REQ_STARTED = 0,
	MMC_REQ_BUSY = 1,
	MMC_REQ_FAILED_TO_START = 2,
	MMC_REQ_FINISHED = 3,
};

enum mmc_issue_type {
	MMC_ISSUE_SYNC = 0,
	MMC_ISSUE_DCMD = 1,
	MMC_ISSUE_ASYNC = 2,
	MMC_ISSUE_MAX = 3,
};

struct mmc_blk_request {
	struct mmc_request mrq;
	struct mmc_command sbc;
	struct mmc_command cmd;
	struct mmc_command stop;
	struct mmc_data data;
};

enum mmc_drv_op {
	MMC_DRV_OP_IOCTL = 0,
	MMC_DRV_OP_IOCTL_RPMB = 1,
	MMC_DRV_OP_BOOT_WP = 2,
	MMC_DRV_OP_GET_CARD_STATUS = 3,
	MMC_DRV_OP_GET_EXT_CSD = 4,
};

struct mmc_queue_req {
	struct mmc_blk_request brq;
	struct scatterlist *sg;
	enum mmc_drv_op drv_op;
	int drv_op_result;
	void *drv_op_data;
	unsigned int ioc_count;
	int retries;
};

struct mmc_blk_data;

struct mmc_queue {
	struct mmc_card *card;
	struct mmc_ctx ctx;
	struct blk_mq_tag_set tag_set;
	struct mmc_blk_data *blkdata;
	struct request_queue *queue;
	spinlock_t lock;
	int in_flight[3];
	unsigned int cqe_busy;
	bool busy;
	bool use_cqe;
	bool recovery_needed;
	bool in_recovery;
	bool rw_wait;
	bool waiting;
	struct work_struct recovery_work;
	wait_queue_head_t wait;
	struct request *recovery_req;
	struct request *complete_req;
	struct mutex complete_lock;
	struct work_struct complete_work;
};

struct mmc_blk_data {
	struct device *parent;
	struct gendisk *disk;
	struct mmc_queue queue;
	struct list_head part;
	struct list_head rpmbs;
	unsigned int flags;
	unsigned int usage;
	unsigned int read_only;
	unsigned int part_type;
	unsigned int reset_done;
	unsigned int part_curr;
	struct device_attribute force_ro;
	struct device_attribute power_ro_lock;
	int area_type;
	struct dentry *status_dentry;
	struct dentry *ext_csd_dentry;
};

struct mmc_rpmb_data {
	struct device dev;
	struct cdev chrdev;
	int id;
	unsigned int part_index;
	struct mmc_blk_data *md;
	struct list_head node;
};

struct mmc_blk_ioc_data {
	struct mmc_ioc_cmd ic;
	unsigned char *buf;
	int: 32;
	u64 buf_bytes;
	struct mmc_rpmb_data *rpmb;
	int: 32;
};

struct mmci_platform_data {
	unsigned int ocr_mask;
	int (*ios_handler)(struct device *, struct mmc_ios *);
	unsigned int (*status)(struct device *);
};

struct mmci_host;

struct variant_data {
	unsigned int clkreg;
	unsigned int clkreg_enable;
	unsigned int clkreg_8bit_bus_enable;
	unsigned int clkreg_neg_edge_enable;
	unsigned int cmdreg_cpsm_enable;
	unsigned int cmdreg_lrsp_crc;
	unsigned int cmdreg_srsp_crc;
	unsigned int cmdreg_srsp;
	unsigned int cmdreg_stop;
	unsigned int datalength_bits;
	unsigned int fifosize;
	unsigned int fifohalfsize;
	unsigned int data_cmd_enable;
	unsigned int datactrl_mask_ddrmode;
	unsigned int datactrl_mask_sdio;
	unsigned int datactrl_blocksz;
	u8 datactrl_any_blocksz: 1;
	u8 dma_power_of_2: 1;
	u8 datactrl_first: 1;
	u8 datacnt_useless: 1;
	u8 st_sdio: 1;
	u8 st_clkdiv: 1;
	u8 stm32_clkdiv: 1;
	u32 pwrreg_powerup;
	u32 f_max;
	u8 signal_direction: 1;
	u8 pwrreg_clkgate: 1;
	u8 busy_detect: 1;
	u8 busy_timeout: 1;
	u32 busy_dpsm_flag;
	u32 busy_detect_flag;
	u32 busy_detect_mask;
	u8 pwrreg_nopower: 1;
	u8 explicit_mclk_control: 1;
	u8 qcom_fifo: 1;
	u8 qcom_dml: 1;
	u8 reversed_irq_handling: 1;
	u8 mmcimask1: 1;
	unsigned int irq_pio_mask;
	u32 start_err;
	u32 opendrain;
	u8 dma_lli: 1;
	u32 stm32_idmabsize_mask;
	void (*init)(struct mmci_host *);
};

struct mmci_host_ops;

struct mmci_host {
	phys_addr_t phybase;
	void *base;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_command stop_abort;
	struct mmc_data *data;
	struct mmc_host *mmc;
	struct clk *clk;
	u8 singleirq: 1;
	struct reset_control *rst;
	spinlock_t lock;
	unsigned int mclk;
	unsigned int clock_cache;
	unsigned int cclk;
	u32 pwr_reg;
	u32 pwr_reg_add;
	u32 clk_reg;
	u32 clk_reg_add;
	u32 datactrl_reg;
	u32 busy_status;
	u32 mask1_reg;
	u8 vqmmc_enabled: 1;
	struct mmci_platform_data *plat;
	struct mmc_host_ops *mmc_ops;
	struct mmci_host_ops *ops;
	struct variant_data *variant;
	void *variant_priv;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_opendrain;
	u8 hw_designer;
	u8 hw_revision: 4;
	struct timer_list timer;
	unsigned int oldstat;
	u32 irq_action;
	struct sg_mapping_iter sg_miter;
	unsigned int size;
	int (*get_rx_fifocnt)(struct mmci_host *, u32, int);
	u8 use_dma: 1;
	u8 dma_in_progress: 1;
	void *dma_priv;
	s32 next_cookie;
};

struct mmci_host_ops {
	int (*validate_data)(struct mmci_host *, struct mmc_data *);
	int (*prep_data)(struct mmci_host *, struct mmc_data *, bool);
	void (*unprep_data)(struct mmci_host *, struct mmc_data *, int);
	u32 (*get_datactrl_cfg)(struct mmci_host *);
	void (*get_next_data)(struct mmci_host *, struct mmc_data *);
	int (*dma_setup)(struct mmci_host *);
	void (*dma_release)(struct mmci_host *);
	int (*dma_start)(struct mmci_host *, unsigned int *);
	void (*dma_finalize)(struct mmci_host *, struct mmc_data *);
	void (*dma_error)(struct mmci_host *);
	void (*set_clkreg)(struct mmci_host *, unsigned int);
	void (*set_pwrreg)(struct mmci_host *, unsigned int);
	bool (*busy_complete)(struct mmci_host *, u32, u32);
	void (*pre_sig_volt_switch)(struct mmci_host *);
	int (*post_sig_volt_switch)(struct mmci_host *, struct mmc_ios *);
};

struct mmci_dmae_next {
	struct dma_async_tx_descriptor *desc;
	struct dma_chan *chan;
};

struct mmci_dmae_priv {
	struct dma_chan *cur;
	struct dma_chan *rx_channel;
	struct dma_chan *tx_channel;
	struct dma_async_tx_descriptor *desc_current;
	struct mmci_dmae_next next_data;
};

struct sdmmc_lli_desc {
	u32 idmalar;
	u32 idmabase;
	u32 idmasize;
};

struct sdmmc_idma {
	dma_addr_t sg_dma;
	void *sg_cpu;
};

struct sdmmc_dlyb {
	void *base;
	u32 unit;
	u32 max;
};

struct sdhci_adma2_64_desc {
	__le16 cmd;
	__le16 len;
	__le32 addr_lo;
	__le32 addr_hi;
};

enum sdhci_cookie {
	COOKIE_UNMAPPED = 0,
	COOKIE_PRE_MAPPED = 1,
	COOKIE_MAPPED = 2,
};

struct sdhci_ops;

struct sdhci_host {
	const char *hw_name;
	unsigned int quirks;
	unsigned int quirks2;
	int irq;
	void *ioaddr;
	phys_addr_t mapbase;
	char *bounce_buffer;
	dma_addr_t bounce_addr;
	unsigned int bounce_buffer_size;
	const struct sdhci_ops *ops;
	struct mmc_host *mmc;
	struct mmc_host_ops mmc_host_ops;
	u64 dma_mask;
	struct led_classdev led;
	char led_name[32];
	spinlock_t lock;
	int flags;
	unsigned int version;
	unsigned int max_clk;
	unsigned int timeout_clk;
	unsigned int clk_mul;
	unsigned int clock;
	u8 pwr;
	bool runtime_suspended;
	bool bus_on;
	bool preset_enabled;
	bool pending_reset;
	bool irq_wake_enabled;
	bool v4_mode;
	bool use_external_dma;
	bool always_defer_done;
	struct mmc_request *mrqs_done[2];
	struct mmc_command *cmd;
	struct mmc_command *data_cmd;
	struct mmc_command *deferred_cmd;
	struct mmc_data *data;
	unsigned int data_early: 1;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int sg_count;
	void *adma_table;
	void *align_buffer;
	size_t adma_table_sz;
	size_t align_buffer_sz;
	dma_addr_t adma_addr;
	dma_addr_t align_addr;
	unsigned int desc_sz;
	unsigned int alloc_desc_sz;
	struct workqueue_struct *complete_wq;
	struct work_struct complete_work;
	struct timer_list timer;
	struct timer_list data_timer;
	struct dma_chan *rx_chan;
	struct dma_chan *tx_chan;
	u32 caps;
	u32 caps1;
	bool read_caps;
	bool sdhci_core_to_disable_vqmmc;
	unsigned int ocr_avail_sdio;
	unsigned int ocr_avail_sd;
	unsigned int ocr_avail_mmc;
	u32 ocr_mask;
	unsigned int timing;
	u32 thread_isr;
	u32 ier;
	bool cqe_on;
	u32 cqe_ier;
	u32 cqe_err_ier;
	wait_queue_head_t buf_ready_int;
	unsigned int tuning_done;
	unsigned int tuning_count;
	unsigned int tuning_mode;
	unsigned int tuning_err;
	int tuning_delay;
	int tuning_loop_count;
	u32 sdma_boundary;
	u32 adma_table_cnt;
	int: 32;
	u64 data_timeout;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct sdhci_ops {
	u32 (*read_l)(struct sdhci_host *, int);
	u16 (*read_w)(struct sdhci_host *, int);
	u8 (*read_b)(struct sdhci_host *, int);
	void (*write_l)(struct sdhci_host *, u32, int);
	void (*write_w)(struct sdhci_host *, u16, int);
	void (*write_b)(struct sdhci_host *, u8, int);
	void (*set_clock)(struct sdhci_host *, unsigned int);
	void (*set_power)(struct sdhci_host *, unsigned char, short unsigned int);
	u32 (*irq)(struct sdhci_host *, u32);
	int (*set_dma_mask)(struct sdhci_host *);
	int (*enable_dma)(struct sdhci_host *);
	unsigned int (*get_max_clock)(struct sdhci_host *);
	unsigned int (*get_min_clock)(struct sdhci_host *);
	unsigned int (*get_timeout_clock)(struct sdhci_host *);
	unsigned int (*get_max_timeout_count)(struct sdhci_host *);
	void (*set_timeout)(struct sdhci_host *, struct mmc_command *);
	void (*set_bus_width)(struct sdhci_host *, int);
	void (*platform_send_init_74_clocks)(struct sdhci_host *, u8);
	unsigned int (*get_ro)(struct sdhci_host *);
	void (*reset)(struct sdhci_host *, u8);
	int (*platform_execute_tuning)(struct sdhci_host *, u32);
	void (*set_uhs_signaling)(struct sdhci_host *, unsigned int);
	void (*hw_reset)(struct sdhci_host *);
	void (*adma_workaround)(struct sdhci_host *, u32);
	void (*card_event)(struct sdhci_host *);
	void (*voltage_switch)(struct sdhci_host *);
	void (*adma_write_desc)(struct sdhci_host *, void **, dma_addr_t, int, unsigned int);
	void (*copy_to_bounce_buffer)(struct sdhci_host *, struct mmc_data *, unsigned int);
	void (*request_done)(struct sdhci_host *, struct mmc_request *);
	void (*dump_vendor_regs)(struct sdhci_host *);
};

struct sdhci_pxa_platdata {
	unsigned int flags;
	unsigned int clk_delay_cycles;
	unsigned int clk_delay_sel;
	bool clk_delay_enable;
	unsigned int max_speed;
	u32 host_caps;
	u32 host_caps2;
	unsigned int quirks;
	unsigned int quirks2;
	unsigned int pm_caps;
};

struct sdhci_pltfm_data {
	const struct sdhci_ops *ops;
	unsigned int quirks;
	unsigned int quirks2;
};

struct sdhci_pltfm_host {
	struct clk *clk;
	unsigned int clock;
	u16 xfer_mode_shadow;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct sdhci_pxa {
	struct clk *clk_core;
	struct clk *clk_io;
	u8 power_mode;
	void *sdio3_conf_reg;
};

enum cd_types {
	S3C_SDHCI_CD_INTERNAL = 0,
	S3C_SDHCI_CD_EXTERNAL = 1,
	S3C_SDHCI_CD_GPIO = 2,
	S3C_SDHCI_CD_NONE = 3,
	S3C_SDHCI_CD_PERMANENT = 4,
};

struct s3c_sdhci_platdata {
	unsigned int max_width;
	unsigned int host_caps;
	unsigned int host_caps2;
	unsigned int pm_caps;
	enum cd_types cd_type;
	int ext_cd_gpio;
	bool ext_cd_gpio_invert;
	int (*ext_cd_init)(void (*)(struct platform_device *, int));
	int (*ext_cd_cleanup)(void (*)(struct platform_device *, int));
	void (*cfg_gpio)(struct platform_device *, int);
};

struct sdhci_s3c {
	struct sdhci_host *host;
	struct platform_device *pdev;
	struct resource *ioarea;
	struct s3c_sdhci_platdata *pdata;
	int cur_clk;
	int ext_cd_irq;
	struct clk *clk_io;
	struct clk *clk_bus[4];
	long unsigned int clk_rates[4];
	bool no_divider;
};

struct sdhci_s3c_drv_data {
	unsigned int sdhci_quirks;
	bool no_divider;
};

struct spear_sdhci {
	struct clk *clk;
};

struct omap_mmc_slot_data {
	u8 wires;
	u32 caps;
	u32 pm_caps;
	unsigned int nomux: 1;
	unsigned int cover: 1;
	unsigned int internal_clock: 1;
	unsigned int nonremovable: 1;
	unsigned int power_saving: 1;
	unsigned int no_off: 1;
	unsigned int no_regulator_off_init: 1;
	unsigned int vcc_aux_disable_is_sleep: 1;
	unsigned int features;
	int switch_pin;
	int gpio_wp;
	int (*set_bus_mode)(struct device *, int, int);
	int (*set_power)(struct device *, int, int, int);
	int (*get_ro)(struct device *, int);
	void (*remux)(struct device *, int, int);
	void (*before_set_reg)(struct device *, int, int, int);
	void (*after_set_reg)(struct device *, int, int, int);
	void (*init_card)(struct mmc_card *);
	int (*get_cover_state)(struct device *, int);
	const char *name;
	u32 ocr_mask;
	int card_detect_irq;
	int (*card_detect)(struct device *, int);
	unsigned int ban_openended: 1;
};

struct omap_mmc_platform_data {
	struct device *dev;
	unsigned int nr_slots: 2;
	unsigned int max_freq;
	int (*switch_slot)(struct device *, int);
	int (*init)(struct device *);
	void (*cleanup)(struct device *);
	void (*shutdown)(struct device *);
	int (*get_context_loss_count)(struct device *);
	u8 controller_flags;
	u16 reg_offset;
	struct omap_mmc_slot_data slots[2];
};

struct mmc_omap_host;

struct mmc_omap_slot {
	int id;
	unsigned int vdd;
	u16 saved_con;
	u16 bus_mode;
	u16 power_mode;
	unsigned int fclk_freq;
	struct tasklet_struct cover_tasklet;
	struct timer_list cover_timer;
	unsigned int cover_open;
	struct mmc_request *mrq;
	struct mmc_omap_host *host;
	struct mmc_host *mmc;
	struct omap_mmc_slot_data *pdata;
};

struct mmc_omap_host {
	int initialized;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_host *mmc;
	struct device *dev;
	unsigned char id;
	struct clk *iclk;
	struct clk *fclk;
	struct dma_chan *dma_rx;
	u32 dma_rx_burst;
	struct dma_chan *dma_tx;
	u32 dma_tx_burst;
	void *virt_base;
	unsigned int phys_base;
	int irq;
	unsigned char bus_mode;
	unsigned int reg_shift;
	struct work_struct cmd_abort_work;
	unsigned int abort: 1;
	struct timer_list cmd_abort_timer;
	struct work_struct slot_release_work;
	struct mmc_omap_slot *next_slot;
	struct work_struct send_stop_work;
	struct mmc_data *stop_data;
	unsigned int sg_len;
	int sg_idx;
	u16 *buffer;
	u32 buffer_bytes_left;
	u32 total_bytes_left;
	unsigned int features;
	unsigned int brs_received: 1;
	unsigned int dma_done: 1;
	unsigned int dma_in_use: 1;
	spinlock_t dma_lock;
	struct mmc_omap_slot *slots[2];
	struct mmc_omap_slot *current_slot;
	spinlock_t slot_lock;
	wait_queue_head_t slot_wq;
	int nr_slots;
	struct timer_list clk_timer;
	spinlock_t clk_lock;
	unsigned int fclk_enabled: 1;
	struct workqueue_struct *mmc_omap_wq;
	struct omap_mmc_platform_data *pdata;
};

struct omap_hsmmc_next {
	unsigned int dma_len;
	s32 cookie;
};

struct omap_hsmmc_host {
	struct device *dev;
	struct mmc_host *mmc;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct clk *fclk;
	struct clk *dbclk;
	struct regulator *pbias;
	bool pbias_enabled;
	void *base;
	int vqmmc_enabled;
	resource_size_t mapbase;
	spinlock_t irq_lock;
	unsigned int dma_len;
	unsigned int dma_sg_idx;
	unsigned char bus_mode;
	unsigned char power_mode;
	int suspended;
	u32 con;
	u32 hctl;
	u32 sysctl;
	u32 capa;
	int irq;
	int wake_irq;
	int use_dma;
	int dma_ch;
	struct dma_chan *tx_chan;
	struct dma_chan *rx_chan;
	int response_busy;
	int context_loss;
	int reqs_blocked;
	int req_in_progress;
	long unsigned int clk_rate;
	unsigned int flags;
	struct omap_hsmmc_next next_data;
	struct omap_hsmmc_platform_data *pdata;
};

struct omap_mmc_of_data {
	u32 reg_offset;
	u8 controller_flags;
};

struct mci_slot_pdata {
	unsigned int bus_width;
	int detect_pin;
	int wp_pin;
	bool detect_is_active_high;
	bool non_removable;
};

struct mci_platform_data {
	void *dma_slave;
	dma_filter_fn dma_filter;
	struct mci_slot_pdata slot[2];
};

enum {
	EVENT_CMD_RDY = 0,
	EVENT_XFER_COMPLETE = 1,
	EVENT_NOTBUSY = 2,
	EVENT_DATA_ERROR = 3,
};

enum atmel_mci_state {
	STATE_IDLE___4 = 0,
	STATE_SENDING_CMD = 1,
	STATE_DATA_XFER = 2,
	STATE_WAITING_NOTBUSY = 3,
	STATE_SENDING_STOP = 4,
	STATE_END_REQUEST = 5,
};

enum atmci_xfer_dir {
	XFER_RECEIVE = 0,
	XFER_TRANSMIT = 1,
};

enum atmci_pdc_buf {
	PDC_FIRST_BUF = 0,
	PDC_SECOND_BUF = 1,
};

struct atmel_mci_caps {
	bool has_dma_conf_reg;
	bool has_pdc;
	bool has_cfg_reg;
	bool has_cstor_reg;
	bool has_highspeed;
	bool has_rwproof;
	bool has_odd_clk_div;
	bool has_bad_data_ordering;
	bool need_reset_after_xfer;
	bool need_blksz_mul_4;
	bool need_notbusy_for_read_ops;
};

struct atmel_mci_dma {
	struct dma_chan *chan;
	struct dma_async_tx_descriptor *data_desc;
};

struct atmel_mci_slot;

struct atmel_mci {
	spinlock_t lock;
	void *regs;
	struct scatterlist *sg;
	unsigned int sg_len;
	unsigned int pio_offset;
	unsigned int *buffer;
	unsigned int buf_size;
	dma_addr_t buf_phys_addr;
	struct atmel_mci_slot *cur_slot;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	unsigned int data_size;
	struct atmel_mci_dma dma;
	struct dma_chan *data_chan;
	struct dma_slave_config dma_conf;
	u32 cmd_status;
	u32 data_status;
	u32 stop_cmdr;
	struct tasklet_struct tasklet;
	long unsigned int pending_events;
	long unsigned int completed_events;
	enum atmel_mci_state state;
	struct list_head queue;
	bool need_clock_update;
	bool need_reset;
	struct timer_list timer;
	u32 mode_reg;
	u32 cfg_reg;
	long unsigned int bus_hz;
	long unsigned int mapbase;
	struct clk *mck;
	struct platform_device *pdev;
	struct atmel_mci_slot *slot[2];
	struct atmel_mci_caps caps;
	u32 (*prepare_data)(struct atmel_mci *, struct mmc_data *);
	void (*submit_data)(struct atmel_mci *, struct mmc_data *);
	void (*stop_transfer)(struct atmel_mci *);
};

struct atmel_mci_slot {
	struct mmc_host *mmc;
	struct atmel_mci *host;
	u32 sdc_reg;
	u32 sdio_irq;
	struct mmc_request *mrq;
	struct list_head queue_node;
	unsigned int clock;
	long unsigned int flags;
	int detect_pin;
	int wp_pin;
	bool detect_is_active_high;
	struct timer_list detect_timer;
};

struct mvsd_host {
	void *base;
	struct mmc_request *mrq;
	spinlock_t lock;
	unsigned int xfer_mode;
	unsigned int intr_en;
	unsigned int ctrl;
	unsigned int pio_size;
	void *pio_ptr;
	unsigned int sg_frags;
	unsigned int ns_per_clk;
	unsigned int clock;
	unsigned int base_clock;
	struct timer_list timer;
	struct mmc_host *mmc;
	struct device *dev;
	struct clk *clk;
};

struct tmio_mmc_data {
	void *chan_priv_tx;
	void *chan_priv_rx;
	unsigned int hclk;
	long unsigned int capabilities;
	long unsigned int capabilities2;
	long unsigned int flags;
	u32 ocr_mask;
	int alignment_shift;
	dma_addr_t dma_rx_offset;
	unsigned int max_blk_count;
	short unsigned int max_segs;
	void (*set_pwr)(struct platform_device *, int);
	void (*set_clk_div)(struct platform_device *, int);
};

struct tmio_mmc_host;

struct tmio_mmc_dma_ops {
	void (*start)(struct tmio_mmc_host *, struct mmc_data *);
	void (*enable)(struct tmio_mmc_host *, bool);
	void (*request)(struct tmio_mmc_host *, struct tmio_mmc_data *);
	void (*release)(struct tmio_mmc_host *);
	void (*abort)(struct tmio_mmc_host *);
	void (*dataend)(struct tmio_mmc_host *);
	void (*end)(struct tmio_mmc_host *);
};

struct tmio_mmc_host {
	void *ctl;
	struct mmc_command *cmd;
	struct mmc_request *mrq;
	struct mmc_data *data;
	struct mmc_host *mmc;
	struct mmc_host_ops ops;
	void (*set_pwr)(struct platform_device *, int);
	struct scatterlist *sg_ptr;
	struct scatterlist *sg_orig;
	unsigned int sg_len;
	unsigned int sg_off;
	unsigned int bus_shift;
	struct platform_device *pdev;
	struct tmio_mmc_data *pdata;
	bool dma_on;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_tx;
	struct tasklet_struct dma_issue;
	struct scatterlist bounce_sg;
	u8 *bounce_buf;
	struct delayed_work delayed_reset_work;
	struct work_struct done;
	u32 sdcard_irq_mask;
	u32 sdio_irq_mask;
	unsigned int clk_cache;
	u32 sdcard_irq_setbit_mask;
	spinlock_t lock;
	long unsigned int last_req_ts;
	struct mutex ios_lock;
	bool native_hotplug;
	bool sdio_irq_enabled;
	int (*clk_enable)(struct tmio_mmc_host *);
	void (*set_clock)(struct tmio_mmc_host *, unsigned int);
	void (*clk_disable)(struct tmio_mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*write16_hook)(struct tmio_mmc_host *, int);
	void (*reset)(struct tmio_mmc_host *);
	bool (*check_retune)(struct tmio_mmc_host *);
	void (*fixup_request)(struct tmio_mmc_host *, struct mmc_request *);
	unsigned int (*get_timeout_cycles)(struct tmio_mmc_host *);
	void (*prepare_hs400_tuning)(struct tmio_mmc_host *);
	void (*hs400_downgrade)(struct tmio_mmc_host *);
	void (*hs400_complete)(struct tmio_mmc_host *);
	const struct tmio_mmc_dma_ops *dma_ops;
};

struct renesas_sdhi_scc {
	long unsigned int clk_rate;
	u32 tap;
	u32 tap_hs400_4tap;
};

struct renesas_sdhi_of_data {
	long unsigned int tmio_flags;
	u32 tmio_ocr_mask;
	long unsigned int capabilities;
	long unsigned int capabilities2;
	enum dma_slave_buswidth dma_buswidth;
	dma_addr_t dma_rx_offset;
	unsigned int bus_shift;
	int scc_offset;
	struct renesas_sdhi_scc *taps;
	int taps_num;
	unsigned int max_blk_count;
	short unsigned int max_segs;
};

struct renesas_sdhi_quirks {
	bool hs400_disabled;
	bool hs400_4taps;
	u32 hs400_bad_taps;
	const u8 (*hs400_calib_table)[32];
};

struct tmio_mmc_dma {
	enum dma_slave_buswidth dma_buswidth;
	bool (*filter)(struct dma_chan *, void *);
	void (*enable)(struct tmio_mmc_host *, bool);
	struct completion dma_dataend;
	struct tasklet_struct dma_complete;
};

struct renesas_sdhi {
	struct clk *clk;
	struct clk *clk_cd;
	struct tmio_mmc_data mmc_data;
	struct tmio_mmc_dma dma_priv;
	const struct renesas_sdhi_quirks *quirks;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_uhs;
	void *scc_ctl;
	u32 scc_tappos;
	u32 scc_tappos_hs400;
	const u8 *adjust_hs400_calib_table;
	bool needs_adjust_hs400;
	long unsigned int taps[1];
	long unsigned int smpcmp[1];
	unsigned int tap_num;
	unsigned int tap_set;
};

struct uniphier_sd_priv {
	struct tmio_mmc_data tmio_data;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinstate_uhs;
	struct clk *clk;
	struct reset_control *rst;
	struct reset_control *rst_br;
	struct reset_control *rst_hw;
	struct dma_chan *chan;
	enum dma_data_direction dma_dir;
	long unsigned int clk_rate;
	long unsigned int caps;
};

enum dw_mci_state {
	STATE_IDLE___5 = 0,
	STATE_SENDING_CMD___2 = 1,
	STATE_SENDING_DATA = 2,
	STATE_DATA_BUSY = 3,
	STATE_SENDING_STOP___2 = 4,
	STATE_DATA_ERROR = 5,
	STATE_SENDING_CMD11 = 6,
	STATE_WAITING_CMD11_DONE = 7,
};

enum {
	EVENT_CMD_COMPLETE = 0,
	EVENT_XFER_COMPLETE___2 = 1,
	EVENT_DATA_COMPLETE = 2,
	EVENT_DATA_ERROR___2 = 3,
};

enum dw_mci_cookie {
	COOKIE_UNMAPPED___2 = 0,
	COOKIE_PRE_MAPPED___2 = 1,
	COOKIE_MAPPED___2 = 2,
};

enum {
	TRANS_MODE_PIO = 0,
	TRANS_MODE_IDMAC = 1,
	TRANS_MODE_EDMAC = 2,
};

struct dw_mci_dma_slave {
	struct dma_chan *ch;
	enum dma_transfer_direction direction;
};

struct dw_mci_dma_ops;

struct dw_mci_board;

struct dw_mci_drv_data;

struct dw_mci_slot;

struct dw_mci {
	spinlock_t lock;
	spinlock_t irq_lock;
	void *regs;
	void *fifo_reg;
	u32 data_addr_override;
	bool wm_aligned;
	struct scatterlist *sg;
	struct sg_mapping_iter sg_miter;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command stop_abort;
	unsigned int prev_blksz;
	unsigned char timing;
	int use_dma;
	int using_dma;
	int dma_64bit_address;
	dma_addr_t sg_dma;
	void *sg_cpu;
	const struct dw_mci_dma_ops *dma_ops;
	unsigned int ring_size;
	struct dw_mci_dma_slave *dms;
	resource_size_t phy_regs;
	u32 cmd_status;
	u32 data_status;
	u32 stop_cmdr;
	u32 dir_status;
	struct tasklet_struct tasklet;
	long unsigned int pending_events;
	long unsigned int completed_events;
	enum dw_mci_state state;
	struct list_head queue;
	u32 bus_hz;
	u32 current_speed;
	u32 fifoth_val;
	u16 verid;
	struct device *dev;
	struct dw_mci_board *pdata;
	const struct dw_mci_drv_data *drv_data;
	void *priv;
	struct clk *biu_clk;
	struct clk *ciu_clk;
	struct dw_mci_slot *slot;
	int fifo_depth;
	int data_shift;
	u8 part_buf_start;
	u8 part_buf_count;
	int: 16;
	int: 32;
	union {
		u16 part_buf16;
		u32 part_buf32;
		u64 part_buf;
	};
	void (*push_data)(struct dw_mci *, void *, int);
	void (*pull_data)(struct dw_mci *, void *, int);
	bool vqmmc_enabled;
	long unsigned int irq_flags;
	int irq;
	int sdio_id0;
	struct timer_list cmd11_timer;
	struct timer_list cto_timer;
	struct timer_list dto_timer;
	int: 32;
};

struct dw_mci_dma_ops {
	int (*init)(struct dw_mci *);
	int (*start)(struct dw_mci *, unsigned int);
	void (*complete)(void *);
	void (*stop)(struct dw_mci *);
	void (*cleanup)(struct dw_mci *);
	void (*exit)(struct dw_mci *);
};

struct dma_pdata;

struct dw_mci_board {
	unsigned int bus_hz;
	u32 caps;
	u32 caps2;
	u32 pm_caps;
	unsigned int fifo_depth;
	u32 detect_delay_ms;
	struct reset_control *rstc;
	struct dw_mci_dma_ops *dma_ops;
	struct dma_pdata *data;
};

struct dw_mci_drv_data {
	long unsigned int *caps;
	u32 num_caps;
	int (*init)(struct dw_mci *);
	void (*set_ios)(struct dw_mci *, struct mmc_ios *);
	int (*parse_dt)(struct dw_mci *);
	int (*execute_tuning)(struct dw_mci_slot *, u32);
	int (*prepare_hs400_tuning)(struct dw_mci *, struct mmc_ios *);
	int (*switch_voltage)(struct mmc_host *, struct mmc_ios *);
};

struct dw_mci_slot {
	struct mmc_host *mmc;
	struct dw_mci *host;
	u32 ctype;
	struct mmc_request *mrq;
	struct list_head queue_node;
	unsigned int clock;
	unsigned int __clk_old;
	long unsigned int flags;
	int id;
	int sdio_id;
};

struct idmac_desc_64addr {
	u32 des0;
	u32 des1;
	u32 des2;
	u32 des3;
	u32 des4;
	u32 des5;
	u32 des6;
	u32 des7;
};

struct idmac_desc {
	__le32 des0;
	__le32 des1;
	__le32 des2;
	__le32 des3;
};

enum dw_mci_exynos_type {
	DW_MCI_TYPE_EXYNOS4210 = 0,
	DW_MCI_TYPE_EXYNOS4412 = 1,
	DW_MCI_TYPE_EXYNOS5250 = 2,
	DW_MCI_TYPE_EXYNOS5420 = 3,
	DW_MCI_TYPE_EXYNOS5420_SMU = 4,
	DW_MCI_TYPE_EXYNOS7 = 5,
	DW_MCI_TYPE_EXYNOS7_SMU = 6,
};

struct dw_mci_exynos_priv_data {
	enum dw_mci_exynos_type ctrl_type;
	u8 ciu_div;
	u32 sdr_timing;
	u32 ddr_timing;
	u32 hs400_timing;
	u32 tuned_sample;
	u32 cur_speed;
	u32 dqs_delay;
	u32 saved_dqs_en;
	u32 saved_strobe_ctrl;
};

struct dw_mci_exynos_compatible {
	char *compatible;
	enum dw_mci_exynos_type ctrl_type;
};

struct dw_mci_rockchip_priv_data {
	struct clk *drv_clk;
	struct clk *sample_clk;
	int default_sample_phase;
	int num_phases;
};

struct range_t {
	int start;
	int end;
};

struct sh_mmcif_plat_data {
	unsigned int slave_id_tx;
	unsigned int slave_id_rx;
	u8 sup_pclk;
	long unsigned int caps;
	u32 ocr;
};

enum sh_mmcif_state {
	STATE_IDLE___6 = 0,
	STATE_REQUEST = 1,
	STATE_IOS = 2,
	STATE_TIMEOUT = 3,
};

enum sh_mmcif_wait_for {
	MMCIF_WAIT_FOR_REQUEST = 0,
	MMCIF_WAIT_FOR_CMD = 1,
	MMCIF_WAIT_FOR_MREAD = 2,
	MMCIF_WAIT_FOR_MWRITE = 3,
	MMCIF_WAIT_FOR_READ = 4,
	MMCIF_WAIT_FOR_WRITE = 5,
	MMCIF_WAIT_FOR_READ_END = 6,
	MMCIF_WAIT_FOR_WRITE_END = 7,
	MMCIF_WAIT_FOR_STOP = 8,
};

struct sh_mmcif_host {
	struct mmc_host *mmc;
	struct mmc_request *mrq;
	struct platform_device *pd;
	struct clk *clk;
	int bus_width;
	unsigned char timing;
	bool sd_error;
	bool dying;
	long int timeout;
	void *addr;
	u32 *pio_ptr;
	spinlock_t lock;
	enum sh_mmcif_state state;
	enum sh_mmcif_wait_for wait_for;
	struct delayed_work timeout_work;
	size_t blocksize;
	int sg_idx;
	int sg_blkidx;
	bool power;
	bool ccs_enable;
	bool clk_ctrl2_enable;
	struct mutex thread_lock;
	u32 clkdiv_map;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_tx;
	struct completion dma_complete;
	bool dma_active;
};

struct wmt_dma_descriptor {
	u32 flags;
	u32 data_buffer_addr;
	u32 branch_addr;
	u32 reserved1;
};

struct wmt_mci_caps {
	unsigned int f_min;
	unsigned int f_max;
	u32 ocr_avail;
	u32 caps;
	u32 max_seg_size;
	u32 max_segs;
	u32 max_blk_size;
};

struct wmt_mci_priv {
	struct mmc_host *mmc;
	void *sdmmc_base;
	int irq_regular;
	int irq_dma;
	void *dma_desc_buffer;
	dma_addr_t dma_desc_device_addr;
	struct completion cmdcomp;
	struct completion datacomp;
	struct completion *comp_cmd;
	struct completion *comp_dma;
	struct mmc_request *req;
	struct mmc_command *cmd;
	struct clk *clk_sdmmc;
	struct device *dev;
	u8 power_inverted;
	u8 cd_inverted;
};

struct meson_mx_mmc_host {
	struct device *controller_dev;
	struct clk *parent_clk;
	struct clk *core_clk;
	struct clk_divider cfg_div;
	struct clk *cfg_div_clk;
	struct clk_fixed_factor fixed_factor;
	struct clk *fixed_factor_clk;
	void *base;
	int irq;
	spinlock_t irq_lock;
	struct timer_list cmd_timeout;
	unsigned int slot_id;
	struct mmc_host *mmc;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	int error;
};

struct sunxi_mmc_clk_delay {
	u32 output;
	u32 sample;
};

struct sunxi_idma_des {
	__le32 config;
	__le32 buf_size;
	__le32 buf_addr_ptr1;
	__le32 buf_addr_ptr2;
};

struct sunxi_mmc_cfg {
	u32 idma_des_size_bits;
	const struct sunxi_mmc_clk_delay *clk_delays;
	bool can_calibrate;
	bool mask_data0;
	bool needs_new_timings;
	bool ccu_has_timings_switch;
};

struct sunxi_mmc_host {
	struct device *dev;
	struct mmc_host *mmc;
	struct reset_control *reset;
	const struct sunxi_mmc_cfg *cfg;
	void *reg_base;
	struct clk *clk_ahb;
	struct clk *clk_mmc;
	struct clk *clk_sample;
	struct clk *clk_output;
	spinlock_t lock;
	int irq;
	u32 int_sum;
	u32 sdio_imask;
	dma_addr_t sg_dma;
	void *sg_cpu;
	bool wait_dma;
	struct mmc_request *mrq;
	struct mmc_request *manual_stop_mrq;
	int ferror;
	bool vqmmc_enabled;
	bool use_new_timings;
};

struct bcm2835_host {
	spinlock_t lock;
	struct mutex mutex;
	void *ioaddr;
	u32 phys_addr;
	struct platform_device *pdev;
	int clock;
	unsigned int max_clk;
	struct work_struct dma_work;
	struct delayed_work timeout_work;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int irq;
	u32 ns_per_fifo_word;
	u32 hcfg;
	u32 cdiv;
	struct mmc_request *mrq;
	struct mmc_command *cmd;
	struct mmc_data *data;
	bool data_complete: 1;
	bool use_busy: 1;
	bool use_sbc: 1;
	bool irq_block;
	bool irq_busy;
	bool irq_data;
	struct dma_chan *dma_chan_rxtx;
	struct dma_chan *dma_chan;
	struct dma_slave_config dma_cfg_rx;
	struct dma_slave_config dma_cfg_tx;
	struct dma_async_tx_descriptor *dma_desc;
	u32 dma_dir;
	u32 drain_words;
	struct page *drain_page;
	u32 drain_offset;
	bool use_dma;
};

enum wp_types {
	ESDHC_WP_NONE = 0,
	ESDHC_WP_CONTROLLER = 1,
	ESDHC_WP_GPIO = 2,
};

enum cd_types___2 {
	ESDHC_CD_NONE = 0,
	ESDHC_CD_CONTROLLER = 1,
	ESDHC_CD_GPIO = 2,
	ESDHC_CD_PERMANENT = 3,
};

struct esdhc_platform_data {
	enum wp_types wp_type;
	enum cd_types___2 cd_type;
	int max_bus_width;
	unsigned int delay_line;
	unsigned int tuning_step;
	unsigned int tuning_start_tap;
	unsigned int strobe_dll_delay_target;
};

struct cqhci_host_ops;

struct cqhci_slot;

struct cqhci_host {
	const struct cqhci_host_ops *ops;
	void *mmio;
	struct mmc_host *mmc;
	spinlock_t lock;
	unsigned int rca;
	bool dma64;
	int num_slots;
	int qcnt;
	u32 dcmd_slot;
	u32 caps;
	u32 quirks;
	bool enabled;
	bool halted;
	bool init_done;
	bool activated;
	bool waiting_for_idle;
	bool recovery_halt;
	size_t desc_size;
	size_t data_size;
	u8 *desc_base;
	u8 slot_sz;
	u8 task_desc_len;
	u8 link_desc_len;
	u8 *trans_desc_base;
	u8 trans_desc_len;
	dma_addr_t desc_dma_base;
	dma_addr_t trans_desc_dma_base;
	struct completion halt_comp;
	wait_queue_head_t wait_queue;
	struct cqhci_slot *slot;
};

struct cqhci_host_ops {
	void (*dumpregs)(struct mmc_host *);
	void (*write_l)(struct cqhci_host *, u32, int);
	u32 (*read_l)(struct cqhci_host *, int);
	void (*enable)(struct mmc_host *);
	void (*disable)(struct mmc_host *, bool);
	void (*update_dcmd_desc)(struct mmc_host *, struct mmc_request *, u64 *);
	void (*pre_enable)(struct mmc_host *);
	void (*post_disable)(struct mmc_host *);
};

struct esdhc_soc_data {
	u32 flags;
};

struct pltfm_imx_data {
	u32 scratchpad;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_100mhz;
	struct pinctrl_state *pins_200mhz;
	const struct esdhc_soc_data *socdata;
	struct esdhc_platform_data boarddata;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_per;
	unsigned int actual_clock;
	enum {
		NO_CMD_PENDING = 0,
		MULTIBLK_IN_PROCESS = 1,
		WAIT_FOR_INT = 2,
	} multiblock_status;
	u32 is_ddr;
	struct pm_qos_request pm_qos_req;
};

struct sdhci_tegra_soc_data {
	const struct sdhci_pltfm_data *pdata;
	int: 32;
	u64 dma_mask;
	u32 nvquirks;
	u8 min_tap_delay;
	u8 max_tap_delay;
};

struct sdhci_tegra_autocal_offsets {
	u32 pull_up_3v3;
	u32 pull_down_3v3;
	u32 pull_up_3v3_timeout;
	u32 pull_down_3v3_timeout;
	u32 pull_up_1v8;
	u32 pull_down_1v8;
	u32 pull_up_1v8_timeout;
	u32 pull_down_1v8_timeout;
	u32 pull_up_sdr104;
	u32 pull_down_sdr104;
	u32 pull_up_hs400;
	u32 pull_down_hs400;
};

struct sdhci_tegra {
	const struct sdhci_tegra_soc_data *soc_data;
	struct gpio_desc *power_gpio;
	struct clk *tmclk;
	bool ddr_signaling;
	bool pad_calib_required;
	bool pad_control_available;
	struct reset_control *rst;
	struct pinctrl *pinctrl_sdmmc;
	struct pinctrl_state *pinctrl_state_3v3;
	struct pinctrl_state *pinctrl_state_1v8;
	struct pinctrl_state *pinctrl_state_3v3_drv;
	struct pinctrl_state *pinctrl_state_1v8_drv;
	struct sdhci_tegra_autocal_offsets autocal_offsets;
	ktime_t last_calib;
	u32 default_tap;
	u32 default_trim;
	u32 dqs_trim;
	bool enable_hwcq;
	long unsigned int curr_clk_rate;
	u8 tuned_tap_delay;
};

enum pm_node_id {
	NODE_SD_0 = 39,
	NODE_SD_1 = 40,
};

enum tap_delay_type {
	PM_TAPDELAY_INPUT = 0,
	PM_TAPDELAY_OUTPUT = 1,
};

enum dll_reset_type {
	PM_DLL_RESET_ASSERT = 0,
	PM_DLL_RESET_RELEASE = 1,
	PM_DLL_RESET_PULSE = 2,
};

struct sdhci_arasan_soc_ctl_field {
	u32 reg;
	u16 width;
	s16 shift;
};

struct sdhci_arasan_soc_ctl_map {
	struct sdhci_arasan_soc_ctl_field baseclkfreq;
	struct sdhci_arasan_soc_ctl_field clockmultiplier;
	struct sdhci_arasan_soc_ctl_field support64b;
	bool hiword_update;
};

struct sdhci_arasan_clk_ops {
	const struct clk_ops *sdcardclk_ops;
	const struct clk_ops *sampleclk_ops;
};

struct sdhci_arasan_clk_data {
	struct clk_hw sdcardclk_hw;
	struct clk *sdcardclk;
	struct clk_hw sampleclk_hw;
	struct clk *sampleclk;
	int clk_phase_in[11];
	int clk_phase_out[11];
	void (*set_clk_delays)(struct sdhci_host *);
	void *clk_of_data;
};

struct sdhci_arasan_data {
	struct sdhci_host *host;
	struct clk *clk_ahb;
	struct phy *phy;
	bool is_phy_on;
	bool has_cqe;
	struct sdhci_arasan_clk_data clk_data;
	const struct sdhci_arasan_clk_ops *clk_ops;
	struct regmap *soc_ctl_base;
	const struct sdhci_arasan_soc_ctl_map *soc_ctl_map;
	unsigned int quirks;
};

struct sdhci_arasan_of_data {
	const struct sdhci_arasan_soc_ctl_map *soc_ctl_map;
	const struct sdhci_pltfm_data *pdata;
	const struct sdhci_arasan_clk_ops *clk_ops;
};

struct sdhci_at91_soc_data {
	const struct sdhci_pltfm_data *pdata;
	bool baseclk_is_generated_internally;
	unsigned int divider_for_baseclk;
};

struct sdhci_at91_priv {
	const struct sdhci_at91_soc_data *soc_data;
	struct clk *hclock;
	struct clk *gck;
	struct clk *mainck;
	bool restore_needed;
	bool cal_always_on;
};

struct esdhc_clk_fixup {
	const unsigned int sd_dflt_max_clk;
	const unsigned int max_clk[11];
};

struct sdhci_esdhc {
	u8 vendor_ver;
	u8 spec_ver;
	bool quirk_incorrect_hostver;
	bool quirk_limited_clk_division;
	bool quirk_unreliable_pulse_detection;
	bool quirk_tuning_erratum_type1;
	bool quirk_tuning_erratum_type2;
	bool quirk_ignore_data_inhibit;
	bool quirk_delay_before_data_reset;
	bool quirk_trans_complete_erratum;
	bool in_sw_tuning;
	unsigned int peripheral_clock;
	const struct esdhc_clk_fixup *clk_fixup;
	u32 div_ratio;
};

struct sdhci_bcm_kona_dev {
	struct mutex write_lock;
};

struct sdhci_iproc_data {
	const struct sdhci_pltfm_data *pdata;
	u32 caps;
	u32 caps1;
	u32 mmc_caps;
};

struct sdhci_iproc_host {
	const struct sdhci_iproc_data *data;
	u32 shadow_cmd;
	u32 shadow_blk;
	bool is_cmd_shadowed;
	bool is_blk_shadowed;
};

struct sdhci_msm_offset {
	u32 core_hc_mode;
	u32 core_mci_data_cnt;
	u32 core_mci_status;
	u32 core_mci_fifo_cnt;
	u32 core_mci_version;
	u32 core_generics;
	u32 core_testbus_config;
	u32 core_testbus_sel2_bit;
	u32 core_testbus_ena;
	u32 core_testbus_sel2;
	u32 core_pwrctl_status;
	u32 core_pwrctl_mask;
	u32 core_pwrctl_clear;
	u32 core_pwrctl_ctl;
	u32 core_sdcc_debug_reg;
	u32 core_dll_config;
	u32 core_dll_status;
	u32 core_vendor_spec;
	u32 core_vendor_spec_adma_err_addr0;
	u32 core_vendor_spec_adma_err_addr1;
	u32 core_vendor_spec_func2;
	u32 core_vendor_spec_capabilities0;
	u32 core_ddr_200_cfg;
	u32 core_vendor_spec3;
	u32 core_dll_config_2;
	u32 core_dll_config_3;
	u32 core_ddr_config_old;
	u32 core_ddr_config;
	u32 core_dll_usr_ctl;
};

struct sdhci_msm_variant_ops {
	u32 (*msm_readl_relaxed)(struct sdhci_host *, u32);
	void (*msm_writel_relaxed)(u32, struct sdhci_host *, u32);
};

struct sdhci_msm_variant_info {
	bool mci_removed;
	bool restore_dll_config;
	const struct sdhci_msm_variant_ops *var_ops;
	const struct sdhci_msm_offset *offset;
};

struct sdhci_msm_host {
	struct platform_device *pdev;
	void *core_mem;
	int pwr_irq;
	struct clk *bus_clk;
	struct clk *xo_clk;
	struct clk_bulk_data bulk_clks[4];
	long unsigned int clk_rate;
	struct mmc_host *mmc;
	struct opp_table *opp_table;
	bool use_14lpp_dll_reset;
	bool tuning_done;
	bool calibration_done;
	u8 saved_tuning_phase;
	bool use_cdclp533;
	u32 curr_pwr_state;
	u32 curr_io_level;
	wait_queue_head_t pwr_irq_wait;
	bool pwr_irq_flag;
	u32 caps_0;
	bool mci_removed;
	bool restore_dll_config;
	const struct sdhci_msm_variant_ops *var_ops;
	const struct sdhci_msm_offset *offset;
	bool use_cdr;
	u32 transfer_mode;
	bool updated_ddr_cfg;
	bool uses_tassadar_dll;
	u32 dll_config;
	u32 ddr_config;
	bool vqmmc_enabled;
};

struct st_mmc_platform_data {
	struct reset_control *rstc;
	struct clk *icnclk;
	void *top_ioaddr;
};

struct sdhci_brcmstb_priv {
	void *cfg_regs;
	bool has_cqe;
};

struct brcmstb_match_priv {
	void (*hs400es)(struct mmc_host *, struct mmc_ios *);
	struct sdhci_ops *ops;
	unsigned int flags;
};

struct sdhci_omap_data {
	u32 offset;
	u8 flags;
};

struct sdhci_omap_host {
	char *version;
	void *base;
	struct device *dev;
	struct regulator *pbias;
	bool pbias_enabled;
	struct sdhci_host *host;
	u8 bus_mode;
	u8 power_mode;
	u8 timing;
	u8 flags;
	struct pinctrl *pinctrl;
	struct pinctrl_state **pinctrl_state;
	bool is_tuning;
	u32 con;
	u32 hctl;
	u32 sysctl;
	u32 capa;
};

struct cqhci_slot {
	struct mmc_request *mrq;
	unsigned int flags;
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

typedef int (*gpio_blink_set_t)(struct gpio_desc *, int, long unsigned int *, long unsigned int *);

struct gpio_led {
	const char *name;
	const char *default_trigger;
	unsigned int gpio;
	unsigned int active_low: 1;
	unsigned int retain_state_suspended: 1;
	unsigned int panic_indicator: 1;
	unsigned int default_state: 2;
	unsigned int retain_state_shutdown: 1;
	struct gpio_desc *gpiod;
};

struct gpio_led_platform_data {
	int num_leds;
	const struct gpio_led *leds;
	gpio_blink_set_t gpio_blink_set;
};

struct gpio_led_data {
	struct led_classdev cdev;
	struct gpio_desc *gpiod;
	u8 can_sleep;
	u8 blinking;
	gpio_blink_set_t platform_gpio_blink_set;
};

struct gpio_leds_priv {
	int num_leds;
	struct gpio_led_data leds[0];
};

enum ns2_led_modes {
	NS_V2_LED_OFF = 0,
	NS_V2_LED_ON = 1,
	NS_V2_LED_SATA = 2,
};

struct ns2_led_modval {
	u32 mode;
	u32 cmd_level;
	u32 slow_level;
};

struct ns2_led {
	struct led_classdev cdev;
	struct gpio_desc *cmd;
	struct gpio_desc *slow;
	bool can_sleep;
	unsigned char sata;
	rwlock_t rw_lock;
	int num_modes;
	struct ns2_led_modval *modval;
};

struct led_pwm {
	const char *name;
	u8 active_low;
	unsigned int max_brightness;
};

struct led_pwm_data {
	struct led_classdev cdev;
	struct pwm_device *pwm;
	int: 32;
	struct pwm_state pwmstate;
	unsigned int active_low;
	int: 32;
};

struct led_pwm_priv {
	int num_leds;
	int: 32;
	struct led_pwm_data leds[0];
};

struct oneshot_trig_data {
	unsigned int invert;
};

struct heartbeat_trig_data {
	struct led_classdev *led_cdev;
	unsigned int phase;
	unsigned int period;
	struct timer_list timer;
	unsigned int invert;
};

struct bl_trig_notifier {
	struct led_classdev *led;
	int brightness;
	int old_status;
	struct notifier_block notifier;
	unsigned int invert;
};

struct gpio_trig_data {
	struct led_classdev *led;
	unsigned int desired_brightness;
	unsigned int inverted;
	unsigned int gpio;
};

struct led_trigger_cpu {
	bool is_active;
	char name[8];
	struct led_trigger *_trig;
};

struct transient_trig_data {
	int activate;
	int state;
	int restore_state;
	long unsigned int duration;
	struct timer_list timer;
	struct led_classdev *led_cdev;
};

enum dmi_entry_type {
	DMI_ENTRY_BIOS = 0,
	DMI_ENTRY_SYSTEM = 1,
	DMI_ENTRY_BASEBOARD = 2,
	DMI_ENTRY_CHASSIS = 3,
	DMI_ENTRY_PROCESSOR = 4,
	DMI_ENTRY_MEM_CONTROLLER = 5,
	DMI_ENTRY_MEM_MODULE = 6,
	DMI_ENTRY_CACHE = 7,
	DMI_ENTRY_PORT_CONNECTOR = 8,
	DMI_ENTRY_SYSTEM_SLOT = 9,
	DMI_ENTRY_ONBOARD_DEVICE = 10,
	DMI_ENTRY_OEMSTRINGS = 11,
	DMI_ENTRY_SYSCONF = 12,
	DMI_ENTRY_BIOS_LANG = 13,
	DMI_ENTRY_GROUP_ASSOC = 14,
	DMI_ENTRY_SYSTEM_EVENT_LOG = 15,
	DMI_ENTRY_PHYS_MEM_ARRAY = 16,
	DMI_ENTRY_MEM_DEVICE = 17,
	DMI_ENTRY_32_MEM_ERROR = 18,
	DMI_ENTRY_MEM_ARRAY_MAPPED_ADDR = 19,
	DMI_ENTRY_MEM_DEV_MAPPED_ADDR = 20,
	DMI_ENTRY_BUILTIN_POINTING_DEV = 21,
	DMI_ENTRY_PORTABLE_BATTERY = 22,
	DMI_ENTRY_SYSTEM_RESET = 23,
	DMI_ENTRY_HW_SECURITY = 24,
	DMI_ENTRY_SYSTEM_POWER_CONTROLS = 25,
	DMI_ENTRY_VOLTAGE_PROBE = 26,
	DMI_ENTRY_COOLING_DEV = 27,
	DMI_ENTRY_TEMP_PROBE = 28,
	DMI_ENTRY_ELECTRICAL_CURRENT_PROBE = 29,
	DMI_ENTRY_OOB_REMOTE_ACCESS = 30,
	DMI_ENTRY_BIS_ENTRY = 31,
	DMI_ENTRY_SYSTEM_BOOT = 32,
	DMI_ENTRY_MGMT_DEV = 33,
	DMI_ENTRY_MGMT_DEV_COMPONENT = 34,
	DMI_ENTRY_MGMT_DEV_THRES = 35,
	DMI_ENTRY_MEM_CHANNEL = 36,
	DMI_ENTRY_IPMI_DEV = 37,
	DMI_ENTRY_SYS_POWER_SUPPLY = 38,
	DMI_ENTRY_ADDITIONAL = 39,
	DMI_ENTRY_ONBOARD_DEV_EXT = 40,
	DMI_ENTRY_MGMT_CONTROLLER_HOST = 41,
	DMI_ENTRY_INACTIVE = 126,
	DMI_ENTRY_END_OF_TABLE = 127,
};

struct dmi_header {
	u8 type;
	u8 length;
	u16 handle;
};

struct dmi_memdev_info {
	const char *device;
	const char *bank;
	u64 size;
	u16 handle;
	u8 type;
	int: 8;
	int: 32;
};

struct dmi_device_attribute {
	struct device_attribute dev_attr;
	int field;
};

struct mafield {
	const char *prefix;
	int field;
};

enum rpi_firmware_property_status {
	RPI_FIRMWARE_STATUS_REQUEST = 0,
	RPI_FIRMWARE_STATUS_SUCCESS = 2147483648,
	RPI_FIRMWARE_STATUS_ERROR = 2147483649,
};

struct rpi_firmware_property_tag_header {
	u32 tag;
	u32 buf_size;
	u32 req_resp_size;
};

struct rpi_firmware___2 {
	struct mbox_client cl;
	struct mbox_chan *chan;
	struct completion c;
	u32 enabled;
};

struct qcom_scm_hdcp_req {
	u32 addr;
	u32 val;
};

struct qcom_scm_vmperm {
	int vmid;
	int perm;
};

enum qcom_scm_ocmem_client {
	QCOM_SCM_OCMEM_UNUSED_ID = 0,
	QCOM_SCM_OCMEM_GRAPHICS_ID = 1,
	QCOM_SCM_OCMEM_VIDEO_ID = 2,
	QCOM_SCM_OCMEM_LP_AUDIO_ID = 3,
	QCOM_SCM_OCMEM_SENSORS_ID = 4,
	QCOM_SCM_OCMEM_OTHER_OS_ID = 5,
	QCOM_SCM_OCMEM_DEBUG_ID = 6,
};

enum qcom_scm_ice_cipher {
	QCOM_SCM_ICE_CIPHER_AES_128_XTS = 0,
	QCOM_SCM_ICE_CIPHER_AES_128_CBC = 1,
	QCOM_SCM_ICE_CIPHER_AES_256_XTS = 3,
	QCOM_SCM_ICE_CIPHER_AES_256_CBC = 4,
};

enum qcom_scm_convention {
	SMC_CONVENTION_UNKNOWN = 0,
	SMC_CONVENTION_LEGACY = 1,
	SMC_CONVENTION_ARM_32 = 2,
	SMC_CONVENTION_ARM_64 = 3,
};

enum qcom_scm_arg_types {
	QCOM_SCM_VAL = 0,
	QCOM_SCM_RO = 1,
	QCOM_SCM_RW = 2,
	QCOM_SCM_BUFVAL = 3,
};

struct qcom_scm_desc {
	u32 svc;
	u32 cmd;
	u32 arginfo;
	int: 32;
	u64 args[10];
	u32 owner;
	int: 32;
};

struct qcom_scm_res {
	u64 result[3];
};

struct qcom_scm {
	struct device *dev;
	struct clk *core_clk;
	struct clk *iface_clk;
	struct clk *bus_clk;
	struct reset_controller_dev reset;
	int: 32;
	u64 dload_mode_addr;
};

struct qcom_scm_current_perm_info {
	__le32 vmid;
	__le32 perm;
	__le64 ctx;
	__le32 ctx_size;
	__le32 unused;
};

struct qcom_scm_mem_map_info {
	__le64 mem_addr;
	__le64 mem_size;
};

struct qcom_scm_wb_entry {
	int flag;
	void *entry;
};

struct arm_smccc_quirk {
	int id;
	union {
		long unsigned int a6;
	} state;
};

struct arm_smccc_args {
	long unsigned int args[8];
};

struct scm_legacy_command {
	__le32 len;
	__le32 buf_offset;
	__le32 resp_hdr_offset;
	__le32 id;
	__le32 buf[0];
};

struct scm_legacy_response {
	__le32 len;
	__le32 buf_offset;
	__le32 is_complete;
};

struct trusted_foundations_platform_data {
	unsigned int version_major;
	unsigned int version_minor;
};

struct nvram_header {
	u32 magic;
	u32 len;
	u32 crc_ver_init;
	u32 config_refresh;
	u32 config_ncdl;
};

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	efi_guid_t guid;
	long unsigned int *ptr;
	const char name[16];
} efi_config_table_type_t;

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
};

struct efivars {
	struct kset *kset;
	struct kobject *kobject;
	const struct efivar_operations *ops;
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	long unsigned int DataSize;
	__u8 Data[1024];
	efi_status_t Status;
	__u32 Attributes;
};

struct efivar_entry {
	struct efi_variable var;
	struct list_head list;
	struct kobject kobj;
	bool scanning;
	bool deleting;
};

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, long unsigned int);
};

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 reserved;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

typedef u64 efi_physical_addr_t;

typedef struct {
	u64 length;
	u64 data;
} efi_capsule_block_desc_t;

enum {
	SYSTAB = 0,
	MMBASE = 1,
	MMSIZE = 2,
	DCSIZE = 3,
	DCVERS = 4,
	PARAMCOUNT = 5,
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
	ssize_t (*store)(struct esre_entry *, const char *, size_t);
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
};

struct efi_runtime_work {
	void *arg1;
	void *arg2;
	void *arg3;
	void *arg4;
	void *arg5;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
};

union efi_boot_services;

typedef union efi_boot_services efi_boot_services_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

typedef union {
	struct {
		efi_table_hdr_t hdr;
		long unsigned int fw_vendor;
		u32 fw_revision;
		long unsigned int con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		long unsigned int con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		long unsigned int stderr_handle;
		long unsigned int stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		long unsigned int nr_tables;
		long unsigned int tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

struct efi_arm_entry_state {
	u32 cpsr_before_ebs;
	u32 sctlr_before_ebs;
	u32 cpsr_after_ebs;
	u32 sctlr_after_ebs;
};

struct psci_0_1_function_ids {
	u32 cpu_suspend;
	u32 cpu_on;
	u32 cpu_off;
	u32 migrate;
};

typedef long unsigned int psci_fn(long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef int (*psci_initcall_t)(const struct device_node *);

struct meson_desc {
	__le32 t_status;
	__le32 t_src;
	__le32 t_dst;
};

struct meson_flow {
	struct crypto_engine *engine;
	struct completion complete;
	int status;
	unsigned int keylen;
	dma_addr_t t_phy;
	struct meson_desc *tl;
};

struct meson_dev {
	void *base;
	struct clk *busclk;
	struct device *dev;
	struct meson_flow *chanlist;
	atomic_t flow;
	int *irqs;
};

struct meson_alg_template {
	u32 type;
	u32 blockmode;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct skcipher_alg skcipher;
	} alg;
	struct meson_dev *mc;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct meson_cipher_req_ctx {
	u32 op_dir;
	int flow;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct skcipher_request fallback_req;
};

struct meson_cipher_tfm_ctx {
	struct crypto_engine_ctx enginectx;
	u32 *key;
	u32 keylen;
	u32 keymode;
	struct meson_dev *mc;
	struct crypto_skcipher *fallback_tfm;
};

struct of_timer_irq {
	int irq;
	int index;
	int percpu;
	const char *name;
	long unsigned int flags;
	irq_handler_t handler;
};

struct of_timer_base {
	void *base;
	const char *name;
	int index;
};

struct of_timer_clk {
	struct clk *clk;
	const char *name;
	int index;
	long unsigned int rate;
	long unsigned int period;
};

struct timer_of {
	unsigned int flags;
	struct device_node *np;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device clkevt;
	struct of_timer_base of_base;
	struct of_timer_irq of_irq;
	struct of_timer_clk of_clk;
	void *private_data;
	int: 32;
};

struct pit_data {
	struct clock_event_device clkevt;
	struct clocksource clksrc;
	void *base;
	u32 cycle;
	u32 cnt;
	unsigned int irq;
	struct clk *mck;
	int: 32;
};

struct tc_clkevt_device {
	struct clock_event_device clkevt;
	struct clk *clk;
	u32 rate;
	void *regs;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sh_timer_config {
	unsigned int channels_mask;
};

enum sh_cmt_model {
	SH_CMT_16BIT = 0,
	SH_CMT_32BIT = 1,
	SH_CMT_48BIT = 2,
	SH_CMT0_RCAR_GEN2 = 3,
	SH_CMT1_RCAR_GEN2 = 4,
};

struct sh_cmt_info {
	enum sh_cmt_model model;
	unsigned int channels_mask;
	long unsigned int width;
	u32 overflow_bit;
	u32 clear_bits;
	u32 (*read_control)(void *, long unsigned int);
	void (*write_control)(void *, long unsigned int, u32);
	u32 (*read_count)(void *, long unsigned int);
	void (*write_count)(void *, long unsigned int, u32);
};

struct sh_cmt_device;

struct sh_cmt_channel {
	struct sh_cmt_device *cmt;
	unsigned int index;
	unsigned int hwidx;
	void *iostart;
	void *ioctrl;
	unsigned int timer_bit;
	long unsigned int flags;
	u32 match_value;
	u32 next_match_value;
	u32 max_match_value;
	raw_spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ced;
	struct clocksource cs;
	u64 total_cycles;
	bool cs_enabled;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
};

struct sh_cmt_device {
	struct platform_device *pdev;
	const struct sh_cmt_info *info;
	void *mapbase;
	struct clk *clk;
	long unsigned int rate;
	raw_spinlock_t lock;
	struct sh_cmt_channel *channels;
	unsigned int num_channels;
	unsigned int hw_channels;
	bool has_clockevent;
	bool has_clocksource;
};

struct sh_mtu2_device;

struct sh_mtu2_channel {
	struct sh_mtu2_device *mtu;
	unsigned int index;
	void *base;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ced;
};

struct sh_mtu2_device {
	struct platform_device *pdev;
	void *mapbase;
	struct clk *clk;
	raw_spinlock_t lock;
	struct sh_mtu2_channel *channels;
	unsigned int num_channels;
	bool has_clockevent;
};

enum sh_tmu_model {
	SH_TMU = 0,
	SH_TMU_SH3 = 1,
};

struct sh_tmu_device;

struct sh_tmu_channel {
	struct sh_tmu_device *tmu;
	unsigned int index;
	void *base;
	int irq;
	long unsigned int periodic;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ced;
	struct clocksource cs;
	bool cs_enabled;
	unsigned int enable_count;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sh_tmu_device {
	struct platform_device *pdev;
	void *mapbase;
	struct clk *clk;
	long unsigned int rate;
	enum sh_tmu_model model;
	raw_spinlock_t lock;
	struct sh_tmu_channel *channels;
	unsigned int num_channels;
	bool has_clockevent;
	bool has_clocksource;
};

enum {
	USER_CLOCKSOURCE = 0,
	USER_CLOCKEVENT = 1,
	USER_NR = 2,
};

struct em_sti_priv {
	void *base;
	struct clk *clk;
	struct platform_device *pdev;
	unsigned int active[2];
	long unsigned int rate;
	raw_spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ced;
	struct clocksource cs;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct clocksource_mmio {
	void *reg;
	int: 32;
	struct clocksource clksrc;
};

enum {
	TIMER_A = 0,
	TIMER_B = 1,
	TIMER_C = 2,
	TIMER_D = 3,
	TIMER_E = 4,
	TIMER_F = 5,
	TIMER_G = 6,
	TIMER_H = 7,
};

struct digicolor_timer {
	struct clock_event_device ce;
	void *base;
	u32 ticks_per_jiffy;
	int timer_id;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct omap_dm_timer;

struct omap_dm_timer_ops {
	struct omap_dm_timer * (*request_by_node)(struct device_node *);
	struct omap_dm_timer * (*request_specific)(int);
	struct omap_dm_timer * (*request)();
	int (*free)(struct omap_dm_timer *);
	void (*enable)(struct omap_dm_timer *);
	void (*disable)(struct omap_dm_timer *);
	int (*get_irq)(struct omap_dm_timer *);
	int (*set_int_enable)(struct omap_dm_timer *, unsigned int);
	int (*set_int_disable)(struct omap_dm_timer *, u32);
	struct clk * (*get_fclk)(struct omap_dm_timer *);
	int (*start)(struct omap_dm_timer *);
	int (*stop)(struct omap_dm_timer *);
	int (*set_source)(struct omap_dm_timer *, int);
	int (*set_load)(struct omap_dm_timer *, unsigned int);
	int (*set_match)(struct omap_dm_timer *, int, unsigned int);
	int (*set_pwm)(struct omap_dm_timer *, int, int, int, int);
	int (*get_pwm_status)(struct omap_dm_timer *);
	int (*set_prescaler)(struct omap_dm_timer *, int);
	unsigned int (*read_counter)(struct omap_dm_timer *);
	int (*write_counter)(struct omap_dm_timer *, unsigned int);
	unsigned int (*read_status)(struct omap_dm_timer *);
	int (*write_status)(struct omap_dm_timer *, unsigned int);
};

struct timer_regs {
	u32 tidr;
	u32 tier;
	u32 twer;
	u32 tclr;
	u32 tcrr;
	u32 tldr;
	u32 ttrg;
	u32 twps;
	u32 tmar;
	u32 tcar1;
	u32 tsicr;
	u32 tcar2;
	u32 tpir;
	u32 tnir;
	u32 tcvr;
	u32 tocr;
	u32 towr;
};

struct omap_dm_timer {
	int id;
	int irq;
	struct clk *fclk;
	void *io_base;
	void *irq_stat;
	void *irq_ena;
	void *irq_dis;
	void *pend;
	void *func_base;
	atomic_t enabled;
	long unsigned int rate;
	unsigned int reserved: 1;
	unsigned int posted: 1;
	struct timer_regs context;
	int revision;
	u32 capability;
	u32 errata;
	struct platform_device *pdev;
	struct list_head node;
	struct notifier_block nb;
};

struct dmtimer_platform_data {
	int (*set_timer_src)(struct platform_device *, int);
	u32 timer_capability;
	u32 timer_errata;
	int (*get_context_loss_count)(struct device *);
	const struct omap_dm_timer_ops *timer_ops;
};

enum {
	REQUEST_ANY = 0,
	REQUEST_BY_ID = 1,
	REQUEST_BY_CAP = 2,
	REQUEST_BY_NODE = 3,
};

struct dmtimer_systimer {
	void *base;
	u8 sysc;
	u8 irq_stat;
	u8 irq_ena;
	u8 pend;
	u8 load;
	u8 counter;
	u8 ctrl;
	u8 wakeup;
	u8 ifctrl;
	struct clk *fck;
	struct clk *ick;
	long unsigned int rate;
};

struct dmtimer_clockevent {
	struct clock_event_device dev;
	struct dmtimer_systimer t;
	u32 period;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct dmtimer_clocksource {
	struct clocksource dev;
	struct dmtimer_systimer t;
	unsigned int loadval;
};

struct dw_apb_timer {
	void *base;
	long unsigned int freq;
	int irq;
};

struct dw_apb_clock_event_device {
	struct clock_event_device ced;
	struct dw_apb_timer timer;
	void (*eoi)(struct dw_apb_timer *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct dw_apb_clocksource {
	struct dw_apb_timer timer;
	int: 32;
	struct clocksource cs;
};

struct rk_timer {
	void *base;
	void *ctrl;
	struct clk *clk;
	struct clk *pclk;
	u32 freq;
	int irq;
};

struct rk_clkevt {
	struct clock_event_device ce;
	struct rk_timer timer;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bcm2835_timer {
	void *control;
	void *compare;
	int match_mask;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device evt;
};

struct sun5i_timer {
	void *base;
	struct clk *clk;
	struct notifier_block clk_rate_cb;
	u32 ticks_per_jiffy;
};

struct sun5i_timer_clksrc {
	struct sun5i_timer timer;
	struct clocksource clksrc;
};

struct sun5i_timer_clkevt {
	struct sun5i_timer timer;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device clkevt;
};

struct kona_bcm_timers {
	int tmr_irq;
	void *tmr_regs;
};

struct ttc_timer {
	void *base_addr;
	long unsigned int freq;
	struct clk *clk;
	struct notifier_block clk_rate_change_nb;
};

struct ttc_timer_clocksource {
	u32 scale_clk_ctrl_reg_old;
	u32 scale_clk_ctrl_reg_new;
	struct ttc_timer ttc;
	struct clocksource cs;
};

struct ttc_timer_clockevent {
	struct ttc_timer ttc;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ce;
};

struct stm32_timer_private {
	int bits;
};

enum {
	MCT_INT_SPI = 0,
	MCT_INT_PPI = 1,
};

enum {
	MCT_G0_IRQ = 0,
	MCT_G1_IRQ = 1,
	MCT_G2_IRQ = 2,
	MCT_G3_IRQ = 3,
	MCT_L0_IRQ = 4,
	MCT_L1_IRQ = 5,
	MCT_L2_IRQ = 6,
	MCT_L3_IRQ = 7,
	MCT_L4_IRQ = 8,
	MCT_L5_IRQ = 9,
	MCT_L6_IRQ = 10,
	MCT_L7_IRQ = 11,
	MCT_NR_IRQS = 12,
};

struct mct_clock_event_device {
	struct clock_event_device evt;
	long unsigned int base;
	char name[10];
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct samsung_pwm_variant {
	u8 bits;
	u8 div_base;
	u8 tclk_mask;
	u8 output_mask;
	bool has_tint_cstat;
};

struct samsung_pwm_clocksource {
	void *base;
	void *source_reg;
	unsigned int irq[5];
	struct samsung_pwm_variant variant;
	struct clk *timerclk;
	unsigned int event_id;
	unsigned int source_id;
	unsigned int tcnt_max;
	unsigned int tscaler_div;
	unsigned int tdiv;
	long unsigned int clock_count_per_tick;
};

struct ti_32k {
	void *base;
	void *counter;
	struct clocksource cs;
};

enum arch_timer_reg {
	ARCH_TIMER_REG_CTRL = 0,
	ARCH_TIMER_REG_TVAL = 1,
};

enum arch_timer_ppi_nr {
	ARCH_TIMER_PHYS_SECURE_PPI = 0,
	ARCH_TIMER_PHYS_NONSECURE_PPI = 1,
	ARCH_TIMER_VIRT_PPI = 2,
	ARCH_TIMER_HYP_PPI = 3,
	ARCH_TIMER_MAX_TIMER_PPI = 4,
};

enum arch_timer_spi_nr {
	ARCH_TIMER_PHYS_SPI = 0,
	ARCH_TIMER_VIRT_SPI = 1,
	ARCH_TIMER_MAX_TIMER_SPI = 2,
};

struct arch_timer_kvm_info {
	struct timecounter timecounter;
	int virtual_irq;
	int physical_irq;
};

struct arch_timer_mem_frame {
	bool valid;
	phys_addr_t cntbase;
	size_t size;
	int phys_irq;
	int virt_irq;
};

struct arch_timer_mem {
	phys_addr_t cntctlbase;
	size_t size;
	struct arch_timer_mem_frame frame[8];
};

struct arch_timer {
	void *base;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device evt;
};

struct sp804_timer {
	int load;
	int load_h;
	int value;
	int value_h;
	int ctrl;
	int intclr;
	int ris;
	int mis;
	int bgload;
	int bgload_h;
	int timer_base[2];
	int width;
};

struct sp804_clkevt {
	void *base;
	void *load;
	void *load_h;
	void *value;
	void *value_h;
	void *ctrl;
	void *intclr;
	void *ris;
	void *mis;
	void *bgload;
	void *bgload_h;
	long unsigned int reload;
	int width;
};

struct keystone_timer {
	void *base;
	long unsigned int hz_period;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device event_dev;
};

enum imx_gpt_type {
	GPT_TYPE_IMX1 = 0,
	GPT_TYPE_IMX21 = 1,
	GPT_TYPE_IMX31 = 2,
	GPT_TYPE_IMX6DL = 3,
};

struct imx_gpt_data;

struct imx_timer {
	enum imx_gpt_type type;
	void *base;
	int irq;
	struct clk *clk_per;
	struct clk *clk_ipg;
	const struct imx_gpt_data *gpt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ced;
};

struct imx_gpt_data {
	int reg_tstat;
	int reg_tcn;
	int reg_tcmp;
	void (*gpt_setup_tctl)(struct imx_timer *);
	void (*gpt_irq_enable)(struct imx_timer *);
	void (*gpt_irq_disable)(struct imx_timer *);
	void (*gpt_irq_acknowledge)(struct imx_timer *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
};

struct st_clksrc_ddata {
	struct clk *clk;
	void *base;
};

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_report;

struct hid_input;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
};

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	unsigned int id;
	unsigned int type;
	unsigned int application;
	struct hid_field *field[256];
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	bool registered;
	struct list_head reports;
	unsigned int application;
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	int: 32;
	struct device dev;
	struct hid_driver *driver;
	struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	long unsigned int last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	long unsigned int last_out;
	struct mutex mutex;
	spinlock_t lock;
	long unsigned int iofl;
	struct timer_list io_retry;
	long unsigned int stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct alias_prop {
	struct list_head link;
	const char *alias;
	struct device_node *np;
	int id;
	char stem[0];
};

struct of_endpoint {
	unsigned int port;
	unsigned int id;
	const struct device_node *local_node;
};

struct supplier_bindings {
	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
};

struct of_changeset_entry {
	struct list_head node;
	long unsigned int action;
	struct device_node *np;
	struct property *prop;
	struct property *old_prop;
};

struct of_bus___2 {
	void (*count_cells)(const void *, int, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
};

struct of_bus {
	const char *name;
	const char *addresses;
	int (*match)(struct device_node *);
	void (*count_cells)(struct device_node *, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
	bool has_flags;
	unsigned int (*get_flags)(const __be32 *);
};

struct of_intc_desc {
	struct list_head list;
	of_irq_init_cb_t irq_init_cb;
	struct device_node *dev;
	struct device_node *interrupt_parent;
};

struct rmem_assigned_device {
	struct device *dev;
	struct reserved_mem *rmem;
	struct list_head list;
};

enum of_overlay_notify_action {
	OF_OVERLAY_PRE_APPLY = 0,
	OF_OVERLAY_POST_APPLY = 1,
	OF_OVERLAY_PRE_REMOVE = 2,
	OF_OVERLAY_POST_REMOVE = 3,
};

struct of_overlay_notify_data {
	struct device_node *overlay;
	struct device_node *target;
};

struct target {
	struct device_node *np;
	bool in_livetree;
};

struct fragment {
	struct device_node *overlay;
	struct device_node *target;
};

struct overlay_changeset {
	int id;
	struct list_head ovcs_list;
	const void *fdt;
	struct device_node *overlay_tree;
	int count;
	struct fragment *fragments;
	bool symbols_fragment;
	struct of_changeset cset;
};

struct bcma_device_id_name {
	u16 id;
	const char *name;
};

enum bcma_clkmode {
	BCMA_CLKMODE_FAST = 0,
	BCMA_CLKMODE_DYNAMIC = 1,
};

struct bcma_sflash_tbl_e {
	char *name;
	u32 id;
	u32 blocksize;
	u16 numblocks;
};

struct bcma_soc {
	struct bcma_bus bus;
	struct device *dev;
};

enum nvec_msg_type {
	NVEC_SYS = 1,
	NVEC_BAT = 2,
	NVEC_GPIO = 3,
	NVEC_SLEEP = 4,
	NVEC_KBD = 5,
	NVEC_PS2 = 6,
	NVEC_CNTL = 7,
	NVEC_OEM0 = 13,
	NVEC_KB_EVT = 128,
	NVEC_PS2_EVT = 129,
};

struct nvec_msg {
	struct list_head node;
	unsigned char data[34];
	short unsigned int size;
	short unsigned int pos;
	atomic_t used;
};

struct nvec_chip {
	struct device *dev;
	struct gpio_desc *gpiod;
	int irq;
	u32 i2c_addr;
	void *base;
	struct clk *i2c_clk;
	struct reset_control *rst;
	struct atomic_notifier_head notifier_list;
	struct list_head rx_data;
	struct list_head tx_data;
	struct notifier_block nvec_status_notifier;
	struct work_struct rx_work;
	struct work_struct tx_work;
	struct workqueue_struct *wq;
	struct nvec_msg msg_pool[64];
	struct nvec_msg *rx;
	struct nvec_msg *tx;
	struct nvec_msg tx_scratch;
	struct completion ec_transfer;
	spinlock_t tx_lock;
	spinlock_t rx_lock;
	struct mutex sync_write_mutex;
	struct completion sync_write;
	u16 sync_write_pending;
	struct nvec_msg *last_sync_msg;
	int state;
};

enum ps2_subcmds {
	SEND_COMMAND = 1,
	RECEIVE_N = 2,
	AUTO_RECEIVE_N = 3,
	CANCEL_AUTO_RECEIVE = 4,
};

struct nvec_ps2 {
	struct serio *ser_dev;
	struct notifier_block notifier;
	struct nvec_chip *nvec;
};

enum nvec_event_size {
	NVEC_2BYTES = 0,
	NVEC_3BYTES = 1,
	NVEC_VAR_SIZE = 2,
};

enum nvec_msg_category {
	NVEC_MSG_RX = 0,
	NVEC_MSG_TX = 1,
};

enum nvec_sleep_subcmds {
	GLOBAL_EVENTS = 0,
	AP_PWR_DOWN = 1,
	AP_SUSPEND = 2,
};

struct nvec_power {
	struct notifier_block notifier;
	struct delayed_work poller;
	struct nvec_chip *nvec;
	int on;
	int bat_present;
	int bat_status;
	int bat_voltage_now;
	int bat_current_now;
	int bat_current_avg;
	int time_remain;
	int charge_full_design;
	int charge_last_full;
	int critical_capacity;
	int capacity_remain;
	int bat_temperature;
	int bat_cap;
	int bat_type_enum;
	char bat_manu[30];
	char bat_model[30];
	char bat_type[30];
};

enum {
	SLOT_STATUS = 0,
	VOLTAGE = 1,
	TIME_REMAINING = 2,
	CURRENT = 3,
	AVERAGE_CURRENT = 4,
	AVERAGING_TIME_INTERVAL = 5,
	CAPACITY_REMAINING = 6,
	LAST_FULL_CHARGE_CAPACITY = 7,
	DESIGN_CAPACITY = 8,
	CRITICAL_CAPACITY = 9,
	TEMPERATURE = 10,
	MANUFACTURER = 11,
	MODEL = 12,
	TYPE___2 = 13,
};

enum {
	AC = 0,
	BAT = 1,
};

struct bat_response {
	u8 event_type;
	u8 length;
	u8 sub_type;
	u8 status;
	union {
		char plc[30];
		u16 plu;
		s16 pls;
	};
};

enum kbd_subcmds {
	CNFG_WAKE = 3,
	CNFG_WAKE_KEY_REPORTING = 4,
	SET_LEDS = 237,
	ENABLE_KBD = 244,
	DISABLE_KBD = 245,
};

struct nvec_keys {
	struct input_dev *input;
	struct notifier_block notifier;
	struct nvec_chip *nvec;
	bool caps_lock;
};

struct nvec_led {
	struct led_classdev cdev;
	struct nvec_chip *nvec;
};

struct board_staging_clk {
	const char *clk;
	const char *con_id;
	const char *dev_id;
};

struct board_staging_dev {
	struct platform_device *pdev;
	const struct board_staging_clk *clocks;
	unsigned int nclocks;
	const char *domain;
};

enum ec_status {
	EC_RES_SUCCESS = 0,
	EC_RES_INVALID_COMMAND = 1,
	EC_RES_ERROR = 2,
	EC_RES_INVALID_PARAM = 3,
	EC_RES_ACCESS_DENIED = 4,
	EC_RES_INVALID_RESPONSE = 5,
	EC_RES_INVALID_VERSION = 6,
	EC_RES_INVALID_CHECKSUM = 7,
	EC_RES_IN_PROGRESS = 8,
	EC_RES_UNAVAILABLE = 9,
	EC_RES_TIMEOUT = 10,
	EC_RES_OVERFLOW = 11,
	EC_RES_INVALID_HEADER = 12,
	EC_RES_REQUEST_TRUNCATED = 13,
	EC_RES_RESPONSE_TOO_BIG = 14,
	EC_RES_BUS_ERROR = 15,
	EC_RES_BUSY = 16,
	EC_RES_INVALID_HEADER_VERSION = 17,
	EC_RES_INVALID_HEADER_CRC = 18,
	EC_RES_INVALID_DATA_CRC = 19,
	EC_RES_DUP_UNAVAILABLE = 20,
};

enum host_event_code {
	EC_HOST_EVENT_LID_CLOSED = 1,
	EC_HOST_EVENT_LID_OPEN = 2,
	EC_HOST_EVENT_POWER_BUTTON = 3,
	EC_HOST_EVENT_AC_CONNECTED = 4,
	EC_HOST_EVENT_AC_DISCONNECTED = 5,
	EC_HOST_EVENT_BATTERY_LOW = 6,
	EC_HOST_EVENT_BATTERY_CRITICAL = 7,
	EC_HOST_EVENT_BATTERY = 8,
	EC_HOST_EVENT_THERMAL_THRESHOLD = 9,
	EC_HOST_EVENT_DEVICE = 10,
	EC_HOST_EVENT_THERMAL = 11,
	EC_HOST_EVENT_USB_CHARGER = 12,
	EC_HOST_EVENT_KEY_PRESSED = 13,
	EC_HOST_EVENT_INTERFACE_READY = 14,
	EC_HOST_EVENT_KEYBOARD_RECOVERY = 15,
	EC_HOST_EVENT_THERMAL_SHUTDOWN = 16,
	EC_HOST_EVENT_BATTERY_SHUTDOWN = 17,
	EC_HOST_EVENT_THROTTLE_START = 18,
	EC_HOST_EVENT_THROTTLE_STOP = 19,
	EC_HOST_EVENT_HANG_DETECT = 20,
	EC_HOST_EVENT_HANG_REBOOT = 21,
	EC_HOST_EVENT_PD_MCU = 22,
	EC_HOST_EVENT_BATTERY_STATUS = 23,
	EC_HOST_EVENT_PANIC = 24,
	EC_HOST_EVENT_KEYBOARD_FASTBOOT = 25,
	EC_HOST_EVENT_RTC = 26,
	EC_HOST_EVENT_MKBP = 27,
	EC_HOST_EVENT_USB_MUX = 28,
	EC_HOST_EVENT_MODE_CHANGE = 29,
	EC_HOST_EVENT_KEYBOARD_RECOVERY_HW_REINIT = 30,
	EC_HOST_EVENT_WOV = 31,
	EC_HOST_EVENT_INVALID = 32,
};

struct ec_host_request {
	uint8_t struct_version;
	uint8_t checksum;
	uint16_t command;
	uint8_t command_version;
	uint8_t reserved;
	uint16_t data_len;
};

struct ec_params_hello {
	uint32_t in_data;
};

struct ec_response_hello {
	uint32_t out_data;
};

struct ec_params_get_cmd_versions {
	uint8_t cmd;
};

struct ec_response_get_cmd_versions {
	uint32_t version_mask;
};

enum ec_comms_status {
	EC_COMMS_STATUS_PROCESSING = 1,
};

struct ec_response_get_comms_status {
	uint32_t flags;
};

struct ec_response_get_protocol_info {
	uint32_t protocol_versions;
	uint16_t max_request_packet_size;
	uint16_t max_response_packet_size;
	uint32_t flags;
};

enum ec_led_colors {
	EC_LED_COLOR_RED = 0,
	EC_LED_COLOR_GREEN = 1,
	EC_LED_COLOR_BLUE = 2,
	EC_LED_COLOR_YELLOW = 3,
	EC_LED_COLOR_WHITE = 4,
	EC_LED_COLOR_AMBER = 5,
	EC_LED_COLOR_COUNT = 6,
};

enum motionsense_command {
	MOTIONSENSE_CMD_DUMP = 0,
	MOTIONSENSE_CMD_INFO = 1,
	MOTIONSENSE_CMD_EC_RATE = 2,
	MOTIONSENSE_CMD_SENSOR_ODR = 3,
	MOTIONSENSE_CMD_SENSOR_RANGE = 4,
	MOTIONSENSE_CMD_KB_WAKE_ANGLE = 5,
	MOTIONSENSE_CMD_DATA = 6,
	MOTIONSENSE_CMD_FIFO_INFO = 7,
	MOTIONSENSE_CMD_FIFO_FLUSH = 8,
	MOTIONSENSE_CMD_FIFO_READ = 9,
	MOTIONSENSE_CMD_PERFORM_CALIB = 10,
	MOTIONSENSE_CMD_SENSOR_OFFSET = 11,
	MOTIONSENSE_CMD_LIST_ACTIVITIES = 12,
	MOTIONSENSE_CMD_SET_ACTIVITY = 13,
	MOTIONSENSE_CMD_LID_ANGLE = 14,
	MOTIONSENSE_CMD_FIFO_INT_ENABLE = 15,
	MOTIONSENSE_CMD_SPOOF = 16,
	MOTIONSENSE_CMD_TABLET_MODE_LID_ANGLE = 17,
	MOTIONSENSE_CMD_SENSOR_SCALE = 18,
	MOTIONSENSE_NUM_CMDS = 19,
};

struct ec_response_motion_sensor_data {
	uint8_t flags;
	uint8_t sensor_num;
	union {
		int16_t data[3];
		struct {
			uint16_t reserved;
			uint32_t timestamp;
		} __attribute__((packed));
		struct {
			uint8_t activity;
			uint8_t state;
			int16_t add_info[2];
		};
	};
} __attribute__((packed));

struct ec_response_motion_sense_fifo_info {
	uint16_t size;
	uint16_t count;
	uint32_t timestamp;
	uint16_t total_lost;
	uint16_t lost[0];
} __attribute__((packed));

struct ec_response_motion_sense_fifo_data {
	uint32_t number_data;
	struct ec_response_motion_sensor_data data[0];
};

struct ec_motion_sense_activity {
	uint8_t sensor_num;
	uint8_t activity;
	uint8_t enable;
	uint8_t reserved;
	uint16_t parameters[3];
};

struct ec_params_motion_sense {
	uint8_t cmd;
	union {
		struct {
			uint8_t max_sensor_count;
		} dump;
		struct {
			int16_t data;
		} kb_wake_angle;
		struct {
			uint8_t sensor_num;
		} info;
		struct {
			uint8_t sensor_num;
		} info_3;
		struct {
			uint8_t sensor_num;
		} data;
		struct {
			uint8_t sensor_num;
		} fifo_flush;
		struct {
			uint8_t sensor_num;
		} perform_calib;
		struct {
			uint8_t sensor_num;
		} list_activities;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} ec_rate;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} sensor_odr;
		struct {
			uint8_t sensor_num;
			uint8_t roundup;
			uint16_t reserved;
			int32_t data;
		} sensor_range;
		struct {
			uint8_t sensor_num;
			uint16_t flags;
			int16_t temp;
			int16_t offset[3];
		} __attribute__((packed)) sensor_offset;
		struct {
			uint8_t sensor_num;
			uint16_t flags;
			int16_t temp;
			uint16_t scale[3];
		} __attribute__((packed)) sensor_scale;
		struct {
			uint32_t max_data_vector;
		} fifo_read;
		struct ec_motion_sense_activity set_activity;
		struct {
			int8_t enable;
		} fifo_int_enable;
		struct {
			uint8_t sensor_id;
			uint8_t spoof_enable;
			uint8_t reserved;
			int16_t components[3];
		} __attribute__((packed)) spoof;
		struct {
			int16_t lid_angle;
			int16_t hys_degree;
		} tablet_mode_threshold;
	};
} __attribute__((packed));

struct ec_response_motion_sense {
	union {
		struct {
			uint8_t module_flags;
			uint8_t sensor_count;
			struct ec_response_motion_sensor_data sensor[0];
		} __attribute__((packed)) dump;
		struct {
			uint8_t type;
			uint8_t location;
			uint8_t chip;
		} info;
		struct {
			uint8_t type;
			uint8_t location;
			uint8_t chip;
			uint32_t min_frequency;
			uint32_t max_frequency;
			uint32_t fifo_max_event_count;
		} info_3;
		struct ec_response_motion_sensor_data data;
		struct {
			int32_t ret;
		} ec_rate;
		struct {
			int32_t ret;
		} sensor_odr;
		struct {
			int32_t ret;
		} sensor_range;
		struct {
			int32_t ret;
		} kb_wake_angle;
		struct {
			int32_t ret;
		} fifo_int_enable;
		struct {
			int32_t ret;
		} spoof;
		struct {
			int16_t temp;
			int16_t offset[3];
		} sensor_offset;
		struct {
			int16_t temp;
			int16_t offset[3];
		} perform_calib;
		struct {
			int16_t temp;
			uint16_t scale[3];
		} sensor_scale;
		struct ec_response_motion_sense_fifo_info fifo_info;
		struct ec_response_motion_sense_fifo_info fifo_flush;
		struct ec_response_motion_sense_fifo_data fifo_read;
		struct {
			uint16_t reserved;
			uint32_t enabled;
			uint32_t disabled;
		} __attribute__((packed)) list_activities;
		struct {
			uint16_t value;
		} lid_angle;
		struct {
			uint16_t lid_angle;
			uint16_t hys_degree;
		} tablet_mode_threshold;
	};
};

enum ec_temp_thresholds {
	EC_TEMP_THRESH_WARN = 0,
	EC_TEMP_THRESH_HIGH = 1,
	EC_TEMP_THRESH_HALT = 2,
	EC_TEMP_THRESH_COUNT = 3,
};

enum ec_mkbp_event {
	EC_MKBP_EVENT_KEY_MATRIX = 0,
	EC_MKBP_EVENT_HOST_EVENT = 1,
	EC_MKBP_EVENT_SENSOR_FIFO = 2,
	EC_MKBP_EVENT_BUTTON = 3,
	EC_MKBP_EVENT_SWITCH = 4,
	EC_MKBP_EVENT_FINGERPRINT = 5,
	EC_MKBP_EVENT_SYSRQ = 6,
	EC_MKBP_EVENT_HOST_EVENT64 = 7,
	EC_MKBP_EVENT_CEC_EVENT = 8,
	EC_MKBP_EVENT_CEC_MESSAGE = 9,
	EC_MKBP_EVENT_COUNT = 10,
};

union ec_response_get_next_data_v1 {
	uint8_t key_matrix[16];
	uint32_t host_event;
	uint64_t host_event64;
	struct {
		uint8_t reserved[3];
		struct ec_response_motion_sense_fifo_info info;
	} __attribute__((packed)) sensor_fifo;
	uint32_t buttons;
	uint32_t switches;
	uint32_t fp_events;
	uint32_t sysrq;
	uint32_t cec_events;
	uint8_t cec_message[16];
};

struct ec_response_get_next_event_v1 {
	uint8_t event_type;
	union ec_response_get_next_data_v1 data;
} __attribute__((packed));

struct ec_response_host_event_mask {
	uint32_t mask;
};

enum {
	EC_MSG_TX_HEADER_BYTES = 3,
	EC_MSG_TX_TRAILER_BYTES = 1,
	EC_MSG_TX_PROTO_BYTES = 4,
	EC_MSG_RX_PROTO_BYTES = 3,
	EC_PROTO2_MSG_BYTES = 256,
	EC_MAX_MSG_BYTES = 65536,
};

struct cros_ec_command {
	uint32_t version;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	uint32_t result;
	uint8_t data[0];
};

struct cros_ec_device {
	const char *phys_name;
	struct device *dev;
	bool was_wake_device;
	struct class *cros_class;
	int (*cmd_readmem)(struct cros_ec_device *, unsigned int, unsigned int, void *);
	u16 max_request;
	u16 max_response;
	u16 max_passthru;
	u16 proto_version;
	void *priv;
	int irq;
	u8 *din;
	u8 *dout;
	int din_size;
	int dout_size;
	bool wake_enabled;
	bool suspended;
	int (*cmd_xfer)(struct cros_ec_device *, struct cros_ec_command *);
	int (*pkt_xfer)(struct cros_ec_device *, struct cros_ec_command *);
	struct mutex lock;
	u8 mkbp_event_supported;
	bool host_sleep_v1;
	struct blocking_notifier_head event_notifier;
	struct ec_response_get_next_event_v1 event_data;
	int event_size;
	u32 host_event_wake_mask;
	u32 last_resume_result;
	int: 32;
	ktime_t last_event_time;
	struct notifier_block notifier_ready;
	struct platform_device *ec;
	struct platform_device *pd;
	int: 32;
};

struct cros_ec_debugfs;

struct cros_ec_dev {
	struct device class_dev;
	struct cros_ec_device *ec_dev;
	struct device *dev;
	struct cros_ec_debugfs *debug_info;
	bool has_kb_wake_angle;
	u16 cmd_offset;
	u32 features[2];
};

struct trace_event_raw_cros_ec_request_start {
	struct trace_entry ent;
	uint32_t version;
	uint32_t offset;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	char __data[0];
};

struct trace_event_raw_cros_ec_request_done {
	struct trace_entry ent;
	uint32_t version;
	uint32_t offset;
	uint32_t command;
	uint32_t outsize;
	uint32_t insize;
	uint32_t result;
	int retval;
	char __data[0];
};

struct trace_event_data_offsets_cros_ec_request_start {};

struct trace_event_data_offsets_cros_ec_request_done {};

typedef void (*btf_trace_cros_ec_request_start)(void *, struct cros_ec_command *);

typedef void (*btf_trace_cros_ec_request_done)(void *, struct cros_ec_command *, int);

struct mbox_chan___2;

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan___2 *, void *);
	int (*flush)(struct mbox_chan___2 *, long unsigned int);
	int (*startup)(struct mbox_chan___2 *);
	void (*shutdown)(struct mbox_chan___2 *);
	bool (*last_tx_done)(struct mbox_chan___2 *);
	bool (*peek_data)(struct mbox_chan___2 *);
};

struct mbox_controller;

struct mbox_chan___2 {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan___2 *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan___2 * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	int: 32;
	struct hrtimer poll_hrt;
	struct list_head node;
};

struct bcm2835_mbox {
	void *regs;
	spinlock_t lock;
	struct mbox_controller controller;
};

struct hi3660_chan_info {
	unsigned int dst_irq;
	unsigned int ack_irq;
};

struct hi3660_mbox {
	struct device *dev;
	void *base;
	struct mbox_chan___2 chan[32];
	struct hi3660_chan_info mchan[32];
	struct mbox_controller controller;
};

struct hi6220_mbox;

struct hi6220_mbox_chan {
	unsigned int dir;
	unsigned int dst_irq;
	unsigned int ack_irq;
	unsigned int slot;
	struct hi6220_mbox *parent;
};

struct hi6220_mbox {
	struct device *dev;
	int irq;
	bool tx_irq_mode;
	void *ipc;
	void *base;
	unsigned int chan_num;
	struct hi6220_mbox_chan *mchan;
	void *irq_map_chan[32];
	struct mbox_chan___2 *chan;
	struct mbox_controller controller;
};

struct sun6i_msgbox {
	struct mbox_controller controller;
	struct clk *clk;
	spinlock_t lock;
	void *regs;
	int: 32;
};

struct resource_table {
	u32 ver;
	u32 num;
	u32 reserved[2];
	u32 offset[0];
};

struct fw_rsc_hdr {
	u32 type;
	u8 data[0];
};

enum fw_resource_type {
	RSC_CARVEOUT = 0,
	RSC_DEVMEM = 1,
	RSC_TRACE = 2,
	RSC_VDEV = 3,
	RSC_LAST = 4,
	RSC_VENDOR_START = 128,
	RSC_VENDOR_END = 512,
};

struct fw_rsc_carveout {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_devmem {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_trace {
	u32 da;
	u32 len;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_vdev_vring {
	u32 da;
	u32 align;
	u32 num;
	u32 notifyid;
	u32 pa;
};

struct fw_rsc_vdev {
	u32 id;
	u32 notifyid;
	u32 dfeatures;
	u32 gfeatures;
	u32 config_len;
	u8 status;
	u8 num_of_vrings;
	u8 reserved[2];
	struct fw_rsc_vdev_vring vring[0];
};

struct rproc;

struct rproc_mem_entry {
	void *va;
	dma_addr_t dma;
	size_t len;
	u32 da;
	void *priv;
	char name[32];
	struct list_head node;
	u32 rsc_offset;
	u32 flags;
	u32 of_resm_idx;
	int (*alloc)(struct rproc *, struct rproc_mem_entry *);
	int (*release)(struct rproc *, struct rproc_mem_entry *);
};

enum rproc_dump_mechanism {
	RPROC_COREDUMP_DISABLED = 0,
	RPROC_COREDUMP_ENABLED = 1,
	RPROC_COREDUMP_INLINE = 2,
};

struct rproc_ops;

struct rproc {
	struct list_head node;
	struct iommu_domain *domain;
	const char *name;
	const char *firmware;
	void *priv;
	struct rproc_ops *ops;
	int: 32;
	struct device dev;
	atomic_t power;
	unsigned int state;
	enum rproc_dump_mechanism dump_conf;
	struct mutex lock;
	struct dentry *dbg_dir;
	struct list_head traces;
	int num_traces;
	struct list_head carveouts;
	struct list_head mappings;
	u64 bootaddr;
	struct list_head rvdevs;
	struct list_head subdevs;
	struct idr notifyids;
	int index;
	struct work_struct crash_handler;
	unsigned int crash_cnt;
	bool recovery_disabled;
	int max_notifyid;
	struct resource_table *table_ptr;
	struct resource_table *cached_table;
	size_t table_sz;
	bool has_iommu;
	bool auto_boot;
	bool autonomous;
	struct list_head dump_segments;
	int nb_vdev;
	u8 elf_class;
	u16 elf_machine;
	struct cdev cdev;
	bool cdev_put_on_release;
	int: 24;
	int: 32;
};

enum rsc_handling_status {
	RSC_HANDLED = 0,
	RSC_IGNORED = 1,
};

struct rproc_ops {
	int (*prepare)(struct rproc *);
	int (*unprepare)(struct rproc *);
	int (*start)(struct rproc *);
	int (*stop)(struct rproc *);
	int (*attach)(struct rproc *);
	void (*kick)(struct rproc *, int);
	void * (*da_to_va)(struct rproc *, u64, size_t);
	int (*parse_fw)(struct rproc *, const struct firmware *);
	int (*handle_rsc)(struct rproc *, u32, void *, int, int);
	struct resource_table * (*find_loaded_rsc_table)(struct rproc *, const struct firmware *);
	int (*load)(struct rproc *, const struct firmware *);
	int (*sanity_check)(struct rproc *, const struct firmware *);
	u64 (*get_boot_addr)(struct rproc *, const struct firmware *);
	long unsigned int (*panic)(struct rproc *);
	void (*coredump)(struct rproc *);
};

enum rproc_state {
	RPROC_OFFLINE = 0,
	RPROC_SUSPENDED = 1,
	RPROC_RUNNING = 2,
	RPROC_CRASHED = 3,
	RPROC_DELETED = 4,
	RPROC_DETACHED = 5,
	RPROC_LAST = 6,
};

enum rproc_crash_type {
	RPROC_MMUFAULT = 0,
	RPROC_WATCHDOG = 1,
	RPROC_FATAL_ERROR = 2,
};

struct rproc_subdev {
	struct list_head node;
	int (*prepare)(struct rproc_subdev *);
	int (*start)(struct rproc_subdev *);
	void (*stop)(struct rproc_subdev *, bool);
	void (*unprepare)(struct rproc_subdev *);
};

struct rproc_vdev;

struct rproc_vring {
	void *va;
	int len;
	u32 da;
	u32 align;
	int notifyid;
	struct rproc_vdev *rvdev;
	struct virtqueue *vq;
};

struct rproc_vdev {
	struct kref refcount;
	struct rproc_subdev subdev;
	int: 32;
	struct device dev;
	unsigned int id;
	struct list_head node;
	struct rproc *rproc;
	struct rproc_vring vring[2];
	u32 rsc_offset;
	u32 index;
};

struct rproc_debug_trace {
	struct rproc *rproc;
	struct dentry *tfile;
	struct list_head node;
	struct rproc_mem_entry trace_mem;
};

typedef int (*rproc_handle_resource_t)(struct rproc *, void *, int, int);

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

struct rproc_dump_segment {
	struct list_head node;
	dma_addr_t da;
	size_t size;
	void *priv;
	void (*dump)(struct rproc *, struct rproc_dump_segment *, void *, size_t, size_t);
	loff_t offset;
};

struct rproc_coredump_state {
	struct rproc *rproc;
	void *header;
	struct completion dump_done;
};

struct devfreq_freqs {
	long unsigned int old;
	long unsigned int new;
};

struct devfreq_passive_data {
	struct devfreq *parent;
	int (*get_target_freq)(struct devfreq *, long unsigned int *);
	struct devfreq *this;
	struct notifier_block nb;
};

struct trace_event_raw_devfreq_frequency {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	long unsigned int freq;
	long unsigned int prev_freq;
	long unsigned int busy_time;
	long unsigned int total_time;
	char __data[0];
};

struct trace_event_raw_devfreq_monitor {
	struct trace_entry ent;
	long unsigned int freq;
	long unsigned int busy_time;
	long unsigned int total_time;
	unsigned int polling_ms;
	u32 __data_loc_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devfreq_frequency {
	u32 dev_name;
};

struct trace_event_data_offsets_devfreq_monitor {
	u32 dev_name;
};

typedef void (*btf_trace_devfreq_frequency)(void *, struct devfreq *, long unsigned int, long unsigned int);

typedef void (*btf_trace_devfreq_monitor)(void *, struct devfreq *);

struct devfreq_notifier_devres {
	struct devfreq *devfreq;
	struct notifier_block *nb;
	unsigned int list;
};

struct devfreq_event_desc;

struct devfreq_event_dev {
	struct list_head node;
	struct device dev;
	struct mutex lock;
	u32 enable_count;
	const struct devfreq_event_desc *desc;
	int: 32;
};

struct devfreq_event_ops;

struct devfreq_event_desc {
	const char *name;
	u32 event_type;
	void *driver_data;
	const struct devfreq_event_ops *ops;
};

struct devfreq_event_data {
	long unsigned int load_count;
	long unsigned int total_count;
};

struct devfreq_event_ops {
	int (*enable)(struct devfreq_event_dev *);
	int (*disable)(struct devfreq_event_dev *);
	int (*reset)(struct devfreq_event_dev *);
	int (*set_event)(struct devfreq_event_dev *);
	int (*get_event)(struct devfreq_event_dev *, struct devfreq_event_data *);
};

struct devfreq_simple_ondemand_data {
	unsigned int upthreshold;
	unsigned int downdifferential;
};

union extcon_property_value {
	int intval;
};

struct extcon_cable;

struct extcon_dev___2 {
	const char *name;
	const unsigned int *supported_cable;
	const u32 *mutually_exclusive;
	int: 32;
	struct device dev;
	struct raw_notifier_head nh_all;
	struct raw_notifier_head *nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;
	u32 state;
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
	int: 32;
};

struct extcon_cable {
	struct extcon_dev___2 *edev;
	int cable_index;
	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct attribute *attrs[3];
	union extcon_property_value usb_propval[3];
	union extcon_property_value chg_propval[1];
	union extcon_property_value jack_propval[1];
	union extcon_property_value disp_propval[2];
	long unsigned int usb_bits[1];
	long unsigned int chg_bits[1];
	long unsigned int jack_bits[1];
	long unsigned int disp_bits[1];
};

struct __extcon_info {
	unsigned int type;
	unsigned int id;
	const char *name;
};

struct extcon_dev_notifier_devres {
	struct extcon_dev___2 *edev;
	unsigned int id;
	struct notifier_block *nb;
};

struct lpddr2_addressing {
	u32 num_banks;
	u32 tREFI_ns;
	u32 tRFCab_ps;
};

struct lpddr2_timings {
	u32 max_freq;
	u32 min_freq;
	u32 tRPab;
	u32 tRCD;
	u32 tWR;
	u32 tRAS_min;
	u32 tRRD;
	u32 tWTR;
	u32 tXP;
	u32 tRTP;
	u32 tCKESR;
	u32 tDQSCK_max;
	u32 tDQSCK_max_derated;
	u32 tFAW;
	u32 tZQCS;
	u32 tZQCL;
	u32 tZQinit;
	u32 tRAS_max_ns;
};

struct lpddr2_min_tck {
	u32 tRPab;
	u32 tRCD;
	u32 tWR;
	u32 tRASmin;
	u32 tRRD;
	u32 tWTR;
	u32 tXP;
	u32 tRTP;
	u32 tCKE;
	u32 tCKESR;
	u32 tFAW;
};

struct lpddr3_timings {
	u32 max_freq;
	u32 min_freq;
	u32 tRFC;
	u32 tRRD;
	u32 tRPab;
	u32 tRPpb;
	u32 tRCD;
	u32 tRC;
	u32 tRAS;
	u32 tWTR;
	u32 tWR;
	u32 tRTP;
	u32 tW2W_C2C;
	u32 tR2R_C2C;
	u32 tWL;
	u32 tDQSCK;
	u32 tRL;
	u32 tFAW;
	u32 tXSR;
	u32 tXP;
	u32 tCKE;
	u32 tCKESR;
	u32 tMRD;
};

struct lpddr3_min_tck {
	u32 tRFC;
	u32 tRRD;
	u32 tRPab;
	u32 tRPpb;
	u32 tRCD;
	u32 tRC;
	u32 tRAS;
	u32 tWTR;
	u32 tWR;
	u32 tRTP;
	u32 tW2W_C2C;
	u32 tR2R_C2C;
	u32 tWL;
	u32 tDQSCK;
	u32 tRL;
	u32 tFAW;
	u32 tXSR;
	u32 tXP;
	u32 tCKE;
	u32 tCKESR;
	u32 tMRD;
};

struct at91_ramc_caps {
	bool has_ddrck;
	bool has_mpddr_clk;
};

struct atmel_ebi_dev_config {
	int cs;
	struct atmel_smc_cs_conf smcconf;
};

struct atmel_ebi;

struct atmel_ebi_dev {
	struct list_head node;
	struct atmel_ebi *ebi;
	u32 mode;
	int numcs;
	struct atmel_ebi_dev_config configs[0];
};

struct atmel_ebi_caps;

struct atmel_ebi {
	struct clk *clk;
	struct regmap *regmap;
	struct {
		struct regmap *regmap;
		struct clk *clk;
		const struct atmel_hsmc_reg_layout *layout;
	} smc;
	struct device *dev;
	const struct atmel_ebi_caps *caps;
	struct list_head devs;
};

struct atmel_ebi_caps {
	unsigned int available_cs;
	unsigned int ebi_csa_offs;
	const char *regmap_name;
	void (*get_config)(struct atmel_ebi_dev *, struct atmel_ebi_dev_config *);
	int (*xlate_config)(struct atmel_ebi_dev *, struct device_node *, struct atmel_ebi_dev_config *);
	void (*apply_config)(struct atmel_ebi_dev *, struct atmel_ebi_dev_config *);
};

struct atmel_smc_timing_xlate {
	const char *name;
	int (*converter)(struct atmel_smc_cs_conf *, unsigned int, unsigned int);
	unsigned int shift;
};

enum dpfe_msg_fields {
	MSG_HEADER = 0,
	MSG_COMMAND = 1,
	MSG_ARG_COUNT = 2,
	MSG_ARG0 = 3,
	MSG_FIELD_MAX = 16,
};

enum dpfe_commands {
	DPFE_CMD_GET_INFO = 0,
	DPFE_CMD_GET_REFRESH = 1,
	DPFE_CMD_GET_VENDOR = 2,
	DPFE_CMD_MAX = 3,
};

struct dpfe_firmware_header {
	u32 magic;
	u32 sequence;
	u32 version;
	u32 imem_size;
	u32 dmem_size;
};

struct init_data {
	unsigned int dmem_len;
	unsigned int imem_len;
	unsigned int chksum;
	bool is_big_endian;
};

struct dpfe_api {
	int version;
	const char *fw_name;
	const struct attribute_group **sysfs_attrs;
	u32 command[48];
};

struct brcmstb_dpfe_priv {
	void *regs;
	void *dmem;
	void *imem;
	struct device *dev;
	const struct dpfe_api *dpfe_api;
	struct mutex lock;
};

struct aemif_abus_data {
	u32 cs;
};

struct aemif_platform_data {
	struct of_dev_auxdata *dev_lookup;
	u32 cs_offset;
	struct aemif_abus_data *abus_data;
	size_t num_abus_data;
	struct platform_device *sub_devices;
	size_t num_sub_devices;
};

struct aemif_cs_data {
	u8 cs;
	u16 wstrobe;
	u16 rstrobe;
	u8 wsetup;
	u8 whold;
	u8 rsetup;
	u8 rhold;
	u8 ta;
	u8 enable_ss;
	u8 enable_ew;
	u8 asize;
};

struct aemif_device {
	void *base;
	struct clk *clk;
	long unsigned int clk_rate;
	u8 num_cs;
	int cs_offset;
	struct aemif_cs_data cs_data[4];
};

struct gpmc_bool_timings {
	bool cycle2cyclediffcsen;
	bool cycle2cyclesamecsen;
	bool we_extra_delay;
	bool oe_extra_delay;
	bool adv_extra_delay;
	bool cs_extra_delay;
	bool time_para_granularity;
};

struct gpmc_timings {
	u32 sync_clk;
	u32 cs_on;
	u32 cs_rd_off;
	u32 cs_wr_off;
	u32 adv_on;
	u32 adv_rd_off;
	u32 adv_wr_off;
	u32 adv_aad_mux_on;
	u32 adv_aad_mux_rd_off;
	u32 adv_aad_mux_wr_off;
	u32 we_on;
	u32 we_off;
	u32 oe_on;
	u32 oe_off;
	u32 oe_aad_mux_on;
	u32 oe_aad_mux_off;
	u32 page_burst_access;
	u32 access;
	u32 rd_cycle;
	u32 wr_cycle;
	u32 bus_turnaround;
	u32 cycle2cycle_delay;
	u32 wait_monitoring;
	u32 clk_activation;
	u32 wr_access;
	u32 wr_data_mux_bus;
	struct gpmc_bool_timings bool_timings;
};

struct gpmc_device_timings {
	u32 t_ceasu;
	u32 t_avdasu;
	u32 t_avdp_r;
	u32 t_avdp_w;
	u32 t_aavdh;
	u32 t_oeasu;
	u32 t_aa;
	u32 t_iaa;
	u32 t_oe;
	u32 t_ce;
	u32 t_rd_cycle;
	u32 t_cez_r;
	u32 t_cez_w;
	u32 t_oez;
	u32 t_weasu;
	u32 t_wpl;
	u32 t_wph;
	u32 t_wr_cycle;
	u32 clk;
	u32 t_bacc;
	u32 t_ces;
	u32 t_avds;
	u32 t_avdh;
	u32 t_ach;
	u32 t_rdyo;
	u32 t_ce_rdyz;
	u32 t_ce_avd;
	u8 cyc_aavdh_oe;
	u8 cyc_aavdh_we;
	u8 cyc_oe;
	u8 cyc_wpl;
	u32 cyc_iaa;
	bool ce_xdelay;
	bool avd_xdelay;
	bool oe_xdelay;
	bool we_xdelay;
};

struct gpmc_settings {
	bool burst_wrap;
	bool burst_read;
	bool burst_write;
	bool device_nand;
	bool sync_read;
	bool sync_write;
	bool wait_on_read;
	bool wait_on_write;
	u32 burst_len;
	u32 device_width;
	u32 mux_add_data;
	u32 wait_pin;
};

struct gpmc_onenand_info {
	bool sync_read;
	bool sync_write;
	int burst_len;
};

enum gpmc_clk_domain {
	GPMC_CD_FCLK = 0,
	GPMC_CD_CLK = 1,
};

struct gpmc_cs_data {
	const char *name;
	u32 flags;
	struct resource mem;
};

struct gpmc_cs_config {
	u32 config1;
	u32 config2;
	u32 config3;
	u32 config4;
	u32 config5;
	u32 config6;
	u32 config7;
	int is_valid;
};

struct omap3_gpmc_regs {
	u32 sysconfig;
	u32 irqenable;
	u32 timeout_ctrl;
	u32 config;
	u32 prefetch_config1;
	u32 prefetch_config2;
	u32 prefetch_control;
	struct gpmc_cs_config cs_context[8];
};

struct gpmc_device {
	struct device *dev;
	int irq;
	struct irq_chip irq_chip;
	struct gpio_chip gpio_chip;
	int nirqs;
};

struct devbus_read_params {
	u32 bus_width;
	u32 badr_skew;
	u32 turn_off;
	u32 acc_first;
	u32 acc_next;
	u32 rd_setup;
	u32 rd_hold;
};

struct devbus_write_params {
	u32 sync_enable;
	u32 wr_high;
	u32 wr_low;
	u32 ale_wr;
};

struct devbus {
	struct device *dev;
	void *base;
	long unsigned int tick_ps;
};

enum pl353_smc_ecc_mode {
	PL353_SMC_ECCMODE_BYPASS = 0,
	PL353_SMC_ECCMODE_APB = 1,
	PL353_SMC_ECCMODE_MEM = 2,
};

enum pl353_smc_mem_width {
	PL353_SMC_MEM_WIDTH_8 = 0,
	PL353_SMC_MEM_WIDTH_16 = 1,
};

struct pl353_smc_data {
	struct clk *memclk;
	struct clk *aclk;
};

struct exynos_srom_reg_dump {
	u32 offset;
	u32 value;
};

struct exynos_srom {
	struct device *dev;
	void *reg_base;
	struct exynos_srom_reg_dump *reg_offset;
};

struct emc_timing___2 {
	long unsigned int rate;
	u32 data[46];
};

enum emc_rate_request_type {
	EMC_RATE_DEVFREQ = 0,
	EMC_RATE_DEBUG = 1,
	EMC_RATE_ICC = 2,
	EMC_RATE_TYPE_MAX = 3,
};

struct emc_rate_request {
	long unsigned int min_rate;
	long unsigned int max_rate;
};

struct tegra_emc___2 {
	struct device *dev;
	struct tegra_mc *mc;
	struct icc_provider provider;
	struct notifier_block clk_nb;
	struct clk *clk;
	void *regs;
	unsigned int dram_bus_width;
	struct emc_timing___2 *timings;
	unsigned int num_timings;
	struct {
		struct dentry *root;
		long unsigned int min_rate;
		long unsigned int max_rate;
	} debugfs;
	struct emc_rate_request requested_rate[3];
	struct mutex rate_lock;
	struct devfreq_simple_ondemand_data ondemand_data;
};

enum emc_dram_type {
	DRAM_TYPE_DDR3 = 0,
	DRAM_TYPE_DDR1 = 1,
	DRAM_TYPE_LPDDR2 = 2,
	DRAM_TYPE_DDR2 = 3,
};

enum emc_dll_change {
	DLL_CHANGE_NONE = 0,
	DLL_CHANGE_ON = 1,
	DLL_CHANGE_OFF = 2,
};

struct emc_timing___3 {
	long unsigned int rate;
	u32 data[89];
	u32 emc_auto_cal_interval;
	u32 emc_mode_1;
	u32 emc_mode_2;
	u32 emc_mode_reset;
	u32 emc_zcal_cnt_long;
	bool emc_cfg_periodic_qrst;
	bool emc_cfg_dyn_self_ref;
};

enum emc_rate_request_type___2 {
	EMC_RATE_DEBUG___2 = 0,
	EMC_RATE_ICC___2 = 1,
	EMC_RATE_TYPE_MAX___2 = 2,
};

struct tegra_emc___3 {
	struct device *dev;
	struct tegra_mc *mc;
	struct icc_provider provider;
	struct notifier_block clk_nb;
	struct clk *clk;
	void *regs;
	unsigned int irq;
	bool bad_state;
	struct emc_timing___3 *new_timing;
	struct emc_timing___3 *timings;
	unsigned int num_timings;
	u32 mc_override;
	u32 emc_cfg;
	u32 emc_mode_1;
	u32 emc_mode_2;
	u32 emc_mode_reset;
	bool vref_cal_toggle: 1;
	bool zcal_long: 1;
	bool dll_on: 1;
	struct {
		struct dentry *root;
		long unsigned int min_rate;
		long unsigned int max_rate;
	} debugfs;
	struct emc_rate_request requested_rate[2];
	struct mutex rate_lock;
};

enum emc_dram_type___2 {
	DRAM_TYPE_DDR3___2 = 0,
	DRAM_TYPE_DDR1___2 = 1,
	DRAM_TYPE_LPDDR3 = 2,
	DRAM_TYPE_DDR2___2 = 3,
};

struct emc_timing___4 {
	long unsigned int rate;
	u32 emc_burst_data[143];
	u32 emc_auto_cal_config;
	u32 emc_auto_cal_config2;
	u32 emc_auto_cal_config3;
	u32 emc_auto_cal_interval;
	u32 emc_bgbias_ctl0;
	u32 emc_cfg;
	u32 emc_cfg_2;
	u32 emc_ctt_term_ctrl;
	u32 emc_mode_1;
	u32 emc_mode_2;
	u32 emc_mode_4;
	u32 emc_mode_reset;
	u32 emc_mrs_wait_cnt;
	u32 emc_sel_dpd_ctrl;
	u32 emc_xm2dqspadctrl2;
	u32 emc_zcal_cnt_long;
	u32 emc_zcal_interval;
};

struct tegra_emc___4 {
	struct device *dev;
	struct tegra_mc *mc;
	void *regs;
	struct clk *clk;
	enum emc_dram_type___2 dram_type;
	unsigned int dram_num;
	struct emc_timing___4 last_timing;
	struct emc_timing___4 *timings;
	unsigned int num_timings;
	struct {
		struct dentry *root;
		long unsigned int min_rate;
		long unsigned int max_rate;
	} debugfs;
};

struct pmu_irq_ops {
	void (*enable_pmuirq)(unsigned int);
	void (*disable_pmuirq)(unsigned int);
	void (*free_pmuirq)(unsigned int, int, void *);
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device___2 {
	struct module *owner;
	int: 32;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	void *priv;
};

struct nvmem_cell___2 {
	const char *name;
	int offset;
	int bytes;
	int bit_offset;
	int nbits;
	struct device_node *np;
	struct nvmem_device___2 *nvmem;
	struct list_head node;
};

struct otpc_map {
	u32 otpc_row_size;
	u16 data_r_offset[4];
	u16 data_w_offset[4];
};

struct otpc_priv {
	struct device *dev;
	void *base;
	const struct otpc_map *map;
	struct nvmem_config *config;
};

struct ocotp_params;

struct ocotp_priv {
	struct device *dev;
	struct clk *clk;
	void *base;
	const struct ocotp_params *params;
	struct nvmem_config *config;
};

struct ocotp_ctrl_reg {
	u32 bm_addr;
	u32 bm_busy;
	u32 bm_error;
	u32 bm_rel_shadows;
};

struct ocotp_params {
	unsigned int nregs;
	unsigned int bank_address_words;
	void (*set_timing)(struct ocotp_priv *);
	struct ocotp_ctrl_reg ctrl;
};

struct sunxi_sid_cfg {
	u32 value_offset;
	u32 size;
	bool need_register_readout;
};

struct sunxi_sid {
	void *base;
	u32 value_offset;
};

struct vf610_ocotp {
	void *base;
	struct clk *clk;
	struct device *dev;
	struct nvmem_device *nvmem;
	int timing;
};

struct icc_req {
	struct hlist_node req_node;
	struct icc_node *node;
	struct device *dev;
	bool enabled;
	u32 tag;
	u32 avg_bw;
	u32 peak_bw;
};

struct icc_path___2 {
	const char *name;
	size_t num_nodes;
	struct icc_req reqs[0];
};

struct icc_onecell_data {
	unsigned int num_nodes;
	struct icc_node *nodes[0];
};

struct trace_event_raw_icc_set_bw {
	struct trace_entry ent;
	u32 __data_loc_path_name;
	u32 __data_loc_dev;
	u32 __data_loc_node_name;
	u32 avg_bw;
	u32 peak_bw;
	u32 node_avg_bw;
	u32 node_peak_bw;
	char __data[0];
};

struct trace_event_raw_icc_set_bw_end {
	struct trace_entry ent;
	u32 __data_loc_path_name;
	u32 __data_loc_dev;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_icc_set_bw {
	u32 path_name;
	u32 dev;
	u32 node_name;
};

struct trace_event_data_offsets_icc_set_bw_end {
	u32 path_name;
	u32 dev;
};

typedef void (*btf_trace_icc_set_bw)(void *, struct icc_path___2 *, struct icc_node *, int, u32, u32);

typedef void (*btf_trace_icc_set_bw_end)(void *, struct icc_path___2 *, int);

struct icc_bulk_data {
	struct icc_path *path;
	const char *name;
	u32 avg_bw;
	u32 peak_bw;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	int: 32;
	int: 32;
};

struct sock_skb_cb {
	u32 dropcount;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
	int: 32;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	__be16 inet_sport;
	__u16 inet_id;
	struct ip_options_rcu *inet_opt;
	int rx_dst_ifindex;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 recverr_rfc4884: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	__u32 rx_dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 dsthao;
	__u16 frag_max_size;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	rwlock_t sflock;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct prot_inuse {
	int val[64];
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	long unsigned int last_probe;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 2;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
	atomic_t fib_rt_uncache;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	__XFRM_MSG_MAX = 39,
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	__XFRMA_MAX = 32,
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_state_offload {
	struct net_device *dev;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	unsigned int num_exthdrs;
	u8 flags;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_replay;

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	const struct xfrm_replay *repl;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_state_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
	int: 32;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

struct xfrm_policy_walk_entry {
	struct list_head all;
	u8 dead;
};

struct xfrm_policy_queue {
	struct sk_buff_head hold_queue;
	struct timer_list hold_timer;
	long unsigned int timeout;
};

struct xfrm_tmpl {
	struct xfrm_id id;
	xfrm_address_t saddr;
	short unsigned int encap_family;
	u32 reqid;
	u8 mode;
	u8 share;
	u8 optional;
	u8 allalgs;
	u32 aalgos;
	u32 ealgos;
	u32 calgos;
};

struct xfrm_policy {
	possible_net_t xp_net;
	struct hlist_node bydst;
	struct hlist_node byidx;
	rwlock_t lock;
	refcount_t refcnt;
	u32 pos;
	struct timer_list timer;
	atomic_t genid;
	u32 priority;
	u32 index;
	u32 if_id;
	struct xfrm_mark mark;
	struct xfrm_selector selector;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_lifetime_cur curlft;
	struct xfrm_policy_walk_entry walk;
	struct xfrm_policy_queue polq;
	bool bydst_reinsert;
	u8 type;
	u8 action;
	u8 flags;
	u8 xfrm_nr;
	u16 family;
	struct xfrm_sec_ctx *security;
	struct xfrm_tmpl xfrm_vec[6];
	struct hlist_node bydst_inexact_list;
	struct callback_head rcu;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_bind_bucket;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	struct hlist_node icsk_listen_portaddr_node;
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int enabled;
		int search_high;
		int search_low;
		int probe_size;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	int: 32;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
	int: 16;
	int: 32;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 max_packets_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	int: 32;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct net_protocol {
	int (*early_demux)(struct sk_buff *);
	int (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int netns_ok: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct xfrm_replay {
	void (*advance)(struct xfrm_state *, __be32);
	int (*check)(struct xfrm_state *, struct sk_buff *, __be32);
	int (*recheck)(struct xfrm_state *, struct sk_buff *, __be32);
	void (*notify)(struct xfrm_state *, int);
	int (*overflow)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_type {
	char *description;
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
	int (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **);
};

struct xfrm_type_offload {
	char *description;
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	int: 32;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

struct ts_state {
	unsigned int offset;
	char cb[40];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
	int: 32;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 gro_remcsum_start;
	long unsigned int age;
	u16 proto;
	u8 same_flow: 1;
	u8 encap_mark: 1;
	u8 csum_valid: 1;
	u8 csum_cnt: 3;
	u8 free: 2;
	u8 is_ipv6: 1;
	u8 is_fou: 1;
	u8 is_atomic: 1;
	u8 recursion_counter: 4;
	u8 is_flist: 1;
	__wsum csum;
	struct sk_buff *last;
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
};

struct sec_path {
	int len;
	int olen;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

struct ahash_request___2;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
	int: 32;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator {
	struct gnet_stats_basic_packed *bstats;
	spinlock_t *stats_lock;
	seqcount_t *running;
	struct gnet_stats_basic_cpu *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	__RTM_MAX = 115,
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	__RTNLGRP_MAX = 34,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct pcpu_gen_cookie {
	local_t nesting;
	int: 32;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	int: 32;
};

struct flow_keys_digest {
	u8 data[16];
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
	int: 32;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
	int: 16;
	int: 32;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	int fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	atomic_t upper_bound;
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool mpath;
	bool fdb_nh;
	bool has_v4;
	struct nh_grp_entry nh_entries[0];
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
	} u;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct mpls_label {
	__be32 entry;
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

struct rps_sock_flow_table {
	u32 mask;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 ents[0];
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct netdev_boot_setup {
	char name[16];
	struct ifmap map;
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_DROP = 4,
	GRO_CONSUMED = 5,
};

typedef enum gro_result gro_result_t;

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	__IPV4_DEVCONF_MAX = 33,
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
	int: 32;
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

struct xfrm_dst {
	union {
		struct dst_entry dst;
		struct rtable rt;
		struct rt6_info rt6;
	} u;
	struct dst_entry *route;
	struct dst_entry *child;
	struct dst_entry *path;
	struct xfrm_policy *pols[2];
	int num_pols;
	int num_xfrms;
	u32 xfrm_genid;
	u32 policy_genid;
	u32 route_mtu_cached;
	u32 child_mtu_cached;
	u32 route_cookie;
	u32 path_cookie;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	__NDA_MAX = 15,
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	__NDTPA_MAX = 19,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
	int: 32;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	__IFLA_MAX = 56,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	__IFLA_BRPORT_MAX = 37,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	__IFLA_OFFLOAD_XSTATS_MAX = 2,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	__IFLA_BRIDGE_MAX = 6,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *);
	int (*set_link_af)(struct net_device *, const struct nlattr *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	__u16 tunnel_ext;
	__u32 tunnel_label;
};

struct bpf_xfrm_state {
	__u32 reqid;
	__u32 spi;
	__u16 family;
	__u16 ext;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	__u16 tot_len;
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_kill: 1;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
	int: 32;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	int: 32;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct fib6_result;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	void (*xfrm6_local_rxpmtu)(struct sk_buff *, u32);
	int (*xfrm6_udp_encap_rcv)(struct sock *, struct sk_buff *);
	int (*xfrm6_rcv_encap)(struct sk_buff *, int, __be32, int);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
};

struct fib_table;

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	int: 32;
	union {
		struct {
			__u32 in_flight: 30;
			__u32 is_app_limited: 1;
			__u32 unused: 1;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
		struct {
			__u32 flags;
			struct sock *sk_redir;
			void *data_end;
		} bpf;
	};
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
	int: 32;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct strp_msg {
	int full_len;
	int offset;
};

struct xdp_umem {
	void *addrs;
	int: 32;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
	int: 32;
};

struct xsk_queue;

struct xdp_sock {
	struct sock sk;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xsk_queue *tx;
	struct list_head tx_list;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct strparser strp;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	struct sk_buff *recv_pkt;
	u8 control;
	u8 async_capable: 1;
	u8 decrypted: 1;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	bool async_notify;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
	};
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_skb_get_xfrm_state)(struct sk_buff *, u32, struct bpf_xfrm_state *, u32, u64);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

struct bpf_dtab_netdev___2;

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

typedef int gifconf_func_t(struct net_device *, char *, int, int);

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct xdp_buff_xsk;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	u32 heads_cnt;
	u16 queue_id;
	int: 16;
	int: 32;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	bool unaligned;
	int: 24;
	int: 32;
	u64 orig_addr;
	struct list_head free_list_node;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
	struct callback_head rcu;
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *skb_parser;
	struct bpf_prog *skb_verdict;
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct sk_psock_parser {
	struct strparser strp;
	bool enabled;
	void (*saved_data_ready)(struct sock *);
};

struct sk_psock_work_state {
	struct sk_buff *skb;
	u32 len;
	u32 off;
};

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	int: 32;
	struct sk_psock_parser parser;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	struct proto *sk_proto;
	struct sk_psock_work_state work_state;
	struct work_struct work;
	union {
		struct callback_head rcu;
		struct work_struct gc;
	};
};

struct fib_rule_uid_range {
	__u32 start;
	__u32 end;
};

enum {
	FRA_UNSPEC = 0,
	FRA_DST = 1,
	FRA_SRC = 2,
	FRA_IIFNAME = 3,
	FRA_GOTO = 4,
	FRA_UNUSED2 = 5,
	FRA_PRIORITY = 6,
	FRA_UNUSED3 = 7,
	FRA_UNUSED4 = 8,
	FRA_UNUSED5 = 9,
	FRA_FWMARK = 10,
	FRA_FLOW = 11,
	FRA_TUN_ID = 12,
	FRA_SUPPRESS_IFGROUP = 13,
	FRA_SUPPRESS_PREFIXLEN = 14,
	FRA_TABLE = 15,
	FRA_FWMASK = 16,
	FRA_OIFNAME = 17,
	FRA_PAD = 18,
	FRA_L3MDEV = 19,
	FRA_UID_RANGE = 20,
	FRA_PROTOCOL = 21,
	FRA_IP_PROTO = 22,
	FRA_SPORT_RANGE = 23,
	FRA_DPORT_RANGE = 24,
	__FRA_MAX = 25,
};

enum {
	FR_ACT_UNSPEC = 0,
	FR_ACT_TO_TBL = 1,
	FR_ACT_GOTO = 2,
	FR_ACT_NOP = 3,
	FR_ACT_RES3 = 4,
	FR_ACT_RES4 = 5,
	FR_ACT_BLACKHOLE = 6,
	FR_ACT_UNREACHABLE = 7,
	FR_ACT_PROHIBIT = 8,
	__FR_ACT_MAX = 9,
};

struct fib_rule_notifier_info {
	struct fib_notifier_info info;
	struct fib_rule *rule;
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_ni_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_rx_ni_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int *sysctl_mem;
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_update_nid {};

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

struct net_dm_drop_point {
	__u8 pc[8];
	__u32 count;
};

struct net_dm_alert_msg {
	__u32 entries;
	struct net_dm_drop_point points[0];
};

enum {
	NET_DM_CMD_UNSPEC = 0,
	NET_DM_CMD_ALERT = 1,
	NET_DM_CMD_CONFIG = 2,
	NET_DM_CMD_START = 3,
	NET_DM_CMD_STOP = 4,
	NET_DM_CMD_PACKET_ALERT = 5,
	NET_DM_CMD_CONFIG_GET = 6,
	NET_DM_CMD_CONFIG_NEW = 7,
	NET_DM_CMD_STATS_GET = 8,
	NET_DM_CMD_STATS_NEW = 9,
	_NET_DM_CMD_MAX = 10,
};

enum net_dm_attr {
	NET_DM_ATTR_UNSPEC = 0,
	NET_DM_ATTR_ALERT_MODE = 1,
	NET_DM_ATTR_PC = 2,
	NET_DM_ATTR_SYMBOL = 3,
	NET_DM_ATTR_IN_PORT = 4,
	NET_DM_ATTR_TIMESTAMP = 5,
	NET_DM_ATTR_PROTO = 6,
	NET_DM_ATTR_PAYLOAD = 7,
	NET_DM_ATTR_PAD = 8,
	NET_DM_ATTR_TRUNC_LEN = 9,
	NET_DM_ATTR_ORIG_LEN = 10,
	NET_DM_ATTR_QUEUE_LEN = 11,
	NET_DM_ATTR_STATS = 12,
	NET_DM_ATTR_HW_STATS = 13,
	NET_DM_ATTR_ORIGIN = 14,
	NET_DM_ATTR_HW_TRAP_GROUP_NAME = 15,
	NET_DM_ATTR_HW_TRAP_NAME = 16,
	NET_DM_ATTR_HW_ENTRIES = 17,
	NET_DM_ATTR_HW_ENTRY = 18,
	NET_DM_ATTR_HW_TRAP_COUNT = 19,
	NET_DM_ATTR_SW_DROPS = 20,
	NET_DM_ATTR_HW_DROPS = 21,
	NET_DM_ATTR_FLOW_ACTION_COOKIE = 22,
	__NET_DM_ATTR_MAX = 23,
	NET_DM_ATTR_MAX = 22,
};

enum net_dm_alert_mode {
	NET_DM_ALERT_MODE_SUMMARY = 0,
	NET_DM_ALERT_MODE_PACKET = 1,
};

enum {
	NET_DM_ATTR_PORT_NETDEV_IFINDEX = 0,
	NET_DM_ATTR_PORT_NETDEV_NAME = 1,
	__NET_DM_ATTR_PORT_MAX = 2,
	NET_DM_ATTR_PORT_MAX = 1,
};

enum {
	NET_DM_ATTR_STATS_DROPPED = 0,
	__NET_DM_ATTR_STATS_MAX = 1,
	NET_DM_ATTR_STATS_MAX = 0,
};

enum net_dm_origin {
	NET_DM_ORIGIN_SW = 0,
	NET_DM_ORIGIN_HW = 1,
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

struct genl_multicast_group {
	char name[16];
};

struct genl_ops;

struct genl_info;

struct genl_small_ops;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	unsigned int mcgrp_offset;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_mcgrps;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct devlink_trap_metadata {
	const char *trap_name;
	const char *trap_group_name;
	struct net_device *input_dev;
	const struct flow_action_cookie *fa_cookie;
	enum devlink_trap_type trap_type;
};

struct net_dm_stats {
	u64 dropped;
	struct u64_stats_sync syncp;
	int: 32;
};

struct net_dm_hw_entry {
	char trap_name[40];
	u32 count;
};

struct net_dm_hw_entries {
	u32 num_entries;
	struct net_dm_hw_entry entries[0];
};

struct per_cpu_dm_data {
	spinlock_t lock;
	union {
		struct sk_buff *skb;
		struct net_dm_hw_entries *hw_entries;
	};
	struct sk_buff_head drop_queue;
	struct work_struct dm_alert_work;
	struct timer_list send_timer;
	int: 32;
	struct net_dm_stats stats;
};

struct dm_hw_stat_delta {
	struct net_device *dev;
	long unsigned int last_rx;
	struct list_head list;
	struct callback_head rcu;
	long unsigned int last_drop_val;
};

struct net_dm_alert_ops {
	void (*kfree_skb_probe)(void *, struct sk_buff *, void *);
	void (*napi_poll_probe)(void *, struct napi_struct *, int, int);
	void (*work_item_func)(struct work_struct *);
	void (*hw_work_item_func)(struct work_struct *);
	void (*hw_trap_probe)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);
};

struct net_dm_skb_cb {
	union {
		struct devlink_trap_metadata *hw_metadata;
		void *pc;
	};
};

struct clock_identity {
	u8 id[8];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	raw_spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	raw_spinlock_t lock;
};

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_MAX = 7,
};

struct rdma_restrack_entry {
	bool valid;
	u8 no_track: 1;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_hw_stats;

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const char * const *names;
	int num_counters;
	int: 32;
	u64 value[0];
};

struct ib_device;

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u8 port;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

struct uverbs_attr_bundle;

struct rdma_cm_id;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_gid_attr;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct ib_pd;

struct ib_ah;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_flow_action_attrs_esp;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*req_ncomp_notif)(struct ib_cq *, int);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u8, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u8, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u8, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u8, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u8);
	struct net_device * (*get_netdev)(struct ib_device *, u8);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u8, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u8, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u8, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u8, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	struct ib_qp * (*create_qp)(struct ib_pd *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	struct ib_flow_action * (*create_flow_action_esp)(struct ib_device *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*modify_flow_action_esp)(struct ib_flow_action *, const struct ib_flow_action_attrs_esp *, struct uverbs_attr_bundle *);
	int (*set_vf_link_state)(struct ib_device *, int, u8, int);
	int (*get_vf_config)(struct ib_device *, int, u8, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u8, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u8, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u8, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_stats)(struct ib_device *, u8);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u8, int);
	int (*init_port)(struct ib_device *, u8, struct kobject *);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	int: 32;
	u64 device_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	int: 32;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	int: 32;
	u64 max_dm_size;
	u32 max_sgl_rd;
	int: 32;
};

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	int: 32;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[3];
	int: 32;
	u64 uverbs_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u8 phys_port_cnt;
	struct ib_device_attr attrs;
	struct attribute_group *hw_stats_ag;
	struct rdma_hw_stats *hw_stats;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	int: 32;
	u64 sig_err_offset;
	u32 key;
	int: 32;
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_flow_action_esp_keymat {
	IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM = 0,
};

struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
	__u64 iv;
	__u32 iv_algo;
	__u32 salt;
	__u32 icv_len;
	__u32 key_len;
	__u32 aes_key[8];
};

enum ib_uverbs_flow_action_esp_replay {
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE = 0,
	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP = 1,
};

struct ib_uverbs_flow_action_esp_replay_bmp {
	__u32 size;
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u8 port_num;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
	int: 32;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

struct ib_ucq_object;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct ib_event;

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	int: 32;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
	int: 32;
};

struct ib_uqp_object;

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u8 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_usrq_object;

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
};

struct ib_uwq_object;

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u8 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	int: 32;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mr_status {
	u32 fail_status;
	int: 32;
	struct ib_sig_err sig_err;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u8 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_REG_MR = 8,
	IB_WC_MASKED_COMP_SWAP = 9,
	IB_WC_MASKED_FETCH_ADD = 10,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u8 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
	int: 8;
	int: 32;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u8 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_uobject;

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	int: 32;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u8 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u8 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	int: 32;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	int: 32;
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	int: 32;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_rdmacg_object {};

struct ib_uverbs_file;

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
	int: 32;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u8 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u8 port;
	union ib_flow_spec flows[0];
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_flow_action_attrs_esp_keymats {
	enum ib_uverbs_flow_action_esp_keymat protocol;
	int: 32;
	union {
		struct ib_uverbs_flow_action_esp_keymat_aes_gcm aes_gcm;
	} keymat;
};

struct ib_flow_action_attrs_esp_replays {
	enum ib_uverbs_flow_action_esp_replay protocol;
	union {
		struct ib_uverbs_flow_action_esp_replay_bmp bmp;
	} replay;
};

struct ib_flow_spec_list {
	struct ib_flow_spec_list *next;
	union ib_flow_spec spec;
};

struct ib_flow_action_attrs_esp {
	struct ib_flow_action_attrs_esp_keymats *keymat;
	struct ib_flow_action_attrs_esp_replays *replay;
	struct ib_flow_spec_list *encap;
	u32 esn;
	u32 spi;
	u32 seq;
	u32 tfc_pad;
	int: 32;
	u64 flags;
	u64 hard_limit_pkts;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	struct list_head pkey_list;
	struct ib_port_cache cache;
	spinlock_t netdev_lock;
	struct net_device *netdev;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct rdma_hw_stats *hw_stats;
	int: 32;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u8, struct net_device *, void *);
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	long unsigned int start_pgoff;
	size_t npages;
	bool driver_removed;
};

struct genl_dumpit_info {
	const struct genl_family *family;
	struct genl_ops op;
	struct nlattr **attrs;
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	DEVLINK_CMD_TRAP_POLICER_GET = 69,
	DEVLINK_CMD_TRAP_POLICER_SET = 70,
	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
	__DEVLINK_CMD_MAX = 74,
	DEVLINK_CMD_MAX = 73,
};

enum devlink_eswitch_mode {
	DEVLINK_ESWITCH_MODE_LEGACY = 0,
	DEVLINK_ESWITCH_MODE_SWITCHDEV = 1,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
	__DEVLINK_ATTR_STATS_MAX = 3,
	DEVLINK_ATTR_STATS_MAX = 2,
};

enum {
	DEVLINK_FLASH_OVERWRITE_SETTINGS_BIT = 0,
	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS_BIT = 1,
	__DEVLINK_FLASH_OVERWRITE_MAX_BIT = 2,
	DEVLINK_FLASH_OVERWRITE_MAX_BIT = 1,
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	DEVLINK_ATTR_NETNS_FD = 138,
	DEVLINK_ATTR_NETNS_PID = 139,
	DEVLINK_ATTR_NETNS_ID = 140,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
	DEVLINK_ATTR_PORT_FUNCTION = 145,
	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
	DEVLINK_ATTR_PORT_LANES = 147,
	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
	DEVLINK_ATTR_PORT_EXTERNAL = 149,
	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
	DEVLINK_ATTR_RELOAD_ACTION = 153,
	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
	DEVLINK_ATTR_RELOAD_LIMITS = 155,
	DEVLINK_ATTR_DEV_STATS = 156,
	DEVLINK_ATTR_RELOAD_STATS = 157,
	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
	DEVLINK_ATTR_RELOAD_ACTION_INFO = 162,
	DEVLINK_ATTR_RELOAD_ACTION_STATS = 163,
	__DEVLINK_ATTR_MAX = 164,
	DEVLINK_ATTR_MAX = 163,
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

enum devlink_dpipe_field_ethernet_id {
	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
};

enum devlink_dpipe_field_ipv4_id {
	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
};

enum devlink_dpipe_field_ipv6_id {
	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
};

enum devlink_dpipe_header_id {
	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
	DEVLINK_DPIPE_HEADER_IPV4 = 1,
	DEVLINK_DPIPE_HEADER_IPV6 = 2,
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

enum devlink_port_function_attr {
	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 2,
	DEVLINK_PORT_FUNCTION_ATTR_MAX = 1,
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
	int: 24;
	int: 32;
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	int: 8;
	int: 32;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
	int: 32;
};

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
	int: 32;
};

typedef u64 devlink_resource_occ_get_t(void *);

struct devlink_resource {
	const char *name;
	int: 32;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

struct devlink_flash_notify {
	const char *status_msg;
	const char *component;
	long unsigned int done;
	long unsigned int total;
	long unsigned int timeout;
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	long unsigned int supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
	bool published;
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 11,
	DEVLINK_PARAM_GENERIC_ID_MAX = 10,
};

struct devlink_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

struct devlink_port_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter;

struct devlink_fmsg;

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
};

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_port *devlink_port;
	struct devlink_fmsg *dump_fmsg;
	struct mutex dump_lock;
	u64 graceful_period;
	bool auto_recover;
	bool auto_dump;
	u8 health_state;
	int: 8;
	int: 32;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
	refcount_t refcount;
	int: 32;
};

struct devlink_fmsg {
	struct list_head item_list;
	bool putting_binary;
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
	DEVLINK_TRAP_GENERIC_ID_STP = 29,
	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_NEXTHOP = 90,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 91,
	DEVLINK_TRAP_GENERIC_ID_MAX = 90,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 25,
};

struct devlink_info_req {
	struct sk_buff *msg;
};

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	long unsigned int type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	int: 24;
	int: 32;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_raw_devlink_trap_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_trap_name;
	u32 __data_loc_trap_group_name;
	u32 __data_loc_input_dev_name;
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_trap_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 trap_name;
	u32 trap_group_name;
	u32 input_dev_name;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct devlink_region {
	struct devlink *devlink;
	struct devlink_port *port;
	struct list_head list;
	union {
		const struct devlink_region_ops *ops;
		const struct devlink_port_region_ops *port_ops;
	};
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	int: 32;
	u64 size;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region *region;
	u8 *data;
	u32 id;
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_reload_combination {
	enum devlink_reload_action action;
	enum devlink_reload_limit limit;
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct devlink_stats {
	u64 rx_bytes;
	u64 rx_packets;
	struct u64_stats_sync syncp;
	int: 32;
};

struct devlink_trap_policer_item {
	const struct devlink_trap_policer *policer;
	int: 32;
	u64 rate;
	u64 burst;
	struct list_head list;
};

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	struct devlink_trap_policer_item *policer_item;
	struct list_head list;
	struct devlink_stats *stats;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats *stats;
	void *priv;
};

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_UNKNOWN = 6,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	__TCA_MAX = 16,
};

struct skb_array {
	struct ptr_ring ring;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u8 linklayer;
	u8 shift;
};

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_packed *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct sch_frag_data {
	long unsigned int dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	__NLMSGERR_ATTR_MAX = 5,
	NLMSGERR_ATTR_MAX = 4,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
	int: 32;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_ops *ops;
	int hdrlen;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	unsigned int opidx;
	u32 op;
	u16 fam_id;
	u8 policies: 1;
	u8 single_op: 1;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state___2 {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	__ETHTOOL_MSG_USER_CNT = 29,
	ETHTOOL_MSG_USER_MAX = 28,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	__ETHTOOL_A_LINKMODES_CNT = 9,
	ETHTOOL_A_LINKMODES_MAX = 8,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	__ETHTOOL_A_LINKSTATE_CNT = 7,
	ETHTOOL_A_LINKSTATE_MAX = 6,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	__ETHTOOL_A_RINGS_CNT = 10,
	ETHTOOL_A_RINGS_MAX = 9,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	__ETHTOOL_A_COALESCE_CNT = 24,
	ETHTOOL_A_COALESCE_MAX = 23,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	__ETHTOOL_A_PAUSE_CNT = 6,
	ETHTOOL_A_PAUSE_MAX = 5,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_req_info {
	struct net_device *dev;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	int pos_hash;
	int pos_idx;
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

typedef const char (* const ethnl_string_array_t)[32];

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[16];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct link_mode_info {
	int speed;
	u8 duplex;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	u32 supported_params;
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	int: 32;
	struct ethtool_pause_stats pausestat;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	int pos_hash;
	int pos_idx;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	u8 tos;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 6;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	u8 fa_tos;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 6;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct raw_hashinfo {
	rwlock_t lock;
	struct hlist_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	int: 32;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	__be32 imsf_slist[1];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct compat_group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
	int: 32;
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

struct mptcp_out_options {};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	union tcp_md5_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	struct tcp_seq_afinfo *bpf_seq_afinfo;
	int bucket;
	int offset;
	int sbucket;
	int num;
	int: 32;
	loff_t last_pos;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
	int: 32;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	possible_net_t tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	int: 32;
	int bucket;
	int: 32;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	bool (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	__IFA_MAX = 11,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct fib_config {
	u8 fc_dst_len;
	u8 fc_tos;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	__LWTUNNEL_ENCAP_MAX = 9,
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	u8 tos;
	u8 type;
	u32 tb_id;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct key_vector *tnode[0];
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
	int: 32;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	rwlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct vxlan_metadata {
	u32 gbp;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	__NEXTHOP_GRP_TYPE_MAX = 1,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	__NHA_MAX = 12,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u8 weight;
	u32 id;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	bool is_grp;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
	};
};

enum tunnel_encap_types {
	TUNNEL_ENCAP_NONE = 0,
	TUNNEL_ENCAP_FOU = 1,
	TUNNEL_ENCAP_GUE = 2,
	TUNNEL_ENCAP_MPLS = 3,
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	u32 o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct tnl_ptk_info {
	__be16 flags;
	__be16 proto;
	__be32 key;
	__be32 seq;
	int hdr_len;
};

struct ip_tunnel_net {
	struct net_device *fb_tunnel_dev;
	struct rtnl_link_ops *rtnl_link_ops;
	struct hlist_head tunnels[128];
	struct ip_tunnel *collect_md_tun;
	int type;
};

struct inet6_protocol {
	void (*early_demux)(struct sk_buff *);
	void (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct xfrm_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm_tunnel *next;
	int priority;
};

struct ic_device {
	struct ic_device *next;
	struct net_device *dev;
	short unsigned int flags;
	short int able;
	__be32 xid;
};

struct bootp_pkt {
	struct iphdr iph;
	struct udphdr udph;
	u8 op;
	u8 htype;
	u8 hlen;
	u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 client_ip;
	__be32 your_ip;
	__be32 server_ip;
	__be32 relay_ip;
	u8 hw_addr[16];
	u8 serv_name[64];
	u8 boot_file[128];
	u8 exten[312];
};

struct inet_diag_sockid {
	__be16 idiag_sport;
	__be16 idiag_dport;
	__be32 idiag_src[4];
	__be32 idiag_dst[4];
	__u32 idiag_if;
	__u32 idiag_cookie[2];
};

struct inet_diag_req {
	__u8 idiag_family;
	__u8 idiag_src_len;
	__u8 idiag_dst_len;
	__u8 idiag_ext;
	struct inet_diag_sockid id;
	__u32 idiag_states;
	__u32 idiag_dbs;
};

struct inet_diag_req_v2 {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 pad;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_bc_op {
	unsigned char code;
	unsigned char yes;
	short unsigned int no;
};

enum {
	INET_DIAG_BC_NOP = 0,
	INET_DIAG_BC_JMP = 1,
	INET_DIAG_BC_S_GE = 2,
	INET_DIAG_BC_S_LE = 3,
	INET_DIAG_BC_D_GE = 4,
	INET_DIAG_BC_D_LE = 5,
	INET_DIAG_BC_AUTO = 6,
	INET_DIAG_BC_S_COND = 7,
	INET_DIAG_BC_D_COND = 8,
	INET_DIAG_BC_DEV_COND = 9,
	INET_DIAG_BC_MARK_COND = 10,
	INET_DIAG_BC_S_EQ = 11,
	INET_DIAG_BC_D_EQ = 12,
	INET_DIAG_BC_CGROUP_COND = 13,
};

struct inet_diag_hostcond {
	__u8 family;
	__u8 prefix_len;
	int port;
	__be32 addr[0];
};

struct inet_diag_markcond {
	__u32 mark;
	__u32 mask;
};

struct inet_diag_msg {
	__u8 idiag_family;
	__u8 idiag_state;
	__u8 idiag_timer;
	__u8 idiag_retrans;
	struct inet_diag_sockid id;
	__u32 idiag_expires;
	__u32 idiag_rqueue;
	__u32 idiag_wqueue;
	__u32 idiag_uid;
	__u32 idiag_inode;
};

enum {
	INET_DIAG_NONE = 0,
	INET_DIAG_MEMINFO = 1,
	INET_DIAG_INFO = 2,
	INET_DIAG_VEGASINFO = 3,
	INET_DIAG_CONG = 4,
	INET_DIAG_TOS = 5,
	INET_DIAG_TCLASS = 6,
	INET_DIAG_SKMEMINFO = 7,
	INET_DIAG_SHUTDOWN = 8,
	INET_DIAG_DCTCPINFO = 9,
	INET_DIAG_PROTOCOL = 10,
	INET_DIAG_SKV6ONLY = 11,
	INET_DIAG_LOCALS = 12,
	INET_DIAG_PEERS = 13,
	INET_DIAG_PAD = 14,
	INET_DIAG_MARK = 15,
	INET_DIAG_BBRINFO = 16,
	INET_DIAG_CLASS_ID = 17,
	INET_DIAG_MD5SIG = 18,
	INET_DIAG_ULP_INFO = 19,
	INET_DIAG_SK_BPF_STORAGES = 20,
	INET_DIAG_CGROUP_ID = 21,
	INET_DIAG_SOCKOPT = 22,
	__INET_DIAG_MAX = 23,
};

struct inet_diag_meminfo {
	__u32 idiag_rmem;
	__u32 idiag_wmem;
	__u32 idiag_fmem;
	__u32 idiag_tmem;
};

struct inet_diag_sockopt {
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 unused: 5;
};

struct inet_diag_handler {
	void (*dump)(struct sk_buff *, struct netlink_callback *, const struct inet_diag_req_v2 *);
	int (*dump_one)(struct netlink_callback *, const struct inet_diag_req_v2 *);
	void (*idiag_get_info)(struct sock *, struct inet_diag_msg *, void *);
	int (*idiag_get_aux)(struct sock *, bool, struct sk_buff *);
	size_t (*idiag_get_aux_size)(struct sock *, bool);
	int (*destroy)(struct sk_buff *, const struct inet_diag_req_v2 *);
	__u16 idiag_type;
	__u16 idiag_info_size;
};

struct bpf_sk_storage_diag___2;

struct inet_diag_dump_data {
	struct nlattr *req_nlas[4];
	struct bpf_sk_storage_diag___2 *bpf_stg_diag;
};

struct inet_diag_entry {
	const __be32 *saddr;
	const __be32 *daddr;
	u16 sport;
	u16 dport;
	u16 family;
	u16 userlocks;
	u32 ifindex;
	u32 mark;
	u64 cgroup_id;
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	char aad_space[13];
	u8 iv_data[16];
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_NUM_CFGS = 2,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

struct xfrm_policy_afinfo {
	struct dst_ops *dst_ops;
	struct dst_entry * (*dst_lookup)(struct net *, int, int, const xfrm_address_t *, const xfrm_address_t *, u32);
	int (*get_saddr)(struct net *, int, xfrm_address_t *, xfrm_address_t *, u32);
	int (*fill_dst)(struct xfrm_dst *, struct net_device *, const struct flowi *);
	struct dst_entry * (*blackhole_route)(struct net *, struct dst_entry *);
};

struct xfrm_state_afinfo {
	u8 family;
	u8 proto;
	const struct xfrm_type_offload *type_offload_esp;
	const struct xfrm_type *type_esp;
	const struct xfrm_type *type_ipip;
	const struct xfrm_type *type_ipip6;
	const struct xfrm_type *type_comp;
	const struct xfrm_type *type_ah;
	const struct xfrm_type *type_routing;
	const struct xfrm_type *type_dstopts;
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*transport_finish)(struct sk_buff *, int);
	void (*local_error)(struct sk_buff *, u32);
};

struct ip6_tnl;

struct xfrm_tunnel_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	union {
		struct ip_tunnel *ip4;
		struct ip6_tnl *ip6;
	} tunnel;
};

struct xfrm_mode_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	__be16 id;
	__be16 frag_off;
	u8 ihl;
	u8 tos;
	u8 ttl;
	u8 protocol;
	u8 optlen;
	u8 flow_lbl[3];
};

struct xfrm_spi_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	unsigned int daddroff;
	unsigned int family;
	__be32 seq;
};

struct xfrm_input_afinfo {
	u8 family;
	bool is_ipip;
	int (*callback)(struct sk_buff *, u8, int);
};

struct xfrm4_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm4_protocol *next;
	int priority;
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

struct seqcount_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_mutex seqcount_mutex_t;

enum {
	XFRM_STATE_VOID = 0,
	XFRM_STATE_ACQ = 1,
	XFRM_STATE_VALID = 2,
	XFRM_STATE_ERROR = 3,
	XFRM_STATE_EXPIRED = 4,
	XFRM_STATE_DEAD = 5,
};

struct xfrm_if;

struct xfrm_if_cb {
	struct xfrm_if * (*decode_session)(struct sk_buff *, short unsigned int);
};

struct xfrm_if_parms {
	int link;
	u32 if_id;
};

struct xfrm_if {
	struct xfrm_if *next;
	struct net_device *dev;
	struct net *net;
	struct xfrm_if_parms p;
	struct gro_cells gro_cells;
};

struct xfrm_policy_walk {
	struct xfrm_policy_walk_entry walk;
	u8 type;
	u32 seq;
};

struct xfrmk_spdinfo {
	u32 incnt;
	u32 outcnt;
	u32 fwdcnt;
	u32 inscnt;
	u32 outscnt;
	u32 fwdscnt;
	u32 spdhcnt;
	u32 spdhmcnt;
};

struct ip6_mh {
	__u8 ip6mh_proto;
	__u8 ip6mh_hdrlen;
	__u8 ip6mh_type;
	__u8 ip6mh_reserved;
	__u16 ip6mh_cksum;
	__u8 data[0];
};

struct xfrm_flo {
	struct dst_entry *dst_orig;
	u8 flags;
};

struct xfrm_pol_inexact_node {
	struct rb_node node;
	union {
		xfrm_address_t addr;
		struct callback_head rcu;
	};
	u8 prefixlen;
	struct rb_root root;
	struct hlist_head hhead;
};

struct xfrm_pol_inexact_key {
	possible_net_t net;
	u32 if_id;
	u16 family;
	u8 dir;
	u8 type;
};

struct xfrm_pol_inexact_bin {
	struct xfrm_pol_inexact_key k;
	struct rhash_head head;
	struct hlist_head hhead;
	seqcount_spinlock_t count;
	struct rb_root root_d;
	struct rb_root root_s;
	struct list_head inexact_bins;
	struct callback_head rcu;
};

enum xfrm_pol_inexact_candidate_type {
	XFRM_POL_CAND_BOTH = 0,
	XFRM_POL_CAND_SADDR = 1,
	XFRM_POL_CAND_DADDR = 2,
	XFRM_POL_CAND_ANY = 3,
	XFRM_POL_CAND_MAX = 4,
};

struct xfrm_pol_inexact_candidates {
	struct hlist_head *res[4];
};

enum xfrm_ae_ftype_t {
	XFRM_AE_UNSPEC = 0,
	XFRM_AE_RTHR = 1,
	XFRM_AE_RVAL = 2,
	XFRM_AE_LVAL = 4,
	XFRM_AE_ETHR = 8,
	XFRM_AE_CR = 16,
	XFRM_AE_CE = 32,
	XFRM_AE_CU = 64,
	__XFRM_AE_MAX = 65,
};

enum xfrm_nlgroups {
	XFRMNLGRP_NONE = 0,
	XFRMNLGRP_ACQUIRE = 1,
	XFRMNLGRP_EXPIRE = 2,
	XFRMNLGRP_SA = 3,
	XFRMNLGRP_POLICY = 4,
	XFRMNLGRP_AEVENTS = 5,
	XFRMNLGRP_REPORT = 6,
	XFRMNLGRP_MIGRATE = 7,
	XFRMNLGRP_MAPPING = 8,
	__XFRMNLGRP_MAX = 9,
};

enum {
	XFRM_MODE_FLAG_TUNNEL = 1,
};

struct km_event {
	union {
		u32 hard;
		u32 proto;
		u32 byid;
		u32 aevent;
		u32 type;
	} data;
	u32 seq;
	u32 portid;
	u32 event;
	struct net *net;
};

struct xfrm_kmaddress {
	xfrm_address_t local;
	xfrm_address_t remote;
	u32 reserved;
	u16 family;
};

struct xfrm_migrate {
	xfrm_address_t old_daddr;
	xfrm_address_t old_saddr;
	xfrm_address_t new_daddr;
	xfrm_address_t new_saddr;
	u8 proto;
	u8 mode;
	u16 reserved;
	u32 reqid;
	u16 old_family;
	u16 new_family;
};

struct xfrm_mgr {
	struct list_head list;
	int (*notify)(struct xfrm_state *, const struct km_event *);
	int (*acquire)(struct xfrm_state *, struct xfrm_tmpl *, struct xfrm_policy *);
	struct xfrm_policy * (*compile_policy)(struct sock *, int, u8 *, int, int *);
	int (*new_mapping)(struct xfrm_state *, xfrm_address_t *, __be16);
	int (*notify_policy)(struct xfrm_policy *, int, const struct km_event *);
	int (*report)(struct net *, u8, struct xfrm_selector *, xfrm_address_t *);
	int (*migrate)(const struct xfrm_selector *, u8, u8, const struct xfrm_migrate *, int, const struct xfrm_kmaddress *, const struct xfrm_encap_tmpl *);
	bool (*is_alive)(const struct km_event *);
};

struct xfrmk_sadinfo {
	u32 sadhcnt;
	u32 sadhmcnt;
	u32 sadcnt;
};

struct xfrm_translator {
	int (*alloc_compat)(struct sk_buff *, const struct nlmsghdr *);
	struct nlmsghdr * (*rcv_msg_compat)(const struct nlmsghdr *, int, const struct nla_policy *, struct netlink_ext_ack *);
	int (*xlate_user_policy_sockptr)(u8 **, int);
	struct module *owner;
};

struct ip_beet_phdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 padlen;
	__u8 reserved;
};

struct __ip6_tnl_parm {
	char name[16];
	int link;
	__u8 proto;
	__u8 encap_limit;
	__u8 hop_limit;
	bool collect_md;
	__be32 flowinfo;
	__u32 flags;
	struct in6_addr laddr;
	struct in6_addr raddr;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	__u32 fwmark;
	__u32 index;
	__u8 erspan_ver;
	__u8 dir;
	__u16 hwid;
};

struct ip6_tnl {
	struct ip6_tnl *next;
	struct net_device *dev;
	struct net *net;
	struct __ip6_tnl_parm parms;
	int: 32;
	struct flowi fl;
	struct dst_cache dst_cache;
	struct gro_cells gro_cells;
	int err_count;
	long unsigned int err_time;
	__u32 i_seqno;
	__u32 o_seqno;
	int hlen;
	int tun_hlen;
	int encap_hlen;
	struct ip_tunnel_encap encap;
	int mlink;
	int: 32;
};

struct xfrm_skb_cb {
	struct xfrm_tunnel_skb_cb header;
	union {
		struct {
			__u32 low;
			__u32 hi;
		} output;
		struct {
			__be32 low;
			__be32 hi;
		} input;
	} seq;
};

struct xfrm_trans_tasklet {
	struct tasklet_struct tasklet;
	struct sk_buff_head queue;
};

struct xfrm_trans_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	int (*finish)(struct net *, struct sock *, struct sk_buff *);
	struct net *net;
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	unsigned int hash;
	struct sockaddr_un name[0];
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	__u16 gso_size;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	__IFLA_INET6_MAX = 9,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	int: 32;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool promiscuous_mode;
	bool ackreq;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_MAX = 52,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	u32 flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u8 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	int: 16;
	int: 32;
	struct device dev;
	possible_net_t _net;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	char priv[0];
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	int: 32;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		__be16 fifo_hi;
		__be32 fifo_lo;
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_NOT_OPTIMISTIC = 9,
	IPV6_SADDR_RULE_MAX = 10,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	u32 __data_loc_name;
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct __rt6_probe_work {
	struct work_struct work;
	struct in6_addr target;
	struct net_device *dev;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_L = 0,
	FWS_R = 1,
	FWS_C = 2,
	FWS_U = 3,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	int: 32;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct static_key_false_deferred {
	struct static_key_false key;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
	int: 32;
};

typedef int mh_filter_t(struct sock *, struct sk_buff *);

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *);

struct ipv6_destopt_hao {
	__u8 type;
	__u8 length;
	struct in6_addr addr;
} __attribute__((packed));

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct in6_addr addr[0];
		__u8 data[0];
	} segments;
};

struct tlvtype_proc {
	int type;
	bool (*func)(struct sk_buff *, int);
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

struct xfrm6_protocol {
	int (*handler)(struct sk_buff *);
	int (*input_handler)(struct sk_buff *, int, __be32, int);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	struct xfrm6_protocol *next;
	int priority;
};

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct fib6_rule {
	struct fib_rule common;
	struct rt6key src;
	struct rt6key dst;
	u8 tclass;
	int: 24;
	int: 32;
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

struct ip_tunnel_prl {
	__be32 addr;
	__u16 flags;
	__u16 __reserved;
	__u32 datalen;
	__u32 __reserved2;
};

struct sit_net {
	struct ip_tunnel *tunnels_r_l[16];
	struct ip_tunnel *tunnels_r[16];
	struct ip_tunnel *tunnels_l[16];
	struct ip_tunnel *tunnels_wc[1];
	struct ip_tunnel **tunnels[4];
	struct net_device *fb_tunnel_dev;
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
	int: 32;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	int: 32;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct packet_type prot_hook;
	struct sock *arr[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned int running;
	unsigned int auxdata: 1;
	unsigned int origdev: 1;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct packet_type prot_hook;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic_t tp_drops;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

enum {
	SUNRPC_PIPEFS_NFS_PRIO = 0,
	SUNRPC_PIPEFS_RPC_PRIO = 1,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
};

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct connect_timeout_data {
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
	const char *netid[0];
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

typedef __be32 rpc_fraghdr;

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	struct page *sk_pages[259];
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		long unsigned int copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	long unsigned int sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct __kernel_sockaddr_storage srcaddr;
	short unsigned int srcport;
	int xprt_err;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

typedef void (*rpc_action)(struct rpc_task *);

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	long unsigned int timeout;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	long unsigned int backlog;
	long unsigned int rtt;
	long unsigned int execute;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	u32 __data_loc_dstaddr;
	u32 __data_loc_dstport;
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	int: 32;
	long long unsigned int ino;
	u32 __data_loc_dstaddr;
	u32 __data_loc_dstport;
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	long unsigned int cong;
	long unsigned int cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	long unsigned int copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	short unsigned int port;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_svc_xdr_msg_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 xid;
	long unsigned int svc_status;
	long unsigned int auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 xid;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 xid;
	int status;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long int error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	unsigned char addr[28];
	char __data[0];
};

struct trace_event_raw_svc_xprt_do_enqueue {
	struct trace_entry ent;
	int pid;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	long unsigned int flags;
	long unsigned int wakeup;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_handle_xprt {
	struct trace_entry ent;
	int len;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 xid;
	long unsigned int execute;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_new_socket {
	struct trace_entry ent;
	long unsigned int type;
	long unsigned int family;
	bool listener;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	long unsigned int socket_state;
	long unsigned int sock_state;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long int status;
	u32 __data_loc_service;
	unsigned char addr[28];
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	long unsigned int family;
	short unsigned int protocol;
	short unsigned int port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 addr;
	u32 port;
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	u32 procname;
	u32 servername;
};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_xs_socket_event {
	u32 dstaddr;
	u32 dstport;
};

struct trace_event_data_offsets_xs_socket_event_done {
	u32 dstaddr;
	u32 dstport;
};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	u32 netid;
};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
};

struct trace_event_data_offsets_svc_xdr_msg_class {};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_authenticate {};

struct trace_event_data_offsets_svc_process {
	u32 service;
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	u32 protocol;
};

struct trace_event_data_offsets_svc_xprt_do_enqueue {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 addr;
	u32 protocol;
	u32 service;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 addr;
};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_handle_xprt {
	u32 addr;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 addr;
};

struct trace_event_data_offsets_svc_deferred_event {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_new_socket {};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
};

struct trace_event_data_offsets_cache_event {
	u32 name;
};

struct trace_event_data_offsets_register_class {
	u32 program;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
};

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const char *, const char *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_cleanup)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_transmit_queued)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, short unsigned int);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, short unsigned int);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, __be32, const struct xdr_buf *);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, int, __be32);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, struct svc_rqst *, int);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_do_enqueue)(void *, struct svc_xprt *, struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_close)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_detach)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_free)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, struct svc_rqst *);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_handle_xprt)(void *, struct svc_xprt *, int);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svcsock_new_socket)(void *, const struct socket *);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

enum {
	SVC_POOL_AUTO = 4294967295,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

struct unix_domain {
	struct auth_domain h;
};

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
	int: 32;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	short unsigned int r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

enum rpc_gss_proc {
	RPC_GSS_PROC_DATA = 0,
	RPC_GSS_PROC_INIT = 1,
	RPC_GSS_PROC_CONTINUE_INIT = 2,
	RPC_GSS_PROC_DESTROY = 3,
};

enum rpc_gss_svc {
	RPC_GSS_SVC_NONE = 1,
	RPC_GSS_SVC_INTEGRITY = 2,
	RPC_GSS_SVC_PRIVACY = 3,
};

struct gss_cl_ctx {
	refcount_t count;
	enum rpc_gss_proc gc_proc;
	u32 gc_seq;
	u32 gc_seq_xmit;
	spinlock_t gc_seq_lock;
	struct gss_ctx *gc_gss_ctx;
	struct xdr_netobj gc_wire_ctx;
	struct xdr_netobj gc_acceptor;
	u32 gc_win;
	long unsigned int gc_expiry;
	struct callback_head gc_rcu;
};

struct gss_upcall_msg;

struct gss_cred {
	struct rpc_cred gc_base;
	enum rpc_gss_svc gc_service;
	struct gss_cl_ctx *gc_ctx;
	struct gss_upcall_msg *gc_upcall;
	const char *gc_principal;
	long unsigned int gc_upcall_timestamp;
};

struct gss_auth;

struct gss_upcall_msg {
	refcount_t count;
	kuid_t uid;
	const char *service_name;
	struct rpc_pipe_msg msg;
	struct list_head list;
	struct gss_auth *auth;
	struct rpc_pipe *pipe;
	struct rpc_wait_queue rpc_waitqueue;
	wait_queue_head_t waitqueue;
	struct gss_cl_ctx *ctx;
	char databuf[256];
};

typedef unsigned int OM_uint32;

struct gss_pipe {
	struct rpc_pipe_dir_object pdo;
	struct rpc_pipe *pipe;
	struct rpc_clnt *clnt;
	const char *name;
	struct kref kref;
};

struct gss_auth {
	struct kref kref;
	struct hlist_node hash;
	struct rpc_auth rpc_auth;
	struct gss_api_mech *mech;
	enum rpc_gss_svc service;
	struct rpc_clnt *client;
	struct net *net;
	struct gss_pipe *gss_pipe[2];
	const char *target_name;
};

struct gss_alloc_pdo {
	struct rpc_clnt *clnt;
	const char *name;
	const struct rpc_pipe_ops *upcall_ops;
};

struct rpc_gss_wire_cred {
	u32 gc_v;
	u32 gc_proc;
	u32 gc_seq;
	u32 gc_svc;
	struct xdr_netobj gc_ctx;
};

struct gssp_in_token {
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
};

struct gssp_upcall_data {
	struct xdr_netobj in_handle;
	struct gssp_in_token in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	struct rpcsec_gss_oid mech_oid;
	struct svc_cred creds;
	int found_creds;
	int major_status;
	int minor_status;
};

struct rsi {
	struct cache_head h;
	struct xdr_netobj in_handle;
	struct xdr_netobj in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	int major_status;
	int minor_status;
	struct callback_head callback_head;
};

struct gss_svc_seq_data {
	u32 sd_max;
	long unsigned int sd_win[4];
	spinlock_t sd_lock;
};

struct rsc {
	struct cache_head h;
	struct xdr_netobj handle;
	struct svc_cred cred;
	struct gss_svc_seq_data seqdata;
	struct gss_ctx *mechctx;
	struct callback_head callback_head;
	int: 32;
};

struct gss_domain {
	struct auth_domain h;
	u32 pseudoflavor;
};

struct gss_svc_data {
	struct rpc_gss_wire_cred clcred;
	__be32 *verf_start;
	struct rsc *rsci;
};

typedef struct xdr_netobj gssx_buffer;

typedef struct xdr_netobj utf8string;

typedef struct xdr_netobj gssx_OID;

struct gssx_option {
	gssx_buffer option;
	gssx_buffer value;
};

struct gssx_option_array {
	u32 count;
	struct gssx_option *data;
};

struct gssx_status {
	u64 major_status;
	gssx_OID mech;
	u64 minor_status;
	utf8string major_status_string;
	utf8string minor_status_string;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_call_ctx {
	utf8string locale;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_name {
	gssx_buffer display_name;
};

typedef struct gssx_name gssx_name;

struct gssx_cred_element {
	gssx_name MN;
	gssx_OID mech;
	u32 cred_usage;
	int: 32;
	u64 initiator_time_rec;
	u64 acceptor_time_rec;
	struct gssx_option_array options;
};

struct gssx_cred_element_array {
	u32 count;
	struct gssx_cred_element *data;
};

struct gssx_cred {
	gssx_name desired_name;
	struct gssx_cred_element_array elements;
	gssx_buffer cred_handle_reference;
	u32 needs_release;
};

struct gssx_ctx {
	gssx_buffer exported_context_token;
	gssx_buffer state;
	u32 need_release;
	gssx_OID mech;
	gssx_name src_name;
	gssx_name targ_name;
	int: 32;
	u64 lifetime;
	u64 ctx_flags;
	u32 locally_initiated;
	u32 open;
	struct gssx_option_array options;
};

struct gssx_cb {
	u64 initiator_addrtype;
	gssx_buffer initiator_address;
	u64 acceptor_addrtype;
	gssx_buffer acceptor_address;
	gssx_buffer application_data;
};

struct gssx_arg_accept_sec_context {
	struct gssx_call_ctx call_ctx;
	struct gssx_ctx *context_handle;
	struct gssx_cred *cred_handle;
	struct gssp_in_token input_token;
	struct gssx_cb *input_cb;
	u32 ret_deleg_cred;
	struct gssx_option_array options;
	struct page **pages;
	unsigned int npages;
};

struct gssx_res_accept_sec_context {
	struct gssx_status status;
	struct gssx_ctx *context_handle;
	gssx_buffer *output_token;
	struct gssx_option_array options;
};

enum {
	GSSX_NULL = 0,
	GSSX_INDICATE_MECHS = 1,
	GSSX_GET_CALL_CONTEXT = 2,
	GSSX_IMPORT_AND_CANON_NAME = 3,
	GSSX_EXPORT_CRED = 4,
	GSSX_IMPORT_CRED = 5,
	GSSX_ACQUIRE_CRED = 6,
	GSSX_STORE_CRED = 7,
	GSSX_INIT_SEC_CONTEXT = 8,
	GSSX_ACCEPT_SEC_CONTEXT = 9,
	GSSX_RELEASE_HANDLE = 10,
	GSSX_GET_MIC = 11,
	GSSX_VERIFY = 12,
	GSSX_WRAP = 13,
	GSSX_UNWRAP = 14,
	GSSX_WRAP_SIZE_LIMIT = 15,
};

struct gssx_name_attr {
	gssx_buffer attr;
	gssx_buffer value;
	struct gssx_option_array extensions;
};

struct gssx_name_attr_array {
	u32 count;
	struct gssx_name_attr *data;
};

struct trace_event_raw_rpcgss_gssapi_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 maj_stat;
	char __data[0];
};

struct trace_event_raw_rpcgss_import_ctx {
	struct trace_entry ent;
	int status;
	char __data[0];
};

struct trace_event_raw_rpcgss_ctx_class {
	struct trace_entry ent;
	const void *cred;
	long unsigned int service;
	u32 __data_loc_principal;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_gssapi_class {
	struct trace_entry ent;
	u32 xid;
	u32 maj_stat;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_unwrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_bad {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_accept_upcall {
	struct trace_entry ent;
	u32 minor_status;
	long unsigned int major_status;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_authenticate {
	struct trace_entry ent;
	u32 seqno;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_unwrap_failed {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpcgss_bad_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 expected;
	u32 received;
	char __data[0];
};

struct trace_event_raw_rpcgss_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_need_reencode {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seq_xmit;
	u32 seqno;
	bool ret;
	char __data[0];
};

struct trace_event_raw_rpcgss_update_slack {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	const void *auth;
	unsigned int rslack;
	unsigned int ralign;
	unsigned int verfsize;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_class {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_low {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_result {
	struct trace_entry ent;
	u32 uid;
	int result;
	char __data[0];
};

struct trace_event_raw_rpcgss_context {
	struct trace_entry ent;
	long unsigned int expiry;
	long unsigned int now;
	unsigned int timeout;
	u32 window_size;
	int len;
	u32 __data_loc_acceptor;
	char __data[0];
};

struct trace_event_raw_rpcgss_createauth {
	struct trace_entry ent;
	unsigned int flavor;
	int error;
	char __data[0];
};

struct trace_event_raw_rpcgss_oid_to_mech {
	struct trace_entry ent;
	u32 __data_loc_oid;
	char __data[0];
};

struct trace_event_data_offsets_rpcgss_gssapi_event {};

struct trace_event_data_offsets_rpcgss_import_ctx {};

struct trace_event_data_offsets_rpcgss_ctx_class {
	u32 principal;
};

struct trace_event_data_offsets_rpcgss_svc_gssapi_class {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_unwrap_failed {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_bad {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_accept_upcall {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_authenticate {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_unwrap_failed {};

struct trace_event_data_offsets_rpcgss_bad_seqno {};

struct trace_event_data_offsets_rpcgss_seqno {};

struct trace_event_data_offsets_rpcgss_need_reencode {};

struct trace_event_data_offsets_rpcgss_update_slack {};

struct trace_event_data_offsets_rpcgss_svc_seqno_class {};

struct trace_event_data_offsets_rpcgss_svc_seqno_low {};

struct trace_event_data_offsets_rpcgss_upcall_msg {
	u32 msg;
};

struct trace_event_data_offsets_rpcgss_upcall_result {};

struct trace_event_data_offsets_rpcgss_context {
	u32 acceptor;
};

struct trace_event_data_offsets_rpcgss_createauth {};

struct trace_event_data_offsets_rpcgss_oid_to_mech {
	u32 oid;
};

typedef void (*btf_trace_rpcgss_import_ctx)(void *, int);

typedef void (*btf_trace_rpcgss_get_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_verify_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_wrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_unwrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_ctx_init)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_ctx_destroy)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_svc_unwrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_seqno_bad)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_accept_upcall)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_authenticate)(void *, const struct svc_rqst *, const struct rpc_gss_wire_cred *);

typedef void (*btf_trace_rpcgss_unwrap_failed)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_bad_seqno)(void *, const struct rpc_task *, u32, u32);

typedef void (*btf_trace_rpcgss_seqno)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_need_reencode)(void *, const struct rpc_task *, u32, bool);

typedef void (*btf_trace_rpcgss_update_slack)(void *, const struct rpc_task *, const struct rpc_auth *);

typedef void (*btf_trace_rpcgss_svc_seqno_large)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_seen)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_low)(void *, const struct svc_rqst *, u32, u32, u32);

typedef void (*btf_trace_rpcgss_upcall_msg)(void *, const char *);

typedef void (*btf_trace_rpcgss_upcall_result)(void *, u32, int);

typedef void (*btf_trace_rpcgss_context)(void *, u32, long unsigned int, long unsigned int, unsigned int, unsigned int, const u8 *);

typedef void (*btf_trace_rpcgss_createauth)(void *, unsigned int, int);

typedef void (*btf_trace_rpcgss_oid_to_mech)(void *, const char *);

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

enum nl80211_commands {
	NL80211_CMD_UNSPEC = 0,
	NL80211_CMD_GET_WIPHY = 1,
	NL80211_CMD_SET_WIPHY = 2,
	NL80211_CMD_NEW_WIPHY = 3,
	NL80211_CMD_DEL_WIPHY = 4,
	NL80211_CMD_GET_INTERFACE = 5,
	NL80211_CMD_SET_INTERFACE = 6,
	NL80211_CMD_NEW_INTERFACE = 7,
	NL80211_CMD_DEL_INTERFACE = 8,
	NL80211_CMD_GET_KEY = 9,
	NL80211_CMD_SET_KEY = 10,
	NL80211_CMD_NEW_KEY = 11,
	NL80211_CMD_DEL_KEY = 12,
	NL80211_CMD_GET_BEACON = 13,
	NL80211_CMD_SET_BEACON = 14,
	NL80211_CMD_START_AP = 15,
	NL80211_CMD_NEW_BEACON = 15,
	NL80211_CMD_STOP_AP = 16,
	NL80211_CMD_DEL_BEACON = 16,
	NL80211_CMD_GET_STATION = 17,
	NL80211_CMD_SET_STATION = 18,
	NL80211_CMD_NEW_STATION = 19,
	NL80211_CMD_DEL_STATION = 20,
	NL80211_CMD_GET_MPATH = 21,
	NL80211_CMD_SET_MPATH = 22,
	NL80211_CMD_NEW_MPATH = 23,
	NL80211_CMD_DEL_MPATH = 24,
	NL80211_CMD_SET_BSS = 25,
	NL80211_CMD_SET_REG = 26,
	NL80211_CMD_REQ_SET_REG = 27,
	NL80211_CMD_GET_MESH_CONFIG = 28,
	NL80211_CMD_SET_MESH_CONFIG = 29,
	NL80211_CMD_SET_MGMT_EXTRA_IE = 30,
	NL80211_CMD_GET_REG = 31,
	NL80211_CMD_GET_SCAN = 32,
	NL80211_CMD_TRIGGER_SCAN = 33,
	NL80211_CMD_NEW_SCAN_RESULTS = 34,
	NL80211_CMD_SCAN_ABORTED = 35,
	NL80211_CMD_REG_CHANGE = 36,
	NL80211_CMD_AUTHENTICATE = 37,
	NL80211_CMD_ASSOCIATE = 38,
	NL80211_CMD_DEAUTHENTICATE = 39,
	NL80211_CMD_DISASSOCIATE = 40,
	NL80211_CMD_MICHAEL_MIC_FAILURE = 41,
	NL80211_CMD_REG_BEACON_HINT = 42,
	NL80211_CMD_JOIN_IBSS = 43,
	NL80211_CMD_LEAVE_IBSS = 44,
	NL80211_CMD_TESTMODE = 45,
	NL80211_CMD_CONNECT = 46,
	NL80211_CMD_ROAM = 47,
	NL80211_CMD_DISCONNECT = 48,
	NL80211_CMD_SET_WIPHY_NETNS = 49,
	NL80211_CMD_GET_SURVEY = 50,
	NL80211_CMD_NEW_SURVEY_RESULTS = 51,
	NL80211_CMD_SET_PMKSA = 52,
	NL80211_CMD_DEL_PMKSA = 53,
	NL80211_CMD_FLUSH_PMKSA = 54,
	NL80211_CMD_REMAIN_ON_CHANNEL = 55,
	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL = 56,
	NL80211_CMD_SET_TX_BITRATE_MASK = 57,
	NL80211_CMD_REGISTER_FRAME = 58,
	NL80211_CMD_REGISTER_ACTION = 58,
	NL80211_CMD_FRAME = 59,
	NL80211_CMD_ACTION = 59,
	NL80211_CMD_FRAME_TX_STATUS = 60,
	NL80211_CMD_ACTION_TX_STATUS = 60,
	NL80211_CMD_SET_POWER_SAVE = 61,
	NL80211_CMD_GET_POWER_SAVE = 62,
	NL80211_CMD_SET_CQM = 63,
	NL80211_CMD_NOTIFY_CQM = 64,
	NL80211_CMD_SET_CHANNEL = 65,
	NL80211_CMD_SET_WDS_PEER = 66,
	NL80211_CMD_FRAME_WAIT_CANCEL = 67,
	NL80211_CMD_JOIN_MESH = 68,
	NL80211_CMD_LEAVE_MESH = 69,
	NL80211_CMD_UNPROT_DEAUTHENTICATE = 70,
	NL80211_CMD_UNPROT_DISASSOCIATE = 71,
	NL80211_CMD_NEW_PEER_CANDIDATE = 72,
	NL80211_CMD_GET_WOWLAN = 73,
	NL80211_CMD_SET_WOWLAN = 74,
	NL80211_CMD_START_SCHED_SCAN = 75,
	NL80211_CMD_STOP_SCHED_SCAN = 76,
	NL80211_CMD_SCHED_SCAN_RESULTS = 77,
	NL80211_CMD_SCHED_SCAN_STOPPED = 78,
	NL80211_CMD_SET_REKEY_OFFLOAD = 79,
	NL80211_CMD_PMKSA_CANDIDATE = 80,
	NL80211_CMD_TDLS_OPER = 81,
	NL80211_CMD_TDLS_MGMT = 82,
	NL80211_CMD_UNEXPECTED_FRAME = 83,
	NL80211_CMD_PROBE_CLIENT = 84,
	NL80211_CMD_REGISTER_BEACONS = 85,
	NL80211_CMD_UNEXPECTED_4ADDR_FRAME = 86,
	NL80211_CMD_SET_NOACK_MAP = 87,
	NL80211_CMD_CH_SWITCH_NOTIFY = 88,
	NL80211_CMD_START_P2P_DEVICE = 89,
	NL80211_CMD_STOP_P2P_DEVICE = 90,
	NL80211_CMD_CONN_FAILED = 91,
	NL80211_CMD_SET_MCAST_RATE = 92,
	NL80211_CMD_SET_MAC_ACL = 93,
	NL80211_CMD_RADAR_DETECT = 94,
	NL80211_CMD_GET_PROTOCOL_FEATURES = 95,
	NL80211_CMD_UPDATE_FT_IES = 96,
	NL80211_CMD_FT_EVENT = 97,
	NL80211_CMD_CRIT_PROTOCOL_START = 98,
	NL80211_CMD_CRIT_PROTOCOL_STOP = 99,
	NL80211_CMD_GET_COALESCE = 100,
	NL80211_CMD_SET_COALESCE = 101,
	NL80211_CMD_CHANNEL_SWITCH = 102,
	NL80211_CMD_VENDOR = 103,
	NL80211_CMD_SET_QOS_MAP = 104,
	NL80211_CMD_ADD_TX_TS = 105,
	NL80211_CMD_DEL_TX_TS = 106,
	NL80211_CMD_GET_MPP = 107,
	NL80211_CMD_JOIN_OCB = 108,
	NL80211_CMD_LEAVE_OCB = 109,
	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY = 110,
	NL80211_CMD_TDLS_CHANNEL_SWITCH = 111,
	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH = 112,
	NL80211_CMD_WIPHY_REG_CHANGE = 113,
	NL80211_CMD_ABORT_SCAN = 114,
	NL80211_CMD_START_NAN = 115,
	NL80211_CMD_STOP_NAN = 116,
	NL80211_CMD_ADD_NAN_FUNCTION = 117,
	NL80211_CMD_DEL_NAN_FUNCTION = 118,
	NL80211_CMD_CHANGE_NAN_CONFIG = 119,
	NL80211_CMD_NAN_MATCH = 120,
	NL80211_CMD_SET_MULTICAST_TO_UNICAST = 121,
	NL80211_CMD_UPDATE_CONNECT_PARAMS = 122,
	NL80211_CMD_SET_PMK = 123,
	NL80211_CMD_DEL_PMK = 124,
	NL80211_CMD_PORT_AUTHORIZED = 125,
	NL80211_CMD_RELOAD_REGDB = 126,
	NL80211_CMD_EXTERNAL_AUTH = 127,
	NL80211_CMD_STA_OPMODE_CHANGED = 128,
	NL80211_CMD_CONTROL_PORT_FRAME = 129,
	NL80211_CMD_GET_FTM_RESPONDER_STATS = 130,
	NL80211_CMD_PEER_MEASUREMENT_START = 131,
	NL80211_CMD_PEER_MEASUREMENT_RESULT = 132,
	NL80211_CMD_PEER_MEASUREMENT_COMPLETE = 133,
	NL80211_CMD_NOTIFY_RADAR = 134,
	NL80211_CMD_UPDATE_OWE_INFO = 135,
	NL80211_CMD_PROBE_MESH_LINK = 136,
	NL80211_CMD_SET_TID_CONFIG = 137,
	NL80211_CMD_UNPROT_BEACON = 138,
	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS = 139,
	NL80211_CMD_SET_SAR_SPECS = 140,
	__NL80211_CMD_AFTER_LAST = 141,
	NL80211_CMD_MAX = 140,
};

enum nl80211_iftype {
	NL80211_IFTYPE_UNSPECIFIED = 0,
	NL80211_IFTYPE_ADHOC = 1,
	NL80211_IFTYPE_STATION = 2,
	NL80211_IFTYPE_AP = 3,
	NL80211_IFTYPE_AP_VLAN = 4,
	NL80211_IFTYPE_WDS = 5,
	NL80211_IFTYPE_MONITOR = 6,
	NL80211_IFTYPE_MESH_POINT = 7,
	NL80211_IFTYPE_P2P_CLIENT = 8,
	NL80211_IFTYPE_P2P_GO = 9,
	NL80211_IFTYPE_P2P_DEVICE = 10,
	NL80211_IFTYPE_OCB = 11,
	NL80211_IFTYPE_NAN = 12,
	NUM_NL80211_IFTYPES = 13,
	NL80211_IFTYPE_MAX = 12,
};

struct nl80211_sta_flag_update {
	__u32 mask;
	__u32 set;
};

enum nl80211_he_gi {
	NL80211_RATE_INFO_HE_GI_0_8 = 0,
	NL80211_RATE_INFO_HE_GI_1_6 = 1,
	NL80211_RATE_INFO_HE_GI_3_2 = 2,
};

enum nl80211_he_ltf {
	NL80211_RATE_INFO_HE_1XLTF = 0,
	NL80211_RATE_INFO_HE_2XLTF = 1,
	NL80211_RATE_INFO_HE_4XLTF = 2,
};

enum nl80211_reg_initiator {
	NL80211_REGDOM_SET_BY_CORE = 0,
	NL80211_REGDOM_SET_BY_USER = 1,
	NL80211_REGDOM_SET_BY_DRIVER = 2,
	NL80211_REGDOM_SET_BY_COUNTRY_IE = 3,
};

enum nl80211_dfs_regions {
	NL80211_DFS_UNSET = 0,
	NL80211_DFS_FCC = 1,
	NL80211_DFS_ETSI = 2,
	NL80211_DFS_JP = 3,
};

enum nl80211_user_reg_hint_type {
	NL80211_USER_REG_HINT_USER = 0,
	NL80211_USER_REG_HINT_CELL_BASE = 1,
	NL80211_USER_REG_HINT_INDOOR = 2,
};

enum nl80211_mntr_flags {
	__NL80211_MNTR_FLAG_INVALID = 0,
	NL80211_MNTR_FLAG_FCSFAIL = 1,
	NL80211_MNTR_FLAG_PLCPFAIL = 2,
	NL80211_MNTR_FLAG_CONTROL = 3,
	NL80211_MNTR_FLAG_OTHER_BSS = 4,
	NL80211_MNTR_FLAG_COOK_FRAMES = 5,
	NL80211_MNTR_FLAG_ACTIVE = 6,
	__NL80211_MNTR_FLAG_AFTER_LAST = 7,
	NL80211_MNTR_FLAG_MAX = 6,
};

enum nl80211_mesh_power_mode {
	NL80211_MESH_POWER_UNKNOWN = 0,
	NL80211_MESH_POWER_ACTIVE = 1,
	NL80211_MESH_POWER_LIGHT_SLEEP = 2,
	NL80211_MESH_POWER_DEEP_SLEEP = 3,
	__NL80211_MESH_POWER_AFTER_LAST = 4,
	NL80211_MESH_POWER_MAX = 3,
};

enum nl80211_ac {
	NL80211_AC_VO = 0,
	NL80211_AC_VI = 1,
	NL80211_AC_BE = 2,
	NL80211_AC_BK = 3,
	NL80211_NUM_ACS = 4,
};

enum nl80211_key_mode {
	NL80211_KEY_RX_TX = 0,
	NL80211_KEY_NO_TX = 1,
	NL80211_KEY_SET_TX = 2,
};

enum nl80211_chan_width {
	NL80211_CHAN_WIDTH_20_NOHT = 0,
	NL80211_CHAN_WIDTH_20 = 1,
	NL80211_CHAN_WIDTH_40 = 2,
	NL80211_CHAN_WIDTH_80 = 3,
	NL80211_CHAN_WIDTH_80P80 = 4,
	NL80211_CHAN_WIDTH_160 = 5,
	NL80211_CHAN_WIDTH_5 = 6,
	NL80211_CHAN_WIDTH_10 = 7,
	NL80211_CHAN_WIDTH_1 = 8,
	NL80211_CHAN_WIDTH_2 = 9,
	NL80211_CHAN_WIDTH_4 = 10,
	NL80211_CHAN_WIDTH_8 = 11,
	NL80211_CHAN_WIDTH_16 = 12,
};

enum nl80211_bss_scan_width {
	NL80211_BSS_CHAN_WIDTH_20 = 0,
	NL80211_BSS_CHAN_WIDTH_10 = 1,
	NL80211_BSS_CHAN_WIDTH_5 = 2,
	NL80211_BSS_CHAN_WIDTH_1 = 3,
	NL80211_BSS_CHAN_WIDTH_2 = 4,
};

enum nl80211_auth_type {
	NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
	NL80211_AUTHTYPE_SHARED_KEY = 1,
	NL80211_AUTHTYPE_FT = 2,
	NL80211_AUTHTYPE_NETWORK_EAP = 3,
	NL80211_AUTHTYPE_SAE = 4,
	NL80211_AUTHTYPE_FILS_SK = 5,
	NL80211_AUTHTYPE_FILS_SK_PFS = 6,
	NL80211_AUTHTYPE_FILS_PK = 7,
	__NL80211_AUTHTYPE_NUM = 8,
	NL80211_AUTHTYPE_MAX = 7,
	NL80211_AUTHTYPE_AUTOMATIC = 8,
};

enum nl80211_mfp {
	NL80211_MFP_NO = 0,
	NL80211_MFP_REQUIRED = 1,
	NL80211_MFP_OPTIONAL = 2,
};

enum nl80211_txrate_gi {
	NL80211_TXRATE_DEFAULT_GI = 0,
	NL80211_TXRATE_FORCE_SGI = 1,
	NL80211_TXRATE_FORCE_LGI = 2,
};

enum nl80211_band {
	NL80211_BAND_2GHZ = 0,
	NL80211_BAND_5GHZ = 1,
	NL80211_BAND_60GHZ = 2,
	NL80211_BAND_6GHZ = 3,
	NL80211_BAND_S1GHZ = 4,
	NUM_NL80211_BANDS = 5,
};

enum nl80211_tx_power_setting {
	NL80211_TX_POWER_AUTOMATIC = 0,
	NL80211_TX_POWER_LIMITED = 1,
	NL80211_TX_POWER_FIXED = 2,
};

enum nl80211_tid_config {
	NL80211_TID_CONFIG_ENABLE = 0,
	NL80211_TID_CONFIG_DISABLE = 1,
};

enum nl80211_tx_rate_setting {
	NL80211_TX_RATE_AUTOMATIC = 0,
	NL80211_TX_RATE_LIMITED = 1,
	NL80211_TX_RATE_FIXED = 2,
};

struct nl80211_wowlan_tcp_data_seq {
	__u32 start;
	__u32 offset;
	__u32 len;
};

struct nl80211_wowlan_tcp_data_token {
	__u32 offset;
	__u32 len;
	__u8 token_stream[0];
};

struct nl80211_wowlan_tcp_data_token_feature {
	__u32 min_len;
	__u32 max_len;
	__u32 bufsize;
};

enum nl80211_coalesce_condition {
	NL80211_COALESCE_CONDITION_MATCH = 0,
	NL80211_COALESCE_CONDITION_NO_MATCH = 1,
};

enum nl80211_hidden_ssid {
	NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
	NL80211_HIDDEN_SSID_ZERO_LEN = 1,
	NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2,
};

enum nl80211_tdls_operation {
	NL80211_TDLS_DISCOVERY_REQ = 0,
	NL80211_TDLS_SETUP = 1,
	NL80211_TDLS_TEARDOWN = 2,
	NL80211_TDLS_ENABLE_LINK = 3,
	NL80211_TDLS_DISABLE_LINK = 4,
};

enum nl80211_feature_flags {
	NL80211_FEATURE_SK_TX_STATUS = 1,
	NL80211_FEATURE_HT_IBSS = 2,
	NL80211_FEATURE_INACTIVITY_TIMER = 4,
	NL80211_FEATURE_CELL_BASE_REG_HINTS = 8,
	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL = 16,
	NL80211_FEATURE_SAE = 32,
	NL80211_FEATURE_LOW_PRIORITY_SCAN = 64,
	NL80211_FEATURE_SCAN_FLUSH = 128,
	NL80211_FEATURE_AP_SCAN = 256,
	NL80211_FEATURE_VIF_TXPOWER = 512,
	NL80211_FEATURE_NEED_OBSS_SCAN = 1024,
	NL80211_FEATURE_P2P_GO_CTWIN = 2048,
	NL80211_FEATURE_P2P_GO_OPPPS = 4096,
	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS = 16384,
	NL80211_FEATURE_FULL_AP_CLIENT_STATE = 32768,
	NL80211_FEATURE_USERSPACE_MPM = 65536,
	NL80211_FEATURE_ACTIVE_MONITOR = 131072,
	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE = 262144,
	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES = 524288,
	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES = 1048576,
	NL80211_FEATURE_QUIET = 2097152,
	NL80211_FEATURE_TX_POWER_INSERTION = 4194304,
	NL80211_FEATURE_ACKTO_ESTIMATION = 8388608,
	NL80211_FEATURE_STATIC_SMPS = 16777216,
	NL80211_FEATURE_DYNAMIC_SMPS = 33554432,
	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION = 67108864,
	NL80211_FEATURE_MAC_ON_CREATE = 134217728,
	NL80211_FEATURE_TDLS_CHANNEL_SWITCH = 268435456,
	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR = 536870912,
	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR = 1073741824,
	NL80211_FEATURE_ND_RANDOM_MAC_ADDR = 2147483648,
};

enum nl80211_ext_feature_index {
	NL80211_EXT_FEATURE_VHT_IBSS = 0,
	NL80211_EXT_FEATURE_RRM = 1,
	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER = 2,
	NL80211_EXT_FEATURE_SCAN_START_TIME = 3,
	NL80211_EXT_FEATURE_BSS_PARENT_TSF = 4,
	NL80211_EXT_FEATURE_SET_SCAN_DWELL = 5,
	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY = 6,
	NL80211_EXT_FEATURE_BEACON_RATE_HT = 7,
	NL80211_EXT_FEATURE_BEACON_RATE_VHT = 8,
	NL80211_EXT_FEATURE_FILS_STA = 9,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA = 10,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED = 11,
	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI = 12,
	NL80211_EXT_FEATURE_CQM_RSSI_LIST = 13,
	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD = 14,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK = 15,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X = 16,
	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME = 17,
	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP = 18,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE = 19,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 20,
	NL80211_EXT_FEATURE_MFP_OPTIONAL = 21,
	NL80211_EXT_FEATURE_LOW_SPAN_SCAN = 22,
	NL80211_EXT_FEATURE_LOW_POWER_SCAN = 23,
	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN = 24,
	NL80211_EXT_FEATURE_DFS_OFFLOAD = 25,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211 = 26,
	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_TXQS = 28,
	NL80211_EXT_FEATURE_SCAN_RANDOM_SN = 29,
	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT = 30,
	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 = 31,
	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER = 32,
	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS = 33,
	NL80211_EXT_FEATURE_AP_PMKSA_CACHING = 34,
	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 35,
	NL80211_EXT_FEATURE_EXT_KEY_ID = 36,
	NL80211_EXT_FEATURE_STA_TX_PWR = 37,
	NL80211_EXT_FEATURE_SAE_OFFLOAD = 38,
	NL80211_EXT_FEATURE_VLAN_OFFLOAD = 39,
	NL80211_EXT_FEATURE_AQL = 40,
	NL80211_EXT_FEATURE_BEACON_PROTECTION = 41,
	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH = 42,
	NL80211_EXT_FEATURE_PROTECTED_TWT = 43,
	NL80211_EXT_FEATURE_DEL_IBSS_STA = 44,
	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS = 45,
	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 46,
	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ = 47,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 48,
	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION = 49,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK = 50,
	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP = 51,
	NL80211_EXT_FEATURE_FILS_DISCOVERY = 52,
	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP = 53,
	NL80211_EXT_FEATURE_BEACON_RATE_HE = 54,
	NUM_NL80211_EXT_FEATURES = 55,
	MAX_NL80211_EXT_FEATURES = 54,
};

enum nl80211_timeout_reason {
	NL80211_TIMEOUT_UNSPECIFIED = 0,
	NL80211_TIMEOUT_SCAN = 1,
	NL80211_TIMEOUT_AUTH = 2,
	NL80211_TIMEOUT_ASSOC = 3,
};

enum nl80211_acl_policy {
	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
	NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1,
};

enum nl80211_smps_mode {
	NL80211_SMPS_OFF = 0,
	NL80211_SMPS_STATIC = 1,
	NL80211_SMPS_DYNAMIC = 2,
	__NL80211_SMPS_AFTER_LAST = 3,
	NL80211_SMPS_MAX = 2,
};

enum nl80211_radar_event {
	NL80211_RADAR_DETECTED = 0,
	NL80211_RADAR_CAC_FINISHED = 1,
	NL80211_RADAR_CAC_ABORTED = 2,
	NL80211_RADAR_NOP_FINISHED = 3,
	NL80211_RADAR_PRE_CAC_EXPIRED = 4,
	NL80211_RADAR_CAC_STARTED = 5,
};

enum nl80211_dfs_state {
	NL80211_DFS_USABLE = 0,
	NL80211_DFS_UNAVAILABLE = 1,
	NL80211_DFS_AVAILABLE = 2,
};

enum nl80211_crit_proto_id {
	NL80211_CRIT_PROTO_UNSPEC = 0,
	NL80211_CRIT_PROTO_DHCP = 1,
	NL80211_CRIT_PROTO_EAPOL = 2,
	NL80211_CRIT_PROTO_APIPA = 3,
	NUM_NL80211_CRIT_PROTO = 4,
};

struct nl80211_vendor_cmd_info {
	__u32 vendor_id;
	__u32 subcmd;
};

enum nl80211_bss_select_attr {
	__NL80211_BSS_SELECT_ATTR_INVALID = 0,
	NL80211_BSS_SELECT_ATTR_RSSI = 1,
	NL80211_BSS_SELECT_ATTR_BAND_PREF = 2,
	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST = 3,
	__NL80211_BSS_SELECT_ATTR_AFTER_LAST = 4,
	NL80211_BSS_SELECT_ATTR_MAX = 3,
};

enum nl80211_nan_function_type {
	NL80211_NAN_FUNC_PUBLISH = 0,
	NL80211_NAN_FUNC_SUBSCRIBE = 1,
	NL80211_NAN_FUNC_FOLLOW_UP = 2,
	__NL80211_NAN_FUNC_TYPE_AFTER_LAST = 3,
	NL80211_NAN_FUNC_MAX_TYPE = 2,
};

enum nl80211_external_auth_action {
	NL80211_EXTERNAL_AUTH_START = 0,
	NL80211_EXTERNAL_AUTH_ABORT = 1,
};

enum nl80211_preamble {
	NL80211_PREAMBLE_LEGACY = 0,
	NL80211_PREAMBLE_HT = 1,
	NL80211_PREAMBLE_VHT = 2,
	NL80211_PREAMBLE_DMG = 3,
	NL80211_PREAMBLE_HE = 4,
};

enum nl80211_sae_pwe_mechanism {
	NL80211_SAE_PWE_UNSPECIFIED = 0,
	NL80211_SAE_PWE_HUNT_AND_PECK = 1,
	NL80211_SAE_PWE_HASH_TO_ELEMENT = 2,
	NL80211_SAE_PWE_BOTH = 3,
};

enum nl80211_sar_type {
	NL80211_SAR_TYPE_POWER = 0,
	NUM_NL80211_SAR_TYPE = 1,
};

enum ieee80211_bss_type {
	IEEE80211_BSS_TYPE_ESS = 0,
	IEEE80211_BSS_TYPE_PBSS = 1,
	IEEE80211_BSS_TYPE_IBSS = 2,
	IEEE80211_BSS_TYPE_MBSS = 3,
	IEEE80211_BSS_TYPE_ANY = 4,
};

enum ieee80211_edmg_bw_config {
	IEEE80211_EDMG_BW_CONFIG_4 = 4,
	IEEE80211_EDMG_BW_CONFIG_5 = 5,
	IEEE80211_EDMG_BW_CONFIG_6 = 6,
	IEEE80211_EDMG_BW_CONFIG_7 = 7,
	IEEE80211_EDMG_BW_CONFIG_8 = 8,
	IEEE80211_EDMG_BW_CONFIG_9 = 9,
	IEEE80211_EDMG_BW_CONFIG_10 = 10,
	IEEE80211_EDMG_BW_CONFIG_11 = 11,
	IEEE80211_EDMG_BW_CONFIG_12 = 12,
	IEEE80211_EDMG_BW_CONFIG_13 = 13,
	IEEE80211_EDMG_BW_CONFIG_14 = 14,
	IEEE80211_EDMG_BW_CONFIG_15 = 15,
};

struct ieee80211_edmg {
	u8 channels;
	enum ieee80211_edmg_bw_config bw_config;
};

struct ieee80211_channel;

struct cfg80211_chan_def {
	struct ieee80211_channel *chan;
	enum nl80211_chan_width width;
	u32 center_freq1;
	u32 center_freq2;
	struct ieee80211_edmg edmg;
	u16 freq1_offset;
};

struct wiphy;

struct cfg80211_conn;

struct cfg80211_cached_keys;

struct cfg80211_internal_bss;

struct cfg80211_cqm_config;

struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;
	struct list_head list;
	struct net_device *netdev;
	u32 identifier;
	struct list_head mgmt_registrations;
	spinlock_t mgmt_registrations_lock;
	u8 mgmt_registrations_need_update: 1;
	struct mutex mtx;
	bool use_4addr;
	bool is_running;
	u8 address[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 mesh_id_len;
	u8 mesh_id_up_len;
	struct cfg80211_conn *conn;
	struct cfg80211_cached_keys *connect_keys;
	enum ieee80211_bss_type conn_bss_type;
	u32 conn_owner_nlportid;
	struct work_struct disconnect_wk;
	u8 disconnect_bssid[6];
	struct list_head event_list;
	spinlock_t event_lock;
	struct cfg80211_internal_bss *current_bss;
	struct cfg80211_chan_def preset_chandef;
	struct cfg80211_chan_def chandef;
	bool ibss_fixed;
	bool ibss_dfs_possible;
	bool ps;
	int ps_timeout;
	int beacon_interval;
	u32 ap_unexpected_nlportid;
	u32 owner_nlportid;
	bool nl_owner_dead;
	bool cac_started;
	long unsigned int cac_start_time;
	unsigned int cac_time_ms;
	struct cfg80211_cqm_config *cqm_config;
	struct list_head pmsr_list;
	spinlock_t pmsr_lock;
	struct work_struct pmsr_free_wk;
	long unsigned int unprot_beacon_reported;
};

struct ieee80211_s1g_cap {
	u8 capab_info[10];
	u8 supp_mcs_nss[5];
};

struct ieee80211_mcs_info {
	u8 rx_mask[10];
	__le16 rx_highest;
	u8 tx_params;
	u8 reserved[3];
};

struct ieee80211_ht_cap {
	__le16 cap_info;
	u8 ampdu_params_info;
	struct ieee80211_mcs_info mcs;
	__le16 extended_ht_cap_info;
	__le32 tx_BF_cap_info;
	u8 antenna_selection_info;
} __attribute__((packed));

struct ieee80211_vht_mcs_info {
	__le16 rx_mcs_map;
	__le16 rx_highest;
	__le16 tx_mcs_map;
	__le16 tx_highest;
};

struct ieee80211_vht_cap {
	__le32 vht_cap_info;
	struct ieee80211_vht_mcs_info supp_mcs;
};

struct ieee80211_he_cap_elem {
	u8 mac_cap_info[6];
	u8 phy_cap_info[11];
};

struct ieee80211_he_mcs_nss_supp {
	__le16 rx_mcs_80;
	__le16 tx_mcs_80;
	__le16 rx_mcs_160;
	__le16 tx_mcs_160;
	__le16 rx_mcs_80p80;
	__le16 tx_mcs_80p80;
};

struct ieee80211_he_operation {
	__le32 he_oper_params;
	__le16 he_mcs_nss_set;
	u8 optional[0];
} __attribute__((packed));

enum ieee80211_reasoncode {
	WLAN_REASON_UNSPECIFIED = 1,
	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
	WLAN_REASON_DEAUTH_LEAVING = 3,
	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
	WLAN_REASON_DISASSOC_AP_BUSY = 5,
	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
	WLAN_REASON_DISASSOC_BAD_POWER = 10,
	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
	WLAN_REASON_INVALID_IE = 13,
	WLAN_REASON_MIC_FAILURE = 14,
	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
	WLAN_REASON_IE_DIFFERENT = 17,
	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
	WLAN_REASON_INVALID_AKMP = 20,
	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
	WLAN_REASON_IEEE8021X_FAILED = 23,
	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
	WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE = 25,
	WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED = 26,
	WLAN_REASON_DISASSOC_UNSPECIFIED_QOS = 32,
	WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH = 33,
	WLAN_REASON_DISASSOC_LOW_ACK = 34,
	WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP = 35,
	WLAN_REASON_QSTA_LEAVE_QBSS = 36,
	WLAN_REASON_QSTA_NOT_USE = 37,
	WLAN_REASON_QSTA_REQUIRE_SETUP = 38,
	WLAN_REASON_QSTA_TIMEOUT = 39,
	WLAN_REASON_QSTA_CIPHER_NOT_SUPP = 45,
	WLAN_REASON_MESH_PEER_CANCELED = 52,
	WLAN_REASON_MESH_MAX_PEERS = 53,
	WLAN_REASON_MESH_CONFIG = 54,
	WLAN_REASON_MESH_CLOSE = 55,
	WLAN_REASON_MESH_MAX_RETRIES = 56,
	WLAN_REASON_MESH_CONFIRM_TIMEOUT = 57,
	WLAN_REASON_MESH_INVALID_GTK = 58,
	WLAN_REASON_MESH_INCONSISTENT_PARAM = 59,
	WLAN_REASON_MESH_INVALID_SECURITY = 60,
	WLAN_REASON_MESH_PATH_ERROR = 61,
	WLAN_REASON_MESH_PATH_NOFORWARD = 62,
	WLAN_REASON_MESH_PATH_DEST_UNREACHABLE = 63,
	WLAN_REASON_MAC_EXISTS_IN_MBSS = 64,
	WLAN_REASON_MESH_CHAN_REGULATORY = 65,
	WLAN_REASON_MESH_CHAN = 66,
};

enum ieee80211_key_len {
	WLAN_KEY_LEN_WEP40 = 5,
	WLAN_KEY_LEN_WEP104 = 13,
	WLAN_KEY_LEN_CCMP = 16,
	WLAN_KEY_LEN_CCMP_256 = 32,
	WLAN_KEY_LEN_TKIP = 32,
	WLAN_KEY_LEN_AES_CMAC = 16,
	WLAN_KEY_LEN_SMS4 = 32,
	WLAN_KEY_LEN_GCMP = 16,
	WLAN_KEY_LEN_GCMP_256 = 32,
	WLAN_KEY_LEN_BIP_CMAC_256 = 32,
	WLAN_KEY_LEN_BIP_GMAC_128 = 16,
	WLAN_KEY_LEN_BIP_GMAC_256 = 32,
};

struct ieee80211_he_6ghz_capa {
	__le16 capa;
};

enum environment_cap {
	ENVIRON_ANY = 0,
	ENVIRON_INDOOR = 1,
	ENVIRON_OUTDOOR = 2,
};

struct regulatory_request {
	struct callback_head callback_head;
	int wiphy_idx;
	enum nl80211_reg_initiator initiator;
	enum nl80211_user_reg_hint_type user_reg_hint_type;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	bool intersect;
	bool processed;
	enum environment_cap country_ie_env;
	struct list_head list;
};

enum ieee80211_regulatory_flags {
	REGULATORY_CUSTOM_REG = 1,
	REGULATORY_STRICT_REG = 2,
	REGULATORY_DISABLE_BEACON_HINTS = 4,
	REGULATORY_COUNTRY_IE_FOLLOW_POWER = 8,
	REGULATORY_COUNTRY_IE_IGNORE = 16,
	REGULATORY_ENABLE_RELAX_NO_IR = 32,
	REGULATORY_IGNORE_STALE_KICKOFF = 64,
	REGULATORY_WIPHY_SELF_MANAGED = 128,
};

struct ieee80211_freq_range {
	u32 start_freq_khz;
	u32 end_freq_khz;
	u32 max_bandwidth_khz;
};

struct ieee80211_power_rule {
	u32 max_antenna_gain;
	u32 max_eirp;
};

struct ieee80211_wmm_ac {
	u16 cw_min;
	u16 cw_max;
	u16 cot;
	u8 aifsn;
};

struct ieee80211_wmm_rule {
	struct ieee80211_wmm_ac client[4];
	struct ieee80211_wmm_ac ap[4];
};

struct ieee80211_reg_rule {
	struct ieee80211_freq_range freq_range;
	struct ieee80211_power_rule power_rule;
	struct ieee80211_wmm_rule wmm_rule;
	u32 flags;
	u32 dfs_cac_ms;
	bool has_wmm;
};

struct ieee80211_regdomain {
	struct callback_head callback_head;
	u32 n_reg_rules;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	struct ieee80211_reg_rule reg_rules[0];
};

struct ieee80211_channel {
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u16 hw_value;
	u32 flags;
	int max_antenna_gain;
	int max_power;
	int max_reg_power;
	bool beacon_found;
	u32 orig_flags;
	int orig_mag;
	int orig_mpwr;
	enum nl80211_dfs_state dfs_state;
	long unsigned int dfs_state_entered;
	unsigned int dfs_cac_ms;
};

struct ieee80211_rate {
	u32 flags;
	u16 bitrate;
	u16 hw_value;
	u16 hw_value_short;
};

struct ieee80211_he_obss_pd {
	bool enable;
	u8 sr_ctrl;
	u8 non_srg_max_offset;
	u8 min_offset;
	u8 max_offset;
	u8 bss_color_bitmap[8];
	u8 partial_bssid_bitmap[8];
};

struct cfg80211_he_bss_color {
	u8 color;
	bool enabled;
	bool partial;
};

struct ieee80211_sta_ht_cap {
	u16 cap;
	bool ht_supported;
	u8 ampdu_factor;
	u8 ampdu_density;
	struct ieee80211_mcs_info mcs;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_vht_cap {
	bool vht_supported;
	u32 cap;
	struct ieee80211_vht_mcs_info vht_mcs;
};

struct ieee80211_sta_he_cap {
	bool has_he;
	struct ieee80211_he_cap_elem he_cap_elem;
	struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;
	u8 ppe_thres[25];
} __attribute__((packed));

struct ieee80211_sband_iftype_data {
	u16 types_mask;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_s1g_cap {
	bool s1g;
	u8 cap[10];
	u8 nss_mcs[5];
};

struct ieee80211_supported_band {
	struct ieee80211_channel *channels;
	struct ieee80211_rate *bitrates;
	enum nl80211_band band;
	int n_channels;
	int n_bitrates;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_s1g_cap s1g_cap;
	struct ieee80211_edmg edmg_cap;
	u16 n_iftype_data;
	const struct ieee80211_sband_iftype_data *iftype_data;
};

struct vif_params {
	u32 flags;
	int use_4addr;
	u8 macaddr[6];
	const u8 *vht_mumimo_groups;
	const u8 *vht_mumimo_follow_addr;
};

struct key_params {
	const u8 *key;
	const u8 *seq;
	int key_len;
	int seq_len;
	u16 vlan_id;
	u32 cipher;
	enum nl80211_key_mode mode;
};

struct cfg80211_bitrate_mask {
	struct {
		u32 legacy;
		u8 ht_mcs[10];
		u16 vht_mcs[8];
		u16 he_mcs[8];
		enum nl80211_txrate_gi gi;
		enum nl80211_he_gi he_gi;
		enum nl80211_he_ltf he_ltf;
	} control[5];
};

struct cfg80211_tid_cfg {
	bool config_override;
	u8 tids;
	int: 16;
	int: 32;
	u64 mask;
	enum nl80211_tid_config noack;
	u8 retry_long;
	u8 retry_short;
	enum nl80211_tid_config ampdu;
	enum nl80211_tid_config rtscts;
	enum nl80211_tid_config amsdu;
	enum nl80211_tx_rate_setting txrate_type;
	struct cfg80211_bitrate_mask txrate_mask;
	int: 32;
};

struct cfg80211_tid_config {
	const u8 *peer;
	u32 n_tid_conf;
	struct cfg80211_tid_cfg tid_conf[0];
};

struct survey_info {
	struct ieee80211_channel *channel;
	int: 32;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u64 time_bss_rx;
	u32 filled;
	s8 noise;
};

struct cfg80211_crypto_settings {
	u32 wpa_versions;
	u32 cipher_group;
	int n_ciphers_pairwise;
	u32 ciphers_pairwise[5];
	int n_akm_suites;
	u32 akm_suites[2];
	bool control_port;
	__be16 control_port_ethertype;
	bool control_port_no_encrypt;
	bool control_port_over_nl80211;
	bool control_port_no_preauth;
	struct key_params *wep_keys;
	int wep_tx_key;
	const u8 *psk;
	const u8 *sae_pwd;
	u8 sae_pwd_len;
	enum nl80211_sae_pwe_mechanism sae_pwe;
};

struct cfg80211_beacon_data {
	const u8 *head;
	const u8 *tail;
	const u8 *beacon_ies;
	const u8 *proberesp_ies;
	const u8 *assocresp_ies;
	const u8 *probe_resp;
	const u8 *lci;
	const u8 *civicloc;
	s8 ftm_responder;
	size_t head_len;
	size_t tail_len;
	size_t beacon_ies_len;
	size_t proberesp_ies_len;
	size_t assocresp_ies_len;
	size_t probe_resp_len;
	size_t lci_len;
	size_t civicloc_len;
};

struct mac_address {
	u8 addr[6];
};

struct cfg80211_acl_data {
	enum nl80211_acl_policy acl_policy;
	int n_acl_entries;
	struct mac_address mac_addrs[0];
};

struct cfg80211_fils_discovery {
	u32 min_interval;
	u32 max_interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_unsol_bcast_probe_resp {
	u32 interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_ap_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon;
	int beacon_interval;
	int dtim_period;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_hidden_ssid hidden_ssid;
	struct cfg80211_crypto_settings crypto;
	bool privacy;
	enum nl80211_auth_type auth_type;
	enum nl80211_smps_mode smps_mode;
	int inactivity_timeout;
	u8 p2p_ctwindow;
	bool p2p_opp_ps;
	const struct cfg80211_acl_data *acl;
	bool pbss;
	struct cfg80211_bitrate_mask beacon_rate;
	const struct ieee80211_ht_cap *ht_cap;
	const struct ieee80211_vht_cap *vht_cap;
	const struct ieee80211_he_cap_elem *he_cap;
	const struct ieee80211_he_operation *he_oper;
	bool ht_required;
	bool vht_required;
	bool he_required;
	bool sae_h2e_required;
	bool twt_responder;
	u32 flags;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_he_bss_color he_bss_color;
	struct cfg80211_fils_discovery fils_discovery;
	struct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;
};

struct cfg80211_csa_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon_csa;
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	unsigned int n_counter_offsets_beacon;
	unsigned int n_counter_offsets_presp;
	struct cfg80211_beacon_data beacon_after;
	bool radar_required;
	bool block_tx;
	u8 count;
};

struct sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct station_parameters {
	const u8 *supported_rates;
	struct net_device *vlan;
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 aid;
	u16 vlan_id;
	u16 peer_aid;
	u8 supported_rates_len;
	u8 plink_action;
	u8 plink_state;
	const struct ieee80211_ht_cap *ht_capa;
	const struct ieee80211_vht_cap *vht_capa;
	u8 uapsd_queues;
	u8 max_sp;
	enum nl80211_mesh_power_mode local_pm;
	u16 capability;
	const u8 *ext_capab;
	u8 ext_capab_len;
	const u8 *supported_channels;
	u8 supported_channels_len;
	const u8 *supported_oper_classes;
	u8 supported_oper_classes_len;
	u8 opmode_notif;
	bool opmode_notif_used;
	int support_p2p_ps;
	const struct ieee80211_he_cap_elem *he_capa;
	u8 he_capa_len;
	u16 airtime_weight;
	struct sta_txpwr txpwr;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
};

struct station_del_parameters {
	const u8 *mac;
	u8 subtype;
	u16 reason_code;
};

struct rate_info {
	u8 flags;
	u8 mcs;
	u16 legacy;
	u8 nss;
	u8 bw;
	u8 he_gi;
	u8 he_dcm;
	u8 he_ru_alloc;
	u8 n_bonded_ch;
};

struct sta_bss_parameters {
	u8 flags;
	u8 dtim_period;
	u16 beacon_interval;
};

struct cfg80211_txq_stats {
	u32 filled;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 flows;
	u32 drops;
	u32 ecn_marks;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
	u32 tx_bytes;
	u32 tx_packets;
	u32 max_flows;
};

struct cfg80211_tid_stats {
	u32 filled;
	int: 32;
	u64 rx_msdu;
	u64 tx_msdu;
	u64 tx_msdu_retries;
	u64 tx_msdu_failed;
	struct cfg80211_txq_stats txq_stats;
};

struct station_info {
	u64 filled;
	u32 connected_time;
	u32 inactive_time;
	u64 assoc_at;
	u64 rx_bytes;
	u64 tx_bytes;
	u16 llid;
	u16 plid;
	u8 plink_state;
	s8 signal;
	s8 signal_avg;
	u8 chains;
	s8 chain_signal[4];
	s8 chain_signal_avg[4];
	struct rate_info txrate;
	struct rate_info rxrate;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	struct sta_bss_parameters bss_param;
	struct nl80211_sta_flag_update sta_flags;
	int generation;
	const u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
	u32 beacon_loss_count;
	int: 32;
	s64 t_offset;
	enum nl80211_mesh_power_mode local_pm;
	enum nl80211_mesh_power_mode peer_pm;
	enum nl80211_mesh_power_mode nonpeer_pm;
	u32 expected_throughput;
	u64 tx_duration;
	u64 rx_duration;
	u64 rx_beacon;
	u8 rx_beacon_signal_avg;
	u8 connected_to_gate;
	struct cfg80211_tid_stats *pertid;
	s8 ack_signal;
	s8 avg_ack_signal;
	u16 airtime_weight;
	u32 rx_mpdu_count;
	u32 fcs_err_count;
	u32 airtime_link_metric;
	u8 connected_to_as;
	int: 24;
	int: 32;
};

struct cfg80211_sar_sub_specs {
	s32 power;
	u32 freq_range_index;
};

struct cfg80211_sar_specs {
	enum nl80211_sar_type type;
	u32 num_sub_specs;
	struct cfg80211_sar_sub_specs sub_specs[0];
};

struct cfg80211_sar_freq_ranges {
	u32 start_freq;
	u32 end_freq;
};

struct cfg80211_sar_capa {
	enum nl80211_sar_type type;
	u32 num_freq_ranges;
	const struct cfg80211_sar_freq_ranges *freq_ranges;
};

struct mpath_info {
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	u8 hop_count;
	u32 path_change_count;
	int generation;
};

struct bss_parameters {
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	const u8 *basic_rates;
	u8 basic_rates_len;
	int ap_isolate;
	int ht_opmode;
	s8 p2p_ctwindow;
	s8 p2p_opp_ps;
};

struct mesh_config {
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u16 min_discovery_timeout;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	bool dot11MeshConnectedToMeshGate;
	bool dot11MeshConnectedToAuthServer;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	enum nl80211_mesh_power_mode power_mode;
	u16 dot11MeshAwakeWindowDuration;
	u32 plink_timeout;
	bool dot11MeshNolearn;
};

struct mesh_setup {
	struct cfg80211_chan_def chandef;
	const u8 *mesh_id;
	u8 mesh_id_len;
	u8 sync_method;
	u8 path_sel_proto;
	u8 path_metric;
	u8 auth_id;
	const u8 *ie;
	u8 ie_len;
	bool is_authenticated;
	bool is_secure;
	bool user_mpm;
	u8 dtim_period;
	u16 beacon_interval;
	int mcast_rate[5];
	u32 basic_rates;
	struct cfg80211_bitrate_mask beacon_rate;
	bool userspace_handles_dfs;
	bool control_port_over_nl80211;
};

struct ocb_setup {
	struct cfg80211_chan_def chandef;
};

struct ieee80211_txq_params {
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
};

struct cfg80211_ssid {
	u8 ssid[32];
	u8 ssid_len;
};

struct cfg80211_scan_info {
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	bool aborted;
};

struct cfg80211_scan_6ghz_params {
	u32 short_ssid;
	u32 channel_idx;
	u8 bssid[6];
	bool unsolicited_probe;
	bool short_ssid_valid;
	bool psc_no_listen;
};

struct cfg80211_scan_request {
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u16 duration;
	bool duration_mandatory;
	u32 flags;
	u32 rates[5];
	struct wireless_dev *wdev;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	u8 bssid[6];
	struct wiphy *wiphy;
	long unsigned int scan_start;
	int: 32;
	struct cfg80211_scan_info info;
	bool notified;
	bool no_cck;
	bool scan_6ghz;
	u32 n_6ghz_params;
	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
	struct ieee80211_channel *channels[0];
	int: 32;
};

enum cfg80211_signal_type {
	CFG80211_SIGNAL_TYPE_NONE = 0,
	CFG80211_SIGNAL_TYPE_MBM = 1,
	CFG80211_SIGNAL_TYPE_UNSPEC = 2,
};

struct ieee80211_txrx_stypes;

struct ieee80211_iface_combination;

struct wiphy_iftype_akm_suites;

struct wiphy_wowlan_support;

struct cfg80211_wowlan;

struct wiphy_iftype_ext_capab;

struct wiphy_coalesce_support;

struct wiphy_vendor_command;

struct cfg80211_pmsr_capabilities;

struct wiphy {
	u8 perm_addr[6];
	u8 addr_mask[6];
	struct mac_address *addresses;
	const struct ieee80211_txrx_stypes *mgmt_stypes;
	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u16 software_iftypes;
	u16 n_addresses;
	u16 interface_modes;
	u16 max_acl_mac_addrs;
	u32 flags;
	u32 regulatory_flags;
	u32 features;
	u8 ext_features[7];
	u32 ap_sme_capa;
	enum cfg80211_signal_type signal_type;
	int bss_priv_size;
	u8 max_scan_ssids;
	u8 max_sched_scan_reqs;
	u8 max_sched_scan_ssids;
	u8 max_match_sets;
	u16 max_scan_ie_len;
	u16 max_sched_scan_ie_len;
	u32 max_sched_scan_plans;
	u32 max_sched_scan_plan_interval;
	u32 max_sched_scan_plan_iterations;
	int n_cipher_suites;
	const u32 *cipher_suites;
	int n_akm_suites;
	const u32 *akm_suites;
	const struct wiphy_iftype_akm_suites *iftype_akm_suites;
	unsigned int num_iftype_akm_suites;
	u8 retry_short;
	u8 retry_long;
	u32 frag_threshold;
	u32 rts_threshold;
	u8 coverage_class;
	char fw_version[32];
	u32 hw_version;
	const struct wiphy_wowlan_support *wowlan;
	struct cfg80211_wowlan *wowlan_config;
	u16 max_remain_on_channel_duration;
	u8 max_num_pmkids;
	u32 available_antennas_tx;
	u32 available_antennas_rx;
	u32 probe_resp_offload;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
	const struct wiphy_iftype_ext_capab *iftype_ext_capab;
	unsigned int num_iftype_ext_capab;
	const void *privid;
	struct ieee80211_supported_band *bands[5];
	void (*reg_notifier)(struct wiphy *, struct regulatory_request *);
	const struct ieee80211_regdomain *regd;
	struct device dev;
	bool registered;
	struct dentry *debugfsdir;
	const struct ieee80211_ht_cap *ht_capa_mod_mask;
	const struct ieee80211_vht_cap *vht_capa_mod_mask;
	struct list_head wdev_list;
	possible_net_t _net;
	const struct wiphy_coalesce_support *coalesce;
	const struct wiphy_vendor_command *vendor_commands;
	const struct nl80211_vendor_cmd_info *vendor_events;
	int n_vendor_commands;
	int n_vendor_events;
	u16 max_ap_assoc_sta;
	u8 max_num_csa_counters;
	u32 bss_select_support;
	u8 nan_supported_bands;
	u32 txq_limit;
	u32 txq_memory_limit;
	u32 txq_quantum;
	long unsigned int tx_queue_len;
	u8 support_mbssid: 1;
	u8 support_only_he_mbssid: 1;
	const struct cfg80211_pmsr_capabilities *pmsr_capa;
	struct {
		u64 peer;
		u64 vif;
		u8 max_retry;
		int: 24;
		int: 32;
	} tid_config_support;
	u8 max_data_retry_count;
	const struct cfg80211_sar_capa *sar_capa;
	int: 32;
	int: 32;
	char priv[0];
};

struct cfg80211_match_set {
	struct cfg80211_ssid ssid;
	u8 bssid[6];
	s32 rssi_thold;
	s32 per_band_rssi_thold[5];
};

struct cfg80211_sched_scan_plan {
	u32 interval;
	u32 iterations;
};

struct cfg80211_bss_select_adjust {
	enum nl80211_band band;
	s8 delta;
};

struct cfg80211_sched_scan_request {
	u64 reqid;
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u32 flags;
	struct cfg80211_match_set *match_sets;
	int n_match_sets;
	s32 min_rssi_thold;
	u32 delay;
	struct cfg80211_sched_scan_plan *scan_plans;
	int n_scan_plans;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	bool relative_rssi_set;
	s8 relative_rssi;
	struct cfg80211_bss_select_adjust rssi_adjust;
	struct wiphy *wiphy;
	struct net_device *dev;
	long unsigned int scan_start;
	bool report_results;
	struct callback_head callback_head;
	u32 owner_nlportid;
	bool nl_owner_dead;
	struct list_head list;
	struct ieee80211_channel *channels[0];
	int: 32;
};

struct cfg80211_bss_ies {
	u64 tsf;
	struct callback_head callback_head;
	int len;
	bool from_beacon;
	u8 data[0];
};

struct cfg80211_bss {
	struct ieee80211_channel *channel;
	enum nl80211_bss_scan_width scan_width;
	const struct cfg80211_bss_ies *ies;
	const struct cfg80211_bss_ies *beacon_ies;
	const struct cfg80211_bss_ies *proberesp_ies;
	struct cfg80211_bss *hidden_beacon_bss;
	struct cfg80211_bss *transmitted_bss;
	struct list_head nontrans_list;
	s32 signal;
	u16 beacon_interval;
	u16 capability;
	u8 bssid[6];
	u8 chains;
	s8 chain_signal[4];
	u8 bssid_index;
	u8 max_bssid_indicator;
	int: 24;
	u8 priv[0];
};

struct cfg80211_auth_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	enum nl80211_auth_type auth_type;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	const u8 *auth_data;
	size_t auth_data_len;
};

struct cfg80211_assoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	const u8 *prev_bssid;
	size_t ie_len;
	struct cfg80211_crypto_settings crypto;
	bool use_mfp;
	int: 24;
	u32 flags;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	const u8 *fils_kek;
	size_t fils_kek_len;
	const u8 *fils_nonces;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	short: 16;
} __attribute__((packed));

struct cfg80211_deauth_request {
	const u8 *bssid;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_disassoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_ibss_params {
	const u8 *ssid;
	const u8 *bssid;
	struct cfg80211_chan_def chandef;
	const u8 *ie;
	u8 ssid_len;
	u8 ie_len;
	u16 beacon_interval;
	u32 basic_rates;
	bool channel_fixed;
	bool privacy;
	bool control_port;
	bool control_port_over_nl80211;
	bool userspace_handles_dfs;
	int: 24;
	int mcast_rate[5];
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct key_params *wep_keys;
	int wep_tx_key;
} __attribute__((packed));

struct cfg80211_bss_selection {
	enum nl80211_bss_select_attr behaviour;
	union {
		enum nl80211_band band_pref;
		struct cfg80211_bss_select_adjust adjust;
	} param;
};

struct cfg80211_connect_params {
	struct ieee80211_channel *channel;
	struct ieee80211_channel *channel_hint;
	const u8 *bssid;
	const u8 *bssid_hint;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_auth_type auth_type;
	const u8 *ie;
	size_t ie_len;
	bool privacy;
	int: 24;
	enum nl80211_mfp mfp;
	struct cfg80211_crypto_settings crypto;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	short: 16;
	u32 flags;
	int bg_scan_period;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	bool pbss;
	int: 24;
	struct cfg80211_bss_selection bss_select;
	const u8 *prev_bssid;
	const u8 *fils_erp_username;
	size_t fils_erp_username_len;
	const u8 *fils_erp_realm;
	size_t fils_erp_realm_len;
	u16 fils_erp_next_seq_num;
	short: 16;
	const u8 *fils_erp_rrk;
	size_t fils_erp_rrk_len;
	bool want_1x;
	int: 24;
	struct ieee80211_edmg edmg;
} __attribute__((packed));

struct cfg80211_pmksa {
	const u8 *bssid;
	const u8 *pmkid;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *ssid;
	size_t ssid_len;
	const u8 *cache_id;
	u32 pmk_lifetime;
	u8 pmk_reauth_threshold;
};

struct cfg80211_pkt_pattern {
	const u8 *mask;
	const u8 *pattern;
	int pattern_len;
	int pkt_offset;
};

struct cfg80211_wowlan_tcp {
	struct socket *sock;
	__be32 src;
	__be32 dst;
	u16 src_port;
	u16 dst_port;
	u8 dst_mac[6];
	int payload_len;
	const u8 *payload;
	struct nl80211_wowlan_tcp_data_seq payload_seq;
	u32 data_interval;
	u32 wake_len;
	const u8 *wake_data;
	const u8 *wake_mask;
	u32 tokens_size;
	struct nl80211_wowlan_tcp_data_token payload_tok;
};

struct cfg80211_wowlan {
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	struct cfg80211_pkt_pattern *patterns;
	struct cfg80211_wowlan_tcp *tcp;
	int n_patterns;
	struct cfg80211_sched_scan_request *nd_config;
};

struct cfg80211_coalesce_rules {
	int delay;
	enum nl80211_coalesce_condition condition;
	struct cfg80211_pkt_pattern *patterns;
	int n_patterns;
};

struct cfg80211_coalesce {
	struct cfg80211_coalesce_rules *rules;
	int n_rules;
};

struct cfg80211_gtk_rekey_data {
	const u8 *kek;
	const u8 *kck;
	const u8 *replay_ctr;
	u32 akm;
	u8 kek_len;
	u8 kck_len;
};

struct cfg80211_update_ft_ies_params {
	u16 md;
	const u8 *ie;
	size_t ie_len;
};

struct cfg80211_mgmt_tx_params {
	struct ieee80211_channel *chan;
	bool offchan;
	unsigned int wait;
	const u8 *buf;
	size_t len;
	bool no_cck;
	bool dont_wait_for_ack;
	int n_csa_offsets;
	const u16 *csa_offsets;
};

struct cfg80211_dscp_exception {
	u8 dscp;
	u8 up;
};

struct cfg80211_dscp_range {
	u8 low;
	u8 high;
};

struct cfg80211_qos_map {
	u8 num_des;
	struct cfg80211_dscp_exception dscp_exception[21];
	struct cfg80211_dscp_range up[8];
};

struct cfg80211_nan_conf {
	u8 master_pref;
	u8 bands;
};

struct cfg80211_nan_func_filter {
	const u8 *filter;
	u8 len;
};

struct cfg80211_nan_func {
	enum nl80211_nan_function_type type;
	u8 service_id[6];
	u8 publish_type;
	bool close_range;
	bool publish_bcast;
	bool subscribe_active;
	u8 followup_id;
	u8 followup_reqid;
	struct mac_address followup_dest;
	u32 ttl;
	const u8 *serv_spec_info;
	u8 serv_spec_info_len;
	bool srf_include;
	const u8 *srf_bf;
	u8 srf_bf_len;
	u8 srf_bf_idx;
	struct mac_address *srf_macs;
	int srf_num_macs;
	struct cfg80211_nan_func_filter *rx_filters;
	struct cfg80211_nan_func_filter *tx_filters;
	u8 num_tx_filters;
	u8 num_rx_filters;
	u8 instance_id;
	u64 cookie;
};

struct cfg80211_pmk_conf {
	const u8 *aa;
	u8 pmk_len;
	const u8 *pmk;
	const u8 *pmk_r0_name;
};

struct cfg80211_external_auth_params {
	enum nl80211_external_auth_action action;
	u8 bssid[6];
	struct cfg80211_ssid ssid;
	unsigned int key_mgmt_suite;
	u16 status;
	const u8 *pmkid;
};

struct cfg80211_ftm_responder_stats {
	u32 filled;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 total_duration_ms;
	u32 unknown_triggers_num;
	u32 reschedule_requests_num;
	u32 out_of_window_triggers_num;
	int: 32;
};

struct cfg80211_pmsr_ftm_request_peer {
	enum nl80211_preamble preamble;
	u16 burst_period;
	u8 requested: 1;
	u8 asap: 1;
	u8 request_lci: 1;
	u8 request_civicloc: 1;
	u8 trigger_based: 1;
	u8 non_trigger_based: 1;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	u8 ftmr_retries;
};

struct cfg80211_pmsr_request_peer {
	u8 addr[6];
	struct cfg80211_chan_def chandef;
	u8 report_ap_tsf: 1;
	struct cfg80211_pmsr_ftm_request_peer ftm;
};

struct cfg80211_pmsr_request {
	u64 cookie;
	void *drv_data;
	u32 n_peers;
	u32 nl_portid;
	u32 timeout;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	struct list_head list;
	struct cfg80211_pmsr_request_peer peers[0];
	int: 32;
};

struct cfg80211_update_owe_info {
	u8 peer[6];
	u16 status;
	const u8 *ie;
	size_t ie_len;
};

struct mgmt_frame_regs {
	u32 global_stypes;
	u32 interface_stypes;
	u32 global_mcast_stypes;
	u32 interface_mcast_stypes;
};

struct cfg80211_ops {
	int (*suspend)(struct wiphy *, struct cfg80211_wowlan *);
	int (*resume)(struct wiphy *);
	void (*set_wakeup)(struct wiphy *, bool);
	struct wireless_dev * (*add_virtual_intf)(struct wiphy *, const char *, unsigned char, enum nl80211_iftype, struct vif_params *);
	int (*del_virtual_intf)(struct wiphy *, struct wireless_dev *);
	int (*change_virtual_intf)(struct wiphy *, struct net_device *, enum nl80211_iftype, struct vif_params *);
	int (*add_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *, struct key_params *);
	int (*get_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *, void *, void (*)(void *, struct key_params *));
	int (*del_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *);
	int (*set_default_key)(struct wiphy *, struct net_device *, u8, bool, bool);
	int (*set_default_mgmt_key)(struct wiphy *, struct net_device *, u8);
	int (*set_default_beacon_key)(struct wiphy *, struct net_device *, u8);
	int (*start_ap)(struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);
	int (*change_beacon)(struct wiphy *, struct net_device *, struct cfg80211_beacon_data *);
	int (*stop_ap)(struct wiphy *, struct net_device *);
	int (*add_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*del_station)(struct wiphy *, struct net_device *, struct station_del_parameters *);
	int (*change_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*get_station)(struct wiphy *, struct net_device *, const u8 *, struct station_info *);
	int (*dump_station)(struct wiphy *, struct net_device *, int, u8 *, struct station_info *);
	int (*add_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*del_mpath)(struct wiphy *, struct net_device *, const u8 *);
	int (*change_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*get_mpath)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpath)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mpp)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpp)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mesh_config)(struct wiphy *, struct net_device *, struct mesh_config *);
	int (*update_mesh_config)(struct wiphy *, struct net_device *, u32, const struct mesh_config *);
	int (*join_mesh)(struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);
	int (*leave_mesh)(struct wiphy *, struct net_device *);
	int (*join_ocb)(struct wiphy *, struct net_device *, struct ocb_setup *);
	int (*leave_ocb)(struct wiphy *, struct net_device *);
	int (*change_bss)(struct wiphy *, struct net_device *, struct bss_parameters *);
	int (*set_txq_params)(struct wiphy *, struct net_device *, struct ieee80211_txq_params *);
	int (*libertas_set_mesh_channel)(struct wiphy *, struct net_device *, struct ieee80211_channel *);
	int (*set_monitor_channel)(struct wiphy *, struct cfg80211_chan_def *);
	int (*scan)(struct wiphy *, struct cfg80211_scan_request *);
	void (*abort_scan)(struct wiphy *, struct wireless_dev *);
	int (*auth)(struct wiphy *, struct net_device *, struct cfg80211_auth_request *);
	int (*assoc)(struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);
	int (*deauth)(struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);
	int (*disassoc)(struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);
	int (*connect)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *);
	int (*update_connect_params)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);
	int (*disconnect)(struct wiphy *, struct net_device *, u16);
	int (*join_ibss)(struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);
	int (*leave_ibss)(struct wiphy *, struct net_device *);
	int (*set_mcast_rate)(struct wiphy *, struct net_device *, int *);
	int (*set_wiphy_params)(struct wiphy *, u32);
	int (*set_tx_power)(struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);
	int (*get_tx_power)(struct wiphy *, struct wireless_dev *, int *);
	void (*rfkill_poll)(struct wiphy *);
	int (*set_bitrate_mask)(struct wiphy *, struct net_device *, const u8 *, const struct cfg80211_bitrate_mask *);
	int (*dump_survey)(struct wiphy *, struct net_device *, int, struct survey_info *);
	int (*set_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*del_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*flush_pmksa)(struct wiphy *, struct net_device *);
	int (*remain_on_channel)(struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int, u64 *);
	int (*cancel_remain_on_channel)(struct wiphy *, struct wireless_dev *, u64);
	int (*mgmt_tx)(struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *, u64 *);
	int (*mgmt_tx_cancel_wait)(struct wiphy *, struct wireless_dev *, u64);
	int (*set_power_mgmt)(struct wiphy *, struct net_device *, bool, int);
	int (*set_cqm_rssi_config)(struct wiphy *, struct net_device *, s32, u32);
	int (*set_cqm_rssi_range_config)(struct wiphy *, struct net_device *, s32, s32);
	int (*set_cqm_txe_config)(struct wiphy *, struct net_device *, u32, u32, u32);
	void (*update_mgmt_frame_registrations)(struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);
	int (*set_antenna)(struct wiphy *, u32, u32);
	int (*get_antenna)(struct wiphy *, u32 *, u32 *);
	int (*sched_scan_start)(struct wiphy *, struct net_device *, struct cfg80211_sched_scan_request *);
	int (*sched_scan_stop)(struct wiphy *, struct net_device *, u64);
	int (*set_rekey_data)(struct wiphy *, struct net_device *, struct cfg80211_gtk_rekey_data *);
	int (*tdls_mgmt)(struct wiphy *, struct net_device *, const u8 *, u8, u8, u16, u32, bool, const u8 *, size_t);
	int (*tdls_oper)(struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation);
	int (*probe_client)(struct wiphy *, struct net_device *, const u8 *, u64 *);
	int (*set_noack_map)(struct wiphy *, struct net_device *, u16);
	int (*get_channel)(struct wiphy *, struct wireless_dev *, struct cfg80211_chan_def *);
	int (*start_p2p_device)(struct wiphy *, struct wireless_dev *);
	void (*stop_p2p_device)(struct wiphy *, struct wireless_dev *);
	int (*set_mac_acl)(struct wiphy *, struct net_device *, const struct cfg80211_acl_data *);
	int (*start_radar_detection)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32);
	void (*end_cac)(struct wiphy *, struct net_device *);
	int (*update_ft_ies)(struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);
	int (*crit_proto_start)(struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);
	void (*crit_proto_stop)(struct wiphy *, struct wireless_dev *);
	int (*set_coalesce)(struct wiphy *, struct cfg80211_coalesce *);
	int (*channel_switch)(struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);
	int (*set_qos_map)(struct wiphy *, struct net_device *, struct cfg80211_qos_map *);
	int (*set_ap_chanwidth)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *);
	int (*add_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);
	int (*del_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *);
	int (*tdls_channel_switch)(struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);
	void (*tdls_cancel_channel_switch)(struct wiphy *, struct net_device *, const u8 *);
	int (*start_nan)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);
	void (*stop_nan)(struct wiphy *, struct wireless_dev *);
	int (*add_nan_func)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_func *);
	void (*del_nan_func)(struct wiphy *, struct wireless_dev *, u64);
	int (*nan_change_conf)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);
	int (*set_multicast_to_unicast)(struct wiphy *, struct net_device *, const bool);
	int (*get_txq_stats)(struct wiphy *, struct wireless_dev *, struct cfg80211_txq_stats *);
	int (*set_pmk)(struct wiphy *, struct net_device *, const struct cfg80211_pmk_conf *);
	int (*del_pmk)(struct wiphy *, struct net_device *, const u8 *);
	int (*external_auth)(struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);
	int (*tx_control_port)(struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, const __be16, const bool, u64 *);
	int (*get_ftm_responder_stats)(struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	int (*update_owe_info)(struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);
	int (*probe_mesh_link)(struct wiphy *, struct net_device *, const u8 *, size_t);
	int (*set_tid_config)(struct wiphy *, struct net_device *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct wiphy *, struct net_device *, const u8 *, u8);
	int (*set_sar_specs)(struct wiphy *, struct cfg80211_sar_specs *);
};

enum wiphy_flags {
	WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK = 1,
	WIPHY_FLAG_SPLIT_SCAN_6GHZ = 4,
	WIPHY_FLAG_NETNS_OK = 8,
	WIPHY_FLAG_PS_ON_BY_DEFAULT = 16,
	WIPHY_FLAG_4ADDR_AP = 32,
	WIPHY_FLAG_4ADDR_STATION = 64,
	WIPHY_FLAG_CONTROL_PORT_PROTOCOL = 128,
	WIPHY_FLAG_IBSS_RSN = 256,
	WIPHY_FLAG_MESH_AUTH = 1024,
	WIPHY_FLAG_SUPPORTS_FW_ROAM = 8192,
	WIPHY_FLAG_AP_UAPSD = 16384,
	WIPHY_FLAG_SUPPORTS_TDLS = 32768,
	WIPHY_FLAG_TDLS_EXTERNAL_SETUP = 65536,
	WIPHY_FLAG_HAVE_AP_SME = 131072,
	WIPHY_FLAG_REPORTS_OBSS = 262144,
	WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD = 524288,
	WIPHY_FLAG_OFFCHAN_TX = 1048576,
	WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL = 2097152,
	WIPHY_FLAG_SUPPORTS_5_10_MHZ = 4194304,
	WIPHY_FLAG_HAS_CHANNEL_SWITCH = 8388608,
	WIPHY_FLAG_HAS_STATIC_WEP = 16777216,
};

struct ieee80211_iface_limit {
	u16 max;
	u16 types;
};

struct ieee80211_iface_combination {
	const struct ieee80211_iface_limit *limits;
	u32 num_different_channels;
	u16 max_interfaces;
	u8 n_limits;
	bool beacon_int_infra_match;
	u8 radar_detect_widths;
	u8 radar_detect_regions;
	u32 beacon_int_min_gcd;
};

struct ieee80211_txrx_stypes {
	u16 tx;
	u16 rx;
};

enum wiphy_wowlan_support_flags {
	WIPHY_WOWLAN_ANY = 1,
	WIPHY_WOWLAN_MAGIC_PKT = 2,
	WIPHY_WOWLAN_DISCONNECT = 4,
	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY = 8,
	WIPHY_WOWLAN_GTK_REKEY_FAILURE = 16,
	WIPHY_WOWLAN_EAP_IDENTITY_REQ = 32,
	WIPHY_WOWLAN_4WAY_HANDSHAKE = 64,
	WIPHY_WOWLAN_RFKILL_RELEASE = 128,
	WIPHY_WOWLAN_NET_DETECT = 256,
};

struct wiphy_wowlan_tcp_support {
	const struct nl80211_wowlan_tcp_data_token_feature *tok;
	u32 data_payload_max;
	u32 data_interval_max;
	u32 wake_payload_max;
	bool seq;
};

struct wiphy_wowlan_support {
	u32 flags;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
	int max_nd_match_sets;
	const struct wiphy_wowlan_tcp_support *tcp;
};

struct wiphy_coalesce_support {
	int n_rules;
	int max_delay;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
};

struct wiphy_vendor_command {
	struct nl80211_vendor_cmd_info info;
	u32 flags;
	int (*doit)(struct wiphy *, struct wireless_dev *, const void *, int);
	int (*dumpit)(struct wiphy *, struct wireless_dev *, struct sk_buff *, const void *, int, long unsigned int *);
	const struct nla_policy *policy;
	unsigned int maxattr;
};

struct wiphy_iftype_ext_capab {
	enum nl80211_iftype iftype;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
};

struct cfg80211_pmsr_capabilities {
	unsigned int max_peers;
	u8 report_ap_tsf: 1;
	u8 randomize_mac_addr: 1;
	struct {
		u32 preambles;
		u32 bandwidths;
		s8 max_bursts_exponent;
		u8 max_ftms_per_burst;
		u8 supported: 1;
		u8 asap: 1;
		u8 non_asap: 1;
		u8 request_lci: 1;
		u8 request_civicloc: 1;
		u8 trigger_based: 1;
		u8 non_trigger_based: 1;
	} ftm;
};

struct wiphy_iftype_akm_suites {
	u16 iftypes_mask;
	const u32 *akm_suites;
	int n_akm_suites;
};

struct cfg80211_cached_keys {
	struct key_params params[4];
	u8 data[52];
	int def;
};

struct cfg80211_internal_bss {
	struct list_head list;
	struct list_head hidden_list;
	struct rb_node rbn;
	int: 32;
	u64 ts_boottime;
	long unsigned int ts;
	long unsigned int refcount;
	atomic_t hold;
	int: 32;
	u64 parent_tsf;
	u8 parent_bssid[6];
	struct cfg80211_bss pub;
	int: 32;
};

struct cfg80211_cqm_config {
	u32 rssi_hyst;
	s32 last_rssi_event_value;
	int n_rssi_thresholds;
	s32 rssi_thresholds[0];
};

struct cfg80211_fils_resp_params {
	const u8 *kek;
	size_t kek_len;
	bool update_erp_next_seq_num;
	u16 erp_next_seq_num;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *pmkid;
};

struct cfg80211_connect_resp_params {
	int status;
	const u8 *bssid;
	struct cfg80211_bss *bss;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
	enum nl80211_timeout_reason timeout_reason;
};

struct cfg80211_roam_info {
	struct ieee80211_channel *channel;
	struct cfg80211_bss *bss;
	const u8 *bssid;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
};

enum rfkill_type {
	RFKILL_TYPE_ALL = 0,
	RFKILL_TYPE_WLAN = 1,
	RFKILL_TYPE_BLUETOOTH = 2,
	RFKILL_TYPE_UWB = 3,
	RFKILL_TYPE_WIMAX = 4,
	RFKILL_TYPE_WWAN = 5,
	RFKILL_TYPE_GPS = 6,
	RFKILL_TYPE_FM = 7,
	RFKILL_TYPE_NFC = 8,
	NUM_RFKILL_TYPES = 9,
};

struct rfkill;

struct rfkill_ops {
	void (*poll)(struct rfkill *, void *);
	void (*query)(struct rfkill *, void *);
	int (*set_block)(void *, bool);
};

struct cfg80211_registered_device {
	const struct cfg80211_ops *ops;
	struct list_head list;
	struct rfkill_ops rfkill_ops;
	struct rfkill *rfkill;
	struct work_struct rfkill_block;
	char country_ie_alpha2[2];
	const struct ieee80211_regdomain *requested_regd;
	enum environment_cap env;
	int wiphy_idx;
	int devlist_generation;
	int wdev_id;
	int opencount;
	wait_queue_head_t dev_wait;
	struct list_head beacon_registrations;
	spinlock_t beacon_registrations_lock;
	int num_running_ifaces;
	int num_running_monitor_ifaces;
	u64 cookie_counter;
	spinlock_t bss_lock;
	struct list_head bss_list;
	struct rb_root bss_tree;
	u32 bss_generation;
	u32 bss_entries;
	struct cfg80211_scan_request *scan_req;
	struct cfg80211_scan_request *int_scan_req;
	struct sk_buff *scan_msg;
	struct list_head sched_scan_req_list;
	int: 32;
	time64_t suspend_at;
	struct work_struct scan_done_wk;
	struct genl_info *cur_cmd_info;
	struct work_struct conn_work;
	struct work_struct event_work;
	struct delayed_work dfs_update_channels_wk;
	u32 crit_proto_nlportid;
	struct cfg80211_coalesce *coalesce;
	struct work_struct destroy_work;
	struct work_struct sched_scan_stop_wk;
	struct work_struct sched_scan_res_wk;
	struct cfg80211_chan_def radar_chandef;
	struct work_struct propagate_radar_detect_wk;
	struct cfg80211_chan_def cac_done_chandef;
	struct work_struct propagate_cac_done_wk;
	struct work_struct mgmt_registrations_update_wk;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct wiphy wiphy;
};

enum cfg80211_event_type {
	EVENT_CONNECT_RESULT = 0,
	EVENT_ROAMED = 1,
	EVENT_DISCONNECTED = 2,
	EVENT_IBSS_JOINED = 3,
	EVENT_STOPPED = 4,
	EVENT_PORT_AUTHORIZED = 5,
};

struct cfg80211_event {
	struct list_head list;
	enum cfg80211_event_type type;
	union {
		struct cfg80211_connect_resp_params cr;
		struct cfg80211_roam_info rm;
		struct {
			const u8 *ie;
			size_t ie_len;
			u16 reason;
			bool locally_generated;
		} dc;
		struct {
			u8 bssid[6];
			struct ieee80211_channel *channel;
		} ij;
		struct {
			u8 bssid[6];
		} pa;
	};
};

struct cfg80211_beacon_registration {
	struct list_head list;
	u32 nlportid;
};

struct radiotap_align_size {
	uint8_t align: 4;
	uint8_t size: 4;
};

struct ieee80211_radiotap_namespace {
	const struct radiotap_align_size *align_size;
	int n_bits;
	uint32_t oui;
	uint8_t subns;
};

struct ieee80211_radiotap_vendor_namespaces {
	const struct ieee80211_radiotap_namespace *ns;
	int n_ns;
};

struct ieee80211_radiotap_header;

struct ieee80211_radiotap_iterator {
	struct ieee80211_radiotap_header *_rtheader;
	const struct ieee80211_radiotap_vendor_namespaces *_vns;
	const struct ieee80211_radiotap_namespace *current_namespace;
	unsigned char *_arg;
	unsigned char *_next_ns_data;
	__le32 *_next_bitmap;
	unsigned char *this_arg;
	int this_arg_index;
	int this_arg_size;
	int is_radiotap_ns;
	int _max_length;
	int _arg_index;
	uint32_t _bitmap_shifter;
	int _reset_on_ext;
};

struct ieee80211_radiotap_header {
	uint8_t it_version;
	uint8_t it_pad;
	__le16 it_len;
	__le32 it_present;
};

enum ieee80211_radiotap_presence {
	IEEE80211_RADIOTAP_TSFT = 0,
	IEEE80211_RADIOTAP_FLAGS = 1,
	IEEE80211_RADIOTAP_RATE = 2,
	IEEE80211_RADIOTAP_CHANNEL = 3,
	IEEE80211_RADIOTAP_FHSS = 4,
	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
	IEEE80211_RADIOTAP_ANTENNA = 11,
	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
	IEEE80211_RADIOTAP_RX_FLAGS = 14,
	IEEE80211_RADIOTAP_TX_FLAGS = 15,
	IEEE80211_RADIOTAP_RTS_RETRIES = 16,
	IEEE80211_RADIOTAP_DATA_RETRIES = 17,
	IEEE80211_RADIOTAP_MCS = 19,
	IEEE80211_RADIOTAP_AMPDU_STATUS = 20,
	IEEE80211_RADIOTAP_VHT = 21,
	IEEE80211_RADIOTAP_TIMESTAMP = 22,
	IEEE80211_RADIOTAP_HE = 23,
	IEEE80211_RADIOTAP_HE_MU = 24,
	IEEE80211_RADIOTAP_ZERO_LEN_PSDU = 26,
	IEEE80211_RADIOTAP_LSIG = 27,
	IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,
	IEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,
	IEEE80211_RADIOTAP_EXT = 31,
};

struct ieee80211_hdr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	u8 addr4[6];
};

struct ieee80211s_hdr {
	u8 flags;
	u8 ttl;
	__le32 seqnum;
	u8 eaddr1[6];
	u8 eaddr2[6];
} __attribute__((packed));

enum ieee80211_p2p_attr_id {
	IEEE80211_P2P_ATTR_STATUS = 0,
	IEEE80211_P2P_ATTR_MINOR_REASON = 1,
	IEEE80211_P2P_ATTR_CAPABILITY = 2,
	IEEE80211_P2P_ATTR_DEVICE_ID = 3,
	IEEE80211_P2P_ATTR_GO_INTENT = 4,
	IEEE80211_P2P_ATTR_GO_CONFIG_TIMEOUT = 5,
	IEEE80211_P2P_ATTR_LISTEN_CHANNEL = 6,
	IEEE80211_P2P_ATTR_GROUP_BSSID = 7,
	IEEE80211_P2P_ATTR_EXT_LISTEN_TIMING = 8,
	IEEE80211_P2P_ATTR_INTENDED_IFACE_ADDR = 9,
	IEEE80211_P2P_ATTR_MANAGABILITY = 10,
	IEEE80211_P2P_ATTR_CHANNEL_LIST = 11,
	IEEE80211_P2P_ATTR_ABSENCE_NOTICE = 12,
	IEEE80211_P2P_ATTR_DEVICE_INFO = 13,
	IEEE80211_P2P_ATTR_GROUP_INFO = 14,
	IEEE80211_P2P_ATTR_GROUP_ID = 15,
	IEEE80211_P2P_ATTR_INTERFACE = 16,
	IEEE80211_P2P_ATTR_OPER_CHANNEL = 17,
	IEEE80211_P2P_ATTR_INVITE_FLAGS = 18,
	IEEE80211_P2P_ATTR_VENDOR_SPECIFIC = 221,
	IEEE80211_P2P_ATTR_MAX = 222,
};

enum ieee80211_vht_chanwidth {
	IEEE80211_VHT_CHANWIDTH_USE_HT = 0,
	IEEE80211_VHT_CHANWIDTH_80MHZ = 1,
	IEEE80211_VHT_CHANWIDTH_160MHZ = 2,
	IEEE80211_VHT_CHANWIDTH_80P80MHZ = 3,
};

enum ieee80211_statuscode {
	WLAN_STATUS_SUCCESS = 0,
	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
	WLAN_STATUS_CHALLENGE_FAIL = 15,
	WLAN_STATUS_AUTH_TIMEOUT = 16,
	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
	WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY = 30,
	WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION = 31,
	WLAN_STATUS_INVALID_IE = 40,
	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
	WLAN_STATUS_INVALID_AKMP = 43,
	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
	WLAN_STATUS_UNSPECIFIED_QOS = 32,
	WLAN_STATUS_ASSOC_DENIED_NOBANDWIDTH = 33,
	WLAN_STATUS_ASSOC_DENIED_LOWACK = 34,
	WLAN_STATUS_ASSOC_DENIED_UNSUPP_QOS = 35,
	WLAN_STATUS_REQUEST_DECLINED = 37,
	WLAN_STATUS_INVALID_QOS_PARAM = 38,
	WLAN_STATUS_CHANGE_TSPEC = 39,
	WLAN_STATUS_WAIT_TS_DELAY = 47,
	WLAN_STATUS_NO_DIRECT_LINK = 48,
	WLAN_STATUS_STA_NOT_PRESENT = 49,
	WLAN_STATUS_STA_NOT_QSTA = 50,
	WLAN_STATUS_ANTI_CLOG_REQUIRED = 76,
	WLAN_STATUS_FCG_NOT_SUPP = 78,
	WLAN_STATUS_STA_NO_TBTT = 78,
	WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES = 39,
	WLAN_STATUS_REJECTED_FOR_DELAY_PERIOD = 47,
	WLAN_STATUS_REJECT_WITH_SCHEDULE = 83,
	WLAN_STATUS_PENDING_ADMITTING_FST_SESSION = 86,
	WLAN_STATUS_PERFORMING_FST_NOW = 87,
	WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW = 88,
	WLAN_STATUS_REJECT_U_PID_SETTING = 89,
	WLAN_STATUS_REJECT_DSE_BAND = 96,
	WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
	WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
	WLAN_STATUS_FILS_AUTHENTICATION_FAILURE = 108,
	WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER = 109,
	WLAN_STATUS_SAE_HASH_TO_ELEMENT = 126,
	WLAN_STATUS_SAE_PK = 127,
};

enum ieee80211_eid {
	WLAN_EID_SSID = 0,
	WLAN_EID_SUPP_RATES = 1,
	WLAN_EID_FH_PARAMS = 2,
	WLAN_EID_DS_PARAMS = 3,
	WLAN_EID_CF_PARAMS = 4,
	WLAN_EID_TIM = 5,
	WLAN_EID_IBSS_PARAMS = 6,
	WLAN_EID_COUNTRY = 7,
	WLAN_EID_REQUEST = 10,
	WLAN_EID_QBSS_LOAD = 11,
	WLAN_EID_EDCA_PARAM_SET = 12,
	WLAN_EID_TSPEC = 13,
	WLAN_EID_TCLAS = 14,
	WLAN_EID_SCHEDULE = 15,
	WLAN_EID_CHALLENGE = 16,
	WLAN_EID_PWR_CONSTRAINT = 32,
	WLAN_EID_PWR_CAPABILITY = 33,
	WLAN_EID_TPC_REQUEST = 34,
	WLAN_EID_TPC_REPORT = 35,
	WLAN_EID_SUPPORTED_CHANNELS = 36,
	WLAN_EID_CHANNEL_SWITCH = 37,
	WLAN_EID_MEASURE_REQUEST = 38,
	WLAN_EID_MEASURE_REPORT = 39,
	WLAN_EID_QUIET = 40,
	WLAN_EID_IBSS_DFS = 41,
	WLAN_EID_ERP_INFO = 42,
	WLAN_EID_TS_DELAY = 43,
	WLAN_EID_TCLAS_PROCESSING = 44,
	WLAN_EID_HT_CAPABILITY = 45,
	WLAN_EID_QOS_CAPA = 46,
	WLAN_EID_RSN = 48,
	WLAN_EID_802_15_COEX = 49,
	WLAN_EID_EXT_SUPP_RATES = 50,
	WLAN_EID_AP_CHAN_REPORT = 51,
	WLAN_EID_NEIGHBOR_REPORT = 52,
	WLAN_EID_RCPI = 53,
	WLAN_EID_MOBILITY_DOMAIN = 54,
	WLAN_EID_FAST_BSS_TRANSITION = 55,
	WLAN_EID_TIMEOUT_INTERVAL = 56,
	WLAN_EID_RIC_DATA = 57,
	WLAN_EID_DSE_REGISTERED_LOCATION = 58,
	WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
	WLAN_EID_EXT_CHANSWITCH_ANN = 60,
	WLAN_EID_HT_OPERATION = 61,
	WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
	WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
	WLAN_EID_ANTENNA_INFO = 64,
	WLAN_EID_RSNI = 65,
	WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
	WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
	WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
	WLAN_EID_TIME_ADVERTISEMENT = 69,
	WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
	WLAN_EID_MULTIPLE_BSSID = 71,
	WLAN_EID_BSS_COEX_2040 = 72,
	WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
	WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
	WLAN_EID_RIC_DESCRIPTOR = 75,
	WLAN_EID_MMIE = 76,
	WLAN_EID_ASSOC_COMEBACK_TIME = 77,
	WLAN_EID_EVENT_REQUEST = 78,
	WLAN_EID_EVENT_REPORT = 79,
	WLAN_EID_DIAGNOSTIC_REQUEST = 80,
	WLAN_EID_DIAGNOSTIC_REPORT = 81,
	WLAN_EID_LOCATION_PARAMS = 82,
	WLAN_EID_NON_TX_BSSID_CAP = 83,
	WLAN_EID_SSID_LIST = 84,
	WLAN_EID_MULTI_BSSID_IDX = 85,
	WLAN_EID_FMS_DESCRIPTOR = 86,
	WLAN_EID_FMS_REQUEST = 87,
	WLAN_EID_FMS_RESPONSE = 88,
	WLAN_EID_QOS_TRAFFIC_CAPA = 89,
	WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
	WLAN_EID_TSF_REQUEST = 91,
	WLAN_EID_TSF_RESPOSNE = 92,
	WLAN_EID_WNM_SLEEP_MODE = 93,
	WLAN_EID_TIM_BCAST_REQ = 94,
	WLAN_EID_TIM_BCAST_RESP = 95,
	WLAN_EID_COLL_IF_REPORT = 96,
	WLAN_EID_CHANNEL_USAGE = 97,
	WLAN_EID_TIME_ZONE = 98,
	WLAN_EID_DMS_REQUEST = 99,
	WLAN_EID_DMS_RESPONSE = 100,
	WLAN_EID_LINK_ID = 101,
	WLAN_EID_WAKEUP_SCHEDUL = 102,
	WLAN_EID_CHAN_SWITCH_TIMING = 104,
	WLAN_EID_PTI_CONTROL = 105,
	WLAN_EID_PU_BUFFER_STATUS = 106,
	WLAN_EID_INTERWORKING = 107,
	WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
	WLAN_EID_EXPEDITED_BW_REQ = 109,
	WLAN_EID_QOS_MAP_SET = 110,
	WLAN_EID_ROAMING_CONSORTIUM = 111,
	WLAN_EID_EMERGENCY_ALERT = 112,
	WLAN_EID_MESH_CONFIG = 113,
	WLAN_EID_MESH_ID = 114,
	WLAN_EID_LINK_METRIC_REPORT = 115,
	WLAN_EID_CONGESTION_NOTIFICATION = 116,
	WLAN_EID_PEER_MGMT = 117,
	WLAN_EID_CHAN_SWITCH_PARAM = 118,
	WLAN_EID_MESH_AWAKE_WINDOW = 119,
	WLAN_EID_BEACON_TIMING = 120,
	WLAN_EID_MCCAOP_SETUP_REQ = 121,
	WLAN_EID_MCCAOP_SETUP_RESP = 122,
	WLAN_EID_MCCAOP_ADVERT = 123,
	WLAN_EID_MCCAOP_TEARDOWN = 124,
	WLAN_EID_GANN = 125,
	WLAN_EID_RANN = 126,
	WLAN_EID_EXT_CAPABILITY = 127,
	WLAN_EID_PREQ = 130,
	WLAN_EID_PREP = 131,
	WLAN_EID_PERR = 132,
	WLAN_EID_PXU = 137,
	WLAN_EID_PXUC = 138,
	WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
	WLAN_EID_MIC = 140,
	WLAN_EID_DESTINATION_URI = 141,
	WLAN_EID_UAPSD_COEX = 142,
	WLAN_EID_WAKEUP_SCHEDULE = 143,
	WLAN_EID_EXT_SCHEDULE = 144,
	WLAN_EID_STA_AVAILABILITY = 145,
	WLAN_EID_DMG_TSPEC = 146,
	WLAN_EID_DMG_AT = 147,
	WLAN_EID_DMG_CAP = 148,
	WLAN_EID_CISCO_VENDOR_SPECIFIC = 150,
	WLAN_EID_DMG_OPERATION = 151,
	WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
	WLAN_EID_DMG_BEAM_REFINEMENT = 153,
	WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
	WLAN_EID_AWAKE_WINDOW = 157,
	WLAN_EID_MULTI_BAND = 158,
	WLAN_EID_ADDBA_EXT = 159,
	WLAN_EID_NEXT_PCP_LIST = 160,
	WLAN_EID_PCP_HANDOVER = 161,
	WLAN_EID_DMG_LINK_MARGIN = 162,
	WLAN_EID_SWITCHING_STREAM = 163,
	WLAN_EID_SESSION_TRANSITION = 164,
	WLAN_EID_DYN_TONE_PAIRING_REPORT = 165,
	WLAN_EID_CLUSTER_REPORT = 166,
	WLAN_EID_RELAY_CAP = 167,
	WLAN_EID_RELAY_XFER_PARAM_SET = 168,
	WLAN_EID_BEAM_LINK_MAINT = 169,
	WLAN_EID_MULTIPLE_MAC_ADDR = 170,
	WLAN_EID_U_PID = 171,
	WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
	WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
	WLAN_EID_QUIET_PERIOD_REQ = 175,
	WLAN_EID_QUIET_PERIOD_RESP = 177,
	WLAN_EID_EPAC_POLICY = 182,
	WLAN_EID_CLISTER_TIME_OFF = 183,
	WLAN_EID_INTER_AC_PRIO = 184,
	WLAN_EID_SCS_DESCRIPTOR = 185,
	WLAN_EID_QLOAD_REPORT = 186,
	WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
	WLAN_EID_HL_STREAM_ID = 188,
	WLAN_EID_GCR_GROUP_ADDR = 189,
	WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
	WLAN_EID_VHT_CAPABILITY = 191,
	WLAN_EID_VHT_OPERATION = 192,
	WLAN_EID_EXTENDED_BSS_LOAD = 193,
	WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
	WLAN_EID_VHT_TX_POWER_ENVELOPE = 195,
	WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
	WLAN_EID_AID = 197,
	WLAN_EID_QUIET_CHANNEL = 198,
	WLAN_EID_OPMODE_NOTIF = 199,
	WLAN_EID_REDUCED_NEIGHBOR_REPORT = 201,
	WLAN_EID_AID_REQUEST = 210,
	WLAN_EID_AID_RESPONSE = 211,
	WLAN_EID_S1G_BCN_COMPAT = 213,
	WLAN_EID_S1G_SHORT_BCN_INTERVAL = 214,
	WLAN_EID_S1G_CAPABILITIES = 217,
	WLAN_EID_VENDOR_SPECIFIC = 221,
	WLAN_EID_QOS_PARAMETER = 222,
	WLAN_EID_S1G_OPERATION = 232,
	WLAN_EID_CAG_NUMBER = 237,
	WLAN_EID_AP_CSN = 239,
	WLAN_EID_FILS_INDICATION = 240,
	WLAN_EID_DILS = 241,
	WLAN_EID_FRAGMENT = 242,
	WLAN_EID_RSNX = 244,
	WLAN_EID_EXTENSION = 255,
};

struct element {
	u8 id;
	u8 datalen;
	u8 data[0];
};

enum nl80211_he_ru_alloc {
	NL80211_RATE_INFO_HE_RU_ALLOC_26 = 0,
	NL80211_RATE_INFO_HE_RU_ALLOC_52 = 1,
	NL80211_RATE_INFO_HE_RU_ALLOC_106 = 2,
	NL80211_RATE_INFO_HE_RU_ALLOC_242 = 3,
	NL80211_RATE_INFO_HE_RU_ALLOC_484 = 4,
	NL80211_RATE_INFO_HE_RU_ALLOC_996 = 5,
	NL80211_RATE_INFO_HE_RU_ALLOC_2x996 = 6,
};

enum ieee80211_channel_flags {
	IEEE80211_CHAN_DISABLED = 1,
	IEEE80211_CHAN_NO_IR = 2,
	IEEE80211_CHAN_RADAR = 8,
	IEEE80211_CHAN_NO_HT40PLUS = 16,
	IEEE80211_CHAN_NO_HT40MINUS = 32,
	IEEE80211_CHAN_NO_OFDM = 64,
	IEEE80211_CHAN_NO_80MHZ = 128,
	IEEE80211_CHAN_NO_160MHZ = 256,
	IEEE80211_CHAN_INDOOR_ONLY = 512,
	IEEE80211_CHAN_IR_CONCURRENT = 1024,
	IEEE80211_CHAN_NO_20MHZ = 2048,
	IEEE80211_CHAN_NO_10MHZ = 4096,
	IEEE80211_CHAN_NO_HE = 8192,
	IEEE80211_CHAN_1MHZ = 16384,
	IEEE80211_CHAN_2MHZ = 32768,
	IEEE80211_CHAN_4MHZ = 65536,
	IEEE80211_CHAN_8MHZ = 131072,
	IEEE80211_CHAN_16MHZ = 262144,
};

enum ieee80211_rate_flags {
	IEEE80211_RATE_SHORT_PREAMBLE = 1,
	IEEE80211_RATE_MANDATORY_A = 2,
	IEEE80211_RATE_MANDATORY_B = 4,
	IEEE80211_RATE_MANDATORY_G = 8,
	IEEE80211_RATE_ERP_G = 16,
	IEEE80211_RATE_SUPPORTS_5MHZ = 32,
	IEEE80211_RATE_SUPPORTS_10MHZ = 64,
};

struct iface_combination_params {
	int num_different_channels;
	u8 radar_detect;
	int iftype_num[13];
	u32 new_beacon_int;
};

enum rate_info_flags {
	RATE_INFO_FLAGS_MCS = 1,
	RATE_INFO_FLAGS_VHT_MCS = 2,
	RATE_INFO_FLAGS_SHORT_GI = 4,
	RATE_INFO_FLAGS_DMG = 8,
	RATE_INFO_FLAGS_HE_MCS = 16,
	RATE_INFO_FLAGS_EDMG = 32,
};

enum rate_info_bw {
	RATE_INFO_BW_20 = 0,
	RATE_INFO_BW_5 = 1,
	RATE_INFO_BW_10 = 2,
	RATE_INFO_BW_40 = 3,
	RATE_INFO_BW_80 = 4,
	RATE_INFO_BW_160 = 5,
	RATE_INFO_BW_HE_RU = 6,
};

struct iapp_layer2_update {
	u8 da[6];
	u8 sa[6];
	__be16 len;
	u8 dsap;
	u8 ssap;
	u8 control;
	u8 xid_info[3];
};

enum nl80211_reg_rule_flags {
	NL80211_RRF_NO_OFDM = 1,
	NL80211_RRF_NO_CCK = 2,
	NL80211_RRF_NO_INDOOR = 4,
	NL80211_RRF_NO_OUTDOOR = 8,
	NL80211_RRF_DFS = 16,
	NL80211_RRF_PTP_ONLY = 32,
	NL80211_RRF_PTMP_ONLY = 64,
	NL80211_RRF_NO_IR = 128,
	__NL80211_RRF_NO_IBSS = 256,
	NL80211_RRF_AUTO_BW = 2048,
	NL80211_RRF_IR_CONCURRENT = 4096,
	NL80211_RRF_NO_HT40MINUS = 8192,
	NL80211_RRF_NO_HT40PLUS = 16384,
	NL80211_RRF_NO_80MHZ = 32768,
	NL80211_RRF_NO_160MHZ = 65536,
	NL80211_RRF_NO_HE = 131072,
};

enum nl80211_channel_type {
	NL80211_CHAN_NO_HT = 0,
	NL80211_CHAN_HT20 = 1,
	NL80211_CHAN_HT40MINUS = 2,
	NL80211_CHAN_HT40PLUS = 3,
};

enum ieee80211_regd_source {
	REGD_SOURCE_INTERNAL_DB = 0,
	REGD_SOURCE_CRDA = 1,
	REGD_SOURCE_CACHED = 2,
};

enum reg_request_treatment {
	REG_REQ_OK = 0,
	REG_REQ_IGNORE = 1,
	REG_REQ_INTERSECT = 2,
	REG_REQ_ALREADY_SET = 3,
};

struct reg_beacon {
	struct list_head list;
	struct ieee80211_channel chan;
};

struct reg_regdb_apply_request {
	struct list_head list;
	const struct ieee80211_regdomain *regdom;
};

struct fwdb_country {
	u8 alpha2[2];
	__be16 coll_ptr;
};

struct fwdb_header {
	__be32 magic;
	__be32 version;
	struct fwdb_country country[0];
};

struct fwdb_collection {
	u8 len;
	u8 n_rules;
	u8 dfs_region;
	char: 8;
};

enum fwdb_flags {
	FWDB_FLAG_NO_OFDM = 1,
	FWDB_FLAG_NO_OUTDOOR = 2,
	FWDB_FLAG_DFS = 4,
	FWDB_FLAG_NO_IR = 8,
	FWDB_FLAG_AUTO_BW = 16,
};

struct fwdb_wmm_ac {
	u8 ecw;
	u8 aifsn;
	__be16 cot;
};

struct fwdb_wmm_rule {
	struct fwdb_wmm_ac client[4];
	struct fwdb_wmm_ac ap[4];
};

struct fwdb_rule {
	u8 len;
	u8 flags;
	__be16 max_eirp;
	__be32 start;
	__be32 end;
	__be32 max_bw;
	__be16 cac_timeout;
	__be16 wmm_ptr;
};

enum nl80211_scan_flags {
	NL80211_SCAN_FLAG_LOW_PRIORITY = 1,
	NL80211_SCAN_FLAG_FLUSH = 2,
	NL80211_SCAN_FLAG_AP = 4,
	NL80211_SCAN_FLAG_RANDOM_ADDR = 8,
	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME = 16,
	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP = 32,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE = 64,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 128,
	NL80211_SCAN_FLAG_LOW_SPAN = 256,
	NL80211_SCAN_FLAG_LOW_POWER = 512,
	NL80211_SCAN_FLAG_HIGH_ACCURACY = 1024,
	NL80211_SCAN_FLAG_RANDOM_SN = 2048,
	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT = 4096,
	NL80211_SCAN_FLAG_FREQ_KHZ = 8192,
	NL80211_SCAN_FLAG_COLOCATED_6GHZ = 16384,
};

struct ieee80211_msrment_ie {
	u8 token;
	u8 mode;
	u8 type;
	u8 request[0];
};

struct ieee80211_ext_chansw_ie {
	u8 mode;
	u8 new_operating_class;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_tpc_report_ie {
	u8 tx_power;
	u8 link_margin;
};

struct ieee80211_s1g_bcn_compat_ie {
	__le16 compat_info;
	__le16 beacon_int;
	__le32 tsf_completion;
};

struct ieee80211_s1g_oper_ie {
	u8 ch_width;
	u8 oper_class;
	u8 primary_ch;
	u8 oper_ch;
	__le16 basic_mcs_nss;
};

struct ieee80211_ext {
	__le16 frame_control;
	__le16 duration;
	union {
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 variable[0];
		} __attribute__((packed)) s1g_beacon;
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 next_tbtt[3];
			u8 variable[0];
		} __attribute__((packed)) s1g_short_beacon;
	} u;
} __attribute__((packed));

struct ieee80211_mgmt {
	__le16 frame_control;
	__le16 duration;
	u8 da[6];
	u8 sa[6];
	u8 bssid[6];
	__le16 seq_ctrl;
	union {
		struct {
			__le16 auth_alg;
			__le16 auth_transaction;
			__le16 status_code;
			u8 variable[0];
		} auth;
		struct {
			__le16 reason_code;
		} deauth;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 variable[0];
		} assoc_req;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 current_ap[6];
			u8 variable[0];
		} reassoc_req;
		struct {
			__le16 reason_code;
		} disassoc;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} beacon;
		struct {
			u8 variable[0];
		} probe_req;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} probe_resp;
		struct {
			u8 category;
			union {
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 status_code;
					u8 variable[0];
				} wme_action;
				struct {
					u8 action_code;
					u8 variable[0];
				} chan_switch;
				struct {
					u8 action_code;
					struct ieee80211_ext_chansw_ie data;
					u8 variable[0];
				} ext_chan_switch;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 element_id;
					u8 length;
					struct ieee80211_msrment_ie msr_elem;
				} measurement;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capab;
					__le16 timeout;
					__le16 start_seq_num;
					u8 variable[0];
				} addba_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 status;
					__le16 capab;
					__le16 timeout;
				} addba_resp;
				struct {
					u8 action_code;
					__le16 params;
					__le16 reason_code;
				} __attribute__((packed)) delba;
				struct {
					u8 action_code;
					u8 variable[0];
				} self_prot;
				struct {
					u8 action_code;
					u8 variable[0];
				} mesh_action;
				struct {
					u8 action;
					u8 trans_id[2];
				} sa_query;
				struct {
					u8 action;
					u8 smps_control;
				} ht_smps;
				struct {
					u8 action_code;
					u8 chanwidth;
				} ht_notify_cw;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capability;
					u8 variable[0];
				} tdls_discover_resp;
				struct {
					u8 action_code;
					u8 operating_mode;
				} vht_opmode_notif;
				struct {
					u8 action_code;
					u8 membership[8];
					u8 position[16];
				} vht_group_notif;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 tpc_elem_id;
					u8 tpc_elem_length;
					struct ieee80211_tpc_report_ie tpc;
				} tpc_report;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 follow_up;
					u8 tod[6];
					u8 toa[6];
					__le16 tod_error;
					__le16 toa_error;
					u8 variable[0];
				} __attribute__((packed)) ftm;
			} u;
		} __attribute__((packed)) action;
	} u;
} __attribute__((packed));

struct ieee80211_ht_operation {
	u8 primary_chan;
	u8 ht_param;
	__le16 operation_mode;
	__le16 stbc_param;
	u8 basic_set[16];
};

enum ieee80211_eid_ext {
	WLAN_EID_EXT_ASSOC_DELAY_INFO = 1,
	WLAN_EID_EXT_FILS_REQ_PARAMS = 2,
	WLAN_EID_EXT_FILS_KEY_CONFIRM = 3,
	WLAN_EID_EXT_FILS_SESSION = 4,
	WLAN_EID_EXT_FILS_HLP_CONTAINER = 5,
	WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN = 6,
	WLAN_EID_EXT_KEY_DELIVERY = 7,
	WLAN_EID_EXT_FILS_WRAPPED_DATA = 8,
	WLAN_EID_EXT_FILS_PUBLIC_KEY = 12,
	WLAN_EID_EXT_FILS_NONCE = 13,
	WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE = 14,
	WLAN_EID_EXT_HE_CAPABILITY = 35,
	WLAN_EID_EXT_HE_OPERATION = 36,
	WLAN_EID_EXT_UORA = 37,
	WLAN_EID_EXT_HE_MU_EDCA = 38,
	WLAN_EID_EXT_HE_SPR = 39,
	WLAN_EID_EXT_NDP_FEEDBACK_REPORT_PARAMSET = 41,
	WLAN_EID_EXT_BSS_COLOR_CHG_ANN = 42,
	WLAN_EID_EXT_QUIET_TIME_PERIOD_SETUP = 43,
	WLAN_EID_EXT_ESS_REPORT = 45,
	WLAN_EID_EXT_OPS = 46,
	WLAN_EID_EXT_HE_BSS_LOAD = 47,
	WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME = 52,
	WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION = 55,
	WLAN_EID_EXT_NON_INHERITANCE = 56,
	WLAN_EID_EXT_KNOWN_BSSID = 57,
	WLAN_EID_EXT_SHORT_SSID_LIST = 58,
	WLAN_EID_EXT_HE_6GHZ_CAPA = 59,
	WLAN_EID_EXT_UL_MU_POWER_CAPA = 60,
};

struct ieee80211_neighbor_ap_info {
	u8 tbtt_info_hdr;
	u8 tbtt_info_len;
	u8 op_class;
	u8 channel;
};

enum ieee80211_privacy {
	IEEE80211_PRIVACY_ON = 0,
	IEEE80211_PRIVACY_OFF = 1,
	IEEE80211_PRIVACY_ANY = 2,
};

struct cfg80211_inform_bss {
	struct ieee80211_channel *chan;
	enum nl80211_bss_scan_width scan_width;
	s32 signal;
	int: 32;
	u64 boottime_ns;
	u64 parent_tsf;
	u8 parent_bssid[6];
	u8 chains;
	s8 chain_signal[4];
	int: 8;
	int: 32;
};

enum cfg80211_bss_frame_type {
	CFG80211_BSS_FTYPE_UNKNOWN = 0,
	CFG80211_BSS_FTYPE_BEACON = 1,
	CFG80211_BSS_FTYPE_PRESP = 2,
};

struct cfg80211_colocated_ap {
	struct list_head list;
	u8 bssid[6];
	u8 ssid[32];
	size_t ssid_len;
	u32 short_ssid;
	u32 center_freq;
	u8 unsolicited_probe: 1;
	u8 oct_recommended: 1;
	u8 same_ssid: 1;
	u8 multi_bss: 1;
	u8 transmitted_bssid: 1;
	u8 colocated_ess: 1;
	u8 short_ssid_valid: 1;
};

enum bss_compare_mode {
	BSS_CMP_REGULAR = 0,
	BSS_CMP_HIDE_ZLEN = 1,
	BSS_CMP_HIDE_NUL = 2,
};

struct cfg80211_non_tx_bss {
	struct cfg80211_bss *tx_bss;
	u8 max_bssid_indicator;
	u8 bssid_index;
};

enum ieee80211_vht_mcs_support {
	IEEE80211_VHT_MCS_SUPPORT_0_7 = 0,
	IEEE80211_VHT_MCS_SUPPORT_0_8 = 1,
	IEEE80211_VHT_MCS_SUPPORT_0_9 = 2,
	IEEE80211_VHT_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_he_mcs_support {
	IEEE80211_HE_MCS_SUPPORT_0_7 = 0,
	IEEE80211_HE_MCS_SUPPORT_0_9 = 1,
	IEEE80211_HE_MCS_SUPPORT_0_11 = 2,
	IEEE80211_HE_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_mesh_sync_method {
	IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET = 1,
	IEEE80211_SYNC_METHOD_VENDOR = 255,
};

enum ieee80211_mesh_path_protocol {
	IEEE80211_PATH_PROTOCOL_HWMP = 1,
	IEEE80211_PATH_PROTOCOL_VENDOR = 255,
};

enum ieee80211_mesh_path_metric {
	IEEE80211_PATH_METRIC_AIRTIME = 1,
	IEEE80211_PATH_METRIC_VENDOR = 255,
};

enum nl80211_attrs {
	NL80211_ATTR_UNSPEC = 0,
	NL80211_ATTR_WIPHY = 1,
	NL80211_ATTR_WIPHY_NAME = 2,
	NL80211_ATTR_IFINDEX = 3,
	NL80211_ATTR_IFNAME = 4,
	NL80211_ATTR_IFTYPE = 5,
	NL80211_ATTR_MAC = 6,
	NL80211_ATTR_KEY_DATA = 7,
	NL80211_ATTR_KEY_IDX = 8,
	NL80211_ATTR_KEY_CIPHER = 9,
	NL80211_ATTR_KEY_SEQ = 10,
	NL80211_ATTR_KEY_DEFAULT = 11,
	NL80211_ATTR_BEACON_INTERVAL = 12,
	NL80211_ATTR_DTIM_PERIOD = 13,
	NL80211_ATTR_BEACON_HEAD = 14,
	NL80211_ATTR_BEACON_TAIL = 15,
	NL80211_ATTR_STA_AID = 16,
	NL80211_ATTR_STA_FLAGS = 17,
	NL80211_ATTR_STA_LISTEN_INTERVAL = 18,
	NL80211_ATTR_STA_SUPPORTED_RATES = 19,
	NL80211_ATTR_STA_VLAN = 20,
	NL80211_ATTR_STA_INFO = 21,
	NL80211_ATTR_WIPHY_BANDS = 22,
	NL80211_ATTR_MNTR_FLAGS = 23,
	NL80211_ATTR_MESH_ID = 24,
	NL80211_ATTR_STA_PLINK_ACTION = 25,
	NL80211_ATTR_MPATH_NEXT_HOP = 26,
	NL80211_ATTR_MPATH_INFO = 27,
	NL80211_ATTR_BSS_CTS_PROT = 28,
	NL80211_ATTR_BSS_SHORT_PREAMBLE = 29,
	NL80211_ATTR_BSS_SHORT_SLOT_TIME = 30,
	NL80211_ATTR_HT_CAPABILITY = 31,
	NL80211_ATTR_SUPPORTED_IFTYPES = 32,
	NL80211_ATTR_REG_ALPHA2 = 33,
	NL80211_ATTR_REG_RULES = 34,
	NL80211_ATTR_MESH_CONFIG = 35,
	NL80211_ATTR_BSS_BASIC_RATES = 36,
	NL80211_ATTR_WIPHY_TXQ_PARAMS = 37,
	NL80211_ATTR_WIPHY_FREQ = 38,
	NL80211_ATTR_WIPHY_CHANNEL_TYPE = 39,
	NL80211_ATTR_KEY_DEFAULT_MGMT = 40,
	NL80211_ATTR_MGMT_SUBTYPE = 41,
	NL80211_ATTR_IE = 42,
	NL80211_ATTR_MAX_NUM_SCAN_SSIDS = 43,
	NL80211_ATTR_SCAN_FREQUENCIES = 44,
	NL80211_ATTR_SCAN_SSIDS = 45,
	NL80211_ATTR_GENERATION = 46,
	NL80211_ATTR_BSS = 47,
	NL80211_ATTR_REG_INITIATOR = 48,
	NL80211_ATTR_REG_TYPE = 49,
	NL80211_ATTR_SUPPORTED_COMMANDS = 50,
	NL80211_ATTR_FRAME = 51,
	NL80211_ATTR_SSID = 52,
	NL80211_ATTR_AUTH_TYPE = 53,
	NL80211_ATTR_REASON_CODE = 54,
	NL80211_ATTR_KEY_TYPE = 55,
	NL80211_ATTR_MAX_SCAN_IE_LEN = 56,
	NL80211_ATTR_CIPHER_SUITES = 57,
	NL80211_ATTR_FREQ_BEFORE = 58,
	NL80211_ATTR_FREQ_AFTER = 59,
	NL80211_ATTR_FREQ_FIXED = 60,
	NL80211_ATTR_WIPHY_RETRY_SHORT = 61,
	NL80211_ATTR_WIPHY_RETRY_LONG = 62,
	NL80211_ATTR_WIPHY_FRAG_THRESHOLD = 63,
	NL80211_ATTR_WIPHY_RTS_THRESHOLD = 64,
	NL80211_ATTR_TIMED_OUT = 65,
	NL80211_ATTR_USE_MFP = 66,
	NL80211_ATTR_STA_FLAGS2 = 67,
	NL80211_ATTR_CONTROL_PORT = 68,
	NL80211_ATTR_TESTDATA = 69,
	NL80211_ATTR_PRIVACY = 70,
	NL80211_ATTR_DISCONNECTED_BY_AP = 71,
	NL80211_ATTR_STATUS_CODE = 72,
	NL80211_ATTR_CIPHER_SUITES_PAIRWISE = 73,
	NL80211_ATTR_CIPHER_SUITE_GROUP = 74,
	NL80211_ATTR_WPA_VERSIONS = 75,
	NL80211_ATTR_AKM_SUITES = 76,
	NL80211_ATTR_REQ_IE = 77,
	NL80211_ATTR_RESP_IE = 78,
	NL80211_ATTR_PREV_BSSID = 79,
	NL80211_ATTR_KEY = 80,
	NL80211_ATTR_KEYS = 81,
	NL80211_ATTR_PID = 82,
	NL80211_ATTR_4ADDR = 83,
	NL80211_ATTR_SURVEY_INFO = 84,
	NL80211_ATTR_PMKID = 85,
	NL80211_ATTR_MAX_NUM_PMKIDS = 86,
	NL80211_ATTR_DURATION = 87,
	NL80211_ATTR_COOKIE = 88,
	NL80211_ATTR_WIPHY_COVERAGE_CLASS = 89,
	NL80211_ATTR_TX_RATES = 90,
	NL80211_ATTR_FRAME_MATCH = 91,
	NL80211_ATTR_ACK = 92,
	NL80211_ATTR_PS_STATE = 93,
	NL80211_ATTR_CQM = 94,
	NL80211_ATTR_LOCAL_STATE_CHANGE = 95,
	NL80211_ATTR_AP_ISOLATE = 96,
	NL80211_ATTR_WIPHY_TX_POWER_SETTING = 97,
	NL80211_ATTR_WIPHY_TX_POWER_LEVEL = 98,
	NL80211_ATTR_TX_FRAME_TYPES = 99,
	NL80211_ATTR_RX_FRAME_TYPES = 100,
	NL80211_ATTR_FRAME_TYPE = 101,
	NL80211_ATTR_CONTROL_PORT_ETHERTYPE = 102,
	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT = 103,
	NL80211_ATTR_SUPPORT_IBSS_RSN = 104,
	NL80211_ATTR_WIPHY_ANTENNA_TX = 105,
	NL80211_ATTR_WIPHY_ANTENNA_RX = 106,
	NL80211_ATTR_MCAST_RATE = 107,
	NL80211_ATTR_OFFCHANNEL_TX_OK = 108,
	NL80211_ATTR_BSS_HT_OPMODE = 109,
	NL80211_ATTR_KEY_DEFAULT_TYPES = 110,
	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION = 111,
	NL80211_ATTR_MESH_SETUP = 112,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX = 113,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX = 114,
	NL80211_ATTR_SUPPORT_MESH_AUTH = 115,
	NL80211_ATTR_STA_PLINK_STATE = 116,
	NL80211_ATTR_WOWLAN_TRIGGERS = 117,
	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED = 118,
	NL80211_ATTR_SCHED_SCAN_INTERVAL = 119,
	NL80211_ATTR_INTERFACE_COMBINATIONS = 120,
	NL80211_ATTR_SOFTWARE_IFTYPES = 121,
	NL80211_ATTR_REKEY_DATA = 122,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS = 123,
	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN = 124,
	NL80211_ATTR_SCAN_SUPP_RATES = 125,
	NL80211_ATTR_HIDDEN_SSID = 126,
	NL80211_ATTR_IE_PROBE_RESP = 127,
	NL80211_ATTR_IE_ASSOC_RESP = 128,
	NL80211_ATTR_STA_WME = 129,
	NL80211_ATTR_SUPPORT_AP_UAPSD = 130,
	NL80211_ATTR_ROAM_SUPPORT = 131,
	NL80211_ATTR_SCHED_SCAN_MATCH = 132,
	NL80211_ATTR_MAX_MATCH_SETS = 133,
	NL80211_ATTR_PMKSA_CANDIDATE = 134,
	NL80211_ATTR_TX_NO_CCK_RATE = 135,
	NL80211_ATTR_TDLS_ACTION = 136,
	NL80211_ATTR_TDLS_DIALOG_TOKEN = 137,
	NL80211_ATTR_TDLS_OPERATION = 138,
	NL80211_ATTR_TDLS_SUPPORT = 139,
	NL80211_ATTR_TDLS_EXTERNAL_SETUP = 140,
	NL80211_ATTR_DEVICE_AP_SME = 141,
	NL80211_ATTR_DONT_WAIT_FOR_ACK = 142,
	NL80211_ATTR_FEATURE_FLAGS = 143,
	NL80211_ATTR_PROBE_RESP_OFFLOAD = 144,
	NL80211_ATTR_PROBE_RESP = 145,
	NL80211_ATTR_DFS_REGION = 146,
	NL80211_ATTR_DISABLE_HT = 147,
	NL80211_ATTR_HT_CAPABILITY_MASK = 148,
	NL80211_ATTR_NOACK_MAP = 149,
	NL80211_ATTR_INACTIVITY_TIMEOUT = 150,
	NL80211_ATTR_RX_SIGNAL_DBM = 151,
	NL80211_ATTR_BG_SCAN_PERIOD = 152,
	NL80211_ATTR_WDEV = 153,
	NL80211_ATTR_USER_REG_HINT_TYPE = 154,
	NL80211_ATTR_CONN_FAILED_REASON = 155,
	NL80211_ATTR_AUTH_DATA = 156,
	NL80211_ATTR_VHT_CAPABILITY = 157,
	NL80211_ATTR_SCAN_FLAGS = 158,
	NL80211_ATTR_CHANNEL_WIDTH = 159,
	NL80211_ATTR_CENTER_FREQ1 = 160,
	NL80211_ATTR_CENTER_FREQ2 = 161,
	NL80211_ATTR_P2P_CTWINDOW = 162,
	NL80211_ATTR_P2P_OPPPS = 163,
	NL80211_ATTR_LOCAL_MESH_POWER_MODE = 164,
	NL80211_ATTR_ACL_POLICY = 165,
	NL80211_ATTR_MAC_ADDRS = 166,
	NL80211_ATTR_MAC_ACL_MAX = 167,
	NL80211_ATTR_RADAR_EVENT = 168,
	NL80211_ATTR_EXT_CAPA = 169,
	NL80211_ATTR_EXT_CAPA_MASK = 170,
	NL80211_ATTR_STA_CAPABILITY = 171,
	NL80211_ATTR_STA_EXT_CAPABILITY = 172,
	NL80211_ATTR_PROTOCOL_FEATURES = 173,
	NL80211_ATTR_SPLIT_WIPHY_DUMP = 174,
	NL80211_ATTR_DISABLE_VHT = 175,
	NL80211_ATTR_VHT_CAPABILITY_MASK = 176,
	NL80211_ATTR_MDID = 177,
	NL80211_ATTR_IE_RIC = 178,
	NL80211_ATTR_CRIT_PROT_ID = 179,
	NL80211_ATTR_MAX_CRIT_PROT_DURATION = 180,
	NL80211_ATTR_PEER_AID = 181,
	NL80211_ATTR_COALESCE_RULE = 182,
	NL80211_ATTR_CH_SWITCH_COUNT = 183,
	NL80211_ATTR_CH_SWITCH_BLOCK_TX = 184,
	NL80211_ATTR_CSA_IES = 185,
	NL80211_ATTR_CNTDWN_OFFS_BEACON = 186,
	NL80211_ATTR_CNTDWN_OFFS_PRESP = 187,
	NL80211_ATTR_RXMGMT_FLAGS = 188,
	NL80211_ATTR_STA_SUPPORTED_CHANNELS = 189,
	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES = 190,
	NL80211_ATTR_HANDLE_DFS = 191,
	NL80211_ATTR_SUPPORT_5_MHZ = 192,
	NL80211_ATTR_SUPPORT_10_MHZ = 193,
	NL80211_ATTR_OPMODE_NOTIF = 194,
	NL80211_ATTR_VENDOR_ID = 195,
	NL80211_ATTR_VENDOR_SUBCMD = 196,
	NL80211_ATTR_VENDOR_DATA = 197,
	NL80211_ATTR_VENDOR_EVENTS = 198,
	NL80211_ATTR_QOS_MAP = 199,
	NL80211_ATTR_MAC_HINT = 200,
	NL80211_ATTR_WIPHY_FREQ_HINT = 201,
	NL80211_ATTR_MAX_AP_ASSOC_STA = 202,
	NL80211_ATTR_TDLS_PEER_CAPABILITY = 203,
	NL80211_ATTR_SOCKET_OWNER = 204,
	NL80211_ATTR_CSA_C_OFFSETS_TX = 205,
	NL80211_ATTR_MAX_CSA_COUNTERS = 206,
	NL80211_ATTR_TDLS_INITIATOR = 207,
	NL80211_ATTR_USE_RRM = 208,
	NL80211_ATTR_WIPHY_DYN_ACK = 209,
	NL80211_ATTR_TSID = 210,
	NL80211_ATTR_USER_PRIO = 211,
	NL80211_ATTR_ADMITTED_TIME = 212,
	NL80211_ATTR_SMPS_MODE = 213,
	NL80211_ATTR_OPER_CLASS = 214,
	NL80211_ATTR_MAC_MASK = 215,
	NL80211_ATTR_WIPHY_SELF_MANAGED_REG = 216,
	NL80211_ATTR_EXT_FEATURES = 217,
	NL80211_ATTR_SURVEY_RADIO_STATS = 218,
	NL80211_ATTR_NETNS_FD = 219,
	NL80211_ATTR_SCHED_SCAN_DELAY = 220,
	NL80211_ATTR_REG_INDOOR = 221,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS = 222,
	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL = 223,
	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS = 224,
	NL80211_ATTR_SCHED_SCAN_PLANS = 225,
	NL80211_ATTR_PBSS = 226,
	NL80211_ATTR_BSS_SELECT = 227,
	NL80211_ATTR_STA_SUPPORT_P2P_PS = 228,
	NL80211_ATTR_PAD = 229,
	NL80211_ATTR_IFTYPE_EXT_CAPA = 230,
	NL80211_ATTR_MU_MIMO_GROUP_DATA = 231,
	NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR = 232,
	NL80211_ATTR_SCAN_START_TIME_TSF = 233,
	NL80211_ATTR_SCAN_START_TIME_TSF_BSSID = 234,
	NL80211_ATTR_MEASUREMENT_DURATION = 235,
	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY = 236,
	NL80211_ATTR_MESH_PEER_AID = 237,
	NL80211_ATTR_NAN_MASTER_PREF = 238,
	NL80211_ATTR_BANDS = 239,
	NL80211_ATTR_NAN_FUNC = 240,
	NL80211_ATTR_NAN_MATCH = 241,
	NL80211_ATTR_FILS_KEK = 242,
	NL80211_ATTR_FILS_NONCES = 243,
	NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED = 244,
	NL80211_ATTR_BSSID = 245,
	NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI = 246,
	NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST = 247,
	NL80211_ATTR_TIMEOUT_REASON = 248,
	NL80211_ATTR_FILS_ERP_USERNAME = 249,
	NL80211_ATTR_FILS_ERP_REALM = 250,
	NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM = 251,
	NL80211_ATTR_FILS_ERP_RRK = 252,
	NL80211_ATTR_FILS_CACHE_ID = 253,
	NL80211_ATTR_PMK = 254,
	NL80211_ATTR_SCHED_SCAN_MULTI = 255,
	NL80211_ATTR_SCHED_SCAN_MAX_REQS = 256,
	NL80211_ATTR_WANT_1X_4WAY_HS = 257,
	NL80211_ATTR_PMKR0_NAME = 258,
	NL80211_ATTR_PORT_AUTHORIZED = 259,
	NL80211_ATTR_EXTERNAL_AUTH_ACTION = 260,
	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT = 261,
	NL80211_ATTR_NSS = 262,
	NL80211_ATTR_ACK_SIGNAL = 263,
	NL80211_ATTR_CONTROL_PORT_OVER_NL80211 = 264,
	NL80211_ATTR_TXQ_STATS = 265,
	NL80211_ATTR_TXQ_LIMIT = 266,
	NL80211_ATTR_TXQ_MEMORY_LIMIT = 267,
	NL80211_ATTR_TXQ_QUANTUM = 268,
	NL80211_ATTR_HE_CAPABILITY = 269,
	NL80211_ATTR_FTM_RESPONDER = 270,
	NL80211_ATTR_FTM_RESPONDER_STATS = 271,
	NL80211_ATTR_TIMEOUT = 272,
	NL80211_ATTR_PEER_MEASUREMENTS = 273,
	NL80211_ATTR_AIRTIME_WEIGHT = 274,
	NL80211_ATTR_STA_TX_POWER_SETTING = 275,
	NL80211_ATTR_STA_TX_POWER = 276,
	NL80211_ATTR_SAE_PASSWORD = 277,
	NL80211_ATTR_TWT_RESPONDER = 278,
	NL80211_ATTR_HE_OBSS_PD = 279,
	NL80211_ATTR_WIPHY_EDMG_CHANNELS = 280,
	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG = 281,
	NL80211_ATTR_VLAN_ID = 282,
	NL80211_ATTR_HE_BSS_COLOR = 283,
	NL80211_ATTR_IFTYPE_AKM_SUITES = 284,
	NL80211_ATTR_TID_CONFIG = 285,
	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH = 286,
	NL80211_ATTR_PMK_LIFETIME = 287,
	NL80211_ATTR_PMK_REAUTH_THRESHOLD = 288,
	NL80211_ATTR_RECEIVE_MULTICAST = 289,
	NL80211_ATTR_WIPHY_FREQ_OFFSET = 290,
	NL80211_ATTR_CENTER_FREQ1_OFFSET = 291,
	NL80211_ATTR_SCAN_FREQ_KHZ = 292,
	NL80211_ATTR_HE_6GHZ_CAPABILITY = 293,
	NL80211_ATTR_FILS_DISCOVERY = 294,
	NL80211_ATTR_UNSOL_BCAST_PROBE_RESP = 295,
	NL80211_ATTR_S1G_CAPABILITY = 296,
	NL80211_ATTR_S1G_CAPABILITY_MASK = 297,
	NL80211_ATTR_SAE_PWE = 298,
	NL80211_ATTR_RECONNECT_REQUESTED = 299,
	NL80211_ATTR_SAR_SPEC = 300,
	__NL80211_ATTR_AFTER_LAST = 301,
	NUM_NL80211_ATTR = 301,
	NL80211_ATTR_MAX = 300,
};

enum nl80211_sta_flags {
	__NL80211_STA_FLAG_INVALID = 0,
	NL80211_STA_FLAG_AUTHORIZED = 1,
	NL80211_STA_FLAG_SHORT_PREAMBLE = 2,
	NL80211_STA_FLAG_WME = 3,
	NL80211_STA_FLAG_MFP = 4,
	NL80211_STA_FLAG_AUTHENTICATED = 5,
	NL80211_STA_FLAG_TDLS_PEER = 6,
	NL80211_STA_FLAG_ASSOCIATED = 7,
	__NL80211_STA_FLAG_AFTER_LAST = 8,
	NL80211_STA_FLAG_MAX = 7,
};

enum nl80211_sta_p2p_ps_status {
	NL80211_P2P_PS_UNSUPPORTED = 0,
	NL80211_P2P_PS_SUPPORTED = 1,
	NUM_NL80211_P2P_PS_STATUS = 2,
};

enum nl80211_rate_info {
	__NL80211_RATE_INFO_INVALID = 0,
	NL80211_RATE_INFO_BITRATE = 1,
	NL80211_RATE_INFO_MCS = 2,
	NL80211_RATE_INFO_40_MHZ_WIDTH = 3,
	NL80211_RATE_INFO_SHORT_GI = 4,
	NL80211_RATE_INFO_BITRATE32 = 5,
	NL80211_RATE_INFO_VHT_MCS = 6,
	NL80211_RATE_INFO_VHT_NSS = 7,
	NL80211_RATE_INFO_80_MHZ_WIDTH = 8,
	NL80211_RATE_INFO_80P80_MHZ_WIDTH = 9,
	NL80211_RATE_INFO_160_MHZ_WIDTH = 10,
	NL80211_RATE_INFO_10_MHZ_WIDTH = 11,
	NL80211_RATE_INFO_5_MHZ_WIDTH = 12,
	NL80211_RATE_INFO_HE_MCS = 13,
	NL80211_RATE_INFO_HE_NSS = 14,
	NL80211_RATE_INFO_HE_GI = 15,
	NL80211_RATE_INFO_HE_DCM = 16,
	NL80211_RATE_INFO_HE_RU_ALLOC = 17,
	__NL80211_RATE_INFO_AFTER_LAST = 18,
	NL80211_RATE_INFO_MAX = 17,
};

enum nl80211_sta_bss_param {
	__NL80211_STA_BSS_PARAM_INVALID = 0,
	NL80211_STA_BSS_PARAM_CTS_PROT = 1,
	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE = 2,
	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME = 3,
	NL80211_STA_BSS_PARAM_DTIM_PERIOD = 4,
	NL80211_STA_BSS_PARAM_BEACON_INTERVAL = 5,
	__NL80211_STA_BSS_PARAM_AFTER_LAST = 6,
	NL80211_STA_BSS_PARAM_MAX = 5,
};

enum nl80211_sta_info {
	__NL80211_STA_INFO_INVALID = 0,
	NL80211_STA_INFO_INACTIVE_TIME = 1,
	NL80211_STA_INFO_RX_BYTES = 2,
	NL80211_STA_INFO_TX_BYTES = 3,
	NL80211_STA_INFO_LLID = 4,
	NL80211_STA_INFO_PLID = 5,
	NL80211_STA_INFO_PLINK_STATE = 6,
	NL80211_STA_INFO_SIGNAL = 7,
	NL80211_STA_INFO_TX_BITRATE = 8,
	NL80211_STA_INFO_RX_PACKETS = 9,
	NL80211_STA_INFO_TX_PACKETS = 10,
	NL80211_STA_INFO_TX_RETRIES = 11,
	NL80211_STA_INFO_TX_FAILED = 12,
	NL80211_STA_INFO_SIGNAL_AVG = 13,
	NL80211_STA_INFO_RX_BITRATE = 14,
	NL80211_STA_INFO_BSS_PARAM = 15,
	NL80211_STA_INFO_CONNECTED_TIME = 16,
	NL80211_STA_INFO_STA_FLAGS = 17,
	NL80211_STA_INFO_BEACON_LOSS = 18,
	NL80211_STA_INFO_T_OFFSET = 19,
	NL80211_STA_INFO_LOCAL_PM = 20,
	NL80211_STA_INFO_PEER_PM = 21,
	NL80211_STA_INFO_NONPEER_PM = 22,
	NL80211_STA_INFO_RX_BYTES64 = 23,
	NL80211_STA_INFO_TX_BYTES64 = 24,
	NL80211_STA_INFO_CHAIN_SIGNAL = 25,
	NL80211_STA_INFO_CHAIN_SIGNAL_AVG = 26,
	NL80211_STA_INFO_EXPECTED_THROUGHPUT = 27,
	NL80211_STA_INFO_RX_DROP_MISC = 28,
	NL80211_STA_INFO_BEACON_RX = 29,
	NL80211_STA_INFO_BEACON_SIGNAL_AVG = 30,
	NL80211_STA_INFO_TID_STATS = 31,
	NL80211_STA_INFO_RX_DURATION = 32,
	NL80211_STA_INFO_PAD = 33,
	NL80211_STA_INFO_ACK_SIGNAL = 34,
	NL80211_STA_INFO_ACK_SIGNAL_AVG = 35,
	NL80211_STA_INFO_RX_MPDUS = 36,
	NL80211_STA_INFO_FCS_ERROR_COUNT = 37,
	NL80211_STA_INFO_CONNECTED_TO_GATE = 38,
	NL80211_STA_INFO_TX_DURATION = 39,
	NL80211_STA_INFO_AIRTIME_WEIGHT = 40,
	NL80211_STA_INFO_AIRTIME_LINK_METRIC = 41,
	NL80211_STA_INFO_ASSOC_AT_BOOTTIME = 42,
	NL80211_STA_INFO_CONNECTED_TO_AS = 43,
	__NL80211_STA_INFO_AFTER_LAST = 44,
	NL80211_STA_INFO_MAX = 43,
};

enum nl80211_tid_stats {
	__NL80211_TID_STATS_INVALID = 0,
	NL80211_TID_STATS_RX_MSDU = 1,
	NL80211_TID_STATS_TX_MSDU = 2,
	NL80211_TID_STATS_TX_MSDU_RETRIES = 3,
	NL80211_TID_STATS_TX_MSDU_FAILED = 4,
	NL80211_TID_STATS_PAD = 5,
	NL80211_TID_STATS_TXQ_STATS = 6,
	NUM_NL80211_TID_STATS = 7,
	NL80211_TID_STATS_MAX = 6,
};

enum nl80211_txq_stats {
	__NL80211_TXQ_STATS_INVALID = 0,
	NL80211_TXQ_STATS_BACKLOG_BYTES = 1,
	NL80211_TXQ_STATS_BACKLOG_PACKETS = 2,
	NL80211_TXQ_STATS_FLOWS = 3,
	NL80211_TXQ_STATS_DROPS = 4,
	NL80211_TXQ_STATS_ECN_MARKS = 5,
	NL80211_TXQ_STATS_OVERLIMIT = 6,
	NL80211_TXQ_STATS_OVERMEMORY = 7,
	NL80211_TXQ_STATS_COLLISIONS = 8,
	NL80211_TXQ_STATS_TX_BYTES = 9,
	NL80211_TXQ_STATS_TX_PACKETS = 10,
	NL80211_TXQ_STATS_MAX_FLOWS = 11,
	NUM_NL80211_TXQ_STATS = 12,
	NL80211_TXQ_STATS_MAX = 11,
};

enum nl80211_mpath_info {
	__NL80211_MPATH_INFO_INVALID = 0,
	NL80211_MPATH_INFO_FRAME_QLEN = 1,
	NL80211_MPATH_INFO_SN = 2,
	NL80211_MPATH_INFO_METRIC = 3,
	NL80211_MPATH_INFO_EXPTIME = 4,
	NL80211_MPATH_INFO_FLAGS = 5,
	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT = 6,
	NL80211_MPATH_INFO_DISCOVERY_RETRIES = 7,
	NL80211_MPATH_INFO_HOP_COUNT = 8,
	NL80211_MPATH_INFO_PATH_CHANGE = 9,
	__NL80211_MPATH_INFO_AFTER_LAST = 10,
	NL80211_MPATH_INFO_MAX = 9,
};

enum nl80211_band_iftype_attr {
	__NL80211_BAND_IFTYPE_ATTR_INVALID = 0,
	NL80211_BAND_IFTYPE_ATTR_IFTYPES = 1,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC = 2,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY = 3,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET = 4,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE = 5,
	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA = 6,
	__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST = 7,
	NL80211_BAND_IFTYPE_ATTR_MAX = 6,
};

enum nl80211_band_attr {
	__NL80211_BAND_ATTR_INVALID = 0,
	NL80211_BAND_ATTR_FREQS = 1,
	NL80211_BAND_ATTR_RATES = 2,
	NL80211_BAND_ATTR_HT_MCS_SET = 3,
	NL80211_BAND_ATTR_HT_CAPA = 4,
	NL80211_BAND_ATTR_HT_AMPDU_FACTOR = 5,
	NL80211_BAND_ATTR_HT_AMPDU_DENSITY = 6,
	NL80211_BAND_ATTR_VHT_MCS_SET = 7,
	NL80211_BAND_ATTR_VHT_CAPA = 8,
	NL80211_BAND_ATTR_IFTYPE_DATA = 9,
	NL80211_BAND_ATTR_EDMG_CHANNELS = 10,
	NL80211_BAND_ATTR_EDMG_BW_CONFIG = 11,
	__NL80211_BAND_ATTR_AFTER_LAST = 12,
	NL80211_BAND_ATTR_MAX = 11,
};

enum nl80211_wmm_rule {
	__NL80211_WMMR_INVALID = 0,
	NL80211_WMMR_CW_MIN = 1,
	NL80211_WMMR_CW_MAX = 2,
	NL80211_WMMR_AIFSN = 3,
	NL80211_WMMR_TXOP = 4,
	__NL80211_WMMR_LAST = 5,
	NL80211_WMMR_MAX = 4,
};

enum nl80211_frequency_attr {
	__NL80211_FREQUENCY_ATTR_INVALID = 0,
	NL80211_FREQUENCY_ATTR_FREQ = 1,
	NL80211_FREQUENCY_ATTR_DISABLED = 2,
	NL80211_FREQUENCY_ATTR_NO_IR = 3,
	__NL80211_FREQUENCY_ATTR_NO_IBSS = 4,
	NL80211_FREQUENCY_ATTR_RADAR = 5,
	NL80211_FREQUENCY_ATTR_MAX_TX_POWER = 6,
	NL80211_FREQUENCY_ATTR_DFS_STATE = 7,
	NL80211_FREQUENCY_ATTR_DFS_TIME = 8,
	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS = 9,
	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS = 10,
	NL80211_FREQUENCY_ATTR_NO_80MHZ = 11,
	NL80211_FREQUENCY_ATTR_NO_160MHZ = 12,
	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME = 13,
	NL80211_FREQUENCY_ATTR_INDOOR_ONLY = 14,
	NL80211_FREQUENCY_ATTR_IR_CONCURRENT = 15,
	NL80211_FREQUENCY_ATTR_NO_20MHZ = 16,
	NL80211_FREQUENCY_ATTR_NO_10MHZ = 17,
	NL80211_FREQUENCY_ATTR_WMM = 18,
	NL80211_FREQUENCY_ATTR_NO_HE = 19,
	NL80211_FREQUENCY_ATTR_OFFSET = 20,
	NL80211_FREQUENCY_ATTR_1MHZ = 21,
	NL80211_FREQUENCY_ATTR_2MHZ = 22,
	NL80211_FREQUENCY_ATTR_4MHZ = 23,
	NL80211_FREQUENCY_ATTR_8MHZ = 24,
	NL80211_FREQUENCY_ATTR_16MHZ = 25,
	__NL80211_FREQUENCY_ATTR_AFTER_LAST = 26,
	NL80211_FREQUENCY_ATTR_MAX = 25,
};

enum nl80211_bitrate_attr {
	__NL80211_BITRATE_ATTR_INVALID = 0,
	NL80211_BITRATE_ATTR_RATE = 1,
	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE = 2,
	__NL80211_BITRATE_ATTR_AFTER_LAST = 3,
	NL80211_BITRATE_ATTR_MAX = 2,
};

enum nl80211_reg_type {
	NL80211_REGDOM_TYPE_COUNTRY = 0,
	NL80211_REGDOM_TYPE_WORLD = 1,
	NL80211_REGDOM_TYPE_CUSTOM_WORLD = 2,
	NL80211_REGDOM_TYPE_INTERSECTION = 3,
};

enum nl80211_reg_rule_attr {
	__NL80211_REG_RULE_ATTR_INVALID = 0,
	NL80211_ATTR_REG_RULE_FLAGS = 1,
	NL80211_ATTR_FREQ_RANGE_START = 2,
	NL80211_ATTR_FREQ_RANGE_END = 3,
	NL80211_ATTR_FREQ_RANGE_MAX_BW = 4,
	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN = 5,
	NL80211_ATTR_POWER_RULE_MAX_EIRP = 6,
	NL80211_ATTR_DFS_CAC_TIME = 7,
	__NL80211_REG_RULE_ATTR_AFTER_LAST = 8,
	NL80211_REG_RULE_ATTR_MAX = 7,
};

enum nl80211_sched_scan_match_attr {
	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID = 0,
	NL80211_SCHED_SCAN_MATCH_ATTR_SSID = 1,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI = 2,
	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI = 3,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST = 4,
	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID = 5,
	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI = 6,
	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST = 7,
	NL80211_SCHED_SCAN_MATCH_ATTR_MAX = 6,
};

enum nl80211_survey_info {
	__NL80211_SURVEY_INFO_INVALID = 0,
	NL80211_SURVEY_INFO_FREQUENCY = 1,
	NL80211_SURVEY_INFO_NOISE = 2,
	NL80211_SURVEY_INFO_IN_USE = 3,
	NL80211_SURVEY_INFO_TIME = 4,
	NL80211_SURVEY_INFO_TIME_BUSY = 5,
	NL80211_SURVEY_INFO_TIME_EXT_BUSY = 6,
	NL80211_SURVEY_INFO_TIME_RX = 7,
	NL80211_SURVEY_INFO_TIME_TX = 8,
	NL80211_SURVEY_INFO_TIME_SCAN = 9,
	NL80211_SURVEY_INFO_PAD = 10,
	NL80211_SURVEY_INFO_TIME_BSS_RX = 11,
	NL80211_SURVEY_INFO_FREQUENCY_OFFSET = 12,
	__NL80211_SURVEY_INFO_AFTER_LAST = 13,
	NL80211_SURVEY_INFO_MAX = 12,
};

enum nl80211_meshconf_params {
	__NL80211_MESHCONF_INVALID = 0,
	NL80211_MESHCONF_RETRY_TIMEOUT = 1,
	NL80211_MESHCONF_CONFIRM_TIMEOUT = 2,
	NL80211_MESHCONF_HOLDING_TIMEOUT = 3,
	NL80211_MESHCONF_MAX_PEER_LINKS = 4,
	NL80211_MESHCONF_MAX_RETRIES = 5,
	NL80211_MESHCONF_TTL = 6,
	NL80211_MESHCONF_AUTO_OPEN_PLINKS = 7,
	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES = 8,
	NL80211_MESHCONF_PATH_REFRESH_TIME = 9,
	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT = 10,
	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT = 11,
	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL = 12,
	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME = 13,
	NL80211_MESHCONF_HWMP_ROOTMODE = 14,
	NL80211_MESHCONF_ELEMENT_TTL = 15,
	NL80211_MESHCONF_HWMP_RANN_INTERVAL = 16,
	NL80211_MESHCONF_GATE_ANNOUNCEMENTS = 17,
	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL = 18,
	NL80211_MESHCONF_FORWARDING = 19,
	NL80211_MESHCONF_RSSI_THRESHOLD = 20,
	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR = 21,
	NL80211_MESHCONF_HT_OPMODE = 22,
	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT = 23,
	NL80211_MESHCONF_HWMP_ROOT_INTERVAL = 24,
	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL = 25,
	NL80211_MESHCONF_POWER_MODE = 26,
	NL80211_MESHCONF_AWAKE_WINDOW = 27,
	NL80211_MESHCONF_PLINK_TIMEOUT = 28,
	NL80211_MESHCONF_CONNECTED_TO_GATE = 29,
	NL80211_MESHCONF_NOLEARN = 30,
	NL80211_MESHCONF_CONNECTED_TO_AS = 31,
	__NL80211_MESHCONF_ATTR_AFTER_LAST = 32,
	NL80211_MESHCONF_ATTR_MAX = 31,
};

enum nl80211_mesh_setup_params {
	__NL80211_MESH_SETUP_INVALID = 0,
	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL = 1,
	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC = 2,
	NL80211_MESH_SETUP_IE = 3,
	NL80211_MESH_SETUP_USERSPACE_AUTH = 4,
	NL80211_MESH_SETUP_USERSPACE_AMPE = 5,
	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC = 6,
	NL80211_MESH_SETUP_USERSPACE_MPM = 7,
	NL80211_MESH_SETUP_AUTH_PROTOCOL = 8,
	__NL80211_MESH_SETUP_ATTR_AFTER_LAST = 9,
	NL80211_MESH_SETUP_ATTR_MAX = 8,
};

enum nl80211_txq_attr {
	__NL80211_TXQ_ATTR_INVALID = 0,
	NL80211_TXQ_ATTR_AC = 1,
	NL80211_TXQ_ATTR_TXOP = 2,
	NL80211_TXQ_ATTR_CWMIN = 3,
	NL80211_TXQ_ATTR_CWMAX = 4,
	NL80211_TXQ_ATTR_AIFS = 5,
	__NL80211_TXQ_ATTR_AFTER_LAST = 6,
	NL80211_TXQ_ATTR_MAX = 5,
};

enum nl80211_bss {
	__NL80211_BSS_INVALID = 0,
	NL80211_BSS_BSSID = 1,
	NL80211_BSS_FREQUENCY = 2,
	NL80211_BSS_TSF = 3,
	NL80211_BSS_BEACON_INTERVAL = 4,
	NL80211_BSS_CAPABILITY = 5,
	NL80211_BSS_INFORMATION_ELEMENTS = 6,
	NL80211_BSS_SIGNAL_MBM = 7,
	NL80211_BSS_SIGNAL_UNSPEC = 8,
	NL80211_BSS_STATUS = 9,
	NL80211_BSS_SEEN_MS_AGO = 10,
	NL80211_BSS_BEACON_IES = 11,
	NL80211_BSS_CHAN_WIDTH = 12,
	NL80211_BSS_BEACON_TSF = 13,
	NL80211_BSS_PRESP_DATA = 14,
	NL80211_BSS_LAST_SEEN_BOOTTIME = 15,
	NL80211_BSS_PAD = 16,
	NL80211_BSS_PARENT_TSF = 17,
	NL80211_BSS_PARENT_BSSID = 18,
	NL80211_BSS_CHAIN_SIGNAL = 19,
	NL80211_BSS_FREQUENCY_OFFSET = 20,
	__NL80211_BSS_AFTER_LAST = 21,
	NL80211_BSS_MAX = 20,
};

enum nl80211_bss_status {
	NL80211_BSS_STATUS_AUTHENTICATED = 0,
	NL80211_BSS_STATUS_ASSOCIATED = 1,
	NL80211_BSS_STATUS_IBSS_JOINED = 2,
};

enum nl80211_key_type {
	NL80211_KEYTYPE_GROUP = 0,
	NL80211_KEYTYPE_PAIRWISE = 1,
	NL80211_KEYTYPE_PEERKEY = 2,
	NUM_NL80211_KEYTYPES = 3,
};

enum nl80211_wpa_versions {
	NL80211_WPA_VERSION_1 = 1,
	NL80211_WPA_VERSION_2 = 2,
	NL80211_WPA_VERSION_3 = 4,
};

enum nl80211_key_default_types {
	__NL80211_KEY_DEFAULT_TYPE_INVALID = 0,
	NL80211_KEY_DEFAULT_TYPE_UNICAST = 1,
	NL80211_KEY_DEFAULT_TYPE_MULTICAST = 2,
	NUM_NL80211_KEY_DEFAULT_TYPES = 3,
};

enum nl80211_key_attributes {
	__NL80211_KEY_INVALID = 0,
	NL80211_KEY_DATA = 1,
	NL80211_KEY_IDX = 2,
	NL80211_KEY_CIPHER = 3,
	NL80211_KEY_SEQ = 4,
	NL80211_KEY_DEFAULT = 5,
	NL80211_KEY_DEFAULT_MGMT = 6,
	NL80211_KEY_TYPE = 7,
	NL80211_KEY_DEFAULT_TYPES = 8,
	NL80211_KEY_MODE = 9,
	NL80211_KEY_DEFAULT_BEACON = 10,
	__NL80211_KEY_AFTER_LAST = 11,
	NL80211_KEY_MAX = 10,
};

enum nl80211_tx_rate_attributes {
	__NL80211_TXRATE_INVALID = 0,
	NL80211_TXRATE_LEGACY = 1,
	NL80211_TXRATE_HT = 2,
	NL80211_TXRATE_VHT = 3,
	NL80211_TXRATE_GI = 4,
	NL80211_TXRATE_HE = 5,
	NL80211_TXRATE_HE_GI = 6,
	NL80211_TXRATE_HE_LTF = 7,
	__NL80211_TXRATE_AFTER_LAST = 8,
	NL80211_TXRATE_MAX = 7,
};

struct nl80211_txrate_vht {
	__u16 mcs[8];
};

struct nl80211_txrate_he {
	__u16 mcs[8];
};

enum nl80211_ps_state {
	NL80211_PS_DISABLED = 0,
	NL80211_PS_ENABLED = 1,
};

enum nl80211_attr_cqm {
	__NL80211_ATTR_CQM_INVALID = 0,
	NL80211_ATTR_CQM_RSSI_THOLD = 1,
	NL80211_ATTR_CQM_RSSI_HYST = 2,
	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT = 3,
	NL80211_ATTR_CQM_PKT_LOSS_EVENT = 4,
	NL80211_ATTR_CQM_TXE_RATE = 5,
	NL80211_ATTR_CQM_TXE_PKTS = 6,
	NL80211_ATTR_CQM_TXE_INTVL = 7,
	NL80211_ATTR_CQM_BEACON_LOSS_EVENT = 8,
	NL80211_ATTR_CQM_RSSI_LEVEL = 9,
	__NL80211_ATTR_CQM_AFTER_LAST = 10,
	NL80211_ATTR_CQM_MAX = 9,
};

enum nl80211_cqm_rssi_threshold_event {
	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW = 0,
	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH = 1,
	NL80211_CQM_RSSI_BEACON_LOSS_EVENT = 2,
};

enum nl80211_tid_config_attr {
	__NL80211_TID_CONFIG_ATTR_INVALID = 0,
	NL80211_TID_CONFIG_ATTR_PAD = 1,
	NL80211_TID_CONFIG_ATTR_VIF_SUPP = 2,
	NL80211_TID_CONFIG_ATTR_PEER_SUPP = 3,
	NL80211_TID_CONFIG_ATTR_OVERRIDE = 4,
	NL80211_TID_CONFIG_ATTR_TIDS = 5,
	NL80211_TID_CONFIG_ATTR_NOACK = 6,
	NL80211_TID_CONFIG_ATTR_RETRY_SHORT = 7,
	NL80211_TID_CONFIG_ATTR_RETRY_LONG = 8,
	NL80211_TID_CONFIG_ATTR_AMPDU_CTRL = 9,
	NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL = 10,
	NL80211_TID_CONFIG_ATTR_AMSDU_CTRL = 11,
	NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE = 12,
	NL80211_TID_CONFIG_ATTR_TX_RATE = 13,
	__NL80211_TID_CONFIG_ATTR_AFTER_LAST = 14,
	NL80211_TID_CONFIG_ATTR_MAX = 13,
};

enum nl80211_packet_pattern_attr {
	__NL80211_PKTPAT_INVALID = 0,
	NL80211_PKTPAT_MASK = 1,
	NL80211_PKTPAT_PATTERN = 2,
	NL80211_PKTPAT_OFFSET = 3,
	NUM_NL80211_PKTPAT = 4,
	MAX_NL80211_PKTPAT = 3,
};

struct nl80211_pattern_support {
	__u32 max_patterns;
	__u32 min_pattern_len;
	__u32 max_pattern_len;
	__u32 max_pkt_offset;
};

enum nl80211_wowlan_triggers {
	__NL80211_WOWLAN_TRIG_INVALID = 0,
	NL80211_WOWLAN_TRIG_ANY = 1,
	NL80211_WOWLAN_TRIG_DISCONNECT = 2,
	NL80211_WOWLAN_TRIG_MAGIC_PKT = 3,
	NL80211_WOWLAN_TRIG_PKT_PATTERN = 4,
	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED = 5,
	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE = 6,
	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST = 7,
	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE = 8,
	NL80211_WOWLAN_TRIG_RFKILL_RELEASE = 9,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211 = 10,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN = 11,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023 = 12,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN = 13,
	NL80211_WOWLAN_TRIG_TCP_CONNECTION = 14,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH = 15,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST = 16,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS = 17,
	NL80211_WOWLAN_TRIG_NET_DETECT = 18,
	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS = 19,
	NUM_NL80211_WOWLAN_TRIG = 20,
	MAX_NL80211_WOWLAN_TRIG = 19,
};

enum nl80211_wowlan_tcp_attrs {
	__NL80211_WOWLAN_TCP_INVALID = 0,
	NL80211_WOWLAN_TCP_SRC_IPV4 = 1,
	NL80211_WOWLAN_TCP_DST_IPV4 = 2,
	NL80211_WOWLAN_TCP_DST_MAC = 3,
	NL80211_WOWLAN_TCP_SRC_PORT = 4,
	NL80211_WOWLAN_TCP_DST_PORT = 5,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD = 6,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ = 7,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN = 8,
	NL80211_WOWLAN_TCP_DATA_INTERVAL = 9,
	NL80211_WOWLAN_TCP_WAKE_PAYLOAD = 10,
	NL80211_WOWLAN_TCP_WAKE_MASK = 11,
	NUM_NL80211_WOWLAN_TCP = 12,
	MAX_NL80211_WOWLAN_TCP = 11,
};

struct nl80211_coalesce_rule_support {
	__u32 max_rules;
	struct nl80211_pattern_support pat;
	__u32 max_delay;
};

enum nl80211_attr_coalesce_rule {
	__NL80211_COALESCE_RULE_INVALID = 0,
	NL80211_ATTR_COALESCE_RULE_DELAY = 1,
	NL80211_ATTR_COALESCE_RULE_CONDITION = 2,
	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN = 3,
	NUM_NL80211_ATTR_COALESCE_RULE = 4,
	NL80211_ATTR_COALESCE_RULE_MAX = 3,
};

enum nl80211_iface_limit_attrs {
	NL80211_IFACE_LIMIT_UNSPEC = 0,
	NL80211_IFACE_LIMIT_MAX = 1,
	NL80211_IFACE_LIMIT_TYPES = 2,
	NUM_NL80211_IFACE_LIMIT = 3,
	MAX_NL80211_IFACE_LIMIT = 2,
};

enum nl80211_if_combination_attrs {
	NL80211_IFACE_COMB_UNSPEC = 0,
	NL80211_IFACE_COMB_LIMITS = 1,
	NL80211_IFACE_COMB_MAXNUM = 2,
	NL80211_IFACE_COMB_STA_AP_BI_MATCH = 3,
	NL80211_IFACE_COMB_NUM_CHANNELS = 4,
	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS = 5,
	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS = 6,
	NL80211_IFACE_COMB_BI_MIN_GCD = 7,
	NUM_NL80211_IFACE_COMB = 8,
	MAX_NL80211_IFACE_COMB = 7,
};

enum nl80211_plink_state {
	NL80211_PLINK_LISTEN = 0,
	NL80211_PLINK_OPN_SNT = 1,
	NL80211_PLINK_OPN_RCVD = 2,
	NL80211_PLINK_CNF_RCVD = 3,
	NL80211_PLINK_ESTAB = 4,
	NL80211_PLINK_HOLDING = 5,
	NL80211_PLINK_BLOCKED = 6,
	NUM_NL80211_PLINK_STATES = 7,
	MAX_NL80211_PLINK_STATES = 6,
};

enum plink_actions {
	NL80211_PLINK_ACTION_NO_ACTION = 0,
	NL80211_PLINK_ACTION_OPEN = 1,
	NL80211_PLINK_ACTION_BLOCK = 2,
	NUM_NL80211_PLINK_ACTIONS = 3,
};

enum nl80211_rekey_data {
	__NL80211_REKEY_DATA_INVALID = 0,
	NL80211_REKEY_DATA_KEK = 1,
	NL80211_REKEY_DATA_KCK = 2,
	NL80211_REKEY_DATA_REPLAY_CTR = 3,
	NL80211_REKEY_DATA_AKM = 4,
	NUM_NL80211_REKEY_DATA = 5,
	MAX_NL80211_REKEY_DATA = 4,
};

enum nl80211_sta_wme_attr {
	__NL80211_STA_WME_INVALID = 0,
	NL80211_STA_WME_UAPSD_QUEUES = 1,
	NL80211_STA_WME_MAX_SP = 2,
	__NL80211_STA_WME_AFTER_LAST = 3,
	NL80211_STA_WME_MAX = 2,
};

enum nl80211_pmksa_candidate_attr {
	__NL80211_PMKSA_CANDIDATE_INVALID = 0,
	NL80211_PMKSA_CANDIDATE_INDEX = 1,
	NL80211_PMKSA_CANDIDATE_BSSID = 2,
	NL80211_PMKSA_CANDIDATE_PREAUTH = 3,
	NUM_NL80211_PMKSA_CANDIDATE = 4,
	MAX_NL80211_PMKSA_CANDIDATE = 3,
};

enum nl80211_connect_failed_reason {
	NL80211_CONN_FAIL_MAX_CLIENTS = 0,
	NL80211_CONN_FAIL_BLOCKED_CLIENT = 1,
};

enum nl80211_protocol_features {
	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP = 1,
};

enum nl80211_sched_scan_plan {
	__NL80211_SCHED_SCAN_PLAN_INVALID = 0,
	NL80211_SCHED_SCAN_PLAN_INTERVAL = 1,
	NL80211_SCHED_SCAN_PLAN_ITERATIONS = 2,
	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST = 3,
	NL80211_SCHED_SCAN_PLAN_MAX = 2,
};

struct nl80211_bss_select_rssi_adjust {
	__u8 band;
	__s8 delta;
};

enum nl80211_nan_publish_type {
	NL80211_NAN_SOLICITED_PUBLISH = 1,
	NL80211_NAN_UNSOLICITED_PUBLISH = 2,
};

enum nl80211_nan_func_term_reason {
	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST = 0,
	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED = 1,
	NL80211_NAN_FUNC_TERM_REASON_ERROR = 2,
};

enum nl80211_nan_func_attributes {
	__NL80211_NAN_FUNC_INVALID = 0,
	NL80211_NAN_FUNC_TYPE = 1,
	NL80211_NAN_FUNC_SERVICE_ID = 2,
	NL80211_NAN_FUNC_PUBLISH_TYPE = 3,
	NL80211_NAN_FUNC_PUBLISH_BCAST = 4,
	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE = 5,
	NL80211_NAN_FUNC_FOLLOW_UP_ID = 6,
	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID = 7,
	NL80211_NAN_FUNC_FOLLOW_UP_DEST = 8,
	NL80211_NAN_FUNC_CLOSE_RANGE = 9,
	NL80211_NAN_FUNC_TTL = 10,
	NL80211_NAN_FUNC_SERVICE_INFO = 11,
	NL80211_NAN_FUNC_SRF = 12,
	NL80211_NAN_FUNC_RX_MATCH_FILTER = 13,
	NL80211_NAN_FUNC_TX_MATCH_FILTER = 14,
	NL80211_NAN_FUNC_INSTANCE_ID = 15,
	NL80211_NAN_FUNC_TERM_REASON = 16,
	NUM_NL80211_NAN_FUNC_ATTR = 17,
	NL80211_NAN_FUNC_ATTR_MAX = 16,
};

enum nl80211_nan_srf_attributes {
	__NL80211_NAN_SRF_INVALID = 0,
	NL80211_NAN_SRF_INCLUDE = 1,
	NL80211_NAN_SRF_BF = 2,
	NL80211_NAN_SRF_BF_IDX = 3,
	NL80211_NAN_SRF_MAC_ADDRS = 4,
	NUM_NL80211_NAN_SRF_ATTR = 5,
	NL80211_NAN_SRF_ATTR_MAX = 4,
};

enum nl80211_nan_match_attributes {
	__NL80211_NAN_MATCH_INVALID = 0,
	NL80211_NAN_MATCH_FUNC_LOCAL = 1,
	NL80211_NAN_MATCH_FUNC_PEER = 2,
	NUM_NL80211_NAN_MATCH_ATTR = 3,
	NL80211_NAN_MATCH_ATTR_MAX = 2,
};

enum nl80211_ftm_responder_attributes {
	__NL80211_FTM_RESP_ATTR_INVALID = 0,
	NL80211_FTM_RESP_ATTR_ENABLED = 1,
	NL80211_FTM_RESP_ATTR_LCI = 2,
	NL80211_FTM_RESP_ATTR_CIVICLOC = 3,
	__NL80211_FTM_RESP_ATTR_LAST = 4,
	NL80211_FTM_RESP_ATTR_MAX = 3,
};

enum nl80211_ftm_responder_stats {
	__NL80211_FTM_STATS_INVALID = 0,
	NL80211_FTM_STATS_SUCCESS_NUM = 1,
	NL80211_FTM_STATS_PARTIAL_NUM = 2,
	NL80211_FTM_STATS_FAILED_NUM = 3,
	NL80211_FTM_STATS_ASAP_NUM = 4,
	NL80211_FTM_STATS_NON_ASAP_NUM = 5,
	NL80211_FTM_STATS_TOTAL_DURATION_MSEC = 6,
	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM = 7,
	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM = 8,
	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM = 9,
	NL80211_FTM_STATS_PAD = 10,
	__NL80211_FTM_STATS_AFTER_LAST = 11,
	NL80211_FTM_STATS_MAX = 10,
};

enum nl80211_peer_measurement_type {
	NL80211_PMSR_TYPE_INVALID = 0,
	NL80211_PMSR_TYPE_FTM = 1,
	NUM_NL80211_PMSR_TYPES = 2,
	NL80211_PMSR_TYPE_MAX = 1,
};

enum nl80211_peer_measurement_req {
	__NL80211_PMSR_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_REQ_ATTR_DATA = 1,
	NL80211_PMSR_REQ_ATTR_GET_AP_TSF = 2,
	NUM_NL80211_PMSR_REQ_ATTRS = 3,
	NL80211_PMSR_REQ_ATTR_MAX = 2,
};

enum nl80211_peer_measurement_peer_attrs {
	__NL80211_PMSR_PEER_ATTR_INVALID = 0,
	NL80211_PMSR_PEER_ATTR_ADDR = 1,
	NL80211_PMSR_PEER_ATTR_CHAN = 2,
	NL80211_PMSR_PEER_ATTR_REQ = 3,
	NL80211_PMSR_PEER_ATTR_RESP = 4,
	NUM_NL80211_PMSR_PEER_ATTRS = 5,
	NL80211_PMSR_PEER_ATTR_MAX = 4,
};

enum nl80211_peer_measurement_attrs {
	__NL80211_PMSR_ATTR_INVALID = 0,
	NL80211_PMSR_ATTR_MAX_PEERS = 1,
	NL80211_PMSR_ATTR_REPORT_AP_TSF = 2,
	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR = 3,
	NL80211_PMSR_ATTR_TYPE_CAPA = 4,
	NL80211_PMSR_ATTR_PEERS = 5,
	NUM_NL80211_PMSR_ATTR = 6,
	NL80211_PMSR_ATTR_MAX = 5,
};

enum nl80211_peer_measurement_ftm_capa {
	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_CAPA_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP = 2,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI = 3,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC = 4,
	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES = 5,
	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS = 6,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT = 7,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED = 9,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED = 10,
	NUM_NL80211_PMSR_FTM_CAPA_ATTR = 11,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX = 10,
};

enum nl80211_peer_measurement_ftm_req {
	__NL80211_PMSR_FTM_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_REQ_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE = 2,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP = 3,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD = 4,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION = 5,
	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST = 6,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES = 7,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI = 8,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC = 9,
	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED = 10,
	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED = 11,
	NUM_NL80211_PMSR_FTM_REQ_ATTR = 12,
	NL80211_PMSR_FTM_REQ_ATTR_MAX = 11,
};

enum nl80211_obss_pd_attributes {
	__NL80211_HE_OBSS_PD_ATTR_INVALID = 0,
	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET = 1,
	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET = 2,
	NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET = 3,
	NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP = 4,
	NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP = 5,
	NL80211_HE_OBSS_PD_ATTR_SR_CTRL = 6,
	__NL80211_HE_OBSS_PD_ATTR_LAST = 7,
	NL80211_HE_OBSS_PD_ATTR_MAX = 6,
};

enum nl80211_bss_color_attributes {
	__NL80211_HE_BSS_COLOR_ATTR_INVALID = 0,
	NL80211_HE_BSS_COLOR_ATTR_COLOR = 1,
	NL80211_HE_BSS_COLOR_ATTR_DISABLED = 2,
	NL80211_HE_BSS_COLOR_ATTR_PARTIAL = 3,
	__NL80211_HE_BSS_COLOR_ATTR_LAST = 4,
	NL80211_HE_BSS_COLOR_ATTR_MAX = 3,
};

enum nl80211_iftype_akm_attributes {
	__NL80211_IFTYPE_AKM_ATTR_INVALID = 0,
	NL80211_IFTYPE_AKM_ATTR_IFTYPES = 1,
	NL80211_IFTYPE_AKM_ATTR_SUITES = 2,
	__NL80211_IFTYPE_AKM_ATTR_LAST = 3,
	NL80211_IFTYPE_AKM_ATTR_MAX = 2,
};

enum nl80211_fils_discovery_attributes {
	__NL80211_FILS_DISCOVERY_ATTR_INVALID = 0,
	NL80211_FILS_DISCOVERY_ATTR_INT_MIN = 1,
	NL80211_FILS_DISCOVERY_ATTR_INT_MAX = 2,
	NL80211_FILS_DISCOVERY_ATTR_TMPL = 3,
	__NL80211_FILS_DISCOVERY_ATTR_LAST = 4,
	NL80211_FILS_DISCOVERY_ATTR_MAX = 3,
};

enum nl80211_unsol_bcast_probe_resp_attributes {
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID = 0,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT = 1,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL = 2,
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST = 3,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX = 2,
};

enum nl80211_sar_attrs {
	__NL80211_SAR_ATTR_INVALID = 0,
	NL80211_SAR_ATTR_TYPE = 1,
	NL80211_SAR_ATTR_SPECS = 2,
	__NL80211_SAR_ATTR_LAST = 3,
	NL80211_SAR_ATTR_MAX = 2,
};

enum nl80211_sar_specs_attrs {
	__NL80211_SAR_ATTR_SPECS_INVALID = 0,
	NL80211_SAR_ATTR_SPECS_POWER = 1,
	NL80211_SAR_ATTR_SPECS_RANGE_INDEX = 2,
	NL80211_SAR_ATTR_SPECS_START_FREQ = 3,
	NL80211_SAR_ATTR_SPECS_END_FREQ = 4,
	__NL80211_SAR_ATTR_SPECS_LAST = 5,
	NL80211_SAR_ATTR_SPECS_MAX = 4,
};

enum survey_info_flags {
	SURVEY_INFO_NOISE_DBM = 1,
	SURVEY_INFO_IN_USE = 2,
	SURVEY_INFO_TIME = 4,
	SURVEY_INFO_TIME_BUSY = 8,
	SURVEY_INFO_TIME_EXT_BUSY = 16,
	SURVEY_INFO_TIME_RX = 32,
	SURVEY_INFO_TIME_TX = 64,
	SURVEY_INFO_TIME_SCAN = 128,
	SURVEY_INFO_TIME_BSS_RX = 256,
};

enum cfg80211_ap_settings_flags {
	AP_SETTINGS_EXTERNAL_AUTH_SUPPORT = 1,
};

enum station_parameters_apply_mask {
	STATION_PARAM_APPLY_UAPSD = 1,
	STATION_PARAM_APPLY_CAPABILITY = 2,
	STATION_PARAM_APPLY_PLINK_STATE = 4,
	STATION_PARAM_APPLY_STA_TXPOWER = 8,
};

enum cfg80211_station_type {
	CFG80211_STA_AP_CLIENT = 0,
	CFG80211_STA_AP_CLIENT_UNASSOC = 1,
	CFG80211_STA_AP_MLME_CLIENT = 2,
	CFG80211_STA_AP_STA = 3,
	CFG80211_STA_IBSS = 4,
	CFG80211_STA_TDLS_PEER_SETUP = 5,
	CFG80211_STA_TDLS_PEER_ACTIVE = 6,
	CFG80211_STA_MESH_PEER_KERNEL = 7,
	CFG80211_STA_MESH_PEER_USER = 8,
};

enum bss_param_flags {
	BSS_PARAM_FLAGS_CTS_PROT = 1,
	BSS_PARAM_FLAGS_SHORT_PREAMBLE = 2,
	BSS_PARAM_FLAGS_SHORT_SLOT_TIME = 4,
};

enum monitor_flags {
	MONITOR_FLAG_CHANGED = 1,
	MONITOR_FLAG_FCSFAIL = 2,
	MONITOR_FLAG_PLCPFAIL = 4,
	MONITOR_FLAG_CONTROL = 8,
	MONITOR_FLAG_OTHER_BSS = 16,
	MONITOR_FLAG_COOK_FRAMES = 32,
	MONITOR_FLAG_ACTIVE = 64,
};

enum mpath_info_flags {
	MPATH_INFO_FRAME_QLEN = 1,
	MPATH_INFO_SN = 2,
	MPATH_INFO_METRIC = 4,
	MPATH_INFO_EXPTIME = 8,
	MPATH_INFO_DISCOVERY_TIMEOUT = 16,
	MPATH_INFO_DISCOVERY_RETRIES = 32,
	MPATH_INFO_FLAGS = 64,
	MPATH_INFO_HOP_COUNT = 128,
	MPATH_INFO_PATH_CHANGE = 256,
};

enum cfg80211_assoc_req_flags {
	ASSOC_REQ_DISABLE_HT = 1,
	ASSOC_REQ_DISABLE_VHT = 2,
	ASSOC_REQ_USE_RRM = 4,
	CONNECT_REQ_EXTERNAL_AUTH_SUPPORT = 8,
};

enum cfg80211_connect_params_changed {
	UPDATE_ASSOC_IES = 1,
	UPDATE_FILS_ERP_INFO = 2,
	UPDATE_AUTH_TYPE = 4,
};

enum wiphy_params_flags {
	WIPHY_PARAM_RETRY_SHORT = 1,
	WIPHY_PARAM_RETRY_LONG = 2,
	WIPHY_PARAM_FRAG_THRESHOLD = 4,
	WIPHY_PARAM_RTS_THRESHOLD = 8,
	WIPHY_PARAM_COVERAGE_CLASS = 16,
	WIPHY_PARAM_DYN_ACK = 32,
	WIPHY_PARAM_TXQ_LIMIT = 64,
	WIPHY_PARAM_TXQ_MEMORY_LIMIT = 128,
	WIPHY_PARAM_TXQ_QUANTUM = 256,
};

struct cfg80211_wowlan_nd_match {
	struct cfg80211_ssid ssid;
	int n_channels;
	u32 channels[0];
};

struct cfg80211_wowlan_nd_info {
	int n_matches;
	struct cfg80211_wowlan_nd_match *matches[0];
};

struct cfg80211_wowlan_wakeup {
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool packet_80211;
	bool tcp_match;
	bool tcp_connlost;
	bool tcp_nomoretokens;
	s32 pattern_idx;
	u32 packet_present_len;
	u32 packet_len;
	const void *packet;
	struct cfg80211_wowlan_nd_info *net_detect;
};

enum cfg80211_nan_conf_changes {
	CFG80211_NAN_CONF_CHANGED_PREF = 1,
	CFG80211_NAN_CONF_CHANGED_BANDS = 2,
};

enum wiphy_vendor_command_flags {
	WIPHY_VENDOR_CMD_NEED_WDEV = 1,
	WIPHY_VENDOR_CMD_NEED_NETDEV = 2,
	WIPHY_VENDOR_CMD_NEED_RUNNING = 4,
};

enum wiphy_opmode_flag {
	STA_OPMODE_MAX_BW_CHANGED = 1,
	STA_OPMODE_SMPS_MODE_CHANGED = 2,
	STA_OPMODE_N_SS_CHANGED = 4,
};

struct sta_opmode_info {
	u32 changed;
	enum nl80211_smps_mode smps_mode;
	enum nl80211_chan_width bw;
	u8 rx_nss;
};

struct cfg80211_ft_event_params {
	const u8 *ies;
	size_t ies_len;
	const u8 *target_ap;
	const u8 *ric_ies;
	size_t ric_ies_len;
};

struct cfg80211_nan_match_params {
	enum nl80211_nan_function_type type;
	u8 inst_id;
	u8 peer_inst_id;
	const u8 *addr;
	u8 info_len;
	const u8 *info;
	int: 32;
	u64 cookie;
};

enum nl80211_multicast_groups {
	NL80211_MCGRP_CONFIG = 0,
	NL80211_MCGRP_SCAN = 1,
	NL80211_MCGRP_REGULATORY = 2,
	NL80211_MCGRP_MLME = 3,
	NL80211_MCGRP_VENDOR = 4,
	NL80211_MCGRP_NAN = 5,
	NL80211_MCGRP_TESTMODE = 6,
};

struct key_parse {
	struct key_params p;
	int idx;
	int type;
	bool def;
	bool defmgmt;
	bool defbeacon;
	bool def_uni;
	bool def_multi;
};

struct nl80211_dump_wiphy_state {
	s64 filter_wiphy;
	long int start;
	long int split_start;
	long int band_start;
	long int chan_start;
	long int capa_start;
	bool split;
};

struct get_key_cookie {
	struct sk_buff *msg;
	int error;
	int idx;
};

enum ieee80211_category {
	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	WLAN_CATEGORY_QOS = 1,
	WLAN_CATEGORY_DLS = 2,
	WLAN_CATEGORY_BACK = 3,
	WLAN_CATEGORY_PUBLIC = 4,
	WLAN_CATEGORY_RADIO_MEASUREMENT = 5,
	WLAN_CATEGORY_HT = 7,
	WLAN_CATEGORY_SA_QUERY = 8,
	WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION = 9,
	WLAN_CATEGORY_WNM = 10,
	WLAN_CATEGORY_WNM_UNPROTECTED = 11,
	WLAN_CATEGORY_TDLS = 12,
	WLAN_CATEGORY_MESH_ACTION = 13,
	WLAN_CATEGORY_MULTIHOP_ACTION = 14,
	WLAN_CATEGORY_SELF_PROTECTED = 15,
	WLAN_CATEGORY_DMG = 16,
	WLAN_CATEGORY_WMM = 17,
	WLAN_CATEGORY_FST = 18,
	WLAN_CATEGORY_UNPROT_DMG = 20,
	WLAN_CATEGORY_VHT = 21,
	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
};

struct cfg80211_mgmt_registration {
	struct list_head list;
	struct wireless_dev *wdev;
	u32 nlportid;
	int match_len;
	__le16 frame_type;
	bool multicast_rx;
	u8 match[0];
};

struct cfg80211_conn {
	struct cfg80211_connect_params params;
	enum {
		CFG80211_CONN_SCANNING = 0,
		CFG80211_CONN_SCAN_AGAIN = 1,
		CFG80211_CONN_AUTHENTICATE_NEXT = 2,
		CFG80211_CONN_AUTHENTICATING = 3,
		CFG80211_CONN_AUTH_FAILED_TIMEOUT = 4,
		CFG80211_CONN_ASSOCIATE_NEXT = 5,
		CFG80211_CONN_ASSOCIATING = 6,
		CFG80211_CONN_ASSOC_FAILED = 7,
		CFG80211_CONN_ASSOC_FAILED_TIMEOUT = 8,
		CFG80211_CONN_DEAUTH = 9,
		CFG80211_CONN_ABANDON = 10,
		CFG80211_CONN_CONNECTED = 11,
	} state;
	u8 bssid[6];
	u8 prev_bssid[6];
	const u8 *ie;
	size_t ie_len;
	bool auto_auth;
	bool prev_bssid_valid;
};

enum cfg80211_chan_mode {
	CHAN_MODE_UNDEFINED = 0,
	CHAN_MODE_SHARED = 1,
	CHAN_MODE_EXCLUSIVE = 2,
};

struct trace_event_raw_rdev_suspend {
	struct trace_entry ent;
	char wiphy_name[32];
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool valid_wow;
	char __data[0];
};

struct trace_event_raw_rdev_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_scan {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_enabled_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_add_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 __data_loc_vir_intf_name;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_cookie_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	int: 32;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_change_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_key_handle {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	u8 key_index;
	bool pairwise;
	char __data[0];
};

struct trace_event_raw_rdev_add_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	u8 key_index;
	bool pairwise;
	u8 mode;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	bool unicast;
	bool multicast;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_mgmt_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_beacon_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	int beacon_interval;
	int dtim_period;
	char ssid[33];
	enum nl80211_hidden_ssid hidden_ssid;
	u32 wpa_ver;
	bool privacy;
	enum nl80211_auth_type auth_type;
	int inactivity_timeout;
	char __data[0];
};

struct trace_event_raw_rdev_change_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_head;
	u32 __data_loc_tail;
	u32 __data_loc_beacon_ies;
	u32 __data_loc_proberesp_ies;
	u32 __data_loc_assocresp_ies;
	u32 __data_loc_probe_resp;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_station_add_change {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 capability;
	u16 aid;
	u8 plink_action;
	u8 plink_state;
	u8 uapsd_queues;
	u8 max_sp;
	u8 opmode_notif;
	bool opmode_notif_used;
	u8 ht_capa[26];
	u8 vht_capa[12];
	char vlan[16];
	u32 __data_loc_supported_rates;
	u32 __data_loc_ext_capab;
	u32 __data_loc_supported_channels;
	u32 __data_loc_supported_oper_classes;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_mac_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	char __data[0];
};

struct trace_event_raw_station_del {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u8 subtype;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_dump_station {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_station_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_mpath_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpath {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_get_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mpath_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_update_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	u32 mask;
	char __data[0];
};

struct trace_event_raw_rdev_join_mesh {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	char __data[0];
};

struct trace_event_raw_rdev_change_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	int ap_isolate;
	int ht_opmode;
	char __data[0];
};

struct trace_event_raw_rdev_set_txq_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
	char __data[0];
};

struct trace_event_raw_rdev_libertas_set_mesh_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_rdev_set_monitor_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_auth_type auth_type;
	char __data[0];
};

struct trace_event_raw_rdev_assoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 prev_bssid[6];
	bool use_mfp;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_rdev_deauth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_disassoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	bool local_state_change;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx_cancel_wait {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	int: 32;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_set_power_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	int timeout;
	char __data[0];
};

struct trace_event_raw_rdev_connect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	enum nl80211_auth_type auth_type;
	bool privacy;
	u32 wpa_versions;
	u32 flags;
	u8 prev_bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_update_connect_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_thold;
	u32 rssi_hyst;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_range_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_low;
	s32 rssi_high;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_txe_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 rate;
	u32 pkts;
	u32 intvl;
	char __data[0];
};

struct trace_event_raw_rdev_disconnect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	char __data[0];
};

struct trace_event_raw_rdev_join_ocb {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_rdev_set_wiphy_params {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_set_tx_power {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_tx_power_setting type;
	int mbm;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int func_ret;
	int func_fill;
	char __data[0];
};

struct trace_event_raw_rdev_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_update_mgmt_frame_registrations {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 global_stypes;
	u16 interface_stypes;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_rdev_return_void_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_tx_rx_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int: 32;
	u64 id;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 action_code;
	u8 dialog_token;
	u16 status_code;
	u32 peer_capability;
	bool initiator;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_rdev_dump_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_survey_info {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	int ret;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u32 filled;
	s8 noise;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_oper {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	char __data[0];
};

struct trace_event_raw_rdev_pmksa {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_probe_client {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_cookie {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int: 32;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_cancel_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	int: 32;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	bool offchan;
	unsigned int wait;
	bool no_cck;
	bool dont_wait_for_ack;
	char __data[0];
};

struct trace_event_raw_rdev_tx_control_port {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	__be16 proto;
	bool unencrypted;
	char __data[0];
};

struct trace_event_raw_rdev_set_noack_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 noack_map;
	char __data[0];
};

struct trace_event_raw_rdev_return_chandef {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_rdev_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_rdev_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 func_type;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	int: 32;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_set_mac_acl {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 acl_policy;
	char __data[0];
};

struct trace_event_raw_rdev_update_ft_ies {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 md;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_start {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 proto;
	u16 duration;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_stop {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_rdev_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	bool radar_required;
	bool block_tx;
	u8 count;
	u32 __data_loc_bcn_ofs;
	u32 __data_loc_pres_ofs;
	char __data[0];
};

struct trace_event_raw_rdev_set_qos_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 num_des;
	u8 dscp_exception[42];
	u8 up[16];
	char __data[0];
};

struct trace_event_raw_rdev_set_ap_chanwidth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_add_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	u8 user_prio;
	u16 admitted_time;
	char __data[0];
};

struct trace_event_raw_rdev_del_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	u8 oper_class;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	u8 pmk_len;
	u8 pmk_r0_name_len;
	u32 __data_loc_pmk;
	u32 __data_loc_pmk_r0_name;
	char __data[0];
};

struct trace_event_raw_rdev_del_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	char __data[0];
};

struct trace_event_raw_rdev_external_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 ssid[33];
	u16 status;
	char __data[0];
};

struct trace_event_raw_rdev_start_radar_detection {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 cac_time_ms;
	char __data[0];
};

struct trace_event_raw_rdev_set_mcast_rate {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int mcast_rate[5];
	char __data[0];
};

struct trace_event_raw_rdev_set_coalesce {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_rules;
	char __data[0];
};

struct trace_event_raw_rdev_set_multicast_to_unicast {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int: 32;
	u64 timestamp;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	int: 32;
	u64 duration;
	u32 unknown_triggers;
	u32 reschedule;
	u32 out_of_window;
	char __data[0];
	int: 32;
};

struct trace_event_raw_cfg80211_return_bool {
	struct trace_entry ent;
	bool ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 macaddr[6];
	char __data[0];
};

struct trace_event_raw_netdev_evt_only {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_cfg80211_send_rx_assoc {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_netdev_frame_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mlme_mgmt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	int reconnect;
	char __data[0];
};

struct trace_event_raw_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_michael_mic_failure {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	enum nl80211_key_type key_type;
	int key_id;
	u8 tsc[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel {
	struct trace_entry ent;
	u32 id;
	int: 32;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel_expired {
	struct trace_entry ent;
	u32 id;
	int: 32;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_cfg80211_tx_mgmt_expired {
	struct trace_entry ent;
	u32 id;
	int: 32;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_cfg80211_new_sta {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_mgmt {
	struct trace_entry ent;
	u32 id;
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_mgmt_tx_status {
	struct trace_entry ent;
	u32 id;
	int: 32;
	u64 cookie;
	bool ack;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_cfg80211_control_port_tx_status {
	struct trace_entry ent;
	u32 id;
	int: 32;
	u64 cookie;
	bool ack;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_cfg80211_rx_control_port {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int len;
	u8 from[6];
	u16 proto;
	bool unencrypted;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_rssi_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_cqm_rssi_threshold_event rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_cfg80211_reg_can_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	enum nl80211_iftype iftype;
	bool check_no_ir;
	char __data[0];
};

struct trace_event_raw_cfg80211_chandef_dfs_required {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_started_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_radar_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_cac_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_radar_event evt;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_ibss_joined {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_probe_status {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	int: 16;
	int: 32;
	u64 cookie;
	bool acked;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_cfg80211_cqm_pktloss_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 num_packets;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmksa_candidate_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int index;
	u8 bssid[6];
	bool preauth;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_obss_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_tdls_oper_request {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_cfg80211_scan_done {
	struct trace_entry ent;
	u32 n_channels;
	u32 __data_loc_ie;
	u32 rates[5];
	u32 wdev_id;
	u8 wiphy_mac[6];
	bool no_cck;
	bool aborted;
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	char __data[0];
};

struct trace_event_raw_wiphy_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_get_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u8 bssid[6];
	u32 __data_loc_ssid;
	enum ieee80211_bss_type bss_type;
	enum ieee80211_privacy privacy;
	char __data[0];
};

struct trace_event_raw_cfg80211_inform_bss_frame {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	enum nl80211_bss_scan_width scan_width;
	u32 __data_loc_mgmt;
	s32 signal;
	u64 ts_boottime;
	u64 parent_tsf;
	u8 parent_bssid[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_bss_evt {
	struct trace_entry ent;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_uint {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_u32 {
	struct trace_entry ent;
	u32 ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_wowlan_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	bool non_wireless;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	s32 pattern_idx;
	u32 packet_len;
	u32 __data_loc_packet;
	char __data[0];
};

struct trace_event_raw_cfg80211_ft_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_ies;
	u8 target_ap[6];
	u32 __data_loc_ric_ies;
	char __data[0];
};

struct trace_event_raw_cfg80211_stop_iface {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_report {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	int: 32;
	u64 cookie;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	int: 32;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_update_owe_info {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u16 status;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_cfg80211_update_owe_info_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_probe_mesh_link {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_reset_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tids;
	char __data[0];
};

struct trace_event_raw_rdev_set_sar_specs {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 type;
	u16 num;
	char __data[0];
};

struct trace_event_data_offsets_rdev_suspend {};

struct trace_event_data_offsets_rdev_return_int {};

struct trace_event_data_offsets_rdev_scan {};

struct trace_event_data_offsets_wiphy_only_evt {};

struct trace_event_data_offsets_wiphy_enabled_evt {};

struct trace_event_data_offsets_rdev_add_virtual_intf {
	u32 vir_intf_name;
};

struct trace_event_data_offsets_wiphy_wdev_evt {};

struct trace_event_data_offsets_wiphy_wdev_cookie_evt {};

struct trace_event_data_offsets_rdev_change_virtual_intf {};

struct trace_event_data_offsets_key_handle {};

struct trace_event_data_offsets_rdev_add_key {};

struct trace_event_data_offsets_rdev_set_default_key {};

struct trace_event_data_offsets_rdev_set_default_mgmt_key {};

struct trace_event_data_offsets_rdev_set_default_beacon_key {};

struct trace_event_data_offsets_rdev_start_ap {};

struct trace_event_data_offsets_rdev_change_beacon {
	u32 head;
	u32 tail;
	u32 beacon_ies;
	u32 proberesp_ies;
	u32 assocresp_ies;
	u32 probe_resp;
};

struct trace_event_data_offsets_wiphy_netdev_evt {};

struct trace_event_data_offsets_station_add_change {
	u32 supported_rates;
	u32 ext_capab;
	u32 supported_channels;
	u32 supported_oper_classes;
};

struct trace_event_data_offsets_wiphy_netdev_mac_evt {};

struct trace_event_data_offsets_station_del {};

struct trace_event_data_offsets_rdev_dump_station {};

struct trace_event_data_offsets_rdev_return_int_station_info {};

struct trace_event_data_offsets_mpath_evt {};

struct trace_event_data_offsets_rdev_dump_mpath {};

struct trace_event_data_offsets_rdev_get_mpp {};

struct trace_event_data_offsets_rdev_dump_mpp {};

struct trace_event_data_offsets_rdev_return_int_mpath_info {};

struct trace_event_data_offsets_rdev_return_int_mesh_config {};

struct trace_event_data_offsets_rdev_update_mesh_config {};

struct trace_event_data_offsets_rdev_join_mesh {};

struct trace_event_data_offsets_rdev_change_bss {};

struct trace_event_data_offsets_rdev_set_txq_params {};

struct trace_event_data_offsets_rdev_libertas_set_mesh_channel {};

struct trace_event_data_offsets_rdev_set_monitor_channel {};

struct trace_event_data_offsets_rdev_auth {};

struct trace_event_data_offsets_rdev_assoc {};

struct trace_event_data_offsets_rdev_deauth {};

struct trace_event_data_offsets_rdev_disassoc {};

struct trace_event_data_offsets_rdev_mgmt_tx_cancel_wait {};

struct trace_event_data_offsets_rdev_set_power_mgmt {};

struct trace_event_data_offsets_rdev_connect {};

struct trace_event_data_offsets_rdev_update_connect_params {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_config {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_range_config {};

struct trace_event_data_offsets_rdev_set_cqm_txe_config {};

struct trace_event_data_offsets_rdev_disconnect {};

struct trace_event_data_offsets_rdev_join_ibss {};

struct trace_event_data_offsets_rdev_join_ocb {};

struct trace_event_data_offsets_rdev_set_wiphy_params {};

struct trace_event_data_offsets_rdev_set_tx_power {};

struct trace_event_data_offsets_rdev_return_int_int {};

struct trace_event_data_offsets_rdev_set_bitrate_mask {};

struct trace_event_data_offsets_rdev_update_mgmt_frame_registrations {};

struct trace_event_data_offsets_rdev_return_int_tx_rx {};

struct trace_event_data_offsets_rdev_return_void_tx_rx {};

struct trace_event_data_offsets_tx_rx_evt {};

struct trace_event_data_offsets_wiphy_netdev_id_evt {};

struct trace_event_data_offsets_rdev_tdls_mgmt {
	u32 buf;
};

struct trace_event_data_offsets_rdev_dump_survey {};

struct trace_event_data_offsets_rdev_return_int_survey_info {};

struct trace_event_data_offsets_rdev_tdls_oper {};

struct trace_event_data_offsets_rdev_pmksa {};

struct trace_event_data_offsets_rdev_probe_client {};

struct trace_event_data_offsets_rdev_remain_on_channel {};

struct trace_event_data_offsets_rdev_return_int_cookie {};

struct trace_event_data_offsets_rdev_cancel_remain_on_channel {};

struct trace_event_data_offsets_rdev_mgmt_tx {};

struct trace_event_data_offsets_rdev_tx_control_port {};

struct trace_event_data_offsets_rdev_set_noack_map {};

struct trace_event_data_offsets_rdev_return_chandef {};

struct trace_event_data_offsets_rdev_start_nan {};

struct trace_event_data_offsets_rdev_nan_change_conf {};

struct trace_event_data_offsets_rdev_add_nan_func {};

struct trace_event_data_offsets_rdev_del_nan_func {};

struct trace_event_data_offsets_rdev_set_mac_acl {};

struct trace_event_data_offsets_rdev_update_ft_ies {
	u32 ie;
};

struct trace_event_data_offsets_rdev_crit_proto_start {};

struct trace_event_data_offsets_rdev_crit_proto_stop {};

struct trace_event_data_offsets_rdev_channel_switch {
	u32 bcn_ofs;
	u32 pres_ofs;
};

struct trace_event_data_offsets_rdev_set_qos_map {};

struct trace_event_data_offsets_rdev_set_ap_chanwidth {};

struct trace_event_data_offsets_rdev_add_tx_ts {};

struct trace_event_data_offsets_rdev_del_tx_ts {};

struct trace_event_data_offsets_rdev_tdls_channel_switch {};

struct trace_event_data_offsets_rdev_tdls_cancel_channel_switch {};

struct trace_event_data_offsets_rdev_set_pmk {
	u32 pmk;
	u32 pmk_r0_name;
};

struct trace_event_data_offsets_rdev_del_pmk {};

struct trace_event_data_offsets_rdev_external_auth {};

struct trace_event_data_offsets_rdev_start_radar_detection {};

struct trace_event_data_offsets_rdev_set_mcast_rate {};

struct trace_event_data_offsets_rdev_set_coalesce {};

struct trace_event_data_offsets_rdev_set_multicast_to_unicast {};

struct trace_event_data_offsets_rdev_get_ftm_responder_stats {};

struct trace_event_data_offsets_cfg80211_return_bool {};

struct trace_event_data_offsets_cfg80211_netdev_mac_evt {};

struct trace_event_data_offsets_netdev_evt_only {};

struct trace_event_data_offsets_cfg80211_send_rx_assoc {};

struct trace_event_data_offsets_netdev_frame_event {
	u32 frame;
};

struct trace_event_data_offsets_cfg80211_tx_mlme_mgmt {
	u32 frame;
};

struct trace_event_data_offsets_netdev_mac_evt {};

struct trace_event_data_offsets_cfg80211_michael_mic_failure {};

struct trace_event_data_offsets_cfg80211_ready_on_channel {};

struct trace_event_data_offsets_cfg80211_ready_on_channel_expired {};

struct trace_event_data_offsets_cfg80211_tx_mgmt_expired {};

struct trace_event_data_offsets_cfg80211_new_sta {};

struct trace_event_data_offsets_cfg80211_rx_mgmt {};

struct trace_event_data_offsets_cfg80211_mgmt_tx_status {};

struct trace_event_data_offsets_cfg80211_control_port_tx_status {};

struct trace_event_data_offsets_cfg80211_rx_control_port {};

struct trace_event_data_offsets_cfg80211_cqm_rssi_notify {};

struct trace_event_data_offsets_cfg80211_reg_can_beacon {};

struct trace_event_data_offsets_cfg80211_chandef_dfs_required {};

struct trace_event_data_offsets_cfg80211_ch_switch_notify {};

struct trace_event_data_offsets_cfg80211_ch_switch_started_notify {};

struct trace_event_data_offsets_cfg80211_radar_event {};

struct trace_event_data_offsets_cfg80211_cac_event {};

struct trace_event_data_offsets_cfg80211_rx_evt {};

struct trace_event_data_offsets_cfg80211_ibss_joined {};

struct trace_event_data_offsets_cfg80211_probe_status {};

struct trace_event_data_offsets_cfg80211_cqm_pktloss_notify {};

struct trace_event_data_offsets_cfg80211_pmksa_candidate_notify {};

struct trace_event_data_offsets_cfg80211_report_obss_beacon {};

struct trace_event_data_offsets_cfg80211_tdls_oper_request {};

struct trace_event_data_offsets_cfg80211_scan_done {
	u32 ie;
};

struct trace_event_data_offsets_wiphy_id_evt {};

struct trace_event_data_offsets_cfg80211_get_bss {
	u32 ssid;
};

struct trace_event_data_offsets_cfg80211_inform_bss_frame {
	u32 mgmt;
};

struct trace_event_data_offsets_cfg80211_bss_evt {};

struct trace_event_data_offsets_cfg80211_return_uint {};

struct trace_event_data_offsets_cfg80211_return_u32 {};

struct trace_event_data_offsets_cfg80211_report_wowlan_wakeup {
	u32 packet;
};

struct trace_event_data_offsets_cfg80211_ft_event {
	u32 ies;
	u32 ric_ies;
};

struct trace_event_data_offsets_cfg80211_stop_iface {};

struct trace_event_data_offsets_cfg80211_pmsr_report {};

struct trace_event_data_offsets_cfg80211_pmsr_complete {};

struct trace_event_data_offsets_rdev_update_owe_info {
	u32 ie;
};

struct trace_event_data_offsets_cfg80211_update_owe_info_event {
	u32 ie;
};

struct trace_event_data_offsets_rdev_probe_mesh_link {};

struct trace_event_data_offsets_rdev_set_tid_config {};

struct trace_event_data_offsets_rdev_reset_tid_config {};

struct trace_event_data_offsets_rdev_set_sar_specs {};

typedef void (*btf_trace_rdev_suspend)(void *, struct wiphy *, struct cfg80211_wowlan *);

typedef void (*btf_trace_rdev_return_int)(void *, struct wiphy *, int);

typedef void (*btf_trace_rdev_scan)(void *, struct wiphy *, struct cfg80211_scan_request *);

typedef void (*btf_trace_rdev_resume)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_return_void)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_get_antenna)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_rfkill_poll)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_set_wakeup)(void *, struct wiphy *, bool);

typedef void (*btf_trace_rdev_add_virtual_intf)(void *, struct wiphy *, char *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_return_wdev)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_del_virtual_intf)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_change_virtual_intf)(void *, struct wiphy *, struct net_device *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_get_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_del_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_add_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *, u8);

typedef void (*btf_trace_rdev_set_default_key)(void *, struct wiphy *, struct net_device *, u8, bool, bool);

typedef void (*btf_trace_rdev_set_default_mgmt_key)(void *, struct wiphy *, struct net_device *, u8);

typedef void (*btf_trace_rdev_set_default_beacon_key)(void *, struct wiphy *, struct net_device *, u8);

typedef void (*btf_trace_rdev_start_ap)(void *, struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);

typedef void (*btf_trace_rdev_change_beacon)(void *, struct wiphy *, struct net_device *, struct cfg80211_beacon_data *);

typedef void (*btf_trace_rdev_stop_ap)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_set_rekey_data)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_get_mesh_config)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_mesh)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ibss)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ocb)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_flush_pmksa)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_end_cac)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_add_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_change_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_del_station)(void *, struct wiphy *, struct net_device *, struct station_del_parameters *);

typedef void (*btf_trace_rdev_get_station)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_del_mpath)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_dump_station)(void *, struct wiphy *, struct net_device *, int, u8 *);

typedef void (*btf_trace_rdev_return_int_station_info)(void *, struct wiphy *, int, struct station_info *);

typedef void (*btf_trace_rdev_add_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_change_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpath)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpp)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpp)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_return_int_mpath_info)(void *, struct wiphy *, int, struct mpath_info *);

typedef void (*btf_trace_rdev_return_int_mesh_config)(void *, struct wiphy *, int, struct mesh_config *);

typedef void (*btf_trace_rdev_update_mesh_config)(void *, struct wiphy *, struct net_device *, u32, const struct mesh_config *);

typedef void (*btf_trace_rdev_join_mesh)(void *, struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);

typedef void (*btf_trace_rdev_change_bss)(void *, struct wiphy *, struct net_device *, struct bss_parameters *);

typedef void (*btf_trace_rdev_set_txq_params)(void *, struct wiphy *, struct net_device *, struct ieee80211_txq_params *);

typedef void (*btf_trace_rdev_libertas_set_mesh_channel)(void *, struct wiphy *, struct net_device *, struct ieee80211_channel *);

typedef void (*btf_trace_rdev_set_monitor_channel)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_auth_request *);

typedef void (*btf_trace_rdev_assoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);

typedef void (*btf_trace_rdev_deauth)(void *, struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);

typedef void (*btf_trace_rdev_disassoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);

typedef void (*btf_trace_rdev_mgmt_tx_cancel_wait)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_set_power_mgmt)(void *, struct wiphy *, struct net_device *, bool, int);

typedef void (*btf_trace_rdev_connect)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *);

typedef void (*btf_trace_rdev_update_connect_params)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_config)(void *, struct wiphy *, struct net_device *, s32, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_range_config)(void *, struct wiphy *, struct net_device *, s32, s32);

typedef void (*btf_trace_rdev_set_cqm_txe_config)(void *, struct wiphy *, struct net_device *, u32, u32, u32);

typedef void (*btf_trace_rdev_disconnect)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_join_ibss)(void *, struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);

typedef void (*btf_trace_rdev_join_ocb)(void *, struct wiphy *, struct net_device *, const struct ocb_setup *);

typedef void (*btf_trace_rdev_set_wiphy_params)(void *, struct wiphy *, u32);

typedef void (*btf_trace_rdev_get_tx_power)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_set_tx_power)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);

typedef void (*btf_trace_rdev_return_int_int)(void *, struct wiphy *, int, int);

typedef void (*btf_trace_rdev_set_bitrate_mask)(void *, struct wiphy *, struct net_device *, const u8 *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_rdev_update_mgmt_frame_registrations)(void *, struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);

typedef void (*btf_trace_rdev_return_int_tx_rx)(void *, struct wiphy *, int, u32, u32);

typedef void (*btf_trace_rdev_return_void_tx_rx)(void *, struct wiphy *, u32, u32, u32, u32);

typedef void (*btf_trace_rdev_set_antenna)(void *, struct wiphy *, u32, u32);

typedef void (*btf_trace_rdev_sched_scan_start)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_sched_scan_stop)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_tdls_mgmt)(void *, struct wiphy *, struct net_device *, u8 *, u8, u8, u16, u32, bool, const u8 *, size_t);

typedef void (*btf_trace_rdev_dump_survey)(void *, struct wiphy *, struct net_device *, int);

typedef void (*btf_trace_rdev_return_int_survey_info)(void *, struct wiphy *, int, struct survey_info *);

typedef void (*btf_trace_rdev_tdls_oper)(void *, struct wiphy *, struct net_device *, u8 *, enum nl80211_tdls_operation);

typedef void (*btf_trace_rdev_probe_client)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_del_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_rdev_return_int_cookie)(void *, struct wiphy *, int, u64);

typedef void (*btf_trace_rdev_cancel_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_mgmt_tx)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *);

typedef void (*btf_trace_rdev_tx_control_port)(void *, struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, __be16, bool);

typedef void (*btf_trace_rdev_set_noack_map)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_get_channel)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_return_chandef)(void *, struct wiphy *, int, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_start_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_stop_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_start_nan)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_rdev_nan_change_conf)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_rdev_stop_nan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_add_nan_func)(void *, struct wiphy *, struct wireless_dev *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_rdev_del_nan_func)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_set_mac_acl)(void *, struct wiphy *, struct net_device *, struct cfg80211_acl_data *);

typedef void (*btf_trace_rdev_update_ft_ies)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);

typedef void (*btf_trace_rdev_crit_proto_start)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);

typedef void (*btf_trace_rdev_crit_proto_stop)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_channel_switch)(void *, struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);

typedef void (*btf_trace_rdev_set_qos_map)(void *, struct wiphy *, struct net_device *, struct cfg80211_qos_map *);

typedef void (*btf_trace_rdev_set_ap_chanwidth)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_add_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);

typedef void (*btf_trace_rdev_del_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *);

typedef void (*btf_trace_rdev_tdls_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_tdls_cancel_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_pmk)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmk_conf *);

typedef void (*btf_trace_rdev_del_pmk)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_external_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);

typedef void (*btf_trace_rdev_start_radar_detection)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32);

typedef void (*btf_trace_rdev_set_mcast_rate)(void *, struct wiphy *, struct net_device *, int *);

typedef void (*btf_trace_rdev_set_coalesce)(void *, struct wiphy *, struct cfg80211_coalesce *);

typedef void (*btf_trace_rdev_abort_scan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_set_multicast_to_unicast)(void *, struct wiphy *, struct net_device *, const bool);

typedef void (*btf_trace_rdev_get_txq_stats)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_get_ftm_responder_stats)(void *, struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_rdev_start_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_abort_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_cfg80211_return_bool)(void *, bool);

typedef void (*btf_trace_cfg80211_notify_new_peer_candidate)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_rx_auth)(void *, struct net_device *);

typedef void (*btf_trace_cfg80211_send_rx_assoc)(void *, struct net_device *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_rx_unprot_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_rx_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_tx_mlme_mgmt)(void *, struct net_device *, const u8 *, int, bool);

typedef void (*btf_trace_cfg80211_send_auth_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_assoc_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_michael_mic_failure)(void *, struct net_device *, const u8 *, enum nl80211_key_type, int, const u8 *);

typedef void (*btf_trace_cfg80211_ready_on_channel)(void *, struct wireless_dev *, u64, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_cfg80211_ready_on_channel_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_tx_mgmt_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_new_sta)(void *, struct net_device *, const u8 *, struct station_info *);

typedef void (*btf_trace_cfg80211_del_sta)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_mgmt)(void *, struct wireless_dev *, int, int);

typedef void (*btf_trace_cfg80211_mgmt_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_control_port_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_rx_control_port)(void *, struct net_device *, struct sk_buff *, bool);

typedef void (*btf_trace_cfg80211_cqm_rssi_notify)(void *, struct net_device *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_cfg80211_reg_can_beacon)(void *, struct wiphy *, struct cfg80211_chan_def *, enum nl80211_iftype, bool);

typedef void (*btf_trace_cfg80211_chandef_dfs_required)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_ch_switch_notify)(void *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_ch_switch_started_notify)(void *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_radar_event)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_cac_event)(void *, struct net_device *, enum nl80211_radar_event);

typedef void (*btf_trace_cfg80211_rx_spurious_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_unexpected_4addr_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_ibss_joined)(void *, struct net_device *, const u8 *, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_probe_status)(void *, struct net_device *, const u8 *, u64, bool);

typedef void (*btf_trace_cfg80211_cqm_pktloss_notify)(void *, struct net_device *, const u8 *, u32);

typedef void (*btf_trace_cfg80211_gtk_rekey_notify)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_pmksa_candidate_notify)(void *, struct net_device *, int, const u8 *, bool);

typedef void (*btf_trace_cfg80211_report_obss_beacon)(void *, struct wiphy *, const u8 *, size_t, int, int);

typedef void (*btf_trace_cfg80211_tdls_oper_request)(void *, struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation, u16);

typedef void (*btf_trace_cfg80211_scan_done)(void *, struct cfg80211_scan_request *, struct cfg80211_scan_info *);

typedef void (*btf_trace_cfg80211_sched_scan_stopped)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_sched_scan_results)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_get_bss)(void *, struct wiphy *, struct ieee80211_channel *, const u8 *, const u8 *, size_t, enum ieee80211_bss_type, enum ieee80211_privacy);

typedef void (*btf_trace_cfg80211_inform_bss_frame)(void *, struct wiphy *, struct cfg80211_inform_bss *, struct ieee80211_mgmt *, size_t);

typedef void (*btf_trace_cfg80211_return_bss)(void *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_return_uint)(void *, unsigned int);

typedef void (*btf_trace_cfg80211_return_u32)(void *, u32);

typedef void (*btf_trace_cfg80211_report_wowlan_wakeup)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_wowlan_wakeup *);

typedef void (*btf_trace_cfg80211_ft_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_ft_event_params *);

typedef void (*btf_trace_cfg80211_stop_iface)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_cfg80211_pmsr_report)(void *, struct wiphy *, struct wireless_dev *, u64, const u8 *);

typedef void (*btf_trace_cfg80211_pmsr_complete)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_update_owe_info)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_cfg80211_update_owe_info_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_rdev_probe_mesh_link)(void *, struct wiphy *, struct net_device *, const u8 *, const u8 *, size_t);

typedef void (*btf_trace_rdev_set_tid_config)(void *, struct wiphy *, struct net_device *, struct cfg80211_tid_config *);

typedef void (*btf_trace_rdev_reset_tid_config)(void *, struct wiphy *, struct net_device *, const u8 *, u8);

typedef void (*btf_trace_rdev_set_sar_specs)(void *, struct wiphy *, struct cfg80211_sar_specs *);

enum nl80211_peer_measurement_status {
	NL80211_PMSR_STATUS_SUCCESS = 0,
	NL80211_PMSR_STATUS_REFUSED = 1,
	NL80211_PMSR_STATUS_TIMEOUT = 2,
	NL80211_PMSR_STATUS_FAILURE = 3,
};

enum nl80211_peer_measurement_resp {
	__NL80211_PMSR_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_RESP_ATTR_DATA = 1,
	NL80211_PMSR_RESP_ATTR_STATUS = 2,
	NL80211_PMSR_RESP_ATTR_HOST_TIME = 3,
	NL80211_PMSR_RESP_ATTR_AP_TSF = 4,
	NL80211_PMSR_RESP_ATTR_FINAL = 5,
	NL80211_PMSR_RESP_ATTR_PAD = 6,
	NUM_NL80211_PMSR_RESP_ATTRS = 7,
	NL80211_PMSR_RESP_ATTR_MAX = 6,
};

enum nl80211_peer_measurement_ftm_failure_reasons {
	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED = 0,
	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE = 1,
	NL80211_PMSR_FTM_FAILURE_REJECTED = 2,
	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL = 3,
	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE = 4,
	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP = 5,
	NL80211_PMSR_FTM_FAILURE_PEER_BUSY = 6,
	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS = 7,
};

enum nl80211_peer_measurement_ftm_resp {
	__NL80211_PMSR_FTM_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON = 1,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX = 2,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS = 3,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES = 4,
	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME = 5,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP = 6,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION = 7,
	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG = 9,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD = 10,
	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE = 11,
	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE = 12,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG = 13,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE = 14,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD = 15,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG = 16,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE = 17,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD = 18,
	NL80211_PMSR_FTM_RESP_ATTR_LCI = 19,
	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC = 20,
	NL80211_PMSR_FTM_RESP_ATTR_PAD = 21,
	NUM_NL80211_PMSR_FTM_RESP_ATTR = 22,
	NL80211_PMSR_FTM_RESP_ATTR_MAX = 21,
};

struct cfg80211_pmsr_ftm_result {
	const u8 *lci;
	const u8 *civicloc;
	unsigned int lci_len;
	unsigned int civicloc_len;
	enum nl80211_peer_measurement_ftm_failure_reasons failure_reason;
	u32 num_ftmr_attempts;
	u32 num_ftmr_successes;
	s16 burst_index;
	u8 busy_retry_time;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	s32 rssi_avg;
	s32 rssi_spread;
	struct rate_info tx_rate;
	struct rate_info rx_rate;
	s64 rtt_avg;
	s64 rtt_variance;
	s64 rtt_spread;
	s64 dist_avg;
	s64 dist_variance;
	s64 dist_spread;
	u16 num_ftmr_attempts_valid: 1;
	u16 num_ftmr_successes_valid: 1;
	u16 rssi_avg_valid: 1;
	u16 rssi_spread_valid: 1;
	u16 tx_rate_valid: 1;
	u16 rx_rate_valid: 1;
	u16 rtt_avg_valid: 1;
	u16 rtt_variance_valid: 1;
	u16 rtt_spread_valid: 1;
	u16 dist_avg_valid: 1;
	u16 dist_variance_valid: 1;
	u16 dist_spread_valid: 1;
	int: 20;
	int: 32;
};

struct cfg80211_pmsr_result {
	u64 host_time;
	u64 ap_tsf;
	enum nl80211_peer_measurement_status status;
	u8 addr[6];
	u8 final: 1;
	u8 ap_tsf_valid: 1;
	enum nl80211_peer_measurement_type type;
	union {
		struct cfg80211_pmsr_ftm_result ftm;
	};
};

struct ieee80211_channel_sw_ie {
	u8 mode;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_sec_chan_offs_ie {
	u8 sec_chan_offs;
};

struct ieee80211_mesh_chansw_params_ie {
	u8 mesh_ttl;
	u8 mesh_flags;
	__le16 mesh_reason;
	__le16 mesh_pre_value;
};

struct ieee80211_wide_bw_chansw_ie {
	u8 new_channel_width;
	u8 new_center_freq_seg0;
	u8 new_center_freq_seg1;
};

struct ieee80211_tim_ie {
	u8 dtim_count;
	u8 dtim_period;
	u8 bitmap_ctrl;
	u8 virtual_map[1];
};

struct ieee80211_meshconf_ie {
	u8 meshconf_psel;
	u8 meshconf_pmetric;
	u8 meshconf_congest;
	u8 meshconf_synch;
	u8 meshconf_auth;
	u8 meshconf_form;
	u8 meshconf_cap;
};

struct ieee80211_rann_ie {
	u8 rann_flags;
	u8 rann_hopcount;
	u8 rann_ttl;
	u8 rann_addr[6];
	__le32 rann_seq;
	__le32 rann_interval;
	__le32 rann_metric;
} __attribute__((packed));

struct ieee80211_addba_ext_ie {
	u8 data;
};

struct ieee80211_aid_response_ie {
	__le16 aid;
	u8 switch_count;
	__le16 response_int;
} __attribute__((packed));

struct ieee80211_ch_switch_timing {
	__le16 switch_time;
	__le16 switch_timeout;
};

struct ieee80211_tdls_lnkie {
	u8 ie_type;
	u8 ie_len;
	u8 bssid[6];
	u8 init_sta[6];
	u8 resp_sta[6];
};

struct ieee80211_p2p_noa_desc {
	u8 count;
	__le32 duration;
	__le32 interval;
	__le32 start_time;
} __attribute__((packed));

struct ieee80211_p2p_noa_attr {
	u8 index;
	u8 oppps_ctwindow;
	struct ieee80211_p2p_noa_desc desc[4];
} __attribute__((packed));

struct ieee80211_vht_operation {
	u8 chan_width;
	u8 center_freq_seg0_idx;
	u8 center_freq_seg1_idx;
	__le16 basic_mcs_set;
} __attribute__((packed));

struct ieee80211_he_spr {
	u8 he_sr_control;
	u8 optional[0];
};

struct ieee80211_he_mu_edca_param_ac_rec {
	u8 aifsn;
	u8 ecw_min_max;
	u8 mu_edca_timer;
};

struct ieee80211_mu_edca_param_set {
	u8 mu_qos_info;
	struct ieee80211_he_mu_edca_param_ac_rec ac_be;
	struct ieee80211_he_mu_edca_param_ac_rec ac_bk;
	struct ieee80211_he_mu_edca_param_ac_rec ac_vi;
	struct ieee80211_he_mu_edca_param_ac_rec ac_vo;
};

struct ieee80211_timeout_interval_ie {
	u8 type;
	__le32 value;
} __attribute__((packed));

struct ieee80211_bss_max_idle_period_ie {
	__le16 max_idle_period;
	u8 idle_options;
} __attribute__((packed));

struct ieee80211_bssid_index {
	u8 bssid_index;
	u8 dtim_period;
	u8 dtim_count;
};

struct ieee80211_multiple_bssid_configuration {
	u8 bssid_count;
	u8 profile_periodicity;
};

typedef u32 codel_time_t;

struct codel_params {
	codel_time_t target;
	codel_time_t ce_threshold;
	codel_time_t interval;
	u32 mtu;
	bool ecn;
};

struct codel_vars {
	u32 count;
	u32 lastcount;
	bool dropping;
	u16 rec_inv_sqrt;
	codel_time_t first_above_time;
	codel_time_t drop_next;
	codel_time_t ldelay;
};

enum ieee80211_radiotap_mcs_have {
	IEEE80211_RADIOTAP_MCS_HAVE_BW = 1,
	IEEE80211_RADIOTAP_MCS_HAVE_MCS = 2,
	IEEE80211_RADIOTAP_MCS_HAVE_GI = 4,
	IEEE80211_RADIOTAP_MCS_HAVE_FMT = 8,
	IEEE80211_RADIOTAP_MCS_HAVE_FEC = 16,
	IEEE80211_RADIOTAP_MCS_HAVE_STBC = 32,
};

enum ieee80211_radiotap_vht_known {
	IEEE80211_RADIOTAP_VHT_KNOWN_STBC = 1,
	IEEE80211_RADIOTAP_VHT_KNOWN_TXOP_PS_NA = 2,
	IEEE80211_RADIOTAP_VHT_KNOWN_GI = 4,
	IEEE80211_RADIOTAP_VHT_KNOWN_SGI_NSYM_DIS = 8,
	IEEE80211_RADIOTAP_VHT_KNOWN_LDPC_EXTRA_OFDM_SYM = 16,
	IEEE80211_RADIOTAP_VHT_KNOWN_BEAMFORMED = 32,
	IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH = 64,
	IEEE80211_RADIOTAP_VHT_KNOWN_GROUP_ID = 128,
	IEEE80211_RADIOTAP_VHT_KNOWN_PARTIAL_AID = 256,
};

enum ieee80211_max_queues {
	IEEE80211_MAX_QUEUES = 16,
	IEEE80211_MAX_QUEUE_MAP = 65535,
};

struct ieee80211_tx_queue_params {
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool acm;
	bool uapsd;
	bool mu_edca;
	struct ieee80211_he_mu_edca_param_ac_rec mu_edca_param_rec;
};

struct ieee80211_low_level_stats {
	unsigned int dot11ACKFailureCount;
	unsigned int dot11RTSFailureCount;
	unsigned int dot11FCSErrorCount;
	unsigned int dot11RTSSuccessCount;
};

struct ieee80211_chanctx_conf {
	struct cfg80211_chan_def def;
	struct cfg80211_chan_def min_def;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	bool radar_enabled;
	char: 8;
	u8 drv_priv[0];
};

enum ieee80211_chanctx_switch_mode {
	CHANCTX_SWMODE_REASSIGN_VIF = 0,
	CHANCTX_SWMODE_SWAP_CONTEXTS = 1,
};

struct ieee80211_vif;

struct ieee80211_vif_chanctx_switch {
	struct ieee80211_vif *vif;
	struct ieee80211_chanctx_conf *old_ctx;
	struct ieee80211_chanctx_conf *new_ctx;
};

struct ieee80211_mu_group_data {
	u8 membership[8];
	u8 position[16];
};

struct ieee80211_fils_discovery {
	u32 min_interval;
	u32 max_interval;
};

struct ieee80211_ftm_responder_params;

struct ieee80211_bss_conf {
	const u8 *bssid;
	u8 htc_trig_based_pkt_ext;
	bool uora_exists;
	u8 uora_ocw_range;
	u16 frame_time_rts_th;
	bool he_support;
	bool twt_requester;
	bool twt_responder;
	bool twt_protected;
	bool assoc;
	bool ibss_joined;
	bool ibss_creator;
	u16 aid;
	bool use_cts_prot;
	bool use_short_preamble;
	bool use_short_slot;
	bool enable_beacon;
	u8 dtim_period;
	u16 beacon_int;
	u16 assoc_capability;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	struct ieee80211_rate *beacon_rate;
	int mcast_rate[5];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	u32 cqm_rssi_hyst;
	s32 cqm_rssi_low;
	s32 cqm_rssi_high;
	struct cfg80211_chan_def chandef;
	struct ieee80211_mu_group_data mu_group;
	__be32 arp_addr_list[4];
	int arp_addr_cnt;
	bool qos;
	bool idle;
	bool ps;
	u8 ssid[32];
	size_t ssid_len;
	bool hidden_ssid;
	int txpower;
	enum nl80211_tx_power_setting txpower_type;
	struct ieee80211_p2p_noa_attr p2p_noa_attr;
	bool allow_p2p_go_ps;
	u16 max_idle_period;
	bool protected_keep_alive;
	bool ftm_responder;
	struct ieee80211_ftm_responder_params *ftmr_params;
	bool nontransmitted;
	u8 transmitter_bssid[6];
	u8 bssid_index;
	u8 bssid_indicator;
	bool ema_ap;
	u8 profile_periodicity;
	struct {
		u32 params;
		u16 nss_set;
	} he_oper;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_he_bss_color he_bss_color;
	struct ieee80211_fils_discovery fils_discovery;
	u32 unsol_bcast_probe_resp_interval;
	bool s1g;
	struct cfg80211_bitrate_mask beacon_tx_rate;
	int: 32;
};

struct ieee80211_txq;

struct ieee80211_vif {
	enum nl80211_iftype type;
	int: 32;
	struct ieee80211_bss_conf bss_conf;
	u8 addr[6];
	bool p2p;
	bool csa_active;
	bool mu_mimo_owner;
	u8 cab_queue;
	u8 hw_queue[4];
	struct ieee80211_txq *txq;
	struct ieee80211_chanctx_conf *chanctx_conf;
	u32 driver_flags;
	u32 offload_flags;
	bool probe_req_reg;
	bool rx_mcast_action_reg;
	bool txqs_stopped[4];
	short: 16;
	u8 drv_priv[0];
};

enum ieee80211_bss_change {
	BSS_CHANGED_ASSOC = 1,
	BSS_CHANGED_ERP_CTS_PROT = 2,
	BSS_CHANGED_ERP_PREAMBLE = 4,
	BSS_CHANGED_ERP_SLOT = 8,
	BSS_CHANGED_HT = 16,
	BSS_CHANGED_BASIC_RATES = 32,
	BSS_CHANGED_BEACON_INT = 64,
	BSS_CHANGED_BSSID = 128,
	BSS_CHANGED_BEACON = 256,
	BSS_CHANGED_BEACON_ENABLED = 512,
	BSS_CHANGED_CQM = 1024,
	BSS_CHANGED_IBSS = 2048,
	BSS_CHANGED_ARP_FILTER = 4096,
	BSS_CHANGED_QOS = 8192,
	BSS_CHANGED_IDLE = 16384,
	BSS_CHANGED_SSID = 32768,
	BSS_CHANGED_AP_PROBE_RESP = 65536,
	BSS_CHANGED_PS = 131072,
	BSS_CHANGED_TXPOWER = 262144,
	BSS_CHANGED_P2P_PS = 524288,
	BSS_CHANGED_BEACON_INFO = 1048576,
	BSS_CHANGED_BANDWIDTH = 2097152,
	BSS_CHANGED_OCB = 4194304,
	BSS_CHANGED_MU_GROUPS = 8388608,
	BSS_CHANGED_KEEP_ALIVE = 16777216,
	BSS_CHANGED_MCAST_RATE = 33554432,
	BSS_CHANGED_FTM_RESPONDER = 67108864,
	BSS_CHANGED_TWT = 134217728,
	BSS_CHANGED_HE_OBSS_PD = 268435456,
	BSS_CHANGED_HE_BSS_COLOR = 536870912,
	BSS_CHANGED_FILS_DISCOVERY = 1073741824,
	BSS_CHANGED_UNSOL_BCAST_PROBE_RESP = 2147483648,
};

enum ieee80211_event_type {
	RSSI_EVENT = 0,
	MLME_EVENT = 1,
	BAR_RX_EVENT = 2,
	BA_FRAME_TIMEOUT = 3,
};

enum ieee80211_rssi_event_data {
	RSSI_EVENT_HIGH = 0,
	RSSI_EVENT_LOW = 1,
};

struct ieee80211_rssi_event {
	enum ieee80211_rssi_event_data data;
};

enum ieee80211_mlme_event_data {
	AUTH_EVENT = 0,
	ASSOC_EVENT = 1,
	DEAUTH_RX_EVENT = 2,
	DEAUTH_TX_EVENT = 3,
};

enum ieee80211_mlme_event_status {
	MLME_SUCCESS = 0,
	MLME_DENIED = 1,
	MLME_TIMEOUT = 2,
};

struct ieee80211_mlme_event {
	enum ieee80211_mlme_event_data data;
	enum ieee80211_mlme_event_status status;
	u16 reason;
};

struct ieee80211_sta;

struct ieee80211_ba_event {
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
};

enum ieee80211_sta_rx_bandwidth {
	IEEE80211_STA_RX_BW_20 = 0,
	IEEE80211_STA_RX_BW_40 = 1,
	IEEE80211_STA_RX_BW_80 = 2,
	IEEE80211_STA_RX_BW_160 = 3,
};

enum ieee80211_smps_mode {
	IEEE80211_SMPS_AUTOMATIC = 0,
	IEEE80211_SMPS_OFF = 1,
	IEEE80211_SMPS_STATIC = 2,
	IEEE80211_SMPS_DYNAMIC = 3,
	IEEE80211_SMPS_NUM_MODES = 4,
};

struct ieee80211_sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct ieee80211_sta_rates;

struct ieee80211_sta {
	u32 supp_rates[5];
	u8 addr[6];
	u16 aid;
	struct ieee80211_sta_ht_cap ht_cap;
	short: 16;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	char: 8;
	u16 max_rx_aggregation_subframes;
	bool wme;
	u8 uapsd_queues;
	u8 max_sp;
	u8 rx_nss;
	enum ieee80211_sta_rx_bandwidth bandwidth;
	enum ieee80211_smps_mode smps_mode;
	struct ieee80211_sta_rates *rates;
	bool tdls;
	bool tdls_initiator;
	bool mfp;
	u8 max_amsdu_subframes;
	u16 max_amsdu_len;
	bool support_p2p_ps;
	char: 8;
	u16 max_rc_amsdu_len;
	u16 max_tid_amsdu_len[16];
	short: 16;
	struct ieee80211_sta_txpwr txpwr;
	struct ieee80211_txq *txq[17];
	u8 drv_priv[0];
} __attribute__((packed));

struct ieee80211_event {
	enum ieee80211_event_type type;
	union {
		struct ieee80211_rssi_event rssi;
		struct ieee80211_mlme_event mlme;
		struct ieee80211_ba_event ba;
	} u;
};

struct ieee80211_ftm_responder_params {
	const u8 *lci;
	const u8 *civicloc;
	size_t lci_len;
	size_t civicloc_len;
};

struct ieee80211_tx_rate {
	s8 idx;
	u16 count: 5;
	u16 flags: 11;
} __attribute__((packed));

struct ieee80211_key_conf {
	atomic64_t tx_pn;
	u32 cipher;
	u8 icv_len;
	u8 iv_len;
	u8 hw_key_idx;
	s8 keyidx;
	u16 flags;
	u8 keylen;
	u8 key[0];
	int: 8;
	int: 32;
};

struct ieee80211_tx_info {
	u32 flags;
	u32 band: 3;
	u32 ack_frame_id: 13;
	u32 hw_queue: 4;
	u32 tx_time_est: 10;
	union {
		struct {
			union {
				struct {
					struct ieee80211_tx_rate rates[4];
					s8 rts_cts_rate_idx;
					u8 use_rts: 1;
					u8 use_cts_prot: 1;
					u8 short_preamble: 1;
					u8 skip_table: 1;
				};
				long unsigned int jiffies;
			};
			struct ieee80211_vif *vif;
			struct ieee80211_key_conf *hw_key;
			u32 flags;
			codel_time_t enqueue_time;
		} control;
		struct {
			u64 cookie;
		} ack;
		struct {
			struct ieee80211_tx_rate rates[4];
			s32 ack_signal;
			u8 ampdu_ack_len;
			u8 ampdu_len;
			u8 antenna;
			u16 tx_time;
			bool is_valid_ack_signal;
			void *status_driver_data[4];
		} status;
		struct {
			struct ieee80211_tx_rate driver_rates[4];
			u8 pad[4];
			void *rate_driver_data[6];
		};
		void *driver_data[10];
	};
};

struct ieee80211_tx_status {
	struct ieee80211_sta *sta;
	struct ieee80211_tx_info *info;
	struct sk_buff *skb;
	struct rate_info *rate;
	struct list_head *free_list;
};

struct ieee80211_scan_ies {
	const u8 *ies[5];
	size_t len[5];
	const u8 *common_ies;
	size_t common_ie_len;
};

struct ieee80211_rx_status {
	u64 mactime;
	u64 boottime_ns;
	u32 device_timestamp;
	u32 ampdu_reference;
	u32 flag;
	u16 freq: 13;
	u16 freq_offset: 1;
	u8 enc_flags;
	u8 encoding: 2;
	u8 bw: 3;
	u8 he_ru: 3;
	u8 he_gi: 2;
	u8 he_dcm: 1;
	u8 rate_idx;
	u8 nss;
	u8 rx_flags;
	u8 band;
	u8 antenna;
	s8 signal;
	u8 chains;
	s8 chain_signal[4];
	u8 ampdu_delimiter_crc;
	u8 zero_length_psdu_type;
};

enum ieee80211_conf_flags {
	IEEE80211_CONF_MONITOR = 1,
	IEEE80211_CONF_PS = 2,
	IEEE80211_CONF_IDLE = 4,
	IEEE80211_CONF_OFFCHANNEL = 8,
};

enum ieee80211_conf_changed {
	IEEE80211_CONF_CHANGE_SMPS = 2,
	IEEE80211_CONF_CHANGE_LISTEN_INTERVAL = 4,
	IEEE80211_CONF_CHANGE_MONITOR = 8,
	IEEE80211_CONF_CHANGE_PS = 16,
	IEEE80211_CONF_CHANGE_POWER = 32,
	IEEE80211_CONF_CHANGE_CHANNEL = 64,
	IEEE80211_CONF_CHANGE_RETRY_LIMITS = 128,
	IEEE80211_CONF_CHANGE_IDLE = 256,
};

struct ieee80211_conf {
	u32 flags;
	int power_level;
	int dynamic_ps_timeout;
	u16 listen_interval;
	u8 ps_dtim_period;
	u8 long_frame_max_tx_count;
	u8 short_frame_max_tx_count;
	struct cfg80211_chan_def chandef;
	bool radar_enabled;
	enum ieee80211_smps_mode smps_mode;
};

struct ieee80211_channel_switch {
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	struct cfg80211_chan_def chandef;
	u8 count;
	u32 delay;
	int: 32;
};

struct ieee80211_txq {
	struct ieee80211_vif *vif;
	struct ieee80211_sta *sta;
	u8 tid;
	u8 ac;
	short: 16;
	u8 drv_priv[0];
};

struct ieee80211_key_seq {
	union {
		struct {
			u32 iv32;
			u16 iv16;
		} tkip;
		struct {
			u8 pn[6];
		} ccmp;
		struct {
			u8 pn[6];
		} aes_cmac;
		struct {
			u8 pn[6];
		} aes_gmac;
		struct {
			u8 pn[6];
		} gcmp;
		struct {
			u8 seq[16];
			u8 seq_len;
		} hw;
	};
};

struct ieee80211_cipher_scheme {
	u32 cipher;
	u16 iftype;
	u8 hdr_len;
	u8 pn_len;
	u8 pn_off;
	u8 key_idx_off;
	u8 key_idx_mask;
	u8 key_idx_shift;
	u8 mic_len;
};

enum set_key_cmd {
	SET_KEY = 0,
	DISABLE_KEY = 1,
};

enum ieee80211_sta_state {
	IEEE80211_STA_NOTEXIST = 0,
	IEEE80211_STA_NONE = 1,
	IEEE80211_STA_AUTH = 2,
	IEEE80211_STA_ASSOC = 3,
	IEEE80211_STA_AUTHORIZED = 4,
};

struct ieee80211_sta_rates {
	struct callback_head callback_head;
	struct {
		s8 idx;
		u8 count;
		u8 count_cts;
		u8 count_rts;
		u16 flags;
	} rate[4];
};

enum sta_notify_cmd {
	STA_NOTIFY_SLEEP = 0,
	STA_NOTIFY_AWAKE = 1,
};

struct ieee80211_tx_control {
	struct ieee80211_sta *sta;
};

enum ieee80211_hw_flags {
	IEEE80211_HW_HAS_RATE_CONTROL = 0,
	IEEE80211_HW_RX_INCLUDES_FCS = 1,
	IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING = 2,
	IEEE80211_HW_SIGNAL_UNSPEC = 3,
	IEEE80211_HW_SIGNAL_DBM = 4,
	IEEE80211_HW_NEED_DTIM_BEFORE_ASSOC = 5,
	IEEE80211_HW_SPECTRUM_MGMT = 6,
	IEEE80211_HW_AMPDU_AGGREGATION = 7,
	IEEE80211_HW_SUPPORTS_PS = 8,
	IEEE80211_HW_PS_NULLFUNC_STACK = 9,
	IEEE80211_HW_SUPPORTS_DYNAMIC_PS = 10,
	IEEE80211_HW_MFP_CAPABLE = 11,
	IEEE80211_HW_WANT_MONITOR_VIF = 12,
	IEEE80211_HW_NO_AUTO_VIF = 13,
	IEEE80211_HW_SW_CRYPTO_CONTROL = 14,
	IEEE80211_HW_SUPPORT_FAST_XMIT = 15,
	IEEE80211_HW_REPORTS_TX_ACK_STATUS = 16,
	IEEE80211_HW_CONNECTION_MONITOR = 17,
	IEEE80211_HW_QUEUE_CONTROL = 18,
	IEEE80211_HW_SUPPORTS_PER_STA_GTK = 19,
	IEEE80211_HW_AP_LINK_PS = 20,
	IEEE80211_HW_TX_AMPDU_SETUP_IN_HW = 21,
	IEEE80211_HW_SUPPORTS_RC_TABLE = 22,
	IEEE80211_HW_P2P_DEV_ADDR_FOR_INTF = 23,
	IEEE80211_HW_TIMING_BEACON_ONLY = 24,
	IEEE80211_HW_SUPPORTS_HT_CCK_RATES = 25,
	IEEE80211_HW_CHANCTX_STA_CSA = 26,
	IEEE80211_HW_SUPPORTS_CLONED_SKBS = 27,
	IEEE80211_HW_SINGLE_SCAN_ON_ALL_BANDS = 28,
	IEEE80211_HW_TDLS_WIDER_BW = 29,
	IEEE80211_HW_SUPPORTS_AMSDU_IN_AMPDU = 30,
	IEEE80211_HW_BEACON_TX_STATUS = 31,
	IEEE80211_HW_NEEDS_UNIQUE_STA_ADDR = 32,
	IEEE80211_HW_SUPPORTS_REORDERING_BUFFER = 33,
	IEEE80211_HW_USES_RSS = 34,
	IEEE80211_HW_TX_AMSDU = 35,
	IEEE80211_HW_TX_FRAG_LIST = 36,
	IEEE80211_HW_REPORTS_LOW_ACK = 37,
	IEEE80211_HW_SUPPORTS_TX_FRAG = 38,
	IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA = 39,
	IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP = 40,
	IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP = 41,
	IEEE80211_HW_BUFF_MMPDU_TXQ = 42,
	IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW = 43,
	IEEE80211_HW_STA_MMPDU_TXQ = 44,
	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN = 45,
	IEEE80211_HW_SUPPORTS_MULTI_BSSID = 46,
	IEEE80211_HW_SUPPORTS_ONLY_HE_MULTI_BSSID = 47,
	IEEE80211_HW_AMPDU_KEYBORDER_SUPPORT = 48,
	IEEE80211_HW_SUPPORTS_TX_ENCAP_OFFLOAD = 49,
	NUM_IEEE80211_HW_FLAGS = 50,
};

struct ieee80211_hw {
	struct ieee80211_conf conf;
	struct wiphy *wiphy;
	const char *rate_control_algorithm;
	void *priv;
	long unsigned int flags[2];
	unsigned int extra_tx_headroom;
	unsigned int extra_beacon_tailroom;
	int vif_data_size;
	int sta_data_size;
	int chanctx_data_size;
	int txq_data_size;
	u16 queues;
	u16 max_listen_interval;
	s8 max_signal;
	u8 max_rates;
	u8 max_report_rates;
	u8 max_rate_tries;
	u16 max_rx_aggregation_subframes;
	u16 max_tx_aggregation_subframes;
	u8 max_tx_fragments;
	u8 offchannel_tx_hw_queue;
	u8 radiotap_mcs_details;
	u16 radiotap_vht_details;
	struct {
		int units_pos;
		s16 accuracy;
	} radiotap_timestamp;
	netdev_features_t netdev_features;
	u8 uapsd_queues;
	u8 uapsd_max_sp_len;
	u8 n_cipher_schemes;
	const struct ieee80211_cipher_scheme *cipher_schemes;
	u8 max_nan_de_entries;
	u8 tx_sk_pacing_shift;
	u8 weight_multiplier;
	u32 max_mtu;
};

struct ieee80211_scan_request {
	struct ieee80211_scan_ies ies;
	struct cfg80211_scan_request req;
};

struct ieee80211_tdls_ch_sw_params {
	struct ieee80211_sta *sta;
	struct cfg80211_chan_def *chandef;
	u8 action_code;
	u32 status;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	struct sk_buff *tmpl_skb;
	u32 ch_sw_tm_ie;
};

enum ieee80211_filter_flags {
	FIF_ALLMULTI = 2,
	FIF_FCSFAIL = 4,
	FIF_PLCPFAIL = 8,
	FIF_BCN_PRBRESP_PROMISC = 16,
	FIF_CONTROL = 32,
	FIF_OTHER_BSS = 64,
	FIF_PSPOLL = 128,
	FIF_PROBE_REQ = 256,
	FIF_MCAST_ACTION = 512,
};

enum ieee80211_ampdu_mlme_action {
	IEEE80211_AMPDU_RX_START = 0,
	IEEE80211_AMPDU_RX_STOP = 1,
	IEEE80211_AMPDU_TX_START = 2,
	IEEE80211_AMPDU_TX_STOP_CONT = 3,
	IEEE80211_AMPDU_TX_STOP_FLUSH = 4,
	IEEE80211_AMPDU_TX_STOP_FLUSH_CONT = 5,
	IEEE80211_AMPDU_TX_OPERATIONAL = 6,
};

struct ieee80211_ampdu_params {
	enum ieee80211_ampdu_mlme_action action;
	struct ieee80211_sta *sta;
	u16 tid;
	u16 ssn;
	u16 buf_size;
	bool amsdu;
	u16 timeout;
};

enum ieee80211_frame_release_type {
	IEEE80211_FRAME_RELEASE_PSPOLL = 0,
	IEEE80211_FRAME_RELEASE_UAPSD = 1,
};

enum ieee80211_roc_type {
	IEEE80211_ROC_TYPE_NORMAL = 0,
	IEEE80211_ROC_TYPE_MGMT_TX = 1,
};

enum ieee80211_reconfig_type {
	IEEE80211_RECONFIG_TYPE_RESTART = 0,
	IEEE80211_RECONFIG_TYPE_SUSPEND = 1,
};

struct ieee80211_ops {
	void (*tx)(struct ieee80211_hw *, struct ieee80211_tx_control *, struct sk_buff *);
	int (*start)(struct ieee80211_hw *);
	void (*stop)(struct ieee80211_hw *);
	int (*suspend)(struct ieee80211_hw *, struct cfg80211_wowlan *);
	int (*resume)(struct ieee80211_hw *);
	void (*set_wakeup)(struct ieee80211_hw *, bool);
	int (*add_interface)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*change_interface)(struct ieee80211_hw *, struct ieee80211_vif *, enum nl80211_iftype, bool);
	void (*remove_interface)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*config)(struct ieee80211_hw *, u32);
	void (*bss_info_changed)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_bss_conf *, u32);
	int (*start_ap)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*stop_ap)(struct ieee80211_hw *, struct ieee80211_vif *);
	u64 (*prepare_multicast)(struct ieee80211_hw *, struct netdev_hw_addr_list *);
	void (*configure_filter)(struct ieee80211_hw *, unsigned int, unsigned int *, u64);
	void (*config_iface_filter)(struct ieee80211_hw *, struct ieee80211_vif *, unsigned int, unsigned int);
	int (*set_tim)(struct ieee80211_hw *, struct ieee80211_sta *, bool);
	int (*set_key)(struct ieee80211_hw *, enum set_key_cmd, struct ieee80211_vif *, struct ieee80211_sta *, struct ieee80211_key_conf *);
	void (*update_tkip_key)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32, u16 *);
	void (*set_rekey_data)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_gtk_rekey_data *);
	void (*set_default_unicast_key)(struct ieee80211_hw *, struct ieee80211_vif *, int);
	int (*hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_scan_request *);
	void (*cancel_hw_scan)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*sched_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_sched_scan_request *, struct ieee80211_scan_ies *);
	int (*sched_scan_stop)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*sw_scan_start)(struct ieee80211_hw *, struct ieee80211_vif *, const u8 *);
	void (*sw_scan_complete)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*get_stats)(struct ieee80211_hw *, struct ieee80211_low_level_stats *);
	void (*get_key_seq)(struct ieee80211_hw *, struct ieee80211_key_conf *, struct ieee80211_key_seq *);
	int (*set_frag_threshold)(struct ieee80211_hw *, u32);
	int (*set_rts_threshold)(struct ieee80211_hw *, u32);
	int (*sta_add)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	int (*sta_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_notify)(struct ieee80211_hw *, struct ieee80211_vif *, enum sta_notify_cmd, struct ieee80211_sta *);
	int (*sta_set_txpwr)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	int (*sta_state)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, enum ieee80211_sta_state, enum ieee80211_sta_state);
	void (*sta_pre_rcu_remove)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_rc_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u32);
	void (*sta_rate_tbl_update)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*sta_statistics)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct station_info *);
	int (*conf_tx)(struct ieee80211_hw *, struct ieee80211_vif *, u16, const struct ieee80211_tx_queue_params *);
	u64 (*get_tsf)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*set_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, u64);
	void (*offset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *, s64);
	void (*reset_tsf)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*tx_last_beacon)(struct ieee80211_hw *);
	int (*ampdu_action)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_ampdu_params *);
	int (*get_survey)(struct ieee80211_hw *, int, struct survey_info *);
	void (*rfkill_poll)(struct ieee80211_hw *);
	void (*set_coverage_class)(struct ieee80211_hw *, s16);
	void (*flush)(struct ieee80211_hw *, struct ieee80211_vif *, u32, bool);
	void (*channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*set_antenna)(struct ieee80211_hw *, u32, u32);
	int (*get_antenna)(struct ieee80211_hw *, u32 *, u32 *);
	int (*remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel *, int, enum ieee80211_roc_type);
	int (*cancel_remain_on_channel)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*set_ringparam)(struct ieee80211_hw *, u32, u32);
	void (*get_ringparam)(struct ieee80211_hw *, u32 *, u32 *, u32 *, u32 *);
	bool (*tx_frames_pending)(struct ieee80211_hw *);
	int (*set_bitrate_mask)(struct ieee80211_hw *, struct ieee80211_vif *, const struct cfg80211_bitrate_mask *);
	void (*event_callback)(struct ieee80211_hw *, struct ieee80211_vif *, const struct ieee80211_event *);
	void (*allow_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);
	void (*release_buffered_frames)(struct ieee80211_hw *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);
	int (*get_et_sset_count)(struct ieee80211_hw *, struct ieee80211_vif *, int);
	void (*get_et_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct ethtool_stats *, u64 *);
	void (*get_et_strings)(struct ieee80211_hw *, struct ieee80211_vif *, u32, u8 *);
	void (*mgd_prepare_tx)(struct ieee80211_hw *, struct ieee80211_vif *, u16);
	void (*mgd_protect_tdls_discover)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*add_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *);
	void (*remove_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *);
	void (*change_chanctx)(struct ieee80211_hw *, struct ieee80211_chanctx_conf *, u32);
	int (*assign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *);
	void (*unassign_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_chanctx_conf *);
	int (*switch_vif_chanctx)(struct ieee80211_hw *, struct ieee80211_vif_chanctx_switch *, int, enum ieee80211_chanctx_switch_mode);
	void (*reconfig_complete)(struct ieee80211_hw *, enum ieee80211_reconfig_type);
	void (*ipv6_addr_change)(struct ieee80211_hw *, struct ieee80211_vif *, struct inet6_dev *);
	void (*channel_switch_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_chan_def *);
	int (*pre_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*post_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*abort_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*channel_switch_rx_beacon)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_channel_switch *);
	int (*join_ibss)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*leave_ibss)(struct ieee80211_hw *, struct ieee80211_vif *);
	u32 (*get_expected_throughput)(struct ieee80211_hw *, struct ieee80211_sta *);
	int (*get_txpower)(struct ieee80211_hw *, struct ieee80211_vif *, int *);
	int (*tdls_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8, struct cfg80211_chan_def *, struct sk_buff *, u32);
	void (*tdls_cancel_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *);
	void (*tdls_recv_channel_switch)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_tdls_ch_sw_params *);
	void (*wake_tx_queue)(struct ieee80211_hw *, struct ieee80211_txq *);
	void (*sync_rx_queues)(struct ieee80211_hw *);
	int (*start_nan)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_nan_conf *);
	int (*stop_nan)(struct ieee80211_hw *, struct ieee80211_vif *);
	int (*nan_change_conf)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_nan_conf *, u32);
	int (*add_nan_func)(struct ieee80211_hw *, struct ieee80211_vif *, const struct cfg80211_nan_func *);
	void (*del_nan_func)(struct ieee80211_hw *, struct ieee80211_vif *, u8);
	bool (*can_aggregate_in_amsdu)(struct ieee80211_hw *, struct sk_buff *, struct sk_buff *);
	int (*get_ftm_responder_stats)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct ieee80211_hw *, struct ieee80211_vif *, struct cfg80211_pmsr_request *);
	int (*set_tid_config)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, u8);
	void (*update_vif_offload)(struct ieee80211_hw *, struct ieee80211_vif *);
	void (*sta_set_4addr)(struct ieee80211_hw *, struct ieee80211_vif *, struct ieee80211_sta *, bool);
	int (*set_sar_specs)(struct ieee80211_hw *, const struct cfg80211_sar_specs *);
};

struct ieee80211_tx_rate_control {
	struct ieee80211_hw *hw;
	struct ieee80211_supported_band *sband;
	struct ieee80211_bss_conf *bss_conf;
	struct sk_buff *skb;
	struct ieee80211_tx_rate reported_rate;
	bool rts;
	bool short_preamble;
	u32 rate_idx_mask;
	u8 *rate_idx_mcs_mask;
	bool bss;
};

enum rate_control_capabilities {
	RATE_CTRL_CAPA_VHT_EXT_NSS_BW = 1,
};

struct rate_control_ops {
	long unsigned int capa;
	const char *name;
	void * (*alloc)(struct ieee80211_hw *);
	void (*add_debugfs)(struct ieee80211_hw *, void *, struct dentry *);
	void (*free)(void *);
	void * (*alloc_sta)(void *, struct ieee80211_sta *, gfp_t);
	void (*rate_init)(void *, struct ieee80211_supported_band *, struct cfg80211_chan_def *, struct ieee80211_sta *, void *);
	void (*rate_update)(void *, struct ieee80211_supported_band *, struct cfg80211_chan_def *, struct ieee80211_sta *, void *, u32);
	void (*free_sta)(void *, struct ieee80211_sta *, void *);
	void (*tx_status_ext)(void *, struct ieee80211_supported_band *, void *, struct ieee80211_tx_status *);
	void (*tx_status)(void *, struct ieee80211_supported_band *, struct ieee80211_sta *, void *, struct sk_buff *);
	void (*get_rate)(void *, struct ieee80211_sta *, void *, struct ieee80211_tx_rate_control *);
	void (*add_sta_debugfs)(void *, void *, struct dentry *);
	u32 (*get_expected_throughput)(void *);
};

struct fq_tin;

struct fq_flow {
	struct fq_tin *tin;
	struct list_head flowchain;
	struct list_head backlogchain;
	struct sk_buff_head queue;
	u32 backlog;
	int deficit;
};

struct fq_tin {
	struct list_head new_flows;
	struct list_head old_flows;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 overlimit;
	u32 collisions;
	u32 flows;
	u32 tx_bytes;
	u32 tx_packets;
};

struct fq {
	struct fq_flow *flows;
	struct list_head backlogs;
	spinlock_t lock;
	u32 flows_cnt;
	u32 limit;
	u32 memory_limit;
	u32 memory_usage;
	u32 quantum;
	u32 backlog;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
};

enum ieee80211_internal_tkip_state {
	TKIP_STATE_NOT_INIT = 0,
	TKIP_STATE_PHASE1_DONE = 1,
	TKIP_STATE_PHASE1_HW_UPLOADED = 2,
};

struct tkip_ctx {
	u16 p1k[5];
	u32 p1k_iv32;
	enum ieee80211_internal_tkip_state state;
};

struct tkip_ctx_rx {
	struct tkip_ctx ctx;
	u32 iv32;
	u16 iv16;
};

struct ieee80211_local;

struct ieee80211_sub_if_data;

struct sta_info;

struct ieee80211_key {
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct list_head list;
	unsigned int flags;
	union {
		struct {
			spinlock_t txlock;
			struct tkip_ctx tx;
			struct tkip_ctx_rx rx[16];
			u32 mic_failures;
		} tkip;
		struct {
			u8 rx_pn[102];
			struct crypto_aead *tfm;
			u32 replays;
		} ccmp;
		struct {
			u8 rx_pn[6];
			struct crypto_shash *tfm;
			u32 replays;
			u32 icverrors;
		} aes_cmac;
		struct {
			u8 rx_pn[6];
			struct crypto_aead *tfm;
			u32 replays;
			u32 icverrors;
		} aes_gmac;
		struct {
			u8 rx_pn[102];
			struct crypto_aead *tfm;
			u32 replays;
		} gcmp;
		struct {
			u8 rx_pn[272];
		} gen;
	} u;
	int: 32;
	struct ieee80211_key_conf conf;
};

enum mac80211_scan_state {
	SCAN_DECISION = 0,
	SCAN_SET_CHANNEL = 1,
	SCAN_SEND_PROBE = 2,
	SCAN_SUSPEND = 3,
	SCAN_RESUME = 4,
	SCAN_ABORT = 5,
};

struct rate_control_ref;

struct ieee80211_local {
	struct ieee80211_hw hw;
	struct fq fq;
	struct codel_vars *cvars;
	struct codel_params cparams;
	spinlock_t active_txq_lock[4];
	struct list_head active_txqs[4];
	u16 schedule_round[4];
	u16 airtime_flags;
	u32 aql_txq_limit_low[4];
	u32 aql_txq_limit_high[4];
	u32 aql_threshold;
	atomic_t aql_total_pending_airtime;
	const struct ieee80211_ops *ops;
	struct workqueue_struct *workqueue;
	long unsigned int queue_stop_reasons[16];
	int q_stop_reasons[176];
	spinlock_t queue_stop_reason_lock;
	int open_count;
	int monitors;
	int cooked_mntrs;
	int fif_fcsfail;
	int fif_plcpfail;
	int fif_control;
	int fif_other_bss;
	int fif_pspoll;
	int fif_probe_req;
	bool probe_req_reg;
	bool rx_mcast_action_reg;
	unsigned int filter_flags;
	bool wiphy_ciphers_allocated;
	bool use_chanctx;
	spinlock_t filter_lock;
	struct work_struct reconfig_filter;
	struct netdev_hw_addr_list mc_list;
	bool tim_in_locked_section;
	bool suspended;
	bool resuming;
	bool quiescing;
	bool started;
	bool in_reconfig;
	bool wowlan;
	struct work_struct radar_detected_work;
	u8 rx_chains;
	u8 sband_allocated;
	int tx_headroom;
	struct tasklet_struct tasklet;
	struct sk_buff_head skb_queue;
	struct sk_buff_head skb_queue_unreliable;
	spinlock_t rx_path_lock;
	struct mutex sta_mtx;
	spinlock_t tim_lock;
	long unsigned int num_sta;
	struct list_head sta_list;
	struct rhltable sta_hash;
	struct timer_list sta_cleanup;
	int sta_generation;
	struct sk_buff_head pending[16];
	struct tasklet_struct tx_pending_tasklet;
	struct tasklet_struct wake_txqs_tasklet;
	atomic_t agg_queue_stop[16];
	atomic_t iff_allmultis;
	struct rate_control_ref *rate_ctrl;
	struct arc4_ctx wep_tx_ctx;
	struct arc4_ctx wep_rx_ctx;
	u32 wep_iv;
	struct list_head interfaces;
	struct list_head mon_list;
	struct mutex iflist_mtx;
	struct mutex key_mtx;
	struct mutex mtx;
	long unsigned int scanning;
	struct cfg80211_ssid scan_ssid;
	struct cfg80211_scan_request *int_scan_req;
	struct cfg80211_scan_request *scan_req;
	struct ieee80211_scan_request *hw_scan_req;
	struct cfg80211_chan_def scan_chandef;
	enum nl80211_band hw_scan_band;
	int scan_channel_idx;
	int scan_ies_len;
	int hw_scan_ies_bufsize;
	int: 32;
	struct cfg80211_scan_info scan_info;
	struct work_struct sched_scan_stopped_work;
	struct ieee80211_sub_if_data *sched_scan_sdata;
	struct cfg80211_sched_scan_request *sched_scan_req;
	u8 scan_addr[6];
	long unsigned int leave_oper_channel_time;
	enum mac80211_scan_state next_scan_state;
	struct delayed_work scan_work;
	struct ieee80211_sub_if_data *scan_sdata;
	struct cfg80211_chan_def _oper_chandef;
	struct ieee80211_channel *tmp_channel;
	struct list_head chanctx_list;
	struct mutex chanctx_mtx;
	int total_ps_buffered;
	bool pspolling;
	struct ieee80211_sub_if_data *ps_sdata;
	struct work_struct dynamic_ps_enable_work;
	struct work_struct dynamic_ps_disable_work;
	struct timer_list dynamic_ps_timer;
	struct notifier_block ifa_notifier;
	struct notifier_block ifa6_notifier;
	int dynamic_ps_forced_timeout;
	int user_power_level;
	enum ieee80211_smps_mode smps_mode;
	struct work_struct restart_work;
	struct delayed_work roc_work;
	struct list_head roc_list;
	struct work_struct hw_roc_start;
	struct work_struct hw_roc_done;
	long unsigned int hw_roc_start_time;
	u64 roc_cookie_counter;
	struct idr ack_status_frames;
	spinlock_t ack_status_lock;
	struct ieee80211_sub_if_data *p2p_sdata;
	struct ieee80211_sub_if_data *monitor_sdata;
	struct cfg80211_chan_def monitor_chandef;
	u8 ext_capa[8];
	struct work_struct tdls_chsw_work;
	struct sk_buff_head skb_queue_tdls_chsw;
	int: 32;
};

struct ieee80211_fragment_entry {
	struct sk_buff_head skb_list;
	long unsigned int first_frag_time;
	u16 seq;
	u16 extra_len;
	u16 last_frag;
	u8 rx_queue;
	bool check_sequential_pn;
	u8 last_pn[6];
};

struct ps_data {
	u8 tim[252];
	struct sk_buff_head bc_buf;
	atomic_t num_sta_ps;
	int dtim_count;
	bool dtim_bc_mc;
};

struct beacon_data;

struct probe_resp;

struct fils_discovery_data;

struct unsol_bcast_probe_resp_data;

struct ieee80211_if_ap {
	struct beacon_data *beacon;
	struct probe_resp *probe_resp;
	struct fils_discovery_data *fils_discovery;
	struct unsol_bcast_probe_resp_data *unsol_bcast_probe_resp;
	struct cfg80211_beacon_data *next_beacon;
	struct list_head vlans;
	struct ps_data ps;
	atomic_t num_mcast_sta;
	bool multicast_to_unicast;
};

struct ieee80211_if_vlan {
	struct list_head list;
	struct sta_info *sta;
	atomic_t num_mcast_sta;
};

struct ewma_beacon_signal {
	long unsigned int internal;
};

struct ieee80211_sta_tx_tspec {
	long unsigned int time_slice_start;
	u32 admitted_time;
	u8 tsid;
	s8 up;
	u32 consumed_tx_time;
	enum {
		TX_TSPEC_ACTION_NONE = 0,
		TX_TSPEC_ACTION_DOWNGRADE = 1,
		TX_TSPEC_ACTION_STOP_DOWNGRADE = 2,
	} action;
	bool downgraded;
};

struct ieee80211_mgd_auth_data;

struct ieee80211_mgd_assoc_data;

struct ieee80211_if_managed {
	struct timer_list timer;
	struct timer_list conn_mon_timer;
	struct timer_list bcn_mon_timer;
	struct timer_list chswitch_timer;
	struct work_struct monitor_work;
	struct work_struct chswitch_work;
	struct work_struct beacon_connection_loss_work;
	struct work_struct csa_connection_drop_work;
	long unsigned int beacon_timeout;
	long unsigned int probe_timeout;
	int probe_send_count;
	bool nullfunc_failed;
	u8 connection_loss: 1;
	u8 driver_disconnect: 1;
	u8 reconnect: 1;
	int: 21;
	struct cfg80211_bss *associated;
	struct ieee80211_mgd_auth_data *auth_data;
	struct ieee80211_mgd_assoc_data *assoc_data;
	u8 bssid[6];
	bool powersave;
	bool broken_ap;
	bool have_beacon;
	u8 dtim_period;
	short: 16;
	enum ieee80211_smps_mode req_smps;
	enum ieee80211_smps_mode driver_smps_mode;
	struct work_struct request_smps_work;
	unsigned int flags;
	bool csa_waiting_bcn;
	bool csa_ignored_same_chan;
	bool beacon_crc_valid;
	char: 8;
	u32 beacon_crc;
	bool status_acked;
	bool status_received;
	__le16 status_fc;
	enum {
		IEEE80211_MFP_DISABLED = 0,
		IEEE80211_MFP_OPTIONAL = 1,
		IEEE80211_MFP_REQUIRED = 2,
	} mfp;
	unsigned int uapsd_queues;
	unsigned int uapsd_max_sp_len;
	int wmm_last_param_set;
	int mu_edca_last_param_set;
	u8 use_4addr;
	char: 8;
	s16 p2p_noa_index;
	struct ewma_beacon_signal ave_beacon_signal;
	unsigned int count_beacon_signal;
	unsigned int beacon_loss_count;
	int last_cqm_event_signal;
	int rssi_min_thold;
	int rssi_max_thold;
	int last_ave_beacon_signal;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	u8 tdls_peer[6];
	struct delayed_work tdls_peer_del_work;
	struct sk_buff *orig_teardown_skb;
	struct sk_buff *teardown_skb;
	spinlock_t teardown_lock;
	bool tdls_chan_switch_prohibited;
	bool tdls_wider_bw_prohibited;
	short: 16;
	struct ieee80211_sta_tx_tspec tx_tspec[4];
	struct delayed_work tx_tspec_wk;
	u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
} __attribute__((packed));

struct ieee80211_if_ibss {
	struct timer_list timer;
	struct work_struct csa_connection_drop_work;
	long unsigned int last_scan_completed;
	u32 basic_rates;
	bool fixed_bssid;
	bool fixed_channel;
	bool privacy;
	bool control_port;
	bool userspace_handles_dfs;
	char: 8;
	u8 bssid[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 ie_len;
	short: 16;
	u8 *ie;
	struct cfg80211_chan_def chandef;
	long unsigned int ibss_join_req;
	struct beacon_data *presp;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	spinlock_t incomplete_lock;
	struct list_head incomplete_stations;
	enum {
		IEEE80211_IBSS_MLME_SEARCH = 0,
		IEEE80211_IBSS_MLME_JOINED = 1,
	} state;
} __attribute__((packed));

struct mesh_preq_queue {
	struct list_head list;
	u8 dst[6];
	u8 flags;
};

struct mesh_stats {
	__u32 fwded_mcast;
	__u32 fwded_unicast;
	__u32 fwded_frames;
	__u32 dropped_frames_ttl;
	__u32 dropped_frames_no_route;
	__u32 dropped_frames_congestion;
};

struct mesh_rmc;

struct ieee80211_mesh_sync_ops;

struct mesh_csa_settings;

struct mesh_table;

struct ieee80211_if_mesh {
	struct timer_list housekeeping_timer;
	struct timer_list mesh_path_timer;
	struct timer_list mesh_path_root_timer;
	long unsigned int wrkq_flags;
	long unsigned int mbss_changed;
	bool userspace_handles_dfs;
	u8 mesh_id[32];
	size_t mesh_id_len;
	u8 mesh_pp_id;
	u8 mesh_pm_id;
	u8 mesh_cc_id;
	u8 mesh_sp_id;
	u8 mesh_auth_id;
	u32 sn;
	u32 preq_id;
	atomic_t mpaths;
	long unsigned int last_sn_update;
	long unsigned int next_perr;
	long unsigned int last_preq;
	struct mesh_rmc *rmc;
	spinlock_t mesh_preq_queue_lock;
	struct mesh_preq_queue preq_queue;
	int preq_queue_len;
	struct mesh_stats mshstats;
	struct mesh_config mshcfg;
	atomic_t estab_plinks;
	u32 mesh_seqnum;
	bool accepting_plinks;
	int num_gates;
	struct beacon_data *beacon;
	const u8 *ie;
	u8 ie_len;
	enum {
		IEEE80211_MESH_SEC_NONE = 0,
		IEEE80211_MESH_SEC_AUTHED = 1,
		IEEE80211_MESH_SEC_SECURED = 2,
	} security;
	bool user_mpm;
	const struct ieee80211_mesh_sync_ops *sync_ops;
	s64 sync_offset_clockdrift_max;
	spinlock_t sync_offset_lock;
	enum nl80211_mesh_power_mode nonpeer_pm;
	int ps_peers_light_sleep;
	int ps_peers_deep_sleep;
	struct ps_data ps;
	struct mesh_csa_settings *csa;
	enum {
		IEEE80211_MESH_CSA_ROLE_NONE = 0,
		IEEE80211_MESH_CSA_ROLE_INIT = 1,
		IEEE80211_MESH_CSA_ROLE_REPEATER = 2,
	} csa_role;
	u8 chsw_ttl;
	u16 pre_value;
	int meshconf_offset;
	struct mesh_table *mesh_paths;
	struct mesh_table *mpp_paths;
	int mesh_paths_generation;
	int mpp_paths_generation;
};

struct ieee80211_if_ocb {
	struct timer_list housekeeping_timer;
	long unsigned int wrkq_flags;
	spinlock_t incomplete_lock;
	struct list_head incomplete_stations;
	bool joined;
};

struct ieee80211_if_mntr {
	u32 flags;
	u8 mu_follow_addr[6];
	struct list_head list;
};

struct ieee80211_if_nan {
	struct cfg80211_nan_conf conf;
	spinlock_t func_lock;
	struct idr function_inst_ids;
};

struct mac80211_qos_map;

struct ieee80211_chanctx;

struct ieee80211_sub_if_data {
	struct list_head list;
	struct wireless_dev wdev;
	struct list_head key_list;
	int crypto_tx_tailroom_needed_cnt;
	int crypto_tx_tailroom_pending_dec;
	struct delayed_work dec_tailroom_needed_wk;
	struct net_device *dev;
	struct ieee80211_local *local;
	unsigned int flags;
	long unsigned int state;
	char name[16];
	struct ieee80211_fragment_entry fragments[4];
	unsigned int fragment_next;
	u16 noack_map;
	u8 wmm_acm;
	struct ieee80211_key *keys[8];
	struct ieee80211_key *default_unicast_key;
	struct ieee80211_key *default_multicast_key;
	struct ieee80211_key *default_mgmt_key;
	struct ieee80211_key *default_beacon_key;
	u16 sequence_number;
	__be16 control_port_protocol;
	bool control_port_no_encrypt;
	bool control_port_no_preauth;
	bool control_port_over_nl80211;
	int encrypt_headroom;
	atomic_t num_tx_queued;
	struct ieee80211_tx_queue_params tx_conf[4];
	struct mac80211_qos_map *qos_map;
	struct work_struct csa_finalize_work;
	bool csa_block_tx;
	struct cfg80211_chan_def csa_chandef;
	struct list_head assigned_chanctx_list;
	struct list_head reserved_chanctx_list;
	struct ieee80211_chanctx *reserved_chanctx;
	struct cfg80211_chan_def reserved_chandef;
	bool reserved_radar_required;
	bool reserved_ready;
	struct work_struct recalc_smps;
	struct work_struct work;
	struct sk_buff_head skb_queue;
	u8 needed_rx_chains;
	enum ieee80211_smps_mode smps_mode;
	int user_power_level;
	int ap_power_level;
	bool radar_required;
	struct delayed_work dfs_cac_timer_work;
	struct ieee80211_if_ap *bss;
	u32 rc_rateidx_mask[5];
	bool rc_has_mcs_mask[5];
	u8 rc_rateidx_mcs_mask[50];
	bool rc_has_vht_mcs_mask[5];
	u16 rc_rateidx_vht_mcs_mask[40];
	u32 beacon_rateidx_mask[5];
	bool beacon_rate_set;
	int: 24;
	int: 32;
	union {
		struct ieee80211_if_ap ap;
		struct ieee80211_if_vlan vlan;
		struct ieee80211_if_managed mgd;
		struct ieee80211_if_ibss ibss;
		struct ieee80211_if_mesh mesh;
		struct ieee80211_if_ocb ocb;
		struct ieee80211_if_mntr mntr;
		struct ieee80211_if_nan nan;
	} u;
	struct ieee80211_vif vif;
};

struct ieee80211_sta_rx_stats {
	long unsigned int packets;
	long unsigned int last_rx;
	long unsigned int num_duplicates;
	long unsigned int fragments;
	long unsigned int dropped;
	int last_signal;
	u8 chains;
	s8 chain_signal_last[4];
	u32 last_rate;
	struct u64_stats_sync syncp;
	u64 bytes;
	u64 msdu[17];
};

struct ewma_signal {
	long unsigned int internal;
};

struct ewma_avg_signal {
	long unsigned int internal;
};

struct airtime_info {
	u64 rx_airtime;
	u64 tx_airtime;
	s64 deficit;
	atomic_t aql_tx_pending;
	u32 aql_limit_low;
	u32 aql_limit_high;
	int: 32;
};

struct tid_ampdu_rx;

struct tid_ampdu_tx;

struct sta_ampdu_mlme {
	struct mutex mtx;
	struct tid_ampdu_rx *tid_rx[16];
	u8 tid_rx_token[16];
	long unsigned int tid_rx_timer_expired[1];
	long unsigned int tid_rx_stop_requested[1];
	long unsigned int tid_rx_manage_offl[1];
	long unsigned int agg_session_valid[1];
	long unsigned int unexpected_agg[1];
	struct work_struct work;
	struct tid_ampdu_tx *tid_tx[16];
	struct tid_ampdu_tx *tid_start_tx[16];
	long unsigned int last_addba_req_time[16];
	u8 addba_req_num[16];
	u8 dialog_token_allocator;
};

struct ieee80211_fast_tx;

struct ieee80211_fast_rx;

struct sta_info {
	struct list_head list;
	struct list_head free_list;
	struct callback_head callback_head;
	struct rhlist_head hash_node;
	u8 addr[6];
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_key *gtk[8];
	struct ieee80211_key *ptk[4];
	u8 ptk_idx;
	struct rate_control_ref *rate_ctrl;
	void *rate_ctrl_priv;
	spinlock_t rate_ctrl_lock;
	spinlock_t lock;
	struct ieee80211_fast_tx *fast_tx;
	struct ieee80211_fast_rx *fast_rx;
	struct ieee80211_sta_rx_stats *pcpu_rx_stats;
	struct work_struct drv_deliver_wk;
	u16 listen_interval;
	bool dead;
	bool removed;
	bool uploaded;
	enum ieee80211_sta_state sta_state;
	long unsigned int _flags;
	spinlock_t ps_lock;
	struct sk_buff_head ps_tx_buf[4];
	struct sk_buff_head tx_filtered[4];
	long unsigned int driver_buffered_tids;
	long unsigned int txq_buffered_tids;
	int: 32;
	u64 assoc_at;
	long int last_connected;
	int: 32;
	struct ieee80211_sta_rx_stats rx_stats;
	struct {
		struct ewma_signal signal;
		struct ewma_signal chain_signal[4];
	} rx_stats_avg;
	__le16 last_seq_ctrl[17];
	struct {
		long unsigned int filtered;
		long unsigned int retry_failed;
		long unsigned int retry_count;
		unsigned int lost_packets;
		long unsigned int last_pkt_time;
		int: 32;
		u64 msdu_retries[17];
		u64 msdu_failed[17];
		long unsigned int last_ack;
		s8 last_ack_signal;
		bool ack_signal_filled;
		struct ewma_avg_signal avg_ack_signal;
		int: 32;
	} status_stats;
	struct {
		u64 packets[4];
		u64 bytes[4];
		struct ieee80211_tx_rate last_rate;
		struct rate_info last_rate_info;
		u64 msdu[17];
	} tx_stats;
	u16 tid_seq[16];
	struct airtime_info airtime[4];
	u16 airtime_weight;
	struct sta_ampdu_mlme ampdu_mlme;
	enum ieee80211_sta_rx_bandwidth cur_max_bandwidth;
	enum ieee80211_smps_mode known_smps_mode;
	const struct ieee80211_cipher_scheme *cipher_scheme;
	struct codel_params cparams;
	u8 reserved_tid;
	struct cfg80211_chan_def tdls_chandef;
	struct ieee80211_sta sta;
};

struct tid_ampdu_tx {
	struct callback_head callback_head;
	struct timer_list session_timer;
	struct timer_list addba_resp_timer;
	struct sk_buff_head pending;
	struct sta_info *sta;
	long unsigned int state;
	long unsigned int last_tx;
	u16 timeout;
	u8 dialog_token;
	u8 stop_initiator;
	bool tx_stop;
	u16 buf_size;
	u16 failed_bar_ssn;
	bool bar_pending;
	bool amsdu;
	u8 tid;
};

struct tid_ampdu_rx {
	struct callback_head callback_head;
	spinlock_t reorder_lock;
	int: 32;
	u64 reorder_buf_filtered;
	struct sk_buff_head *reorder_buf;
	long unsigned int *reorder_time;
	struct sta_info *sta;
	struct timer_list session_timer;
	struct timer_list reorder_timer;
	long unsigned int last_rx;
	u16 head_seq_num;
	u16 stored_mpdu_num;
	u16 ssn;
	u16 buf_size;
	u16 timeout;
	u8 tid;
	u8 auto_seq: 1;
	u8 removed: 1;
	u8 started: 1;
	int: 5;
	int: 32;
};

struct ieee80211_fast_tx {
	struct ieee80211_key *key;
	u8 hdr_len;
	u8 sa_offs;
	u8 da_offs;
	u8 pn_offs;
	u8 band;
	char: 8;
	u8 hdr[56];
	struct callback_head callback_head;
};

struct ieee80211_fast_rx {
	struct net_device *dev;
	enum nl80211_iftype vif_type;
	u8 vif_addr[6];
	u8 rfc1042_hdr[6];
	__be16 control_port_protocol;
	__le16 expected_ds_bits;
	u8 icv_len;
	u8 key: 1;
	u8 internal_forward: 1;
	u8 uses_rss: 1;
	u8 da_offs;
	u8 sa_offs;
	struct callback_head callback_head;
};

struct rate_control_ref {
	const struct rate_control_ops *ops;
	void *priv;
};

struct beacon_data {
	u8 *head;
	u8 *tail;
	int head_len;
	int tail_len;
	struct ieee80211_meshconf_ie *meshconf;
	u16 cntdwn_counter_offsets[2];
	u8 cntdwn_current_counter;
	struct callback_head callback_head;
};

struct probe_resp {
	struct callback_head callback_head;
	int len;
	u16 cntdwn_counter_offsets[2];
	u8 data[0];
};

struct fils_discovery_data {
	struct callback_head callback_head;
	int len;
	u8 data[0];
};

struct unsol_bcast_probe_resp_data {
	struct callback_head callback_head;
	int len;
	u8 data[0];
};

struct ieee80211_mgd_auth_data {
	struct cfg80211_bss *bss;
	long unsigned int timeout;
	int tries;
	u16 algorithm;
	u16 expected_transaction;
	u8 key[13];
	u8 key_len;
	u8 key_idx;
	bool done;
	bool peer_confirmed;
	bool timeout_started;
	u16 sae_trans;
	u16 sae_status;
	size_t data_len;
	u8 data[0];
};

struct ieee80211_mgd_assoc_data {
	struct cfg80211_bss *bss;
	const u8 *supp_rates;
	long unsigned int timeout;
	int tries;
	u16 capability;
	u8 prev_bssid[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 supp_rates_len;
	bool wmm;
	bool uapsd;
	bool need_beacon;
	bool synced;
	bool timeout_started;
	u8 ap_ht_param;
	struct ieee80211_vht_cap ap_vht_cap;
	u8 fils_nonces[32];
	u8 fils_kek[64];
	size_t fils_kek_len;
	size_t ie_len;
	u8 ie[0];
};

struct ieee802_11_elems;

struct ieee80211_mesh_sync_ops {
	void (*rx_bcn_presp)(struct ieee80211_sub_if_data *, u16, struct ieee80211_mgmt *, struct ieee802_11_elems *, struct ieee80211_rx_status *);
	void (*adjust_tsf)(struct ieee80211_sub_if_data *, struct beacon_data *);
};

struct ieee802_11_elems {
	const u8 *ie_start;
	size_t total_len;
	const struct ieee80211_tdls_lnkie *lnk_id;
	const struct ieee80211_ch_switch_timing *ch_sw_timing;
	const u8 *ext_capab;
	const u8 *ssid;
	const u8 *supp_rates;
	const u8 *ds_params;
	const struct ieee80211_tim_ie *tim;
	const u8 *challenge;
	const u8 *rsn;
	const u8 *rsnx;
	const u8 *erp_info;
	const u8 *ext_supp_rates;
	const u8 *wmm_info;
	const u8 *wmm_param;
	const struct ieee80211_ht_cap *ht_cap_elem;
	const struct ieee80211_ht_operation *ht_operation;
	const struct ieee80211_vht_cap *vht_cap_elem;
	const struct ieee80211_vht_operation *vht_operation;
	const struct ieee80211_meshconf_ie *mesh_config;
	const u8 *he_cap;
	const struct ieee80211_he_operation *he_operation;
	const struct ieee80211_he_spr *he_spr;
	const struct ieee80211_mu_edca_param_set *mu_edca_param_set;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
	const u8 *uora_element;
	const u8 *mesh_id;
	const u8 *peering;
	const __le16 *awake_window;
	const u8 *preq;
	const u8 *prep;
	const u8 *perr;
	const struct ieee80211_rann_ie *rann;
	const struct ieee80211_channel_sw_ie *ch_switch_ie;
	const struct ieee80211_ext_chansw_ie *ext_chansw_ie;
	const struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;
	const u8 *max_channel_switch_time;
	const u8 *country_elem;
	const u8 *pwr_constr_elem;
	const u8 *cisco_dtpc_elem;
	const struct ieee80211_timeout_interval_ie *timeout_int;
	const u8 *opmode_notif;
	const struct ieee80211_sec_chan_offs_ie *sec_chan_offs;
	struct ieee80211_mesh_chansw_params_ie *mesh_chansw_params_ie;
	const struct ieee80211_bss_max_idle_period_ie *max_idle_period_ie;
	const struct ieee80211_multiple_bssid_configuration *mbssid_config_ie;
	const struct ieee80211_bssid_index *bssid_index;
	u8 max_bssid_indicator;
	u8 dtim_count;
	u8 dtim_period;
	const struct ieee80211_addba_ext_ie *addba_ext_ie;
	const struct ieee80211_s1g_cap *s1g_capab;
	const struct ieee80211_s1g_oper_ie *s1g_oper;
	const struct ieee80211_s1g_bcn_compat_ie *s1g_bcn_compat;
	const struct ieee80211_aid_response_ie *aid_resp;
	u8 ext_capab_len;
	u8 ssid_len;
	u8 supp_rates_len;
	u8 tim_len;
	u8 challenge_len;
	u8 rsn_len;
	u8 rsnx_len;
	u8 ext_supp_rates_len;
	u8 wmm_info_len;
	u8 wmm_param_len;
	u8 he_cap_len;
	u8 mesh_id_len;
	u8 peering_len;
	u8 preq_len;
	u8 prep_len;
	u8 perr_len;
	u8 country_elem_len;
	u8 bssid_index_len;
	bool parse_error;
};

struct mesh_csa_settings {
	struct callback_head callback_head;
	struct cfg80211_csa_settings settings;
};

struct mesh_rmc {
	struct hlist_head bucket[256];
	u32 idx_mask;
};

struct mesh_table {
	struct hlist_head known_gates;
	spinlock_t gates_lock;
	struct rhashtable rhead;
	struct hlist_head walk_head;
	spinlock_t walk_lock;
	atomic_t entries;
};

enum ieee80211_sub_if_data_flags {
	IEEE80211_SDATA_ALLMULTI = 1,
	IEEE80211_SDATA_OPERATING_GMODE = 4,
	IEEE80211_SDATA_DONT_BRIDGE_PACKETS = 8,
	IEEE80211_SDATA_DISCONNECT_RESUME = 16,
	IEEE80211_SDATA_IN_DRIVER = 32,
};

enum ieee80211_chanctx_mode {
	IEEE80211_CHANCTX_SHARED = 0,
	IEEE80211_CHANCTX_EXCLUSIVE = 1,
};

enum ieee80211_chanctx_replace_state {
	IEEE80211_CHANCTX_REPLACE_NONE = 0,
	IEEE80211_CHANCTX_WILL_BE_REPLACED = 1,
	IEEE80211_CHANCTX_REPLACES_OTHER = 2,
};

struct ieee80211_chanctx {
	struct list_head list;
	struct callback_head callback_head;
	struct list_head assigned_vifs;
	struct list_head reserved_vifs;
	enum ieee80211_chanctx_replace_state replace_state;
	struct ieee80211_chanctx *replace_ctx;
	enum ieee80211_chanctx_mode mode;
	bool driver_present;
	struct ieee80211_chanctx_conf conf;
};

struct mac80211_qos_map {
	struct cfg80211_qos_map qos_map;
	struct callback_head callback_head;
};

enum {
	IEEE80211_RX_MSG = 1,
	IEEE80211_TX_STATUS_MSG = 2,
};

enum queue_stop_reason {
	IEEE80211_QUEUE_STOP_REASON_DRIVER = 0,
	IEEE80211_QUEUE_STOP_REASON_PS = 1,
	IEEE80211_QUEUE_STOP_REASON_CSA = 2,
	IEEE80211_QUEUE_STOP_REASON_AGGREGATION = 3,
	IEEE80211_QUEUE_STOP_REASON_SUSPEND = 4,
	IEEE80211_QUEUE_STOP_REASON_SKB_ADD = 5,
	IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL = 6,
	IEEE80211_QUEUE_STOP_REASON_FLUSH = 7,
	IEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN = 8,
	IEEE80211_QUEUE_STOP_REASON_RESERVE_TID = 9,
	IEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE = 10,
	IEEE80211_QUEUE_STOP_REASONS = 11,
};

enum {
	SCAN_SW_SCANNING = 0,
	SCAN_HW_SCANNING = 1,
	SCAN_ONCHANNEL_SCANNING = 2,
	SCAN_COMPLETED = 3,
	SCAN_ABORTED = 4,
	SCAN_HW_CANCELLED = 5,
};

struct ieee80211_bar {
	__le16 frame_control;
	__le16 duration;
	__u8 ra[6];
	__u8 ta[6];
	__le16 control;
	__le16 start_seq_num;
};

enum ieee80211_ht_actioncode {
	WLAN_HT_ACTION_NOTIFY_CHANWIDTH = 0,
	WLAN_HT_ACTION_SMPS = 1,
	WLAN_HT_ACTION_PSMP = 2,
	WLAN_HT_ACTION_PCO_PHASE = 3,
	WLAN_HT_ACTION_CSI = 4,
	WLAN_HT_ACTION_NONCOMPRESSED_BF = 5,
	WLAN_HT_ACTION_COMPRESSED_BF = 6,
	WLAN_HT_ACTION_ASEL_IDX_FEEDBACK = 7,
};

enum ieee80211_tdls_actioncode {
	WLAN_TDLS_SETUP_REQUEST = 0,
	WLAN_TDLS_SETUP_RESPONSE = 1,
	WLAN_TDLS_SETUP_CONFIRM = 2,
	WLAN_TDLS_TEARDOWN = 3,
	WLAN_TDLS_PEER_TRAFFIC_INDICATION = 4,
	WLAN_TDLS_CHANNEL_SWITCH_REQUEST = 5,
	WLAN_TDLS_CHANNEL_SWITCH_RESPONSE = 6,
	WLAN_TDLS_PEER_PSM_REQUEST = 7,
	WLAN_TDLS_PEER_PSM_RESPONSE = 8,
	WLAN_TDLS_PEER_TRAFFIC_RESPONSE = 9,
	WLAN_TDLS_DISCOVERY_REQUEST = 10,
};

enum ieee80211_radiotap_tx_flags {
	IEEE80211_RADIOTAP_F_TX_FAIL = 1,
	IEEE80211_RADIOTAP_F_TX_CTS = 2,
	IEEE80211_RADIOTAP_F_TX_RTS = 4,
	IEEE80211_RADIOTAP_F_TX_NOACK = 8,
	IEEE80211_RADIOTAP_F_TX_NOSEQNO = 16,
	IEEE80211_RADIOTAP_F_TX_ORDER = 32,
};

enum ieee80211_radiotap_mcs_flags {
	IEEE80211_RADIOTAP_MCS_BW_MASK = 3,
	IEEE80211_RADIOTAP_MCS_BW_20 = 0,
	IEEE80211_RADIOTAP_MCS_BW_40 = 1,
	IEEE80211_RADIOTAP_MCS_BW_20L = 2,
	IEEE80211_RADIOTAP_MCS_BW_20U = 3,
	IEEE80211_RADIOTAP_MCS_SGI = 4,
	IEEE80211_RADIOTAP_MCS_FMT_GF = 8,
	IEEE80211_RADIOTAP_MCS_FEC_LDPC = 16,
	IEEE80211_RADIOTAP_MCS_STBC_MASK = 96,
	IEEE80211_RADIOTAP_MCS_STBC_1 = 1,
	IEEE80211_RADIOTAP_MCS_STBC_2 = 2,
	IEEE80211_RADIOTAP_MCS_STBC_3 = 3,
	IEEE80211_RADIOTAP_MCS_STBC_SHIFT = 5,
};

enum ieee80211_radiotap_vht_flags {
	IEEE80211_RADIOTAP_VHT_FLAG_STBC = 1,
	IEEE80211_RADIOTAP_VHT_FLAG_TXOP_PS_NA = 2,
	IEEE80211_RADIOTAP_VHT_FLAG_SGI = 4,
	IEEE80211_RADIOTAP_VHT_FLAG_SGI_NSYM_M10_9 = 8,
	IEEE80211_RADIOTAP_VHT_FLAG_LDPC_EXTRA_OFDM_SYM = 16,
	IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED = 32,
};

struct ieee80211_radiotap_he {
	__le16 data1;
	__le16 data2;
	__le16 data3;
	__le16 data4;
	__le16 data5;
	__le16 data6;
};

enum ieee80211_radiotap_he_bits {
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MASK = 3,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_SU = 0,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_EXT_SU = 1,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MU = 2,
	IEEE80211_RADIOTAP_HE_DATA1_FORMAT_TRIG = 3,
	IEEE80211_RADIOTAP_HE_DATA1_BSS_COLOR_KNOWN = 4,
	IEEE80211_RADIOTAP_HE_DATA1_BEAM_CHANGE_KNOWN = 8,
	IEEE80211_RADIOTAP_HE_DATA1_UL_DL_KNOWN = 16,
	IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA1_DATA_DCM_KNOWN = 64,
	IEEE80211_RADIOTAP_HE_DATA1_CODING_KNOWN = 128,
	IEEE80211_RADIOTAP_HE_DATA1_LDPC_XSYMSEG_KNOWN = 256,
	IEEE80211_RADIOTAP_HE_DATA1_STBC_KNOWN = 512,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE_KNOWN = 1024,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE2_KNOWN = 2048,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE3_KNOWN = 4096,
	IEEE80211_RADIOTAP_HE_DATA1_SPTL_REUSE4_KNOWN = 8192,
	IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN = 16384,
	IEEE80211_RADIOTAP_HE_DATA1_DOPPLER_KNOWN = 32768,
	IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_KNOWN = 1,
	IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN = 2,
	IEEE80211_RADIOTAP_HE_DATA2_NUM_LTF_SYMS_KNOWN = 4,
	IEEE80211_RADIOTAP_HE_DATA2_PRE_FEC_PAD_KNOWN = 8,
	IEEE80211_RADIOTAP_HE_DATA2_TXBF_KNOWN = 16,
	IEEE80211_RADIOTAP_HE_DATA2_PE_DISAMBIG_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA2_TXOP_KNOWN = 64,
	IEEE80211_RADIOTAP_HE_DATA2_MIDAMBLE_KNOWN = 128,
	IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET = 16128,
	IEEE80211_RADIOTAP_HE_DATA2_RU_OFFSET_KNOWN = 16384,
	IEEE80211_RADIOTAP_HE_DATA2_PRISEC_80_SEC = 32768,
	IEEE80211_RADIOTAP_HE_DATA3_BSS_COLOR = 63,
	IEEE80211_RADIOTAP_HE_DATA3_BEAM_CHANGE = 64,
	IEEE80211_RADIOTAP_HE_DATA3_UL_DL = 128,
	IEEE80211_RADIOTAP_HE_DATA3_DATA_MCS = 3840,
	IEEE80211_RADIOTAP_HE_DATA3_DATA_DCM = 4096,
	IEEE80211_RADIOTAP_HE_DATA3_CODING = 8192,
	IEEE80211_RADIOTAP_HE_DATA3_LDPC_XSYMSEG = 16384,
	IEEE80211_RADIOTAP_HE_DATA3_STBC = 32768,
	IEEE80211_RADIOTAP_HE_DATA4_SU_MU_SPTL_REUSE = 15,
	IEEE80211_RADIOTAP_HE_DATA4_MU_STA_ID = 32752,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE1 = 15,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE2 = 240,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE3 = 3840,
	IEEE80211_RADIOTAP_HE_DATA4_TB_SPTL_REUSE4 = 61440,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC = 15,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ = 0,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_40MHZ = 1,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_80MHZ = 2,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_160MHZ = 3,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_26T = 4,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_52T = 5,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_106T = 6,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_242T = 7,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_484T = 8,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_996T = 9,
	IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_2x996T = 10,
	IEEE80211_RADIOTAP_HE_DATA5_GI = 48,
	IEEE80211_RADIOTAP_HE_DATA5_GI_0_8 = 0,
	IEEE80211_RADIOTAP_HE_DATA5_GI_1_6 = 1,
	IEEE80211_RADIOTAP_HE_DATA5_GI_3_2 = 2,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE = 192,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_UNKNOWN = 0,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_1X = 1,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_2X = 2,
	IEEE80211_RADIOTAP_HE_DATA5_LTF_SIZE_4X = 3,
	IEEE80211_RADIOTAP_HE_DATA5_NUM_LTF_SYMS = 1792,
	IEEE80211_RADIOTAP_HE_DATA5_PRE_FEC_PAD = 12288,
	IEEE80211_RADIOTAP_HE_DATA5_TXBF = 16384,
	IEEE80211_RADIOTAP_HE_DATA5_PE_DISAMBIG = 32768,
	IEEE80211_RADIOTAP_HE_DATA6_NSTS = 15,
	IEEE80211_RADIOTAP_HE_DATA6_DOPPLER = 16,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_KNOWN = 32,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW = 192,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_20MHZ = 0,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_40MHZ = 1,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_80MHZ = 2,
	IEEE80211_RADIOTAP_HE_DATA6_TB_PPDU_BW_160MHZ = 3,
	IEEE80211_RADIOTAP_HE_DATA6_TXOP = 32512,
	IEEE80211_RADIOTAP_HE_DATA6_MIDAMBLE_PDCTY = 32768,
};

enum ieee80211_ac_numbers {
	IEEE80211_AC_VO = 0,
	IEEE80211_AC_VI = 1,
	IEEE80211_AC_BE = 2,
	IEEE80211_AC_BK = 3,
};

enum mac80211_tx_info_flags {
	IEEE80211_TX_CTL_REQ_TX_STATUS = 1,
	IEEE80211_TX_CTL_ASSIGN_SEQ = 2,
	IEEE80211_TX_CTL_NO_ACK = 4,
	IEEE80211_TX_CTL_CLEAR_PS_FILT = 8,
	IEEE80211_TX_CTL_FIRST_FRAGMENT = 16,
	IEEE80211_TX_CTL_SEND_AFTER_DTIM = 32,
	IEEE80211_TX_CTL_AMPDU = 64,
	IEEE80211_TX_CTL_INJECTED = 128,
	IEEE80211_TX_STAT_TX_FILTERED = 256,
	IEEE80211_TX_STAT_ACK = 512,
	IEEE80211_TX_STAT_AMPDU = 1024,
	IEEE80211_TX_STAT_AMPDU_NO_BACK = 2048,
	IEEE80211_TX_CTL_RATE_CTRL_PROBE = 4096,
	IEEE80211_TX_INTFL_OFFCHAN_TX_OK = 8192,
	IEEE80211_TX_CTL_HW_80211_ENCAP = 16384,
	IEEE80211_TX_INTFL_RETRIED = 32768,
	IEEE80211_TX_INTFL_DONT_ENCRYPT = 65536,
	IEEE80211_TX_CTL_NO_PS_BUFFER = 131072,
	IEEE80211_TX_CTL_MORE_FRAMES = 262144,
	IEEE80211_TX_INTFL_RETRANSMISSION = 524288,
	IEEE80211_TX_INTFL_MLME_CONN_TX = 1048576,
	IEEE80211_TX_INTFL_NL80211_FRAME_TX = 2097152,
	IEEE80211_TX_CTL_LDPC = 4194304,
	IEEE80211_TX_CTL_STBC = 25165824,
	IEEE80211_TX_CTL_TX_OFFCHAN = 33554432,
	IEEE80211_TX_INTFL_TKIP_MIC_FAILURE = 67108864,
	IEEE80211_TX_CTL_NO_CCK_RATE = 134217728,
	IEEE80211_TX_STATUS_EOSP = 268435456,
	IEEE80211_TX_CTL_USE_MINRATE = 536870912,
	IEEE80211_TX_CTL_DONTFRAG = 1073741824,
	IEEE80211_TX_STAT_NOACK_TRANSMITTED = 2147483648,
};

enum mac80211_tx_control_flags {
	IEEE80211_TX_CTRL_PORT_CTRL_PROTO = 1,
	IEEE80211_TX_CTRL_PS_RESPONSE = 2,
	IEEE80211_TX_CTRL_RATE_INJECT = 4,
	IEEE80211_TX_CTRL_AMSDU = 8,
	IEEE80211_TX_CTRL_FAST_XMIT = 16,
	IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP = 32,
	IEEE80211_TX_INTCFL_NEED_TXPROCESSING = 64,
	IEEE80211_TX_CTRL_NO_SEQNO = 128,
	IEEE80211_TX_CTRL_DONT_REORDER = 256,
};

enum mac80211_rate_control_flags {
	IEEE80211_TX_RC_USE_RTS_CTS = 1,
	IEEE80211_TX_RC_USE_CTS_PROTECT = 2,
	IEEE80211_TX_RC_USE_SHORT_PREAMBLE = 4,
	IEEE80211_TX_RC_MCS = 8,
	IEEE80211_TX_RC_GREEN_FIELD = 16,
	IEEE80211_TX_RC_40_MHZ_WIDTH = 32,
	IEEE80211_TX_RC_DUP_DATA = 64,
	IEEE80211_TX_RC_SHORT_GI = 128,
	IEEE80211_TX_RC_VHT_MCS = 256,
	IEEE80211_TX_RC_80_MHZ_WIDTH = 512,
	IEEE80211_TX_RC_160_MHZ_WIDTH = 1024,
};

enum ieee80211_sta_info_flags {
	WLAN_STA_AUTH = 0,
	WLAN_STA_ASSOC = 1,
	WLAN_STA_PS_STA = 2,
	WLAN_STA_AUTHORIZED = 3,
	WLAN_STA_SHORT_PREAMBLE = 4,
	WLAN_STA_WDS = 5,
	WLAN_STA_CLEAR_PS_FILT = 6,
	WLAN_STA_MFP = 7,
	WLAN_STA_BLOCK_BA = 8,
	WLAN_STA_PS_DRIVER = 9,
	WLAN_STA_PSPOLL = 10,
	WLAN_STA_TDLS_PEER = 11,
	WLAN_STA_TDLS_PEER_AUTH = 12,
	WLAN_STA_TDLS_INITIATOR = 13,
	WLAN_STA_TDLS_CHAN_SWITCH = 14,
	WLAN_STA_TDLS_OFF_CHANNEL = 15,
	WLAN_STA_TDLS_WIDER_BW = 16,
	WLAN_STA_UAPSD = 17,
	WLAN_STA_SP = 18,
	WLAN_STA_4ADDR_EVENT = 19,
	WLAN_STA_INSERTED = 20,
	WLAN_STA_RATE_CONTROL = 21,
	WLAN_STA_TOFFSET_KNOWN = 22,
	WLAN_STA_MPSP_OWNER = 23,
	WLAN_STA_MPSP_RECIPIENT = 24,
	WLAN_STA_PS_DELIVER = 25,
	WLAN_STA_USES_ENCRYPTION = 26,
	NUM_WLAN_STA_FLAGS = 27,
};

enum ieee80211_sta_flags {
	IEEE80211_STA_CONNECTION_POLL = 2,
	IEEE80211_STA_CONTROL_PORT = 4,
	IEEE80211_STA_DISABLE_HT = 16,
	IEEE80211_STA_MFP_ENABLED = 64,
	IEEE80211_STA_UAPSD_ENABLED = 128,
	IEEE80211_STA_NULLFUNC_ACKED = 256,
	IEEE80211_STA_RESET_SIGNAL_AVE = 512,
	IEEE80211_STA_DISABLE_40MHZ = 1024,
	IEEE80211_STA_DISABLE_VHT = 2048,
	IEEE80211_STA_DISABLE_80P80MHZ = 4096,
	IEEE80211_STA_DISABLE_160MHZ = 8192,
	IEEE80211_STA_DISABLE_WMM = 16384,
	IEEE80211_STA_ENABLE_RRM = 32768,
	IEEE80211_STA_DISABLE_HE = 65536,
};

enum ieee80211_sdata_state_bits {
	SDATA_STATE_RUNNING = 0,
	SDATA_STATE_OFFCHANNEL = 1,
	SDATA_STATE_OFFCHANNEL_BEACON_STOPPED = 2,
};

enum ieee80211_rate_control_changed {
	IEEE80211_RC_BW_CHANGED = 1,
	IEEE80211_RC_SMPS_CHANGED = 2,
	IEEE80211_RC_SUPP_RATES_CHANGED = 4,
	IEEE80211_RC_NSS_CHANGED = 8,
};

struct codel_stats {
	u32 maxpacket;
	u32 drop_count;
	u32 drop_len;
	u32 ecn_mark;
	u32 ce_mark;
};

struct ieee80211_qos_hdr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	__le16 qos_ctrl;
};

enum ieee80211_vif_flags {
	IEEE80211_VIF_BEACON_FILTER = 1,
	IEEE80211_VIF_SUPPORTS_CQM_RSSI = 2,
	IEEE80211_VIF_SUPPORTS_UAPSD = 4,
	IEEE80211_VIF_GET_NOA_UPDATE = 8,
};

enum ieee80211_agg_stop_reason {
	AGG_STOP_DECLINED = 0,
	AGG_STOP_LOCAL_REQUEST = 1,
	AGG_STOP_PEER_REQUEST = 2,
	AGG_STOP_DESTROY_STA = 3,
};

enum sta_stats_type {
	STA_STATS_RATE_TYPE_INVALID = 0,
	STA_STATS_RATE_TYPE_LEGACY = 1,
	STA_STATS_RATE_TYPE_HT = 2,
	STA_STATS_RATE_TYPE_VHT = 3,
	STA_STATS_RATE_TYPE_HE = 4,
	STA_STATS_RATE_TYPE_S1G = 5,
};

struct txq_info {
	struct fq_tin tin;
	struct fq_flow def_flow;
	struct codel_vars def_cvars;
	struct codel_stats cstats;
	struct sk_buff_head frags;
	struct list_head schedule_order;
	u16 schedule_round;
	long unsigned int flags;
	struct ieee80211_txq txq;
};

enum mac80211_rx_flags {
	RX_FLAG_MMIC_ERROR = 1,
	RX_FLAG_DECRYPTED = 2,
	RX_FLAG_MACTIME_PLCP_START = 4,
	RX_FLAG_MMIC_STRIPPED = 8,
	RX_FLAG_IV_STRIPPED = 16,
	RX_FLAG_FAILED_FCS_CRC = 32,
	RX_FLAG_FAILED_PLCP_CRC = 64,
	RX_FLAG_MACTIME_START = 128,
	RX_FLAG_NO_SIGNAL_VAL = 256,
	RX_FLAG_AMPDU_DETAILS = 512,
	RX_FLAG_PN_VALIDATED = 1024,
	RX_FLAG_DUP_VALIDATED = 2048,
	RX_FLAG_AMPDU_LAST_KNOWN = 4096,
	RX_FLAG_AMPDU_IS_LAST = 8192,
	RX_FLAG_AMPDU_DELIM_CRC_ERROR = 16384,
	RX_FLAG_AMPDU_DELIM_CRC_KNOWN = 32768,
	RX_FLAG_MACTIME_END = 65536,
	RX_FLAG_ONLY_MONITOR = 131072,
	RX_FLAG_SKIP_MONITOR = 262144,
	RX_FLAG_AMSDU_MORE = 524288,
	RX_FLAG_RADIOTAP_VENDOR_DATA = 1048576,
	RX_FLAG_MIC_STRIPPED = 2097152,
	RX_FLAG_ALLOW_SAME_PN = 4194304,
	RX_FLAG_ICV_STRIPPED = 8388608,
	RX_FLAG_AMPDU_EOF_BIT = 16777216,
	RX_FLAG_AMPDU_EOF_BIT_KNOWN = 33554432,
	RX_FLAG_RADIOTAP_HE = 67108864,
	RX_FLAG_RADIOTAP_HE_MU = 134217728,
	RX_FLAG_RADIOTAP_LSIG = 268435456,
	RX_FLAG_NO_PSDU = 536870912,
};

enum ieee80211_key_flags {
	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT = 1,
	IEEE80211_KEY_FLAG_GENERATE_IV = 2,
	IEEE80211_KEY_FLAG_GENERATE_MMIC = 4,
	IEEE80211_KEY_FLAG_PAIRWISE = 8,
	IEEE80211_KEY_FLAG_SW_MGMT_TX = 16,
	IEEE80211_KEY_FLAG_PUT_IV_SPACE = 32,
	IEEE80211_KEY_FLAG_RX_MGMT = 64,
	IEEE80211_KEY_FLAG_RESERVE_TAILROOM = 128,
	IEEE80211_KEY_FLAG_PUT_MIC_SPACE = 256,
	IEEE80211_KEY_FLAG_NO_AUTO_TX = 512,
	IEEE80211_KEY_FLAG_GENERATE_MMIE = 1024,
};

typedef unsigned int ieee80211_tx_result;

struct ieee80211_tx_data {
	struct sk_buff *skb;
	struct sk_buff_head skbs;
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct ieee80211_key *key;
	struct ieee80211_tx_rate rate;
	unsigned int flags;
};

typedef unsigned int ieee80211_rx_result;

struct ieee80211_rx_data {
	struct list_head *list;
	struct sk_buff *skb;
	struct ieee80211_local *local;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *sta;
	struct ieee80211_key *key;
	unsigned int flags;
	int seqno_idx;
	int security_idx;
	u32 tkip_iv32;
	u16 tkip_iv16;
};

struct ieee80211_mmie {
	u8 element_id;
	u8 length;
	__le16 key_id;
	u8 sequence_number[6];
	u8 mic[8];
};

struct ieee80211_mmie_16 {
	u8 element_id;
	u8 length;
	__le16 key_id;
	u8 sequence_number[6];
	u8 mic[16];
};

enum ieee80211_internal_key_flags {
	KEY_FLAG_UPLOADED_TO_HARDWARE = 1,
	KEY_FLAG_TAINTED = 2,
	KEY_FLAG_CIPHER_SCHEME = 4,
};

enum {
	TKIP_DECRYPT_OK = 0,
	TKIP_DECRYPT_NO_EXT_IV = 4294967295,
	TKIP_DECRYPT_INVALID_KEYIDX = 4294967294,
	TKIP_DECRYPT_REPLAY = 4294967293,
};

enum mac80211_rx_encoding {
	RX_ENC_LEGACY = 0,
	RX_ENC_HT = 1,
	RX_ENC_VHT = 2,
	RX_ENC_HE = 3,
};

struct ieee80211_bss {
	u32 device_ts_beacon;
	u32 device_ts_presp;
	bool wmm_used;
	bool uapsd_supported;
	u8 supp_rates[32];
	size_t supp_rates_len;
	struct ieee80211_rate *beacon_rate;
	u32 vht_cap_info;
	bool has_erp_value;
	u8 erp_value;
	u8 corrupt_data;
	u8 valid_data;
};

enum ieee80211_bss_corrupt_data_flags {
	IEEE80211_BSS_CORRUPT_BEACON = 1,
	IEEE80211_BSS_CORRUPT_PROBE_RESP = 2,
};

enum ieee80211_bss_valid_data_flags {
	IEEE80211_BSS_VALID_WMM = 2,
	IEEE80211_BSS_VALID_RATES = 4,
	IEEE80211_BSS_VALID_ERP = 8,
};

enum {
	IEEE80211_PROBE_FLAG_DIRECTED = 1,
	IEEE80211_PROBE_FLAG_MIN_CONTENT = 2,
	IEEE80211_PROBE_FLAG_RANDOM_SN = 4,
};

struct ieee80211_roc_work {
	struct list_head list;
	struct ieee80211_sub_if_data *sdata;
	struct ieee80211_channel *chan;
	bool started;
	bool abort;
	bool hw_begun;
	bool notified;
	bool on_channel;
	long unsigned int start_time;
	u32 duration;
	u32 req_duration;
	struct sk_buff *frame;
	u64 cookie;
	u64 mgmt_tx_cookie;
	enum ieee80211_roc_type type;
	int: 32;
};

enum ieee80211_back_actioncode {
	WLAN_ACTION_ADDBA_REQ = 0,
	WLAN_ACTION_ADDBA_RESP = 1,
	WLAN_ACTION_DELBA = 2,
};

enum ieee80211_back_parties {
	WLAN_BACK_RECIPIENT = 0,
	WLAN_BACK_INITIATOR = 1,
};

enum txq_info_flags {
	IEEE80211_TXQ_STOP = 0,
	IEEE80211_TXQ_AMPDU = 1,
	IEEE80211_TXQ_NO_AMSDU = 2,
	IEEE80211_TXQ_STOP_NETIF_TX = 3,
};

enum ieee80211_vht_opmode_bits {
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK = 3,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ = 0,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ = 1,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ = 2,
	IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ = 3,
	IEEE80211_OPMODE_NOTIF_BW_160_80P80 = 4,
	IEEE80211_OPMODE_NOTIF_RX_NSS_MASK = 112,
	IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT = 4,
	IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF = 128,
};

enum ieee80211_spectrum_mgmt_actioncode {
	WLAN_ACTION_SPCT_MSR_REQ = 0,
	WLAN_ACTION_SPCT_MSR_RPRT = 1,
	WLAN_ACTION_SPCT_TPC_REQ = 2,
	WLAN_ACTION_SPCT_TPC_RPRT = 3,
	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
};

struct ieee80211_csa_ie {
	struct cfg80211_chan_def chandef;
	u8 mode;
	u8 count;
	u8 ttl;
	u16 pre_value;
	u16 reason_code;
	u32 max_switch_time;
};

enum ieee80211_vht_actioncode {
	WLAN_VHT_ACTION_COMPRESSED_BF = 0,
	WLAN_VHT_ACTION_GROUPID_MGMT = 1,
	WLAN_VHT_ACTION_OPMODE_NOTIF = 2,
};

enum ieee80211_offload_flags {
	IEEE80211_OFFLOAD_ENCAP_ENABLED = 1,
	IEEE80211_OFFLOAD_ENCAP_4ADDR = 2,
};

enum ieee80211_tpt_led_trigger_flags {
	IEEE80211_TPT_LEDTRIG_FL_RADIO = 1,
	IEEE80211_TPT_LEDTRIG_FL_WORK = 2,
	IEEE80211_TPT_LEDTRIG_FL_CONNECTED = 4,
};

struct rate_control_alg {
	struct list_head list;
	const struct rate_control_ops *ops;
};

struct michael_mic_ctx {
	u32 l;
	u32 r;
};

struct ieee80211_csa_settings {
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	int n_counter_offsets_beacon;
	int n_counter_offsets_presp;
	u8 count;
};

struct ieee80211_hdr_3addr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
};

enum ieee80211_ht_chanwidth_values {
	IEEE80211_HT_CHANWIDTH_20MHZ = 0,
	IEEE80211_HT_CHANWIDTH_ANY = 1,
};

struct ieee80211_tdls_data {
	u8 da[6];
	u8 sa[6];
	__be16 ether_type;
	u8 payload_type;
	u8 category;
	u8 action_code;
	union {
		struct {
			u8 dialog_token;
			__le16 capability;
			u8 variable[0];
		} __attribute__((packed)) setup_req;
		struct {
			__le16 status_code;
			u8 dialog_token;
			__le16 capability;
			u8 variable[0];
		} __attribute__((packed)) setup_resp;
		struct {
			__le16 status_code;
			u8 dialog_token;
			u8 variable[0];
		} __attribute__((packed)) setup_cfm;
		struct {
			__le16 reason_code;
			u8 variable[0];
		} teardown;
		struct {
			u8 dialog_token;
			u8 variable[0];
		} discover_req;
		struct {
			u8 target_channel;
			u8 oper_class;
			u8 variable[0];
		} chan_switch_req;
		struct {
			__le16 status_code;
			u8 variable[0];
		} chan_switch_resp;
	} u;
} __attribute__((packed));

enum ieee80211_self_protected_actioncode {
	WLAN_SP_RESERVED = 0,
	WLAN_SP_MESH_PEERING_OPEN = 1,
	WLAN_SP_MESH_PEERING_CONFIRM = 2,
	WLAN_SP_MESH_PEERING_CLOSE = 3,
	WLAN_SP_MGK_INFORM = 4,
	WLAN_SP_MGK_ACK = 5,
};

enum ieee80211_pub_actioncode {
	WLAN_PUB_ACTION_20_40_BSS_COEX = 0,
	WLAN_PUB_ACTION_DSE_ENABLEMENT = 1,
	WLAN_PUB_ACTION_DSE_DEENABLEMENT = 2,
	WLAN_PUB_ACTION_DSE_REG_LOC_ANN = 3,
	WLAN_PUB_ACTION_EXT_CHANSW_ANN = 4,
	WLAN_PUB_ACTION_DSE_MSMT_REQ = 5,
	WLAN_PUB_ACTION_DSE_MSMT_RESP = 6,
	WLAN_PUB_ACTION_MSMT_PILOT = 7,
	WLAN_PUB_ACTION_DSE_PC = 8,
	WLAN_PUB_ACTION_VENDOR_SPECIFIC = 9,
	WLAN_PUB_ACTION_GAS_INITIAL_REQ = 10,
	WLAN_PUB_ACTION_GAS_INITIAL_RESP = 11,
	WLAN_PUB_ACTION_GAS_COMEBACK_REQ = 12,
	WLAN_PUB_ACTION_GAS_COMEBACK_RESP = 13,
	WLAN_PUB_ACTION_TDLS_DISCOVER_RES = 14,
	WLAN_PUB_ACTION_LOC_TRACK_NOTI = 15,
	WLAN_PUB_ACTION_QAB_REQUEST_FRAME = 16,
	WLAN_PUB_ACTION_QAB_RESPONSE_FRAME = 17,
	WLAN_PUB_ACTION_QMF_POLICY = 18,
	WLAN_PUB_ACTION_QMF_POLICY_CHANGE = 19,
	WLAN_PUB_ACTION_QLOAD_REQUEST = 20,
	WLAN_PUB_ACTION_QLOAD_REPORT = 21,
	WLAN_PUB_ACTION_HCCA_TXOP_ADVERT = 22,
	WLAN_PUB_ACTION_HCCA_TXOP_RESPONSE = 23,
	WLAN_PUB_ACTION_PUBLIC_KEY = 24,
	WLAN_PUB_ACTION_CHANNEL_AVAIL_QUERY = 25,
	WLAN_PUB_ACTION_CHANNEL_SCHEDULE_MGMT = 26,
	WLAN_PUB_ACTION_CONTACT_VERI_SIGNAL = 27,
	WLAN_PUB_ACTION_GDD_ENABLEMENT_REQ = 28,
	WLAN_PUB_ACTION_GDD_ENABLEMENT_RESP = 29,
	WLAN_PUB_ACTION_NETWORK_CHANNEL_CONTROL = 30,
	WLAN_PUB_ACTION_WHITE_SPACE_MAP_ANN = 31,
	WLAN_PUB_ACTION_FTM_REQUEST = 32,
	WLAN_PUB_ACTION_FTM = 33,
	WLAN_PUB_ACTION_FILS_DISCOVERY = 34,
};

enum ieee80211_sa_query_action {
	WLAN_ACTION_SA_QUERY_REQUEST = 0,
	WLAN_ACTION_SA_QUERY_RESPONSE = 1,
};

enum ieee80211_radiotap_flags {
	IEEE80211_RADIOTAP_F_CFP = 1,
	IEEE80211_RADIOTAP_F_SHORTPRE = 2,
	IEEE80211_RADIOTAP_F_WEP = 4,
	IEEE80211_RADIOTAP_F_FRAG = 8,
	IEEE80211_RADIOTAP_F_FCS = 16,
	IEEE80211_RADIOTAP_F_DATAPAD = 32,
	IEEE80211_RADIOTAP_F_BADFCS = 64,
};

enum ieee80211_radiotap_channel_flags {
	IEEE80211_CHAN_CCK = 32,
	IEEE80211_CHAN_OFDM = 64,
	IEEE80211_CHAN_2GHZ = 128,
	IEEE80211_CHAN_5GHZ = 256,
	IEEE80211_CHAN_DYN = 1024,
	IEEE80211_CHAN_HALF = 16384,
	IEEE80211_CHAN_QUARTER = 32768,
};

enum ieee80211_radiotap_rx_flags {
	IEEE80211_RADIOTAP_F_RX_BADPLCP = 2,
};

enum ieee80211_radiotap_ampdu_flags {
	IEEE80211_RADIOTAP_AMPDU_REPORT_ZEROLEN = 1,
	IEEE80211_RADIOTAP_AMPDU_IS_ZEROLEN = 2,
	IEEE80211_RADIOTAP_AMPDU_LAST_KNOWN = 4,
	IEEE80211_RADIOTAP_AMPDU_IS_LAST = 8,
	IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR = 16,
	IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN = 32,
	IEEE80211_RADIOTAP_AMPDU_EOF = 64,
	IEEE80211_RADIOTAP_AMPDU_EOF_KNOWN = 128,
};

enum ieee80211_radiotap_vht_coding {
	IEEE80211_RADIOTAP_CODING_LDPC_USER0 = 1,
	IEEE80211_RADIOTAP_CODING_LDPC_USER1 = 2,
	IEEE80211_RADIOTAP_CODING_LDPC_USER2 = 4,
	IEEE80211_RADIOTAP_CODING_LDPC_USER3 = 8,
};

enum ieee80211_radiotap_timestamp_flags {
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_64BIT = 0,
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_32BIT = 1,
	IEEE80211_RADIOTAP_TIMESTAMP_FLAG_ACCURACY = 2,
};

struct ieee80211_radiotap_he_mu {
	__le16 flags1;
	__le16 flags2;
	u8 ru_ch1[4];
	u8 ru_ch2[4];
};

struct ieee80211_radiotap_lsig {
	__le16 data1;
	__le16 data2;
};

enum mac80211_rx_encoding_flags {
	RX_ENC_FLAG_SHORTPRE = 1,
	RX_ENC_FLAG_SHORT_GI = 4,
	RX_ENC_FLAG_HT_GF = 8,
	RX_ENC_FLAG_STBC_MASK = 48,
	RX_ENC_FLAG_LDPC = 64,
	RX_ENC_FLAG_BF = 128,
};

struct ieee80211_vendor_radiotap {
	u32 present;
	u8 align;
	u8 oui[3];
	u8 subns;
	u8 pad;
	u16 len;
	u8 data[0];
};

enum ieee80211_packet_rx_flags {
	IEEE80211_RX_AMSDU = 8,
	IEEE80211_RX_MALFORMED_ACTION_FRM = 16,
	IEEE80211_RX_DEFERRED_RELEASE = 32,
};

enum ieee80211_rx_flags {
	IEEE80211_RX_CMNTR = 1,
	IEEE80211_RX_BEACON_REPORTED = 2,
};

struct ieee80211_rts {
	__le16 frame_control;
	__le16 duration;
	u8 ra[6];
	u8 ta[6];
};

struct ieee80211_cts {
	__le16 frame_control;
	__le16 duration;
	u8 ra[6];
};

struct ieee80211_pspoll {
	__le16 frame_control;
	__le16 aid;
	u8 bssid[6];
	u8 ta[6];
};

typedef u32 (*codel_skb_len_t)(const struct sk_buff *);

typedef codel_time_t (*codel_skb_time_t)(const struct sk_buff *);

typedef void (*codel_skb_drop_t)(struct sk_buff *, void *);

typedef struct sk_buff * (*codel_skb_dequeue_t)(struct codel_vars *, void *);

struct ieee80211_mutable_offsets {
	u16 tim_offset;
	u16 tim_length;
	u16 cntdwn_counter_offs[2];
};

typedef struct sk_buff *fq_tin_dequeue_t(struct fq *, struct fq_tin *, struct fq_flow *);

typedef void fq_skb_free_t(struct fq *, struct fq_tin *, struct fq_flow *, struct sk_buff *);

typedef bool fq_skb_filter_t(struct fq *, struct fq_tin *, struct fq_flow *, struct sk_buff *, void *);

typedef struct fq_flow *fq_flow_get_default_t(struct fq *, struct fq_tin *, int, struct sk_buff *);

enum mesh_path_flags {
	MESH_PATH_ACTIVE = 1,
	MESH_PATH_RESOLVING = 2,
	MESH_PATH_SN_VALID = 4,
	MESH_PATH_FIXED = 8,
	MESH_PATH_RESOLVED = 16,
	MESH_PATH_REQ_QUEUED = 32,
	MESH_PATH_DELETED = 64,
};

struct mesh_path {
	u8 dst[6];
	u8 mpp[6];
	struct rhash_head rhash;
	struct hlist_node walk_list;
	struct hlist_node gate_list;
	struct ieee80211_sub_if_data *sdata;
	struct sta_info *next_hop;
	struct timer_list timer;
	struct sk_buff_head frame_queue;
	struct callback_head rcu;
	u32 sn;
	u32 metric;
	u8 hop_count;
	long unsigned int exp_time;
	u32 discovery_timeout;
	u8 discovery_retries;
	enum mesh_path_flags flags;
	spinlock_t state_lock;
	u8 rann_snd_addr[6];
	u32 rann_metric;
	long unsigned int last_preq_to_root;
	bool is_root;
	bool is_gate;
	u32 path_change_count;
};

enum ieee80211_encrypt {
	ENCRYPT_NO = 0,
	ENCRYPT_MGMT = 1,
	ENCRYPT_DATA = 2,
};

enum ieee80211_s1g_chanwidth {
	IEEE80211_S1G_CHANWIDTH_1MHZ = 0,
	IEEE80211_S1G_CHANWIDTH_2MHZ = 1,
	IEEE80211_S1G_CHANWIDTH_4MHZ = 3,
	IEEE80211_S1G_CHANWIDTH_8MHZ = 7,
	IEEE80211_S1G_CHANWIDTH_16MHZ = 15,
};

struct ieee80211_he_6ghz_oper {
	u8 primary;
	u8 control;
	u8 ccfs0;
	u8 ccfs1;
	u8 minrate;
};

enum ieee80211_interface_iteration_flags {
	IEEE80211_IFACE_ITER_NORMAL = 0,
	IEEE80211_IFACE_ITER_RESUME_ALL = 1,
	IEEE80211_IFACE_ITER_ACTIVE = 2,
	IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER = 4,
};

struct ieee80211_noa_data {
	u32 next_tsf;
	bool has_next_tsf;
	u8 absent;
	u8 count[4];
	struct {
		u32 start;
		u32 duration;
		u32 interval;
	} desc[4];
};

enum ieee80211_chanctx_change {
	IEEE80211_CHANCTX_CHANGE_WIDTH = 1,
	IEEE80211_CHANCTX_CHANGE_RX_CHAINS = 2,
	IEEE80211_CHANCTX_CHANGE_RADAR = 4,
	IEEE80211_CHANCTX_CHANGE_CHANNEL = 8,
	IEEE80211_CHANCTX_CHANGE_MIN_WIDTH = 16,
};

struct trace_vif_entry {
	enum nl80211_iftype vif_type;
	bool p2p;
	char vif_name[16];
} __attribute__((packed));

struct trace_chandef_entry {
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
};

struct trace_switch_entry {
	struct trace_vif_entry vif;
	struct trace_chandef_entry old_chandef;
	struct trace_chandef_entry new_chandef;
} __attribute__((packed));

struct trace_event_raw_local_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_local_sdata_addr_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char addr[6];
	char __data[0];
};

struct trace_event_raw_local_u32_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 value;
	char __data[0];
};

struct trace_event_raw_local_sdata_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_return_bool {
	struct trace_entry ent;
	char wiphy_name[32];
	bool ret;
	char __data[0];
};

struct trace_event_raw_drv_return_u32 {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 ret;
	char __data[0];
};

struct trace_event_raw_drv_return_u64 {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 ret;
	char __data[0];
};

struct trace_event_raw_drv_set_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_drv_change_interface {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 new_type;
	bool new_p2p;
	char __data[0];
};

struct trace_event_raw_drv_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	u32 flags;
	int power_level;
	int dynamic_ps_timeout;
	u16 listen_interval;
	u8 long_frame_max_tx_count;
	u8 short_frame_max_tx_count;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	int smps;
	char __data[0];
};

struct trace_event_raw_drv_bss_info_changed {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 changed;
	bool assoc;
	bool ibss_joined;
	bool ibss_creator;
	u16 aid;
	bool cts;
	bool shortpre;
	bool shortslot;
	bool enable_beacon;
	u8 dtimper;
	u16 bcnint;
	u16 assoc_cap;
	int: 32;
	u64 sync_tsf;
	u32 sync_device_ts;
	u8 sync_dtim_count;
	u32 basic_rates;
	int mcast_rate[5];
	u16 ht_operation_mode;
	s32 cqm_rssi_thold;
	s32 cqm_rssi_hyst;
	u32 channel_width;
	u32 channel_cfreq1;
	u32 channel_cfreq1_offset;
	u32 __data_loc_arp_addr_list;
	int arp_addr_cnt;
	bool qos;
	bool idle;
	bool ps;
	u32 __data_loc_ssid;
	bool hidden_ssid;
	int txpower;
	u8 p2p_oppps_ctwindow;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_drv_prepare_multicast {
	struct trace_entry ent;
	char wiphy_name[32];
	int mc_count;
	char __data[0];
};

struct trace_event_raw_drv_configure_filter {
	struct trace_entry ent;
	char wiphy_name[32];
	unsigned int changed;
	unsigned int total;
	u64 multicast;
	char __data[0];
};

struct trace_event_raw_drv_config_iface_filter {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	unsigned int filter_flags;
	unsigned int changed_flags;
	char __data[0];
};

struct trace_event_raw_drv_set_tim {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	bool set;
	char __data[0];
};

struct trace_event_raw_drv_set_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 cipher;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	char __data[0];
};

struct trace_event_raw_drv_update_tkip_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 iv32;
	char __data[0];
};

struct trace_event_raw_drv_sw_scan_start {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char mac_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_get_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	unsigned int ackfail;
	unsigned int rtsfail;
	unsigned int fcserr;
	unsigned int rtssucc;
	char __data[0];
};

struct trace_event_raw_drv_get_key_seq {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 cipher;
	u8 hw_key_idx;
	u8 flags;
	s8 keyidx;
	char __data[0];
};

struct trace_event_raw_drv_set_coverage_class {
	struct trace_entry ent;
	char wiphy_name[32];
	s16 value;
	char __data[0];
};

struct trace_event_raw_drv_sta_notify {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 cmd;
	char __data[0];
};

struct trace_event_raw_drv_sta_state {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 old_state;
	u32 new_state;
	char __data[0];
};

struct trace_event_raw_drv_sta_set_txpwr {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	s16 txpwr;
	u8 type;
	char __data[0];
};

struct trace_event_raw_drv_sta_rc_update {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u32 changed;
	char __data[0];
};

struct trace_event_raw_sta_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_conf_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u16 ac;
	u16 txop;
	u16 cw_min;
	u16 cw_max;
	u8 aifs;
	bool uapsd;
	char __data[0];
};

struct trace_event_raw_drv_set_tsf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u64 tsf;
	char __data[0];
};

struct trace_event_raw_drv_offset_tsf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	s64 tsf_offset;
	char __data[0];
};

struct trace_event_raw_drv_ampdu_action {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	enum ieee80211_ampdu_mlme_action ieee80211_ampdu_mlme_action;
	char sta_addr[6];
	u16 tid;
	u16 ssn;
	u16 buf_size;
	bool amsdu;
	u16 timeout;
	u16 action;
	char __data[0];
};

struct trace_event_raw_drv_get_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	int idx;
	char __data[0];
};

struct trace_event_raw_drv_flush {
	struct trace_entry ent;
	char wiphy_name[32];
	bool drop;
	u32 queues;
	char __data[0];
};

struct trace_event_raw_drv_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	char __data[0];
};

struct trace_event_raw_drv_set_antenna {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx_ant;
	u32 rx_ant;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_get_antenna {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx_ant;
	u32 rx_ant;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int center_freq;
	int freq_offset;
	unsigned int duration;
	u32 type;
	char __data[0];
};

struct trace_event_raw_drv_set_ringparam {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_drv_get_ringparam {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_drv_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 legacy_2g;
	u32 legacy_5g;
	char __data[0];
};

struct trace_event_raw_drv_set_rekey_data {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 kek[16];
	u8 kck[16];
	u8 replay_ctr[8];
	char __data[0];
};

struct trace_event_raw_drv_event_callback {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 type;
	char __data[0];
};

struct trace_event_raw_release_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u16 tids;
	int num_frames;
	int reason;
	bool more_data;
	char __data[0];
};

struct trace_event_raw_drv_mgd_prepare_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 duration;
	char __data[0];
};

struct trace_event_raw_local_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	char __data[0];
};

struct trace_event_raw_drv_change_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_drv_switch_vif_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_vifs;
	u32 mode;
	u32 __data_loc_vifs;
	char __data[0];
};

struct trace_event_raw_local_sdata_chanctx {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 min_control_freq;
	u32 min_freq_offset;
	u32 min_chan_width;
	u32 min_center_freq1;
	u32 min_freq1_offset;
	u32 min_center_freq2;
	u8 rx_chains_static;
	u8 rx_chains_dynamic;
	char __data[0];
};

struct trace_event_raw_drv_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 dtimper;
	u16 bcnint;
	u32 __data_loc_ssid;
	bool hidden_ssid;
	char __data[0];
};

struct trace_event_raw_drv_reconfig_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u8 reconfig_type;
	char __data[0];
};

struct trace_event_raw_drv_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 dtimper;
	u16 bcnint;
	u32 __data_loc_ssid;
	char __data[0];
};

struct trace_event_raw_drv_get_expected_throughput {
	struct trace_entry ent;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_drv_stop_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_drv_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 type;
	u8 inst_id;
	char __data[0];
};

struct trace_event_raw_drv_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 instance_id;
	char __data[0];
};

struct trace_event_raw_api_start_tx_ba_session {
	struct trace_entry ent;
	char sta_addr[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_start_tx_ba_cb {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 ra[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_stop_tx_ba_session {
	struct trace_entry ent;
	char sta_addr[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_stop_tx_ba_cb {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 ra[6];
	u16 tid;
	char __data[0];
};

struct trace_event_raw_api_beacon_loss {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_api_connection_loss {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_api_disconnect {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int reconnect;
	char __data[0];
};

struct trace_event_raw_api_cqm_rssi_notify {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_api_scan_completed {
	struct trace_entry ent;
	char wiphy_name[32];
	bool aborted;
	char __data[0];
};

struct trace_event_raw_api_sched_scan_results {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_sched_scan_stopped {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_api_sta_block_awake {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	bool block;
	char __data[0];
};

struct trace_event_raw_api_chswitch_done {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	bool success;
	char __data[0];
};

struct trace_event_raw_api_gtk_rekey_notify {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 bssid[6];
	u8 replay_ctr[8];
	char __data[0];
};

struct trace_event_raw_api_enable_rssi_reports {
	struct trace_entry ent;
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int rssi_min_thold;
	int rssi_max_thold;
	char __data[0];
};

struct trace_event_raw_api_eosp {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_api_send_eosp_nullfunc {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 tid;
	char __data[0];
};

struct trace_event_raw_api_sta_set_buffered {
	struct trace_entry ent;
	char wiphy_name[32];
	char sta_addr[6];
	u8 tid;
	bool buffered;
	char __data[0];
};

struct trace_event_raw_wake_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 queue;
	u32 reason;
	char __data[0];
};

struct trace_event_raw_stop_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 queue;
	u32 reason;
	char __data[0];
};

struct trace_event_raw_drv_set_default_unicast_key {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int key_idx;
	char __data[0];
};

struct trace_event_raw_api_radar_detected {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_drv_channel_switch_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_drv_pre_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	char __data[0];
};

struct trace_event_raw_drv_channel_switch_rx_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u64 timestamp;
	u32 device_timestamp;
	bool block_tx;
	u8 count;
	char __data[0];
};

struct trace_event_raw_drv_get_txpower {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	int dbm;
	int ret;
	char __data[0];
};

struct trace_event_raw_drv_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u8 oper_class;
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_drv_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	char __data[0];
};

struct trace_event_raw_drv_tdls_recv_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	u8 action_code;
	char sta_addr[6];
	u32 control_freq;
	u32 freq_offset;
	u32 chan_width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 status;
	bool peer_initiator;
	u32 timestamp;
	u16 switch_time;
	u16 switch_timeout;
	char __data[0];
};

struct trace_event_raw_drv_wake_tx_queue {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	u8 ac;
	u8 tid;
	char __data[0];
};

struct trace_event_raw_drv_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char __data[0];
};

struct trace_event_raw_drv_sta_set_4addr {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_iftype vif_type;
	void *sdata;
	bool p2p;
	u32 __data_loc_vif_name;
	char sta_addr[6];
	bool enabled;
	char __data[0];
};

struct trace_event_data_offsets_local_only_evt {};

struct trace_event_data_offsets_local_sdata_addr_evt {
	u32 vif_name;
};

struct trace_event_data_offsets_local_u32_evt {};

struct trace_event_data_offsets_local_sdata_evt {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_return_int {};

struct trace_event_data_offsets_drv_return_bool {};

struct trace_event_data_offsets_drv_return_u32 {};

struct trace_event_data_offsets_drv_return_u64 {};

struct trace_event_data_offsets_drv_set_wakeup {};

struct trace_event_data_offsets_drv_change_interface {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_config {};

struct trace_event_data_offsets_drv_bss_info_changed {
	u32 vif_name;
	u32 arp_addr_list;
	u32 ssid;
};

struct trace_event_data_offsets_drv_prepare_multicast {};

struct trace_event_data_offsets_drv_configure_filter {};

struct trace_event_data_offsets_drv_config_iface_filter {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_tim {};

struct trace_event_data_offsets_drv_set_key {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_update_tkip_key {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sw_scan_start {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_stats {};

struct trace_event_data_offsets_drv_get_key_seq {};

struct trace_event_data_offsets_drv_set_coverage_class {};

struct trace_event_data_offsets_drv_sta_notify {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_state {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_set_txpwr {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_rc_update {
	u32 vif_name;
};

struct trace_event_data_offsets_sta_event {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_conf_tx {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_tsf {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_offset_tsf {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_ampdu_action {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_survey {};

struct trace_event_data_offsets_drv_flush {};

struct trace_event_data_offsets_drv_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_antenna {};

struct trace_event_data_offsets_drv_get_antenna {};

struct trace_event_data_offsets_drv_remain_on_channel {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_ringparam {};

struct trace_event_data_offsets_drv_get_ringparam {};

struct trace_event_data_offsets_drv_set_bitrate_mask {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_set_rekey_data {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_event_callback {
	u32 vif_name;
};

struct trace_event_data_offsets_release_evt {};

struct trace_event_data_offsets_drv_mgd_prepare_tx {
	u32 vif_name;
};

struct trace_event_data_offsets_local_chanctx {};

struct trace_event_data_offsets_drv_change_chanctx {};

struct trace_event_data_offsets_drv_switch_vif_chanctx {
	u32 vifs;
};

struct trace_event_data_offsets_local_sdata_chanctx {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_start_ap {
	u32 vif_name;
	u32 ssid;
};

struct trace_event_data_offsets_drv_reconfig_complete {};

struct trace_event_data_offsets_drv_join_ibss {
	u32 vif_name;
	u32 ssid;
};

struct trace_event_data_offsets_drv_get_expected_throughput {};

struct trace_event_data_offsets_drv_start_nan {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_stop_nan {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_nan_change_conf {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_add_nan_func {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_del_nan_func {
	u32 vif_name;
};

struct trace_event_data_offsets_api_start_tx_ba_session {};

struct trace_event_data_offsets_api_start_tx_ba_cb {
	u32 vif_name;
};

struct trace_event_data_offsets_api_stop_tx_ba_session {};

struct trace_event_data_offsets_api_stop_tx_ba_cb {
	u32 vif_name;
};

struct trace_event_data_offsets_api_beacon_loss {
	u32 vif_name;
};

struct trace_event_data_offsets_api_connection_loss {
	u32 vif_name;
};

struct trace_event_data_offsets_api_disconnect {
	u32 vif_name;
};

struct trace_event_data_offsets_api_cqm_rssi_notify {
	u32 vif_name;
};

struct trace_event_data_offsets_api_scan_completed {};

struct trace_event_data_offsets_api_sched_scan_results {};

struct trace_event_data_offsets_api_sched_scan_stopped {};

struct trace_event_data_offsets_api_sta_block_awake {};

struct trace_event_data_offsets_api_chswitch_done {
	u32 vif_name;
};

struct trace_event_data_offsets_api_gtk_rekey_notify {
	u32 vif_name;
};

struct trace_event_data_offsets_api_enable_rssi_reports {
	u32 vif_name;
};

struct trace_event_data_offsets_api_eosp {};

struct trace_event_data_offsets_api_send_eosp_nullfunc {};

struct trace_event_data_offsets_api_sta_set_buffered {};

struct trace_event_data_offsets_wake_queue {};

struct trace_event_data_offsets_stop_queue {};

struct trace_event_data_offsets_drv_set_default_unicast_key {
	u32 vif_name;
};

struct trace_event_data_offsets_api_radar_detected {};

struct trace_event_data_offsets_drv_channel_switch_beacon {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_pre_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_channel_switch_rx_beacon {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_txpower {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_tdls_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_tdls_cancel_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_tdls_recv_channel_switch {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_wake_tx_queue {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_get_ftm_responder_stats {
	u32 vif_name;
};

struct trace_event_data_offsets_drv_sta_set_4addr {
	u32 vif_name;
};

typedef void (*btf_trace_drv_return_void)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_return_int)(void *, struct ieee80211_local *, int);

typedef void (*btf_trace_drv_return_bool)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_return_u32)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_return_u64)(void *, struct ieee80211_local *, u64);

typedef void (*btf_trace_drv_start)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_get_et_strings)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_get_et_sset_count)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_get_et_stats)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_suspend)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_resume)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_set_wakeup)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_drv_stop)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_add_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_change_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum nl80211_iftype, bool);

typedef void (*btf_trace_drv_remove_interface)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_config)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_bss_info_changed)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *, u32);

typedef void (*btf_trace_drv_prepare_multicast)(void *, struct ieee80211_local *, int);

typedef void (*btf_trace_drv_configure_filter)(void *, struct ieee80211_local *, unsigned int, unsigned int *, u64);

typedef void (*btf_trace_drv_config_iface_filter)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, unsigned int, unsigned int);

typedef void (*btf_trace_drv_set_tim)(void *, struct ieee80211_local *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_drv_set_key)(void *, struct ieee80211_local *, enum set_key_cmd, struct ieee80211_sub_if_data *, struct ieee80211_sta *, struct ieee80211_key_conf *);

typedef void (*btf_trace_drv_update_tkip_key)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_key_conf *, struct ieee80211_sta *, u32);

typedef void (*btf_trace_drv_hw_scan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_cancel_hw_scan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sched_scan_start)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sched_scan_stop)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sw_scan_start)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const u8 *);

typedef void (*btf_trace_drv_sw_scan_complete)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_get_stats)(void *, struct ieee80211_local *, struct ieee80211_low_level_stats *, int);

typedef void (*btf_trace_drv_get_key_seq)(void *, struct ieee80211_local *, struct ieee80211_key_conf *);

typedef void (*btf_trace_drv_set_frag_threshold)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_set_rts_threshold)(void *, struct ieee80211_local *, u32);

typedef void (*btf_trace_drv_set_coverage_class)(void *, struct ieee80211_local *, s16);

typedef void (*btf_trace_drv_sta_notify)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, enum sta_notify_cmd, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_state)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, enum ieee80211_sta_state, enum ieee80211_sta_state);

typedef void (*btf_trace_drv_sta_set_txpwr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_rc_update)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, u32);

typedef void (*btf_trace_drv_sta_statistics)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_add)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_remove)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_pre_rcu_remove)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sync_rx_queues)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_sta_rate_tbl_update)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_conf_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16, const struct ieee80211_tx_queue_params *);

typedef void (*btf_trace_drv_get_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_set_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u64);

typedef void (*btf_trace_drv_offset_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, s64);

typedef void (*btf_trace_drv_reset_tsf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_tx_last_beacon)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_ampdu_action)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_ampdu_params *);

typedef void (*btf_trace_drv_get_survey)(void *, struct ieee80211_local *, int, struct survey_info *);

typedef void (*btf_trace_drv_flush)(void *, struct ieee80211_local *, u32, bool);

typedef void (*btf_trace_drv_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_set_antenna)(void *, struct ieee80211_local *, u32, u32, int);

typedef void (*btf_trace_drv_get_antenna)(void *, struct ieee80211_local *, u32, u32, int);

typedef void (*btf_trace_drv_remain_on_channel)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel *, unsigned int, enum ieee80211_roc_type);

typedef void (*btf_trace_drv_cancel_remain_on_channel)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_set_ringparam)(void *, struct ieee80211_local *, u32, u32);

typedef void (*btf_trace_drv_get_ringparam)(void *, struct ieee80211_local *, u32 *, u32 *, u32 *, u32 *);

typedef void (*btf_trace_drv_tx_frames_pending)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_offchannel_tx_cancel_wait)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_set_bitrate_mask)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_drv_set_rekey_data)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_gtk_rekey_data *);

typedef void (*btf_trace_drv_event_callback)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct ieee80211_event *);

typedef void (*btf_trace_drv_release_buffered_frames)(void *, struct ieee80211_local *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);

typedef void (*btf_trace_drv_allow_buffered_frames)(void *, struct ieee80211_local *, struct ieee80211_sta *, u16, int, enum ieee80211_frame_release_type, bool);

typedef void (*btf_trace_drv_mgd_prepare_tx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u16);

typedef void (*btf_trace_drv_mgd_protect_tdls_discover)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_add_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_remove_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_change_chanctx)(void *, struct ieee80211_local *, struct ieee80211_chanctx *, u32);

typedef void (*btf_trace_drv_switch_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_vif_chanctx_switch *, int, enum ieee80211_chanctx_switch_mode);

typedef void (*btf_trace_drv_assign_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_unassign_vif_chanctx)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_chanctx *);

typedef void (*btf_trace_drv_start_ap)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_stop_ap)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_reconfig_complete)(void *, struct ieee80211_local *, enum ieee80211_reconfig_type);

typedef void (*btf_trace_drv_ipv6_addr_change)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_join_ibss)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_bss_conf *);

typedef void (*btf_trace_drv_leave_ibss)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_get_expected_throughput)(void *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_start_nan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_drv_stop_nan)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_nan_change_conf)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_drv_add_nan_func)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_drv_del_nan_func)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, u8);

typedef void (*btf_trace_drv_start_pmsr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_abort_pmsr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_start_tx_ba_session)(void *, struct ieee80211_sta *, u16);

typedef void (*btf_trace_api_start_tx_ba_cb)(void *, struct ieee80211_sub_if_data *, const u8 *, u16);

typedef void (*btf_trace_api_stop_tx_ba_session)(void *, struct ieee80211_sta *, u16);

typedef void (*btf_trace_api_stop_tx_ba_cb)(void *, struct ieee80211_sub_if_data *, const u8 *, u16);

typedef void (*btf_trace_api_restart_hw)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_beacon_loss)(void *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_connection_loss)(void *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_disconnect)(void *, struct ieee80211_sub_if_data *, bool);

typedef void (*btf_trace_api_cqm_rssi_notify)(void *, struct ieee80211_sub_if_data *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_api_cqm_beacon_loss_notify)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_api_scan_completed)(void *, struct ieee80211_local *, bool);

typedef void (*btf_trace_api_sched_scan_results)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_sched_scan_stopped)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_sta_block_awake)(void *, struct ieee80211_local *, struct ieee80211_sta *, bool);

typedef void (*btf_trace_api_chswitch_done)(void *, struct ieee80211_sub_if_data *, bool);

typedef void (*btf_trace_api_ready_on_channel)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_remain_on_channel_expired)(void *, struct ieee80211_local *);

typedef void (*btf_trace_api_gtk_rekey_notify)(void *, struct ieee80211_sub_if_data *, const u8 *, const u8 *);

typedef void (*btf_trace_api_enable_rssi_reports)(void *, struct ieee80211_sub_if_data *, int, int);

typedef void (*btf_trace_api_eosp)(void *, struct ieee80211_local *, struct ieee80211_sta *);

typedef void (*btf_trace_api_send_eosp_nullfunc)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8);

typedef void (*btf_trace_api_sta_set_buffered)(void *, struct ieee80211_local *, struct ieee80211_sta *, u8, bool);

typedef void (*btf_trace_wake_queue)(void *, struct ieee80211_local *, u16, enum queue_stop_reason);

typedef void (*btf_trace_stop_queue)(void *, struct ieee80211_local *, u16, enum queue_stop_reason);

typedef void (*btf_trace_drv_set_default_unicast_key)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, int);

typedef void (*btf_trace_api_radar_detected)(void *, struct ieee80211_local *);

typedef void (*btf_trace_drv_channel_switch_beacon)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_chan_def *);

typedef void (*btf_trace_drv_pre_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_post_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_abort_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_channel_switch_rx_beacon)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_channel_switch *);

typedef void (*btf_trace_drv_get_txpower)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, int, int);

typedef void (*btf_trace_drv_tdls_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_drv_tdls_cancel_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *);

typedef void (*btf_trace_drv_tdls_recv_channel_switch)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_tdls_ch_sw_params *);

typedef void (*btf_trace_drv_wake_tx_queue)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct txq_info *);

typedef void (*btf_trace_drv_get_ftm_responder_stats)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_drv_update_vif_offload)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *);

typedef void (*btf_trace_drv_sta_set_4addr)(void *, struct ieee80211_local *, struct ieee80211_sub_if_data *, struct ieee80211_sta *, bool);

struct ieee80211_country_ie_triplet {
	union {
		struct {
			u8 first_channel;
			u8 num_channels;
			s8 max_power;
		} chans;
		struct {
			u8 reg_extension_id;
			u8 reg_class;
			u8 coverage_class;
		} ext;
	};
};

enum ieee80211_timeout_interval_type {
	WLAN_TIMEOUT_REASSOC_DEADLINE = 1,
	WLAN_TIMEOUT_KEY_LIFETIME = 2,
	WLAN_TIMEOUT_ASSOC_COMEBACK = 3,
};

enum ieee80211_idle_options {
	WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE = 1,
};

struct ieee80211_wmm_ac_param {
	u8 aci_aifsn;
	u8 cw;
	__le16 txop_limit;
};

struct ieee80211_wmm_param_ie {
	u8 element_id;
	u8 len;
	u8 oui[3];
	u8 oui_type;
	u8 oui_subtype;
	u8 version;
	u8 qos_info;
	u8 reserved;
	struct ieee80211_wmm_ac_param ac[4];
};

enum ocb_deferred_task_flags {
	OCB_WORK_HOUSEKEEPING = 0,
};

struct mcs_group {
	u8 shift;
	u16 duration[12];
};

struct minstrel_rate_stats {
	u16 attempts;
	u16 last_attempts;
	u16 success;
	u16 last_success;
	u32 att_hist;
	u32 succ_hist;
	u16 prob_avg;
	u16 prob_avg_1;
	u8 retry_count;
	u8 retry_count_rtscts;
	u8 sample_skipped;
	bool retry_updated;
};

struct minstrel_rate {
	int bitrate;
	s8 rix;
	u8 retry_count_cts;
	u8 adjusted_retry_count;
	unsigned int perfect_tx_time;
	unsigned int ack_time;
	int sample_limit;
	struct minstrel_rate_stats stats;
};

struct minstrel_sta_info {
	struct ieee80211_sta *sta;
	long unsigned int last_stats_update;
	unsigned int sp_ack_dur;
	unsigned int rate_avg;
	unsigned int lowest_rix;
	u8 max_tp_rate[4];
	u8 max_prob_rate;
	unsigned int total_packets;
	unsigned int sample_packets;
	unsigned int sample_row;
	unsigned int sample_column;
	int n_rates;
	struct minstrel_rate *r;
	bool prev_sample;
	u8 *sample_table;
};

struct minstrel_priv {
	struct ieee80211_hw *hw;
	bool has_mrr;
	bool new_avg;
	u32 sample_switch;
	unsigned int cw_min;
	unsigned int cw_max;
	unsigned int max_retry;
	unsigned int segment_size;
	unsigned int update_interval;
	unsigned int lookaround_rate;
	unsigned int lookaround_rate_mrr;
	u8 cck_rates[4];
};

struct mcs_group___2 {
	u16 flags;
	u8 streams;
	u8 shift;
	u8 bw;
	u16 duration[10];
};

struct minstrel_mcs_group_data {
	u8 index;
	u8 column;
	u16 max_group_tp_rate[4];
	u16 max_group_prob_rate;
	struct minstrel_rate_stats rates[10];
};

enum minstrel_sample_mode {
	MINSTREL_SAMPLE_IDLE = 0,
	MINSTREL_SAMPLE_ACTIVE = 1,
	MINSTREL_SAMPLE_PENDING = 2,
};

struct minstrel_ht_sta {
	struct ieee80211_sta *sta;
	unsigned int ampdu_len;
	unsigned int ampdu_packets;
	unsigned int avg_ampdu_len;
	u16 max_tp_rate[4];
	u16 max_prob_rate;
	long unsigned int last_stats_update;
	unsigned int overhead;
	unsigned int overhead_rtscts;
	unsigned int total_packets_last;
	unsigned int total_packets_cur;
	unsigned int total_packets;
	unsigned int sample_packets;
	u32 tx_flags;
	u8 sample_wait;
	u8 sample_tries;
	u8 sample_count;
	u8 sample_slow;
	enum minstrel_sample_mode sample_mode;
	u16 sample_rate;
	u8 sample_group;
	u8 cck_supported;
	u8 cck_supported_short;
	u16 supported[41];
	struct minstrel_mcs_group_data groups[41];
};

struct minstrel_ht_sta_priv {
	union {
		struct minstrel_ht_sta ht;
		struct minstrel_sta_info legacy;
	};
	void *ratelist;
	void *sample_table;
	bool is_ht;
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 2,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 4,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 8,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 9,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		long unsigned int brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		u16 vlan_protocol;
		bool mc_disabled;
	} u;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct switchdev_notifier_port_obj_info {
	struct switchdev_notifier_info info;
	const struct switchdev_obj *obj;
	struct switchdev_trans *trans;
	bool handled;
};

struct switchdev_notifier_port_attr_info {
	struct switchdev_notifier_info info;
	const struct switchdev_attr *attr;
	struct switchdev_trans *trans;
	bool handled;
};

typedef void switchdev_deferred_func_t(struct net_device *, const void *);

struct switchdev_deferred_item {
	struct list_head list;
	struct net_device *dev;
	switchdev_deferred_func_t *func;
	long unsigned int data[0];
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
