apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: nccl-multinode
  labels:
    app: nccl-multinode
spec:
  serviceName: nccl-multinode
  replicas: $REPLICAS  # 节点数量
  selector:
    matchLabels:
      app: nccl-multinode
  template:
    metadata:
      labels:
        app: nccl-multinode
    spec:
      serviceAccountName: nccl-service-account  # 使用专用的 ServiceAccount
      schedulerName: "hami-scheduler"  # 指定使用 hami 调度器
      restartPolicy: Always
      hostNetwork: true  # 使用主机网络，支持 InfiniBand
      hostIPC: true      # 共享主机 IPC
      dnsPolicy: ClusterFirstWithHostNet
      containers:
      - name: nccl-test
        image: nccl-test:latest
        imagePullPolicy: IfNotPresent
        securityContext:
          privileged: true  # 特权模式，访问 GPU 和网络设备
          capabilities:
            add:
            - SYS_ADMIN
            - IPC_LOCK
        resources:
          requests:
            nvidia.com/gpu: "$NPROC_PER_NODE"  # 每个 Pod 请求的 GPU 数量
          limits:
            nvidia.com/gpu: "$NPROC_PER_NODE"
            memory: "16Gi"
            cpu: "8"
        env:
        - name: NCCL_DEBUG
          value: "INFO"
        - name: NCCL_SOCKET_IFNAME
          value: "eno*,eth*,ib*,enp*"  # 使用通配符匹配物理接口
        - name: NCCL_IB_DISABLE
          value: "0"  # 启用 InfiniBand（如果可用）
        - name: NCCL_NET_GDR_LEVEL
          value: "2"  # 启用 GPUDirect RDMA
        - name: NCCL_P2P_DISABLE
          value: "0"  # 启用 P2P 通信
        - name: NCCL_SHM_DISABLE
          value: "0"  # 启用共享内存
        - name: NCCL_IGNORE_CPU_AFFINITY
          value: "1"  # 忽略 CPU 亲和性限制
        - name: WORLD_SIZE
          value: "$WORLD_SIZE"  # 总 GPU 数量
        - name: NPROC_PER_NODE
          value: "$NPROC_PER_NODE"  # 每节点 GPU 数量
        - name: HOST_IP
          valueFrom:
            fieldRef:
              fieldPath: status.hostIP  # 获取当前节点 IP
        - name: MASTER_PORT
          value: "29500"
        - name: NODE_RANK
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: dev-shm
          mountPath: /dev/shm
        - name: nccl-logs
          mountPath: /workspace/logs
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "=== NCCL Kubernetes 多节点测试 (StatefulSet) ==="
          echo "Pod: $HOSTNAME"
          
          # 强制使用物理网络接口
          echo "=== 网络配置 ==="
          echo "强制使用物理接口: $NCCL_SOCKET_IFNAME"
          
          # 从 StatefulSet Pod 名称中提取 NODE_RANK
          # StatefulSet Pod 命名格式: <statefulset-name>-<ordinal>
          # 例如: nccl-multinode-0, nccl-multinode-1
          if [ -n "$NODE_RANK" ] && [[ "$NODE_RANK" =~ ^.*-[0-9]+$ ]]; then
            # 如果 NODE_RANK 环境变量包含完整的 Pod 名称，提取数字部分
            NODE_RANK=$(echo $NODE_RANK | grep -o '[0-9]\+$')
          elif [ -n "$POD_NAME" ]; then
            # 从 POD_NAME 提取
            NODE_RANK=$(echo $POD_NAME | grep -o '[0-9]\+$')
          else
            # 从 HOSTNAME 提取
            NODE_RANK=$(echo $HOSTNAME | grep -o '[0-9]\+$')
          fi
          
          # 验证 NODE_RANK 是否为有效数字
          if ! [[ "$NODE_RANK" =~ ^[0-9]+$ ]]; then
            echo "错误: 无法提取有效的 NODE_RANK"
            echo "HOSTNAME: $HOSTNAME"
            echo "POD_NAME: $POD_NAME"
            echo "NODE_RANK: $NODE_RANK"
            exit 1
          fi
          
          # 动态确定主节点地址
          if [ "$NODE_RANK" = "0" ]; then
            # 主节点使用自己的 IP
            MASTER_ADDR="$HOST_IP"
            echo "主节点 (NODE_RANK=0) IP: $MASTER_ADDR"
          else
            # 工作节点使用短域名（包含命名空间）访问主节点
            echo "工作节点 (NODE_RANK=$NODE_RANK) 获取主节点地址..."
            echo "当前命名空间: $NAMESPACE"
            echo "当前 Pod 名称: $POD_NAME"
            echo "当前主机 IP: $HOST_IP"
            
            # 使用包含命名空间的短域名，让 Kubernetes DNS 搜索域自动补全
            # 格式: <pod-name>.<service-name>.<namespace>
            MASTER_HOSTNAME="nccl-multinode-0.nccl-multinode.$NAMESPACE"
            echo "主节点域名: $MASTER_HOSTNAME"
            
            # 使用 ping 解析域名为 IP 地址
            echo "正在使用 ping 解析主节点 IP 地址..."
            # 更精确的 IP 地址提取，匹配完整的 IPv4 地址格式
            MASTER_ADDR=$(ping -c 1 -W 2 $MASTER_HOSTNAME 2>/dev/null | grep "PING" | sed -n 's/.*(\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)).*/\1/p')
            
            # 如果上述方法失败，尝试另一种提取方式
            if [ -z "$MASTER_ADDR" ]; then
              echo "尝试备用解析方法..."
              MASTER_ADDR=$(ping -c 1 -W 2 $MASTER_HOSTNAME 2>/dev/null | head -1 | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}')
            fi
            
            # 验证解析结果和 IP 地址格式
            if [ -z "$MASTER_ADDR" ]; then
              echo "错误: 无法解析主节点地址 $MASTER_HOSTNAME"
              echo "使用域名作为备选方案"
              MASTER_ADDR="$MASTER_HOSTNAME"
            elif [[ ! "$MASTER_ADDR" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
              echo "警告: 解析结果格式异常: $MASTER_ADDR"
              echo "使用域名作为备选方案"
              MASTER_ADDR="$MASTER_HOSTNAME"
            else
              echo "成功解析主节点 IP: $MASTER_ADDR"
              # 验证 IP 地址的每个段是否在有效范围内 (0-255)
              IFS='.' read -ra IP_PARTS <<< "$MASTER_ADDR"
              for part in "${IP_PARTS[@]}"; do
                if [ "$part" -gt 255 ] || [ "$part" -lt 0 ]; then
                  echo "警告: IP 地址段超出范围: $part"
                  echo "使用域名作为备选方案"
                  MASTER_ADDR="$MASTER_HOSTNAME"
                  break
                fi
              done
            fi
          fi
          
          echo "Node Rank: $NODE_RANK"
          echo "World Size: $WORLD_SIZE"
          echo "Master Addr: $MASTER_ADDR"
          echo "Master Port: $MASTER_PORT"
          
          # 节点协调启动逻辑
          if [ "$NODE_RANK" = "0" ]; then
            echo "主节点 (NODE_RANK=0) 直接启动..."
            sleep 5  # 短暂等待，确保容器完全就绪
          else
            echo "工作节点 (NODE_RANK=$NODE_RANK) 等待主节点服务可用..."
            # 等待主节点服务可达
            until ping -c 1 -W 2 $MASTER_ADDR >/dev/null 2>&1; do
              echo "等待服务 $MASTER_ADDR 可达..."
              sleep 2
            done
            
            # 错时启动，避免同时连接
            wait_time=$((NODE_RANK * 10 + 10))
            echo "工作节点等待 $wait_time 秒后启动..."
            sleep $wait_time
          fi
          
          # 启动 NCCL 测试
          cd /workspace
          echo "启动 NCCL 测试..."
          
          # 检查脚本是否存在
          if [ -f "/workspace/nccl_benchmark.sh" ]; then
            SCRIPT_PATH="/workspace/nccl_benchmark.sh"
          elif [ -f "/workspace/nccl_test/nccl_benchmark.sh" ]; then
            SCRIPT_PATH="/workspace/nccl_test/nccl_benchmark.sh"
          else
            echo "错误: 找不到 nccl_benchmark.sh 脚本"
            exit 1
          fi
          
          echo "使用脚本: $SCRIPT_PATH"
          $SCRIPT_PATH \
            -m \
            --master-addr $MASTER_ADDR \
            --master-port $MASTER_PORT \
            --network auto \
            -s $TEST_SIZE \
            -t $TEST_DURATION \
            2>&1 | tee /workspace/logs/nccl-test-node-$NODE_RANK.log
          
          echo "测试完成，节点 $NODE_RANK"
      volumes:
      - name: dev-shm
        hostPath:
          path: /dev/shm
          type: Directory
      - name: nccl-logs
        hostPath:
          path: /tmp/nccl-logs
          type: DirectoryOrCreate
      nodeSelector:
        gpu: "on"  # 只调度到有 GPU 的节点
      tolerations:
      - key: nvidia.com/gpu
        operator: Exists
        effect: NoSchedule