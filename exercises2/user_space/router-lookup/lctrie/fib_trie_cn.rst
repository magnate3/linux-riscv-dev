SPDX 许可证标识符: GPL-2.0

============================
LC-trie 实现说明
============================

节点类型
----------
叶节点(leaf)
	带有数据的终端节点。它包含相关键的一个副本，以及 'hlist'（按照前缀长度排序的路由表项）。
参见结构体 `leaf` 和 `leaf_info`。
trie 节点 或 tnode
	内部节点，持有指向子节点（叶节点或 tnode）的指针数组，这些指针通过键的一部分进行索引。参见 级别压缩(Level Compression)。

一些概念解释
------------------------
位数(Bits, tnode)
	用于索引到子节点数组中的键段所包含的位数——“子索引”。参见 级别压缩。
位置(Pos, tnode)
	用于索引到子节点数组中的键段在键中的位置。参见 路径压缩(Path Compression)。
路径压缩/跳过的位数
	给定的 tnode 通过其父节点的“pos”和“bits”指定的键段与其父节点的子节点数组相连。
在某些情况下，此 tnode 的自身“pos”不会紧接在父节点(pos+bits)之后，
而是会有一些位被跳过，因为它们代表了一个没有分叉的单一路径。这些“跳过的位”构成了路径压缩。
需要注意的是，搜索算法在搜索时将直接跳过这些位，
这使得必须保存叶节点中的键以验证它们是否确实与我们正在搜索的键匹配。
级别压缩/子数组
	trie 在特定条件下保持层级平衡，将一个满子节点（参见“full_children”）的所有子节点向上移动一级，
因此，除了纯二叉树外，每个内部节点（“tnode”）可能包含任意大小的链接到多个子节点的数组。
相反，如果 tnode 的子数组大部分为空（参见 “empty_children”），则可以将其“减半”，
即让其中的一些子节点向下移动一级，以避免子数组不断增大。
empty_children
	给定 tnode 的子数组中为 NULL 的位置数量。
### 翻译

#### `full_children`
给定的`tnode`中未经过路径压缩的孩子节点的数量
（换句话说，这些孩子节点既不是`NULL`也不是叶子节点，并且它们的`pos`等于该`tnode`的`pos`加上`bits`）
（这里的“full”更多地是用于表示“完整”，而不是作为“空”的反义词，这可能会让人有些困惑。）

#### 评论
我们尽量保持代码结构与`fib_hash`尽可能接近，以便于验证和帮助我们审查。

- `fib_find_node()`
  - 理解这段代码的一个良好起点。此函数实现了一个简单的字典树查找。
- `fib_insert_node()`
  - 在字典树中插入一个新的叶节点。这比`fib_find_node()`稍微复杂一些。插入一个新节点意味着我们可能需要对字典树的一部分运行层级压缩算法。
- `trie_leaf_remove()`
  - 查找一个键、删除它并运行层级压缩算法。
- `trie_rebalance()`
  - 对字典树进行任何更改后动态字典树的关键函数。它会从给定的`tnode`向上遍历字典树直至根节点，在每一步都执行`resize()`以实现层级压缩。
- `resize()`
  - 分析一个`tnode`并通过反复扩展或缩小子数组大小来优化其大小，直到满足最优层级压缩的标准。这部分非常接近原始论文的内容，并且可能还有一定的实验空间。
- `inflate()`
  - 将`tnode`中的子数组大小加倍。由`resize()`调用。
- `halve()`
  - 将`tnode`中的子数组大小减半——是`inflate()`的逆操作。由`resize()`调用。

- `fn_trie_insert()`, `fn_trie_delete()`, `fn_trie_select_default()`
  - 路由操纵函数。应该与`fib_hash`中的相应函数相当接近。
`fn_trie_flush()`
这将遍历整个前缀树（使用nextleaf()），并查找需要移除的空叶子。

`fn_trie_dump()`
按照前缀长度排序后转储路由表。这比对应的fib_hash函数稍慢一些，因为我们必须为每个前缀长度遍历整个前缀树。相比之下，fib_hash是以每个前缀长度一个“区域”/哈希的形式组织的。

锁定
-----

`fib_lock`用于实现与fib_hash中相同的读写锁。但是，这些函数在其他可能的锁定场景中被分开了一些。理论上，我们可以通过RCU运行`trie_rebalance`来避免`fn_trie_lookup()`函数中的读锁。

主要查找机制
-------------

`fn_trie_lookup()`是主要的查找函数。
查找的基本形式就像`fib_find_node()`。我们按键段逐层下降前缀树，直到找到一个叶子。`check_leaf()`在叶子的排序前缀hlist中执行fib_semantic_match。

如果我们找到匹配项，则完成查找。
如果没有找到匹配项，我们将进入前缀匹配模式。前缀长度最初等于键长度，然后逐步递减，并且我们在前缀树中向上回溯以寻找最长匹配前缀。我们的目标始终是到达一个叶子节点，并从前缀匹配机制`fib_semantic_match`中获得肯定的结果。

在每个tnode内部，寻找最长匹配前缀的过程包括搜索子数组，逐个去掉（置零）子索引中最不重要的“1”，直到找到匹配项或者子索引仅由零组成为止。

此时我们进行回溯（t->stats.backtrack++），继续去掉键的一部分，以便找到最长匹配前缀。
在这个阶段，我们会反复深入子trie以寻找匹配项，并且有一些优化手段可以为我们提供“捷径”，以避免进入无果的分支。在代码中查找标记为 "HL_OPTIMIZE" 的部分。
为了消除对路由选择过程正确性的任何疑虑，新增加了一个netlink操作。查找 NETLINK_FIB_LOOKUP，它使得用户空间能够访问 fib_lookup() 函数。
